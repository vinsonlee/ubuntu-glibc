<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html401/loose.dtd">
<html>
<!-- This file documents the GNU C library.

This is Edition 0.12, last updated 2007-10-27,
of The GNU C Library Reference Manual, for version 2.8.

Copyright (C) 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2001, 2002,
2003, 2007, 2008 Free Software Foundation, Inc.

Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.2 or
any later version published by the Free Software Foundation; with the
Invariant Sections being "Free Software Needs Free Documentation"
and "GNU Lesser General Public License", the Front-Cover texts being
"A GNU Manual", and with the Back-Cover Texts as in (a) below.  A
copy of the license is included in the section entitled "GNU Free
Documentation License".

(a) The FSF's Back-Cover Text is: "You have the freedom to
copy and modify this GNU manual.  Buying copies from the FSF
supports it in developing GNU and promoting software freedom."
 -->
<!-- Created on January, 19 2009 by texi2html 1.78 -->
<!--
Written by: Lionel Cons <Lionel.Cons@cern.ch> (original author)
            Karl Berry  <karl@freefriends.org>
            Olaf Bachmann <obachman@mathematik.uni-kl.de>
            and many others.
Maintained by: Many creative people.
Send bugs and suggestions to <texi2html-bug@nongnu.org>

-->
<head>
<title>The GNU C Library: A. C Language Facilities in the Library</title>

<meta name="description" content="The GNU C Library: A. C Language Facilities in the Library">
<meta name="keywords" content="The GNU C Library: A. C Language Facilities in the Library">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="texi2html 1.78">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
<!--
a.summary-letter {text-decoration: none}
pre.display {font-family: serif}
pre.format {font-family: serif}
pre.menu-comment {font-family: serif}
pre.menu-preformatted {font-family: serif}
pre.smalldisplay {font-family: serif; font-size: smaller}
pre.smallexample {font-size: smaller}
pre.smallformat {font-family: serif; font-size: smaller}
pre.smalllisp {font-size: smaller}
span.roman {font-family:serif; font-weight:normal;}
span.sansserif {font-family:sans-serif; font-weight:normal;}
ul.toc {list-style: none}
-->
</style>


</head>

<body lang="en" bgcolor="#FFFFFF" text="#000000" link="#0000FF" vlink="#800080" alink="#FF0000">

<a name="Language-Features"></a>
<a name="SEC671"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="libc_33.html#SEC670" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC672" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="libc_33.html#SEC669" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="libc.html#SEC_Top" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="libc_35.html#SEC693" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="libc.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="libc_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="libc_42.html#SEC712" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="libc_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h1 class="appendix"> A. C Language Facilities in the Library </h1>

<p>Some of the facilities implemented by the C library really should be
thought of as parts of the C language itself.  These facilities ought to
be documented in the C Language Manual, not in the library manual; but
since we don't have the language manual yet, and documentation for these
features has been written, we are publishing it here.
</p>
<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top"><a href="#SEC672">A.1 Explicitly Checking Internal Consistency</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">        Using <code>assert</code> to abort if
				 something &ldquo;impossible&rdquo; happens.
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC673">A.2 Variadic Functions</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">          Defining functions with varying numbers
                                 of args.
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC683">A.3 Null Pointer Constant</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">       The macro <code>NULL</code>.
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC684">A.4 Important Data Types</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">        Data types for object sizes.
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC685">A.5 Data Type Measurements</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">      Parameters of data type representations.
</td></tr>
</table>

<hr size="6">
<a name="Consistency-Checking"></a>
<a name="SEC672"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC671" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC673" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC671" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC671" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="libc_35.html#SEC693" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="libc.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="libc_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="libc_42.html#SEC712" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="libc_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="section"> A.1 Explicitly Checking Internal Consistency </h2>

<p>When you're writing a program, it's often a good idea to put in checks
at strategic places for &ldquo;impossible&rdquo; errors or violations of basic
assumptions.  These kinds of checks are helpful in debugging problems
with the interfaces between different parts of the program, for example.
</p>
<a name="IDX3154"></a>
<p>The <code>assert</code> macro, defined in the header file &lsquo;<tt>assert.h</tt>&rsquo;,
provides a convenient way to abort the program while printing a message
about where in the program the error was detected.
</p>
<a name="IDX3155"></a>
<p>Once you think your program is debugged, you can disable the error
checks performed by the <code>assert</code> macro by recompiling with the
macro <code>NDEBUG</code> defined.  This means you don't actually have to
change the program source code to disable these checks.
</p>
<p>But disabling these consistency checks is undesirable unless they make
the program significantly slower.  All else being equal, more error
checking is good no matter who is running the program.  A wise user
would rather have a program crash, visibly, than have it return nonsense
without indicating anything might be wrong.
</p>
<dl>
<dt><u>Macro:</u> void <b>assert</b><i> (int <var>expression</var>)</i>
<a name="IDX3156"></a>
</dt>
<dd><p>Verify the programmer's belief that <var>expression</var> is nonzero at
this point in the program.
</p>
<p>If <code>NDEBUG</code> is not defined, <code>assert</code> tests the value of
<var>expression</var>.  If it is false (zero), <code>assert</code> aborts the
program (see section <a href="libc_25.html#SEC566">Aborting a Program</a>) after printing a message of the
form:
</p>
<table><tr><td>&nbsp;</td><td><pre class="smallexample">&lsquo;<tt><var>file</var></tt>&rsquo;:<var>linenum</var>: <var>function</var>: Assertion `<var>expression</var>' failed.
</pre></td></tr></table>

<p>on the standard error stream <code>stderr</code> (see section <a href="libc_12.html#SEC179">Standard Streams</a>).
The filename and line number are taken from the C preprocessor macros
<code>__FILE__</code> and <code>__LINE__</code> and specify where the call to
<code>assert</code> was made.  When using the GNU C compiler, the name of
the function which calls <code>assert</code> is taken from the built-in
variable <code>__PRETTY_FUNCTION__</code>; with older compilers, the function
name and following colon are omitted.
</p>
<p>If the preprocessor macro <code>NDEBUG</code> is defined before
&lsquo;<tt>assert.h</tt>&rsquo; is included, the <code>assert</code> macro is defined to do
absolutely nothing.
</p>
<p><strong>Warning:</strong> Even the argument expression <var>expression</var> is not
evaluated if <code>NDEBUG</code> is in effect.  So never use <code>assert</code>
with arguments that involve side effects.  For example, <code>assert
(++i &gt; 0);</code> is a bad idea, because <code>i</code> will not be incremented if
<code>NDEBUG</code> is defined.
</p></dd></dl>

<p>Sometimes the &ldquo;impossible&rdquo; condition you want to check for is an error
return from an operating system function.  Then it is useful to display
not only where the program crashes, but also what error was returned.
The <code>assert_perror</code> macro makes this easy.
</p>
<dl>
<dt><u>Macro:</u> void <b>assert_perror</b><i> (int <var>errnum</var>)</i>
<a name="IDX3157"></a>
</dt>
<dd><p>Similar to <code>assert</code>, but verifies that <var>errnum</var> is zero.
</p>
<p>If <code>NDEBUG</code> is not defined, <code>assert_perror</code> tests the value of
<var>errnum</var>.  If it is nonzero, <code>assert_perror</code> aborts the program
after printing a message of the form:
</p>
<table><tr><td>&nbsp;</td><td><pre class="smallexample">&lsquo;<tt><var>file</var></tt>&rsquo;:<var>linenum</var>: <var>function</var>: <var>error text</var>
</pre></td></tr></table>

<p>on the standard error stream.  The file name, line number, and function
name are as for <code>assert</code>.  The error text is the result of
<code>strerror (<var>errnum</var>)</code>.  See section <a href="libc_2.html#SEC18">Error Messages</a>.
</p>
<p>Like <code>assert</code>, if <code>NDEBUG</code> is defined before &lsquo;<tt>assert.h</tt>&rsquo;
is included, the <code>assert_perror</code> macro does absolutely nothing.  It
does not evaluate the argument, so <var>errnum</var> should not have any side
effects.  It is best for <var>errnum</var> to be just a simple variable
reference; often it will be <code>errno</code>.
</p>
<p>This macro is a GNU extension.
</p></dd></dl>

<p><strong>Usage note:</strong> The <code>assert</code> facility is designed for
detecting <em>internal inconsistency</em>; it is not suitable for
reporting invalid input or improper usage by the <em>user</em> of the
program.
</p>
<p>The information in the diagnostic messages printed by the <code>assert</code>
and <code>assert_perror</code> macro is intended to help you, the programmer,
track down the cause of a bug, but is not really useful for telling a user
of your program why his or her input was invalid or why a command could not
be carried out.  What's more, your program should not abort when given
invalid input, as <code>assert</code> would do&mdash;it should exit with nonzero
status (see section <a href="libc_25.html#SEC564">Exit Status</a>) after printing its error messages, or perhaps
read another command or move on to the next input file.
</p>
<p>See section <a href="libc_2.html#SEC18">Error Messages</a>, for information on printing error messages for
problems that <em>do not</em> represent bugs in the program.
</p>

<hr size="6">
<a name="Variadic-Functions"></a>
<a name="SEC673"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC672" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC674" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC671" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC671" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="libc_35.html#SEC693" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="libc.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="libc_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="libc_42.html#SEC712" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="libc_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="section"> A.2 Variadic Functions </h2>

<p>ISO C defines a syntax for declaring a function to take a variable
number or type of arguments.  (Such functions are referred to as
<em>varargs functions</em> or <em>variadic functions</em>.)  However, the
language itself provides no mechanism for such functions to access their
non-required arguments; instead, you use the variable arguments macros
defined in &lsquo;<tt>stdarg.h</tt>&rsquo;.
</p>
<p>This section describes how to declare variadic functions, how to write
them, and how to call them properly.
</p>
<p><strong>Compatibility Note:</strong> Many older C dialects provide a similar,
but incompatible, mechanism for defining functions with variable numbers
of arguments, using &lsquo;<tt>varargs.h</tt>&rsquo;.
</p>
<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top"><a href="#SEC674">A.2.1 Why Variadic Functions are Used</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                Reasons for making functions take
                                 variable arguments.
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC675">A.2.2 How Variadic Functions are Defined and Used</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                How to define and call variadic functions.
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC681">A.2.3 Example of a Variadic Function</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">            A complete example.
</td></tr>
</table>

<hr size="6">
<a name="Why-Variadic"></a>
<a name="SEC674"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC673" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC675" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC671" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC673" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="libc_35.html#SEC693" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="libc.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="libc_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="libc_42.html#SEC712" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="libc_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h3 class="subsection"> A.2.1 Why Variadic Functions are Used </h3>

<p>Ordinary C functions take a fixed number of arguments.  When you define
a function, you specify the data type for each argument.  Every call to
the function should supply the expected number of arguments, with types
that can be converted to the specified ones.  Thus, if the function
&lsquo;<samp>foo</samp>&rsquo; is declared with <code>int foo (int, char *);</code> then you must
call it with two arguments, a number (any kind will do) and a string
pointer.
</p>
<p>But some functions perform operations that can meaningfully accept an
unlimited number of arguments.
</p>
<p>In some cases a function can handle any number of values by operating on
all of them as a block.  For example, consider a function that allocates
a one-dimensional array with <code>malloc</code> to hold a specified set of
values.  This operation makes sense for any number of values, as long as
the length of the array corresponds to that number.  Without facilities
for variable arguments, you would have to define a separate function for
each possible array size.
</p>
<p>The library function <code>printf</code> (see section <a href="libc_12.html#SEC191">Formatted Output</a>) is an
example of another class of function where variable arguments are
useful.  This function prints its arguments (which can vary in type as
well as number) under the control of a format template string.
</p>
<p>These are good reasons to define a <em>variadic</em> function which can
handle as many arguments as the caller chooses to pass.
</p>
<p>Some functions such as <code>open</code> take a fixed set of arguments, but
occasionally ignore the last few.  Strict adherence to ISO C requires
these functions to be defined as variadic; in practice, however, the GNU
C compiler and most other C compilers let you define such a function to
take a fixed set of arguments&mdash;the most it can ever use&mdash;and then only
<em>declare</em> the function as variadic (or not declare its arguments
at all!).
</p>
<hr size="6">
<a name="How-Variadic"></a>
<a name="SEC675"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC674" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC676" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC671" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC673" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="libc_35.html#SEC693" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="libc.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="libc_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="libc_42.html#SEC712" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="libc_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h3 class="subsection"> A.2.2 How Variadic Functions are Defined and Used </h3>

<p>Defining and using a variadic function involves three steps:
</p>
<ul>
<li>
<em>Define</em> the function as variadic, using an ellipsis
(&lsquo;<samp>&hellip;</samp>&rsquo;) in the argument list, and using special macros to
access the variable arguments.  See section <a href="#SEC677">Receiving the Argument Values</a>.

</li><li>
<em>Declare</em> the function as variadic, using a prototype with an
ellipsis (&lsquo;<samp>&hellip;</samp>&rsquo;), in all the files which call it.
See section <a href="#SEC676">Syntax for Variable Arguments</a>.

</li><li>
<em>Call</em> the function by writing the fixed arguments followed by the
additional variable arguments.  See section <a href="#SEC679">Calling Variadic Functions</a>.
</li></ul>

<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top"><a href="#SEC676">A.2.2.1 Syntax for Variable Arguments</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">  How to make a prototype for a function
			  with variable arguments.
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC677">A.2.2.2 Receiving the Argument Values</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">  Steps you must follow to access the
			  optional argument values.
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC678">A.2.2.3 How Many Arguments Were Supplied</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">   How to decide whether there are more arguments.
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC679">A.2.2.4 Calling Variadic Functions</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">    Things you need to know about calling
			  variable arguments functions.
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC680">A.2.2.5 Argument Access Macros</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">      Detailed specification of the macros
        		  for accessing variable arguments.
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC682">A.2.3.1 Old-Style Variadic Functions</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">		 The pre-ISO way of defining variadic functions.
</td></tr>
</table>

<hr size="6">
<a name="Variadic-Prototypes"></a>
<a name="SEC676"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC675" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC677" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC671" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC675" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="libc_35.html#SEC693" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="libc.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="libc_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="libc_42.html#SEC712" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="libc_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h4 class="subsubsection"> A.2.2.1 Syntax for Variable Arguments </h4>

<p>A function that accepts a variable number of arguments must be declared
with a prototype that says so.   You write the fixed arguments as usual,
and then tack on &lsquo;<samp>&hellip;</samp>&rsquo; to indicate the possibility of
additional arguments.  The syntax of ISO C requires at least one fixed
argument before the &lsquo;<samp>&hellip;</samp>&rsquo;.  For example,
</p>
<table><tr><td>&nbsp;</td><td><pre class="smallexample">int
func (const char *a, int b, &hellip;)
{
  &hellip;
}
</pre></td></tr></table>

<p>defines a function <code>func</code> which returns an <code>int</code> and takes two
required arguments, a <code>const char *</code> and an <code>int</code>.  These are
followed by any number of anonymous arguments.
</p>
<p><strong>Portability note:</strong> For some C compilers, the last required
argument must not be declared <code>register</code> in the function
definition.  Furthermore, this argument's type must be
<em>self-promoting</em>: that is, the default promotions must not change
its type.  This rules out array and function types, as well as
<code>float</code>, <code>char</code> (whether signed or not) and <code>short int</code>
(whether signed or not).  This is actually an ISO C requirement.
</p>
<hr size="6">
<a name="Receiving-Arguments"></a>
<a name="SEC677"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC676" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC678" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC671" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC675" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="libc_35.html#SEC693" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="libc.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="libc_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="libc_42.html#SEC712" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="libc_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h4 class="subsubsection"> A.2.2.2 Receiving the Argument Values </h4>

<p>Ordinary fixed arguments have individual names, and you can use these
names to access their values.  But optional arguments have no
names&mdash;nothing but &lsquo;<samp>&hellip;</samp>&rsquo;.  How can you access them?
</p>
<a name="IDX3158"></a>
<p>The only way to access them is sequentially, in the order they were
written, and you must use special macros from &lsquo;<tt>stdarg.h</tt>&rsquo; in the
following three step process:
</p>
<ol>
<li>
You initialize an argument pointer variable of type <code>va_list</code> using
<code>va_start</code>.  The argument pointer when initialized points to the
first optional argument.

</li><li>
You access the optional arguments by successive calls to <code>va_arg</code>.
The first call to <code>va_arg</code> gives you the first optional argument,
the next call gives you the second, and so on.

<p>You can stop at any time if you wish to ignore any remaining optional
arguments.  It is perfectly all right for a function to access fewer
arguments than were supplied in the call, but you will get garbage
values if you try to access too many arguments.
</p>
</li><li>
You indicate that you are finished with the argument pointer variable by
calling <code>va_end</code>.

<p>(In practice, with most C compilers, calling <code>va_end</code> does nothing.
This is always true in the GNU C compiler.  But you might as well call
<code>va_end</code> just in case your program is someday compiled with a peculiar
compiler.)
</p></li></ol>

<p>See section <a href="#SEC680">Argument Access Macros</a>, for the full definitions of <code>va_start</code>,
<code>va_arg</code> and <code>va_end</code>.
</p>
<p>Steps 1 and 3 must be performed in the function that accepts the
optional arguments.  However, you can pass the <code>va_list</code> variable
as an argument to another function and perform all or part of step 2
there.
</p>
<p>You can perform the entire sequence of three steps multiple times
within a single function invocation.  If you want to ignore the optional
arguments, you can do these steps zero times.
</p>
<p>You can have more than one argument pointer variable if you like.  You
can initialize each variable with <code>va_start</code> when you wish, and
then you can fetch arguments with each argument pointer as you wish.
Each argument pointer variable will sequence through the same set of
argument values, but at its own pace.
</p>
<p><strong>Portability note:</strong> With some compilers, once you pass an
argument pointer value to a subroutine, you must not keep using the same
argument pointer value after that subroutine returns.  For full
portability, you should just pass it to <code>va_end</code>.  This is actually
an ISO C requirement, but most ANSI C compilers work happily
regardless.
</p>
<hr size="6">
<a name="How-Many-Arguments"></a>
<a name="SEC678"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC677" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC679" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC671" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC675" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="libc_35.html#SEC693" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="libc.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="libc_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="libc_42.html#SEC712" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="libc_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h4 class="subsubsection"> A.2.2.3 How Many Arguments Were Supplied </h4>

<p>There is no general way for a function to determine the number and type
of the optional arguments it was called with.  So whoever designs the
function typically designs a convention for the caller to specify the number
and type of arguments.  It is up to you to define an appropriate calling
convention for each variadic function, and write all calls accordingly.
</p>
<p>One kind of calling convention is to pass the number of optional
arguments as one of the fixed arguments.  This convention works provided
all of the optional arguments are of the same type.
</p>
<p>A similar alternative is to have one of the required arguments be a bit
mask, with a bit for each possible purpose for which an optional
argument might be supplied.  You would test the bits in a predefined
sequence; if the bit is set, fetch the value of the next argument,
otherwise use a default value.
</p>
<p>A required argument can be used as a pattern to specify both the number
and types of the optional arguments.  The format string argument to
<code>printf</code> is one example of this (see section <a href="libc_12.html#SEC198">Formatted Output Functions</a>).
</p>
<p>Another possibility is to pass an &ldquo;end marker&rdquo; value as the last
optional argument.  For example, for a function that manipulates an
arbitrary number of pointer arguments, a null pointer might indicate the
end of the argument list.  (This assumes that a null pointer isn't
otherwise meaningful to the function.)  The <code>execl</code> function works
in just this way; see <a href="libc_26.html#SEC573">Executing a File</a>.
</p>

<hr size="6">
<a name="Calling-Variadics"></a>
<a name="SEC679"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC678" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC680" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC671" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC675" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="libc_35.html#SEC693" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="libc.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="libc_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="libc_42.html#SEC712" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="libc_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h4 class="subsubsection"> A.2.2.4 Calling Variadic Functions </h4>

<p>You don't have to do anything special to call a variadic function.
Just put the arguments (required arguments, followed by optional ones)
inside parentheses, separated by commas, as usual.  But you must declare
the function with a prototype and know how the argument values are converted.
</p>
<p>In principle, functions that are <em>defined</em> to be variadic must also
be <em>declared</em> to be variadic using a function prototype whenever
you call them.  (See section <a href="#SEC676">Syntax for Variable Arguments</a>, for how.)  This is because
some C compilers use a different calling convention to pass the same set
of argument values to a function depending on whether that function
takes variable arguments or fixed arguments.
</p>
<p>In practice, the GNU C compiler always passes a given set of argument
types in the same way regardless of whether they are optional or
required.  So, as long as the argument types are self-promoting, you can
safely omit declaring them.  Usually it is a good idea to declare the
argument types for variadic functions, and indeed for all functions.
But there are a few functions which it is extremely convenient not to
have to declare as variadic&mdash;for example, <code>open</code> and
<code>printf</code>.
</p>
<a name="IDX3159"></a>
<a name="IDX3160"></a>
<p>Since the prototype doesn't specify types for optional arguments, in a
call to a variadic function the <em>default argument promotions</em> are
performed on the optional argument values.  This means the objects of
type <code>char</code> or <code>short int</code> (whether signed or not) are
promoted to either <code>int</code> or <code>unsigned int</code>, as
appropriate; and that objects of type <code>float</code> are promoted to type
<code>double</code>.  So, if the caller passes a <code>char</code> as an optional
argument, it is promoted to an <code>int</code>, and the function can access
it with <code>va_arg (<var>ap</var>, int)</code>.
</p>
<p>Conversion of the required arguments is controlled by the function
prototype in the usual way: the argument expression is converted to the
declared argument type as if it were being assigned to a variable of
that type.
</p>
<hr size="6">
<a name="Argument-Macros"></a>
<a name="SEC680"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC679" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC681" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC671" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC675" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="libc_35.html#SEC693" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="libc.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="libc_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="libc_42.html#SEC712" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="libc_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h4 class="subsubsection"> A.2.2.5 Argument Access Macros </h4>

<p>Here are descriptions of the macros used to retrieve variable arguments.
These macros are defined in the header file &lsquo;<tt>stdarg.h</tt>&rsquo;.
<a name="IDX3161"></a>
</p>
<dl>
<dt><u>Data Type:</u> <b>va_list</b>
<a name="IDX3162"></a>
</dt>
<dd><p>The type <code>va_list</code> is used for argument pointer variables.
</p></dd></dl>

<dl>
<dt><u>Macro:</u> void <b>va_start</b><i> (va_list <var>ap</var>, <var>last-required</var>)</i>
<a name="IDX3163"></a>
</dt>
<dd><p>This macro initializes the argument pointer variable <var>ap</var> to point
to the first of the optional arguments of the current function;
<var>last-required</var> must be the last required argument to the function.
</p>
<p>See section <a href="#SEC682">Old-Style Variadic Functions</a>, for an alternate definition of <code>va_start</code>
found in the header file &lsquo;<tt>varargs.h</tt>&rsquo;.
</p></dd></dl>

<dl>
<dt><u>Macro:</u> <var>type</var> <b>va_arg</b><i> (va_list <var>ap</var>, <var>type</var>)</i>
<a name="IDX3164"></a>
</dt>
<dd><p>The <code>va_arg</code> macro returns the value of the next optional argument,
and modifies the value of <var>ap</var> to point to the subsequent argument.
Thus, successive uses of <code>va_arg</code> return successive optional
arguments.
</p>
<p>The type of the value returned by <code>va_arg</code> is <var>type</var> as
specified in the call.  <var>type</var> must be a self-promoting type (not
<code>char</code> or <code>short int</code> or <code>float</code>) that matches the type
of the actual argument.
</p></dd></dl>

<dl>
<dt><u>Macro:</u> void <b>va_end</b><i> (va_list <var>ap</var>)</i>
<a name="IDX3165"></a>
</dt>
<dd><p>This ends the use of <var>ap</var>.  After a <code>va_end</code> call, further
<code>va_arg</code> calls with the same <var>ap</var> may not work.  You should invoke
<code>va_end</code> before returning from the function in which <code>va_start</code>
was invoked with the same <var>ap</var> argument.
</p>
<p>In the GNU C library, <code>va_end</code> does nothing, and you need not ever
use it except for reasons of portability.

</p></dd></dl>

<p>Sometimes it is necessary to parse the list of parameters more than once
or one wants to remember a certain position in the parameter list.  To
do this, one will have to make a copy of the current value of the
argument.  But <code>va_list</code> is an opaque type and one cannot necessarily
assign the value of one variable of type <code>va_list</code> to another variable
of the same type.
</p>
<dl>
<dt><u>Macro:</u> void <b>__va_copy</b><i> (va_list <var>dest</var>, va_list <var>src</var>)</i>
<a name="IDX3166"></a>
</dt>
<dd><p>The <code>__va_copy</code> macro allows copying of objects of type
<code>va_list</code> even if this is not an integral type.  The argument pointer
in <var>dest</var> is initialized to point to the same argument as the
pointer in <var>src</var>.
</p>
<p>This macro is a GNU extension but it will hopefully also be available in
the next update of the ISO C standard.
</p></dd></dl>

<p>If you want to use <code>__va_copy</code> you should always be prepared for the
possibility that this macro will not be available.  On architectures where a
simple assignment is invalid, hopefully <code>__va_copy</code> <em>will</em> be available,
so one should always write something like this:
</p>
<table><tr><td>&nbsp;</td><td><pre class="smallexample">{
  va_list ap, save;
  &hellip;
#ifdef __va_copy
  __va_copy (save, ap);
#else
  save = ap;
#endif
  &hellip;
}
</pre></td></tr></table>


<hr size="6">
<a name="Variadic-Example"></a>
<a name="SEC681"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC680" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC682" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC671" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC673" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="libc_35.html#SEC693" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="libc.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="libc_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="libc_42.html#SEC712" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="libc_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h3 class="subsection"> A.2.3 Example of a Variadic Function </h3>

<p>Here is a complete sample function that accepts a variable number of
arguments.  The first argument to the function is the count of remaining
arguments, which are added up and the result returned.  While trivial,
this function is sufficient to illustrate how to use the variable
arguments facility.
</p>
<table><tr><td>&nbsp;</td><td><pre class="smallexample">#include &lt;stdarg.h&gt;
#include &lt;stdio.h&gt;

int
add_em_up (int count,...)
{
  va_list ap;
  int i, sum;

  va_start (ap, count);         /* <span class="roman">Initialize the argument list.</span> */

  sum = 0;
  for (i = 0; i &lt; count; i++)
    sum += va_arg (ap, int);    /* <span class="roman">Get the next argument value.</span> */

  va_end (ap);                  /* <span class="roman">Clean up.</span> */
  return sum;
}

int
main (void)
{
  /* <span class="roman">This call prints 16.</span> */
  printf (&quot;%d\n&quot;, add_em_up (3, 5, 5, 6));

  /* <span class="roman">This call prints 55.</span> */
  printf (&quot;%d\n&quot;, add_em_up (10, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10));

  return 0;
}
</pre></td></tr></table>

<hr size="6">
<a name="Old-Varargs"></a>
<a name="SEC682"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC681" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC683" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC671" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC681" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="libc_35.html#SEC693" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="libc.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="libc_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="libc_42.html#SEC712" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="libc_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h4 class="subsubsection"> A.2.3.1 Old-Style Variadic Functions </h4>

<p>Before ISO C, programmers used a slightly different facility for
writing variadic functions.  The GNU C compiler still supports it;
currently, it is more portable than the ISO C facility, since support
for ISO C is still not universal.  The header file which defines the
old-fashioned variadic facility is called &lsquo;<tt>varargs.h</tt>&rsquo;.
</p>
<p>Using &lsquo;<tt>varargs.h</tt>&rsquo; is almost the same as using &lsquo;<tt>stdarg.h</tt>&rsquo;.
There is no difference in how you call a variadic function;
see <a href="#SEC679">Calling Variadic Functions</a>.  The only difference is in how you define
them.  First of all, you must use old-style non-prototype syntax, like
this:
</p>
<table><tr><td>&nbsp;</td><td><pre class="smallexample">tree
build (va_alist)
     va_dcl
{
</pre></td></tr></table>

<p>Secondly, you must give <code>va_start</code> only one argument, like this:
</p>
<table><tr><td>&nbsp;</td><td><pre class="smallexample">  va_list p;
  va_start (p);
</pre></td></tr></table>

<p>These are the special macros used for defining old-style variadic
functions:
</p>
<dl>
<dt><u>Macro:</u> <b>va_alist</b>
<a name="IDX3167"></a>
</dt>
<dd><p>This macro stands for the argument name list required in a variadic
function.
</p></dd></dl>

<dl>
<dt><u>Macro:</u> <b>va_dcl</b>
<a name="IDX3168"></a>
</dt>
<dd><p>This macro declares the implicit argument or arguments for a variadic
function.
</p></dd></dl>

<dl>
<dt><u>Macro:</u> void <b>va_start</b><i> (va_list <var>ap</var>)</i>
<a name="IDX3169"></a>
</dt>
<dd><p>This macro, as defined in &lsquo;<tt>varargs.h</tt>&rsquo;, initializes the argument
pointer variable <var>ap</var> to point to the first argument of the current
function.
</p></dd></dl>

<p>The other argument macros, <code>va_arg</code> and <code>va_end</code>, are the same
in &lsquo;<tt>varargs.h</tt>&rsquo; as in &lsquo;<tt>stdarg.h</tt>&rsquo;; see <a href="#SEC680">Argument Access Macros</a>, for
details.
</p>
<p>It does not work to include both &lsquo;<tt>varargs.h</tt>&rsquo; and &lsquo;<tt>stdarg.h</tt>&rsquo; in
the same compilation; they define <code>va_start</code> in conflicting ways.
</p>
<hr size="6">
<a name="Null-Pointer-Constant"></a>
<a name="SEC683"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC682" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC684" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC671" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC671" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="libc_35.html#SEC693" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="libc.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="libc_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="libc_42.html#SEC712" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="libc_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="section"> A.3 Null Pointer Constant </h2>

<p>The null pointer constant is guaranteed not to point to any real object.
You can assign it to any pointer variable since it has type <code>void
*</code>.  The preferred way to write a null pointer constant is with
<code>NULL</code>.
</p>
<dl>
<dt><u>Macro:</u> void * <b>NULL</b>
<a name="IDX3170"></a>
</dt>
<dd><p>This is a null pointer constant.
</p></dd></dl>

<p>You can also use <code>0</code> or <code>(void *)0</code> as a null pointer
constant, but using <code>NULL</code> is cleaner because it makes the purpose
of the constant more evident.
</p>
<p>If you use the null pointer constant as a function argument, then for
complete portability you should make sure that the function has a
prototype declaration.  Otherwise, if the target machine has two
different pointer representations, the compiler won't know which
representation to use for that argument.  You can avoid the problem by
explicitly casting the constant to the proper pointer type, but we
recommend instead adding a prototype for the function you are calling.
</p>
<hr size="6">
<a name="Important-Data-Types"></a>
<a name="SEC684"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC683" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC685" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC671" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC671" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="libc_35.html#SEC693" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="libc.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="libc_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="libc_42.html#SEC712" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="libc_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="section"> A.4 Important Data Types </h2>

<p>The result of subtracting two pointers in C is always an integer, but the
precise data type varies from C compiler to C compiler.  Likewise, the
data type of the result of <code>sizeof</code> also varies between compilers.
ISO defines standard aliases for these two types, so you can refer to
them in a portable fashion.  They are defined in the header file
&lsquo;<tt>stddef.h</tt>&rsquo;.
<a name="IDX3171"></a>
</p>
<dl>
<dt><u>Data Type:</u> <b>ptrdiff_t</b>
<a name="IDX3172"></a>
</dt>
<dd><p>This is the signed integer type of the result of subtracting two
pointers.  For example, with the declaration <code>char *p1, *p2;</code>, the
expression <code>p2 - p1</code> is of type <code>ptrdiff_t</code>.  This will
probably be one of the standard signed integer types (<code>short
int</code>, <code>int</code> or <code>long int</code>), but might be a nonstandard
type that exists only for this purpose.
</p></dd></dl>

<dl>
<dt><u>Data Type:</u> <b>size_t</b>
<a name="IDX3173"></a>
</dt>
<dd><p>This is an unsigned integer type used to represent the sizes of objects.
The result of the <code>sizeof</code> operator is of this type, and functions
such as <code>malloc</code> (see section <a href="libc_3.html#SEC24">Unconstrained Allocation</a>) and
<code>memcpy</code> (see section <a href="libc_5.html#SEC74">Copying and Concatenation</a>) accept arguments of
this type to specify object sizes.
</p>
<p><strong>Usage Note:</strong> <code>size_t</code> is the preferred way to declare any
arguments or variables that hold the size of an object.
</p></dd></dl>

<p>In the GNU system <code>size_t</code> is equivalent to either
<code>unsigned int</code> or <code>unsigned long int</code>.  These types
have identical properties on the GNU system and, for most purposes, you
can use them interchangeably.  However, they are distinct as data types,
which makes a difference in certain contexts.
</p>
<p>For example, when you specify the type of a function argument in a
function prototype, it makes a difference which one you use.  If the
system header files declare <code>malloc</code> with an argument of type
<code>size_t</code> and you declare <code>malloc</code> with an argument of type
<code>unsigned int</code>, you will get a compilation error if <code>size_t</code>
happens to be <code>unsigned long int</code> on your system.  To avoid any
possibility of error, when a function argument or value is supposed to
have type <code>size_t</code>, never declare its type in any other way.
</p>
<p><strong>Compatibility Note:</strong> Implementations of C before the advent of
ISO C generally used <code>unsigned int</code> for representing object sizes
and <code>int</code> for pointer subtraction results.  They did not
necessarily define either <code>size_t</code> or <code>ptrdiff_t</code>.  Unix
systems did define <code>size_t</code>, in &lsquo;<tt>sys/types.h</tt>&rsquo;, but the
definition was usually a signed type.
</p>
<hr size="6">
<a name="Data-Type-Measurements"></a>
<a name="SEC685"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC684" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC686" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC671" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC671" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="libc_35.html#SEC693" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="libc.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="libc_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="libc_42.html#SEC712" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="libc_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="section"> A.5 Data Type Measurements </h2>

<p>Most of the time, if you choose the proper C data type for each object
in your program, you need not be concerned with just how it is
represented or how many bits it uses.  When you do need such
information, the C language itself does not provide a way to get it.
The header files &lsquo;<tt>limits.h</tt>&rsquo; and &lsquo;<tt>float.h</tt>&rsquo; contain macros
which give you this information in full detail.
</p>
<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top"><a href="#SEC686">A.5.1 Computing the Width of an Integer Data Type</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">           How many bits does an integer type hold?
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC687">A.5.2 Range of an Integer Type</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">           What are the largest and smallest values
			     that an integer type can hold?
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC688">A.5.3 Floating Type Macros</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">    Parameters that measure the floating point types.
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC692">A.5.4 Structure Field Offset Measurement</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">   Getting measurements on structure types.
</td></tr>
</table>

<hr size="6">
<a name="Width-of-Type"></a>
<a name="SEC686"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC685" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC687" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC671" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC685" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="libc_35.html#SEC693" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="libc.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="libc_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="libc_42.html#SEC712" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="libc_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h3 class="subsection"> A.5.1 Computing the Width of an Integer Data Type </h3>

<p>The most common reason that a program needs to know how many bits are in
an integer type is for using an array of <code>long int</code> as a bit vector.
You can access the bit at index <var>n</var> with
</p>
<table><tr><td>&nbsp;</td><td><pre class="smallexample">vector[<var>n</var> / LONGBITS] &amp; (1 &lt;&lt; (<var>n</var> % LONGBITS))
</pre></td></tr></table>

<p>provided you define <code>LONGBITS</code> as the number of bits in a
<code>long int</code>.
</p>
<a name="IDX3174"></a>
<p>There is no operator in the C language that can give you the number of
bits in an integer data type.  But you can compute it from the macro
<code>CHAR_BIT</code>, defined in the header file &lsquo;<tt>limits.h</tt>&rsquo;.
</p>
<dl compact="compact">
<dt> <code>CHAR_BIT</code></dt>
<dd><p>This is the number of bits in a <code>char</code>&mdash;eight, on most systems.
The value has type <code>int</code>.
</p>
<p>You can compute the number of bits in any data type <var>type</var> like
this:
</p>
<table><tr><td>&nbsp;</td><td><pre class="smallexample">sizeof (<var>type</var>) * CHAR_BIT
</pre></td></tr></table>
</dd>
</dl>

<hr size="6">
<a name="Range-of-Type"></a>
<a name="SEC687"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC686" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC688" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC671" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC685" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="libc_35.html#SEC693" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="libc.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="libc_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="libc_42.html#SEC712" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="libc_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h3 class="subsection"> A.5.2 Range of an Integer Type </h3>

<p>Suppose you need to store an integer value which can range from zero to
one million.  Which is the smallest type you can use?  There is no
general rule; it depends on the C compiler and target machine.  You can
use the &lsquo;<samp>MIN</samp>&rsquo; and &lsquo;<samp>MAX</samp>&rsquo; macros in &lsquo;<tt>limits.h</tt>&rsquo; to determine
which type will work.
</p>
<p>Each signed integer type has a pair of macros which give the smallest
and largest values that it can hold.  Each unsigned integer type has one
such macro, for the maximum value; the minimum value is, of course,
zero.
</p>
<p>The values of these macros are all integer constant expressions.  The
&lsquo;<samp>MAX</samp>&rsquo; and &lsquo;<samp>MIN</samp>&rsquo; macros for <code>char</code> and <code>short
int</code> types have values of type <code>int</code>.  The &lsquo;<samp>MAX</samp>&rsquo; and
&lsquo;<samp>MIN</samp>&rsquo; macros for the other types have values of the same type
described by the macro&mdash;thus, <code>ULONG_MAX</code> has type
<code>unsigned long int</code>.
</p>
<dl compact="compact">
<dt> <code>SCHAR_MIN</code>
<a name="IDX3175"></a>
</dt>
<dd>
<p>This is the minimum value that can be represented by a <code>signed char</code>.
</p>
</dd>
<dt> <code>SCHAR_MAX</code>
<a name="IDX3176"></a>
</dt>
<dt> <code>UCHAR_MAX</code>
<a name="IDX3177"></a>
</dt>
<dd>
<p>These are the maximum values that can be represented by a
<code>signed char</code> and <code>unsigned char</code>, respectively.
</p>
</dd>
<dt> <code>CHAR_MIN</code>
<a name="IDX3178"></a>
</dt>
<dd>
<p>This is the minimum value that can be represented by a <code>char</code>.
It's equal to <code>SCHAR_MIN</code> if <code>char</code> is signed, or zero
otherwise.
</p>
</dd>
<dt> <code>CHAR_MAX</code>
<a name="IDX3179"></a>
</dt>
<dd>
<p>This is the maximum value that can be represented by a <code>char</code>.
It's equal to <code>SCHAR_MAX</code> if <code>char</code> is signed, or
<code>UCHAR_MAX</code> otherwise.
</p>
</dd>
<dt> <code>SHRT_MIN</code>
<a name="IDX3180"></a>
</dt>
<dd>
<p>This is the minimum value that can be represented by a <code>signed
short int</code>.  On most machines that the GNU C library runs on,
<code>short</code> integers are 16-bit quantities.
</p>
</dd>
<dt> <code>SHRT_MAX</code>
<a name="IDX3181"></a>
</dt>
<dt> <code>USHRT_MAX</code>
<a name="IDX3182"></a>
</dt>
<dd>
<p>These are the maximum values that can be represented by a
<code>signed short int</code> and <code>unsigned short int</code>,
respectively.
</p>
</dd>
<dt> <code>INT_MIN</code>
<a name="IDX3183"></a>
</dt>
<dd>
<p>This is the minimum value that can be represented by a <code>signed
int</code>.  On most machines that the GNU C system runs on, an <code>int</code> is
a 32-bit quantity.
</p>
</dd>
<dt> <code>INT_MAX</code>
<a name="IDX3184"></a>
</dt>
<dt> <code>UINT_MAX</code>
<a name="IDX3185"></a>
</dt>
<dd>
<p>These are the maximum values that can be represented by, respectively,
the type <code>signed int</code> and the type <code>unsigned int</code>.
</p>
</dd>
<dt> <code>LONG_MIN</code>
<a name="IDX3186"></a>
</dt>
<dd>
<p>This is the minimum value that can be represented by a <code>signed
long int</code>.  On most machines that the GNU C system runs on, <code>long</code>
integers are 32-bit quantities, the same size as <code>int</code>.
</p>
</dd>
<dt> <code>LONG_MAX</code>
<a name="IDX3187"></a>
</dt>
<dt> <code>ULONG_MAX</code>
<a name="IDX3188"></a>
</dt>
<dd>
<p>These are the maximum values that can be represented by a
<code>signed long int</code> and <code>unsigned long int</code>, respectively.
</p>
</dd>
<dt> <code>LONG_LONG_MIN</code>
<a name="IDX3189"></a>
</dt>
<dd>
<p>This is the minimum value that can be represented by a <code>signed
long long int</code>.  On most machines that the GNU C system runs on,
<code>long long</code> integers are 64-bit quantities.
</p>
</dd>
<dt> <code>LONG_LONG_MAX</code>
<a name="IDX3190"></a>
</dt>
<dt> <code>ULONG_LONG_MAX</code>
<a name="IDX3191"></a>
</dt>
<dd>
<p>These are the maximum values that can be represented by a <code>signed
long long int</code> and <code>unsigned long long int</code>, respectively.
</p>
</dd>
<dt> <code>WCHAR_MAX</code>
<a name="IDX3192"></a>
</dt>
<dd>
<p>This is the maximum value that can be represented by a <code>wchar_t</code>.
See section <a href="libc_6.html#SEC87">Introduction to Extended Characters</a>.
</p></dd>
</dl>

<p>The header file &lsquo;<tt>limits.h</tt>&rsquo; also defines some additional constants
that parameterize various operating system and file system limits.  These
constants are described in <a href="libc_31.html#SEC648">System Configuration Parameters</a>.
</p>
<hr size="6">
<a name="Floating-Type-Macros"></a>
<a name="SEC688"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC687" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC689" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC671" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC685" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="libc_35.html#SEC693" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="libc.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="libc_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="libc_42.html#SEC712" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="libc_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h3 class="subsection"> A.5.3 Floating Type Macros </h3>

<p>The specific representation of floating point numbers varies from
machine to machine.  Because floating point numbers are represented
internally as approximate quantities, algorithms for manipulating
floating point data often need to take account of the precise details of
the machine's floating point representation.
</p>
<p>Some of the functions in the C library itself need this information; for
example, the algorithms for printing and reading floating point numbers
(see section <a href="libc_12.html#SEC177">Input/Output on Streams</a>) and for calculating trigonometric and
irrational functions (see section <a href="libc_19.html#SEC390">Mathematics</a>) use it to avoid round-off
error and loss of accuracy.  User programs that implement numerical
analysis techniques also often need this information in order to
minimize or compute error bounds.
</p>
<p>The header file &lsquo;<tt>float.h</tt>&rsquo; describes the format used by your
machine.
</p>
<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top"><a href="#SEC689">A.5.3.1 Floating Point Representation Concepts</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">     Definitions of terminology.
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC690">A.5.3.2 Floating Point Parameters</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">   Details of specific macros.
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC691">A.5.3.3 IEEE Floating Point</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">         The measurements for one common
                                 representation.
</td></tr>
</table>

<hr size="6">
<a name="Floating-Point-Concepts"></a>
<a name="SEC689"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC688" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC690" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC671" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC688" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="libc_35.html#SEC693" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="libc.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="libc_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="libc_42.html#SEC712" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="libc_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h4 class="subsubsection"> A.5.3.1 Floating Point Representation Concepts </h4>

<p>This section introduces the terminology for describing floating point
representations.
</p>
<p>You are probably already familiar with most of these concepts in terms
of scientific or exponential notation for floating point numbers.  For
example, the number <code>123456.0</code> could be expressed in exponential
notation as <code>1.23456e+05</code>, a shorthand notation indicating that the
mantissa <code>1.23456</code> is multiplied by the base <code>10</code> raised to
power <code>5</code>.
</p>
<p>More formally, the internal representation of a floating point number
can be characterized in terms of the following parameters:
</p>
<ul>
<li>
<a name="IDX3193"></a>
The <em>sign</em> is either <code>-1</code> or <code>1</code>.

</li><li>
<a name="IDX3194"></a>
<a name="IDX3195"></a>
The <em>base</em> or <em>radix</em> for exponentiation, an integer greater
than <code>1</code>.  This is a constant for a particular representation.

</li><li>
<a name="IDX3196"></a>
The <em>exponent</em> to which the base is raised.  The upper and lower
bounds of the exponent value are constants for a particular
representation.

<a name="IDX3197"></a>
<p>Sometimes, in the actual bits representing the floating point number,
the exponent is <em>biased</em> by adding a constant to it, to make it
always be represented as an unsigned quantity.  This is only important
if you have some reason to pick apart the bit fields making up the
floating point number by hand, which is something for which the GNU
library provides no support.  So this is ignored in the discussion that
follows.
</p>
</li><li>
<a name="IDX3198"></a>
<a name="IDX3199"></a>
The <em>mantissa</em> or <em>significand</em> is an unsigned integer which is a
part of each floating point number.

</li><li>
<a name="IDX3200"></a>
The <em>precision</em> of the mantissa.  If the base of the representation
is <var>b</var>, then the precision is the number of base-<var>b</var> digits in
the mantissa.  This is a constant for a particular representation.

<a name="IDX3201"></a>
<p>Many floating point representations have an implicit <em>hidden bit</em> in
the mantissa.  This is a bit which is present virtually in the mantissa,
but not stored in memory because its value is always 1 in a normalized
number.  The precision figure (see above) includes any hidden bits.
</p>
<p>Again, the GNU library provides no facilities for dealing with such
low-level aspects of the representation.
</p></li></ul>

<p>The mantissa of a floating point number represents an implicit fraction
whose denominator is the base raised to the power of the precision.  Since
the largest representable mantissa is one less than this denominator, the
value of the fraction is always strictly less than <code>1</code>.  The
mathematical value of a floating point number is then the product of this
fraction, the sign, and the base raised to the exponent.
</p>
<a name="IDX3202"></a>
<p>We say that the floating point number is <em>normalized</em> if the
fraction is at least <code>1/<var>b</var></code>, where <var>b</var> is the base.  In
other words, the mantissa would be too large to fit if it were
multiplied by the base.  Non-normalized numbers are sometimes called
<em>denormal</em>; they contain less precision than the representation
normally can hold.
</p>
<p>If the number is not normalized, then you can subtract <code>1</code> from the
exponent while multiplying the mantissa by the base, and get another
floating point number with the same value.  <em>Normalization</em> consists
of doing this repeatedly until the number is normalized.  Two distinct
normalized floating point numbers cannot be equal in value.
</p>
<p>(There is an exception to this rule: if the mantissa is zero, it is
considered normalized.  Another exception happens on certain machines
where the exponent is as small as the representation can hold.  Then
it is impossible to subtract <code>1</code> from the exponent, so a number
may be normalized even if its fraction is less than <code>1/<var>b</var></code>.)
</p>
<hr size="6">
<a name="Floating-Point-Parameters"></a>
<a name="SEC690"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC689" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC691" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC671" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC688" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="libc_35.html#SEC693" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="libc.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="libc_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="libc_42.html#SEC712" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="libc_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h4 class="subsubsection"> A.5.3.2 Floating Point Parameters </h4>

<p>These macro definitions can be accessed by including the header file
&lsquo;<tt>float.h</tt>&rsquo; in your program.
</p>
<p>Macro names starting with &lsquo;<samp>FLT_</samp>&rsquo; refer to the <code>float</code> type,
while names beginning with &lsquo;<samp>DBL_</samp>&rsquo; refer to the <code>double</code> type
and names beginning with &lsquo;<samp>LDBL_</samp>&rsquo; refer to the <code>long double</code>
type.  (If GCC does not support <code>long double</code> as a distinct data
type on a target machine then the values for the &lsquo;<samp>LDBL_</samp>&rsquo; constants
are equal to the corresponding constants for the <code>double</code> type.)
</p>
<p>Of these macros, only <code>FLT_RADIX</code> is guaranteed to be a constant
expression.  The other macros listed here cannot be reliably used in
places that require constant expressions, such as &lsquo;<samp>#if</samp>&rsquo;
preprocessing directives or in the dimensions of static arrays.
</p>
<p>Although the ISO C standard specifies minimum and maximum values for
most of these parameters, the GNU C implementation uses whatever values
describe the floating point representation of the target machine.  So in
principle GNU C actually satisfies the ISO C requirements only if the
target machine is suitable.  In practice, all the machines currently
supported are suitable.
</p>
<dl compact="compact">
<dt> <code>FLT_ROUNDS</code>
<a name="IDX3203"></a>
</dt>
<dd><p>This value characterizes the rounding mode for floating point addition.
The following values indicate standard rounding modes:
</p>

<dl compact="compact">
<dt> <code>-1</code></dt>
<dd><p>The mode is indeterminable.
</p></dd>
<dt> <code>0</code></dt>
<dd><p>Rounding is towards zero.
</p></dd>
<dt> <code>1</code></dt>
<dd><p>Rounding is to the nearest number.
</p></dd>
<dt> <code>2</code></dt>
<dd><p>Rounding is towards positive infinity.
</p></dd>
<dt> <code>3</code></dt>
<dd><p>Rounding is towards negative infinity.
</p></dd>
</dl>

<p>Any other value represents a machine-dependent nonstandard rounding
mode.
</p>
<p>On most machines, the value is <code>1</code>, in accordance with the IEEE
standard for floating point.
</p>
<p>Here is a table showing how certain values round for each possible value
of <code>FLT_ROUNDS</code>, if the other aspects of the representation match
the IEEE single-precision standard.
</p>
<table><tr><td>&nbsp;</td><td><pre class="smallexample">                0      1             2             3
 1.00000003    1.0    1.0           1.00000012    1.0
 1.00000007    1.0    1.00000012    1.00000012    1.0
-1.00000003   -1.0   -1.0          -1.0          -1.00000012
-1.00000007   -1.0   -1.00000012   -1.0          -1.00000012
</pre></td></tr></table>

</dd>
<dt> <code>FLT_RADIX</code>
<a name="IDX3204"></a>
</dt>
<dd><p>This is the value of the base, or radix, of the exponent representation.
This is guaranteed to be a constant expression, unlike the other macros
described in this section.  The value is 2 on all machines we know of
except the IBM 360 and derivatives.
</p>
</dd>
<dt> <code>FLT_MANT_DIG</code>
<a name="IDX3205"></a>
</dt>
<dd><p>This is the number of base-<code>FLT_RADIX</code> digits in the floating point
mantissa for the <code>float</code> data type.  The following expression
yields <code>1.0</code> (even though mathematically it should not) due to the
limited number of mantissa digits:
</p>
<table><tr><td>&nbsp;</td><td><pre class="smallexample">float radix = FLT_RADIX;

1.0f + 1.0f / radix / radix / &hellip; / radix
</pre></td></tr></table>

<p>where <code>radix</code> appears <code>FLT_MANT_DIG</code> times.
</p>
</dd>
<dt> <code>DBL_MANT_DIG</code>
<a name="IDX3206"></a>
</dt>
<dt> <code>LDBL_MANT_DIG</code>
<a name="IDX3207"></a>
</dt>
<dd><p>This is the number of base-<code>FLT_RADIX</code> digits in the floating point
mantissa for the data types <code>double</code> and <code>long double</code>,
respectively.
</p>
</dd>
<dt> <code>FLT_DIG</code>
<a name="IDX3208"></a>
</dt>
<dd>
<p>This is the number of decimal digits of precision for the <code>float</code>
data type.  Technically, if <var>p</var> and <var>b</var> are the precision and
base (respectively) for the representation, then the decimal precision
<var>q</var> is the maximum number of decimal digits such that any floating
point number with <var>q</var> base 10 digits can be rounded to a floating
point number with <var>p</var> base <var>b</var> digits and back again, without
change to the <var>q</var> decimal digits.
</p>
<p>The value of this macro is supposed to be at least <code>6</code>, to satisfy
ISO C.
</p>
</dd>
<dt> <code>DBL_DIG</code>
<a name="IDX3209"></a>
</dt>
<dt> <code>LDBL_DIG</code>
<a name="IDX3210"></a>
</dt>
<dd>
<p>These are similar to <code>FLT_DIG</code>, but for the data types
<code>double</code> and <code>long double</code>, respectively.  The values of these
macros are supposed to be at least <code>10</code>.
</p>
</dd>
<dt> <code>FLT_MIN_EXP</code>
<a name="IDX3211"></a>
</dt>
<dd><p>This is the smallest possible exponent value for type <code>float</code>.
More precisely, is the minimum negative integer such that the value
<code>FLT_RADIX</code> raised to this power minus 1 can be represented as a
normalized floating point number of type <code>float</code>.
</p>
</dd>
<dt> <code>DBL_MIN_EXP</code>
<a name="IDX3212"></a>
</dt>
<dt> <code>LDBL_MIN_EXP</code>
<a name="IDX3213"></a>
</dt>
<dd>
<p>These are similar to <code>FLT_MIN_EXP</code>, but for the data types
<code>double</code> and <code>long double</code>, respectively.
</p>
</dd>
<dt> <code>FLT_MIN_10_EXP</code>
<a name="IDX3214"></a>
</dt>
<dd><p>This is the minimum negative integer such that <code>10</code> raised to this
power minus 1 can be represented as a normalized floating point number
of type <code>float</code>.  This is supposed to be <code>-37</code> or even less.
</p>
</dd>
<dt> <code>DBL_MIN_10_EXP</code>
<a name="IDX3215"></a>
</dt>
<dt> <code>LDBL_MIN_10_EXP</code>
<a name="IDX3216"></a>
</dt>
<dd><p>These are similar to <code>FLT_MIN_10_EXP</code>, but for the data types
<code>double</code> and <code>long double</code>, respectively.
</p>
</dd>
<dt> <code>FLT_MAX_EXP</code>
<a name="IDX3217"></a>
</dt>
<dd><p>This is the largest possible exponent value for type <code>float</code>.  More
precisely, this is the maximum positive integer such that value
<code>FLT_RADIX</code> raised to this power minus 1 can be represented as a
floating point number of type <code>float</code>.
</p>
</dd>
<dt> <code>DBL_MAX_EXP</code>
<a name="IDX3218"></a>
</dt>
<dt> <code>LDBL_MAX_EXP</code>
<a name="IDX3219"></a>
</dt>
<dd><p>These are similar to <code>FLT_MAX_EXP</code>, but for the data types
<code>double</code> and <code>long double</code>, respectively.
</p>
</dd>
<dt> <code>FLT_MAX_10_EXP</code>
<a name="IDX3220"></a>
</dt>
<dd><p>This is the maximum positive integer such that <code>10</code> raised to this
power minus 1 can be represented as a normalized floating point number
of type <code>float</code>.  This is supposed to be at least <code>37</code>.
</p>
</dd>
<dt> <code>DBL_MAX_10_EXP</code>
<a name="IDX3221"></a>
</dt>
<dt> <code>LDBL_MAX_10_EXP</code>
<a name="IDX3222"></a>
</dt>
<dd><p>These are similar to <code>FLT_MAX_10_EXP</code>, but for the data types
<code>double</code> and <code>long double</code>, respectively.
</p>
</dd>
<dt> <code>FLT_MAX</code>
<a name="IDX3223"></a>
</dt>
<dd>
<p>The value of this macro is the maximum number representable in type
<code>float</code>.  It is supposed to be at least <code>1E+37</code>.  The value
has type <code>float</code>.
</p>
<p>The smallest representable number is <code>- FLT_MAX</code>.
</p>
</dd>
<dt> <code>DBL_MAX</code>
<a name="IDX3224"></a>
</dt>
<dt> <code>LDBL_MAX</code>
<a name="IDX3225"></a>
</dt>
<dd>
<p>These are similar to <code>FLT_MAX</code>, but for the data types
<code>double</code> and <code>long double</code>, respectively.  The type of the
macro's value is the same as the type it describes.
</p>
</dd>
<dt> <code>FLT_MIN</code>
<a name="IDX3226"></a>
</dt>
<dd>
<p>The value of this macro is the minimum normalized positive floating
point number that is representable in type <code>float</code>.  It is supposed
to be no more than <code>1E-37</code>.
</p>
</dd>
<dt> <code>DBL_MIN</code>
<a name="IDX3227"></a>
</dt>
<dt> <code>LDBL_MIN</code>
<a name="IDX3228"></a>
</dt>
<dd>
<p>These are similar to <code>FLT_MIN</code>, but for the data types
<code>double</code> and <code>long double</code>, respectively.  The type of the
macro's value is the same as the type it describes.
</p>
</dd>
<dt> <code>FLT_EPSILON</code>
<a name="IDX3229"></a>
</dt>
<dd>
<p>This is the minimum positive floating point number of type <code>float</code>
such that <code>1.0 + FLT_EPSILON != 1.0</code> is true.  It's supposed to
be no greater than <code>1E-5</code>.
</p>
</dd>
<dt> <code>DBL_EPSILON</code>
<a name="IDX3230"></a>
</dt>
<dt> <code>LDBL_EPSILON</code>
<a name="IDX3231"></a>
</dt>
<dd>
<p>These are similar to <code>FLT_EPSILON</code>, but for the data types
<code>double</code> and <code>long double</code>, respectively.  The type of the
macro's value is the same as the type it describes.  The values are not
supposed to be greater than <code>1E-9</code>.
</p></dd>
</dl>

<hr size="6">
<a name="IEEE-Floating-Point"></a>
<a name="SEC691"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC690" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC692" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC671" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC688" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="libc_35.html#SEC693" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="libc.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="libc_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="libc_42.html#SEC712" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="libc_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h4 class="subsubsection"> A.5.3.3 IEEE Floating Point </h4>

<p>Here is an example showing how the floating type measurements come out
for the most common floating point representation, specified by the
<cite>IEEE Standard for Binary Floating Point Arithmetic (ANSI/IEEE Std
754-1985)</cite>.  Nearly all computers designed since the 1980s use this
format.
</p>
<p>The IEEE single-precision float representation uses a base of 2.  There
is a sign bit, a mantissa with 23 bits plus one hidden bit (so the total
precision is 24 base-2 digits), and an 8-bit exponent that can represent
values in the range -125 to 128, inclusive.
</p>
<p>So, for an implementation that uses this representation for the
<code>float</code> data type, appropriate values for the corresponding
parameters are:
</p>
<table><tr><td>&nbsp;</td><td><pre class="smallexample">FLT_RADIX                             2
FLT_MANT_DIG                         24
FLT_DIG                               6
FLT_MIN_EXP                        -125
FLT_MIN_10_EXP                      -37
FLT_MAX_EXP                         128
FLT_MAX_10_EXP                      +38
FLT_MIN                 1.17549435E-38F
FLT_MAX                 3.40282347E+38F
FLT_EPSILON             1.19209290E-07F
</pre></td></tr></table>

<p>Here are the values for the <code>double</code> data type:
</p>
<table><tr><td>&nbsp;</td><td><pre class="smallexample">DBL_MANT_DIG                         53
DBL_DIG                              15
DBL_MIN_EXP                       -1021
DBL_MIN_10_EXP                     -307
DBL_MAX_EXP                        1024
DBL_MAX_10_EXP                      308
DBL_MAX         1.7976931348623157E+308
DBL_MIN         2.2250738585072014E-308
DBL_EPSILON     2.2204460492503131E-016
</pre></td></tr></table>

<hr size="6">
<a name="Structure-Measurement"></a>
<a name="SEC692"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC691" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="libc_35.html#SEC693" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC671" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC685" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="libc_35.html#SEC693" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="libc.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="libc_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="libc_42.html#SEC712" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="libc_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h3 class="subsection"> A.5.4 Structure Field Offset Measurement </h3>

<p>You can use <code>offsetof</code> to measure the location within a structure
type of a particular structure member.
</p>
<dl>
<dt><u>Macro:</u> size_t <b>offsetof</b><i> (<var>type</var>, <var>member</var>)</i>
<a name="IDX3232"></a>
</dt>
<dd><p>This expands to a integer constant expression that is the offset of the
structure member named <var>member</var> in the structure type <var>type</var>.
For example, <code>offsetof (struct s, elem)</code> is the offset, in bytes,
of the member <code>elem</code> in a <code>struct s</code>.
</p>
<p>This macro won't work if <var>member</var> is a bit field; you get an error
from the C compiler in that case.
</p></dd></dl>
<hr size="6">
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC671" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="libc_35.html#SEC693" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="libc.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="libc_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="libc_42.html#SEC712" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="libc_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<p>
 <font size="-1">
  This document was generated by <em>root</em> on <em>January, 19 2009</em> using <a href="http://www.nongnu.org/texi2html/"><em>texi2html 1.78</em></a>.
 </font>
 <br>

</p>
</body>
</html>
