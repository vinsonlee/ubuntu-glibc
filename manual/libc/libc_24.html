<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html401/loose.dtd">
<html>
<!-- This file documents the GNU C library.

This is Edition 0.12, last updated 2007-10-27,
of The GNU C Library Reference Manual, for version 2.8.

Copyright (C) 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2001, 2002,
2003, 2007, 2008 Free Software Foundation, Inc.

Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.2 or
any later version published by the Free Software Foundation; with the
Invariant Sections being "Free Software Needs Free Documentation"
and "GNU Lesser General Public License", the Front-Cover texts being
"A GNU Manual", and with the Back-Cover Texts as in (a) below.  A
copy of the license is included in the section entitled "GNU Free
Documentation License".

(a) The FSF's Back-Cover Text is: "You have the freedom to
copy and modify this GNU manual.  Buying copies from the FSF
supports it in developing GNU and promoting software freedom."
 -->
<!-- Created on February, 26 2009 by texi2html 1.78 -->
<!--
Written by: Lionel Cons <Lionel.Cons@cern.ch> (original author)
            Karl Berry  <karl@freefriends.org>
            Olaf Bachmann <obachman@mathematik.uni-kl.de>
            and many others.
Maintained by: Many creative people.
Send bugs and suggestions to <texi2html-bug@nongnu.org>

-->
<head>
<title>The GNU C Library: 24. Signal Handling</title>

<meta name="description" content="The GNU C Library: 24. Signal Handling">
<meta name="keywords" content="The GNU C Library: 24. Signal Handling">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="texi2html 1.78">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
<!--
a.summary-letter {text-decoration: none}
pre.display {font-family: serif}
pre.format {font-family: serif}
pre.menu-comment {font-family: serif}
pre.menu-preformatted {font-family: serif}
pre.smalldisplay {font-family: serif; font-size: smaller}
pre.smallexample {font-size: smaller}
pre.smallformat {font-family: serif; font-size: smaller}
pre.smalllisp {font-size: smaller}
span.roman {font-family:serif; font-weight:normal;}
span.sansserif {font-family:sans-serif; font-weight:normal;}
ul.toc {list-style: none}
-->
</style>


</head>

<body lang="en" bgcolor="#FFFFFF" text="#000000" link="#0000FF" vlink="#800080" alink="#FF0000">

<a name="Signal-Handling"></a>
<a name="SEC471"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="libc_23.html#SEC469" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC472" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="libc_23.html#SEC465" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="libc.html#SEC_Top" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="libc_25.html#SEC525" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="libc.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="libc_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="libc_42.html#SEC712" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="libc_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h1 class="chapter"> 24. Signal Handling </h1>

<p>A <em>signal</em> is a software interrupt delivered to a process.  The
operating system uses signals to report exceptional situations to an
executing program.  Some signals report errors such as references to
invalid memory addresses; others report asynchronous events, such as
disconnection of a phone line.
</p>
<p>The GNU C library defines a variety of signal types, each for a
particular kind of event.  Some kinds of events make it inadvisable or
impossible for the program to proceed as usual, and the corresponding
signals normally abort the program.  Other kinds of signals that report
harmless events are ignored by default.
</p>
<p>If you anticipate an event that causes signals, you can define a handler
function and tell the operating system to run it when that particular
type of signal arrives.
</p>
<p>Finally, one process can send a signal to another process; this allows a
parent process to abort a child, or two related processes to communicate
and synchronize.
</p>
<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top"><a href="#SEC472">24.1 Basic Concepts of Signals</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">         Introduction to the signal facilities.
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC476">24.2 Standard Signals</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">            Particular kinds of signals with
                                 standard names and meanings.
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC485">24.3 Specifying Signal Actions</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">              Specifying what happens when a
                                 particular signal is delivered.
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC492">24.4 Defining Signal Handlers</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">           How to write a signal handler function.
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC503">24.5 Primitives Interrupted by Signals</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">	Signal handlers affect use of <code>open</code>,
				 <code>read</code>, <code>write</code> and other functions.
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC504">24.6 Generating Signals</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">          How to send a signal to a process.
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC509">24.7 Blocking Signals</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">            Making the system hold signals temporarily.
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC517">24.8 Waiting for a Signal</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">        Suspending your program until a signal
                                 arrives.
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC521">24.9 Using a Separate Signal Stack</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top"></td></tr>
<tr><td align="left" valign="top"><a href="#SEC522">24.10 BSD Signal Handling</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">         Additional functions for backward
			         compatibility with BSD.
</td></tr>
</table>

<hr size="6">
<a name="Concepts-of-Signals"></a>
<a name="SEC472"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC471" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC473" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC471" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC471" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="libc_25.html#SEC525" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="libc.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="libc_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="libc_42.html#SEC712" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="libc_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="section"> 24.1 Basic Concepts of Signals </h2>

<p>This section explains basic concepts of how signals are generated, what
happens after a signal is delivered, and how programs can handle
signals.
</p>
<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top"><a href="#SEC473">24.1.1 Some Kinds of Signals</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">            Some examples of what can cause a signal.
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC474">24.1.2 Concepts of Signal Generation</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">           Concepts of why and how signals occur.
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC475">24.1.3 How Signals Are Delivered</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">          Concepts of what a signal does to the
                                 process.
</td></tr>
</table>

<hr size="6">
<a name="Kinds-of-Signals"></a>
<a name="SEC473"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC472" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC474" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC471" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC472" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="libc_25.html#SEC525" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="libc.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="libc_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="libc_42.html#SEC712" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="libc_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h3 class="subsection"> 24.1.1 Some Kinds of Signals </h3>

<p>A signal reports the occurrence of an exceptional event.  These are some
of the events that can cause (or <em>generate</em>, or <em>raise</em>) a
signal:
</p>
<ul>
<li>
A program error such as dividing by zero or issuing an address outside
the valid range.

</li><li>
A user request to interrupt or terminate the program.  Most environments
are set up to let a user suspend the program by typing <kbd>C-z</kbd>, or
terminate it with <kbd>C-c</kbd>.  Whatever key sequence is used, the
operating system sends the proper signal to interrupt the process.

</li><li>
The termination of a child process.

</li><li>
Expiration of a timer or alarm.

</li><li>
A call to <code>kill</code> or <code>raise</code> by the same process.

</li><li>
A call to <code>kill</code> from another process.  Signals are a limited but
useful form of interprocess communication.

</li><li>
An attempt to perform an I/O operation that cannot be done.  Examples
are reading from a pipe that has no writer (see section <a href="libc_15.html#SEC297">Pipes and FIFOs</a>),
and reading or writing to a terminal in certain situations (see section <a href="libc_27.html#SEC578">Job Control</a>).
</li></ul>

<p>Each of these kinds of events (excepting explicit calls to <code>kill</code>
and <code>raise</code>) generates its own particular kind of signal.  The
various kinds of signals are listed and described in detail in
<a href="#SEC476">Standard Signals</a>.
</p>
<hr size="6">
<a name="Signal-Generation"></a>
<a name="SEC474"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC473" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC475" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC471" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC472" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="libc_25.html#SEC525" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="libc.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="libc_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="libc_42.html#SEC712" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="libc_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h3 class="subsection"> 24.1.2 Concepts of Signal Generation </h3>

<p>In general, the events that generate signals fall into three major
categories: errors, external events, and explicit requests.
</p>
<p>An error means that a program has done something invalid and cannot
continue execution.  But not all kinds of errors generate signals&mdash;in
fact, most do not.  For example, opening a nonexistent file is an error,
but it does not raise a signal; instead, <code>open</code> returns <code>-1</code>.
In general, errors that are necessarily associated with certain library
functions are reported by returning a value that indicates an error.
The errors which raise signals are those which can happen anywhere in
the program, not just in library calls.  These include division by zero
and invalid memory addresses.
</p>
<p>An external event generally has to do with I/O or other processes.
These include the arrival of input, the expiration of a timer, and the
termination of a child process.
</p>
<p>An explicit request means the use of a library function such as
<code>kill</code> whose purpose is specifically to generate a signal.
</p>
<p>Signals may be generated <em>synchronously</em> or <em>asynchronously</em>.  A
synchronous signal pertains to a specific action in the program, and is
delivered (unless blocked) during that action.  Most errors generate
signals synchronously, and so do explicit requests by a process to
generate a signal for that same process.  On some machines, certain
kinds of hardware errors (usually floating-point exceptions) are not
reported completely synchronously, but may arrive a few instructions
later.
</p>
<p>Asynchronous signals are generated by events outside the control of the
process that receives them.  These signals arrive at unpredictable times
during execution.  External events generate signals asynchronously, and
so do explicit requests that apply to some other process.
</p>
<p>A given type of signal is either typically synchronous or typically
asynchronous.  For example, signals for errors are typically synchronous
because errors generate signals synchronously.  But any type of signal
can be generated synchronously or asynchronously with an explicit
request.
</p>
<hr size="6">
<a name="Delivery-of-Signal"></a>
<a name="SEC475"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC474" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC476" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC471" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC472" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="libc_25.html#SEC525" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="libc.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="libc_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="libc_42.html#SEC712" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="libc_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h3 class="subsection"> 24.1.3 How Signals Are Delivered </h3>

<p>When a signal is generated, it becomes <em>pending</em>.  Normally it
remains pending for just a short period of time and then is
<em>delivered</em> to the process that was signaled.  However, if that kind
of signal is currently <em>blocked</em>, it may remain pending
indefinitely&mdash;until signals of that kind are <em>unblocked</em>.  Once
unblocked, it will be delivered immediately.  See section <a href="#SEC509">Blocking Signals</a>.
</p>
<a name="IDX2399"></a>
<a name="IDX2400"></a>
<a name="IDX2401"></a>
<a name="IDX2402"></a>
<p>When the signal is delivered, whether right away or after a long delay,
the <em>specified action</em> for that signal is taken.  For certain
signals, such as <code>SIGKILL</code> and <code>SIGSTOP</code>, the action is fixed,
but for most signals, the program has a choice: ignore the signal,
specify a <em>handler function</em>, or accept the <em>default action</em> for
that kind of signal.  The program specifies its choice using functions
such as <code>signal</code> or <code>sigaction</code> (see section <a href="#SEC485">Specifying Signal Actions</a>).  We
sometimes say that a handler <em>catches</em> the signal.  While the
handler is running, that particular signal is normally blocked.
</p>
<p>If the specified action for a kind of signal is to ignore it, then any
such signal which is generated is discarded immediately.  This happens
even if the signal is also blocked at the time.  A signal discarded in
this way will never be delivered, not even if the program subsequently
specifies a different action for that kind of signal and then unblocks
it.
</p>
<p>If a signal arrives which the program has neither handled nor ignored,
its <em>default action</em> takes place.  Each kind of signal has its own
default action, documented below (see section <a href="#SEC476">Standard Signals</a>).  For most kinds
of signals, the default action is to terminate the process.  For certain
kinds of signals that represent &ldquo;harmless&rdquo; events, the default action
is to do nothing.
</p>
<p>When a signal terminates a process, its parent process can determine the
cause of termination by examining the termination status code reported
by the <code>wait</code> or <code>waitpid</code> functions.  (This is discussed in
more detail in <a href="libc_26.html#SEC574">Process Completion</a>.)  The information it can get
includes the fact that termination was due to a signal and the kind of
signal involved.  If a program you run from a shell is terminated by a
signal, the shell typically prints some kind of error message.
</p>
<p>The signals that normally represent program errors have a special
property: when one of these signals terminates the process, it also
writes a <em>core dump file</em> which records the state of the process at
the time of termination.  You can examine the core dump with a debugger
to investigate what caused the error.
</p>
<p>If you raise a &ldquo;program error&rdquo; signal by explicit request, and this
terminates the process, it makes a core dump file just as if the signal
had been due directly to an error.
</p>
<hr size="6">
<a name="Standard-Signals"></a>
<a name="SEC476"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC475" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC477" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC471" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC471" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="libc_25.html#SEC525" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="libc.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="libc_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="libc_42.html#SEC712" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="libc_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="section"> 24.2 Standard Signals </h2>

<p>This section lists the names for various standard kinds of signals and
describes what kind of event they mean.  Each signal name is a macro
which stands for a positive integer&mdash;the <em>signal number</em> for that
kind of signal.  Your programs should never make assumptions about the
numeric code for a particular kind of signal, but rather refer to them
always by the names defined here.  This is because the number for a
given kind of signal can vary from system to system, but the meanings of
the names are standardized and fairly uniform.
</p>
<p>The signal names are defined in the header file &lsquo;<tt>signal.h</tt>&rsquo;.
</p>
<dl>
<dt><u>Macro:</u> int <b>NSIG</b>
<a name="IDX2403"></a>
</dt>
<dd><p>The value of this symbolic constant is the total number of signals
defined.  Since the signal numbers are allocated consecutively,
<code>NSIG</code> is also one greater than the largest defined signal number.
</p></dd></dl>

<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top"><a href="#SEC477">24.2.1 Program Error Signals</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">       Used to report serious program errors.
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC478">24.2.2 Termination Signals</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">         Used to interrupt and/or terminate the
                                 program.
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC479">24.2.3 Alarm Signals</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">               Used to indicate expiration of timers.
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC480">24.2.4 Asynchronous I/O Signals</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">    Used to indicate input is available.
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC481">24.2.5 Job Control Signals</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">         Signals used to support job control.
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC482">24.2.6 Operation Error Signals</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">     Used to report operational system errors.
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC483">24.2.7 Miscellaneous Signals</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top"></td></tr>
<tr><td align="left" valign="top"><a href="#SEC484">24.2.8 Signal Messages</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">             Printing a message describing a signal.
</td></tr>
</table>

<hr size="6">
<a name="Program-Error-Signals"></a>
<a name="SEC477"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC476" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC478" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC471" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC476" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="libc_25.html#SEC525" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="libc.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="libc_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="libc_42.html#SEC712" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="libc_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h3 class="subsection"> 24.2.1 Program Error Signals </h3>

<p>The following signals are generated when a serious program error is
detected by the operating system or the computer itself.  In general,
all of these signals are indications that your program is seriously
broken in some way, and there's usually no way to continue the
computation which encountered the error.
</p>
<p>Some programs handle program error signals in order to tidy up before
terminating; for example, programs that turn off echoing of terminal
input should handle program error signals in order to turn echoing back
on.  The handler should end by specifying the default action for the
signal that happened and then reraising it; this will cause the program
to terminate with that signal, as if it had not had a handler.
(See section <a href="#SEC494">Handlers That Terminate the Process</a>.)
</p>
<p>Termination is the sensible ultimate outcome from a program error in
most programs.  However, programming systems such as Lisp that can load
compiled user programs might need to keep executing even if a user
program incurs an error.  These programs have handlers which use
<code>longjmp</code> to return control to the command level.
</p>
<p>The default action for all of these signals is to cause the process to
terminate.  If you block or ignore these signals or establish handlers
for them that return normally, your program will probably break horribly
when such signals happen, unless they are generated by <code>raise</code> or
<code>kill</code> instead of a real error.
</p>
<a name="IDX2404"></a>
<p>When one of these program error signals terminates a process, it also
writes a <em>core dump file</em> which records the state of the process at
the time of termination.  The core dump file is named &lsquo;<tt>core</tt>&rsquo; and is
written in whichever directory is current in the process at the time.
(On the GNU system, you can specify the file name for core dumps with
the environment variable <code>COREFILE</code>.)  The purpose of core dump
files is so that you can examine them with a debugger to investigate
what caused the error.
</p>
<dl>
<dt><u>Macro:</u> int <b>SIGFPE</b>
<a name="IDX2405"></a>
</dt>
<dd><p>The <code>SIGFPE</code> signal reports a fatal arithmetic error.  Although the
name is derived from &ldquo;floating-point exception&rdquo;, this signal actually
covers all arithmetic errors, including division by zero and overflow.
If a program stores integer data in a location which is then used in a
floating-point operation, this often causes an &ldquo;invalid operation&rdquo;
exception, because the processor cannot recognize the data as a
floating-point number.
<a name="IDX2406"></a>
<a name="IDX2407"></a>
</p>
<p>Actual floating-point exceptions are a complicated subject because there
are many types of exceptions with subtly different meanings, and the
<code>SIGFPE</code> signal doesn't distinguish between them.  The <cite>IEEE
Standard for Binary Floating-Point Arithmetic (ANSI/IEEE Std 754-1985
and ANSI/IEEE Std 854-1987)</cite>
defines various floating-point exceptions and requires conforming
computer systems to report their occurrences.  However, this standard
does not specify how the exceptions are reported, or what kinds of
handling and control the operating system can offer to the programmer.
</p></dd></dl>

<p>BSD systems provide the <code>SIGFPE</code> handler with an extra argument
that distinguishes various causes of the exception.  In order to access
this argument, you must define the handler to accept two arguments,
which means you must cast it to a one-argument function type in order to
establish the handler.  The GNU library does provide this extra
argument, but the value is meaningful only on operating systems that
provide the information (BSD systems and GNU systems).
</p>
<dl compact="compact">
<dt> <code>FPE_INTOVF_TRAP</code></dt>
<dd><a name="IDX2408"></a>
<p>Integer overflow (impossible in a C program unless you enable overflow
trapping in a hardware-specific fashion).
</p></dd>
<dt> <code>FPE_INTDIV_TRAP</code></dt>
<dd><a name="IDX2409"></a>
<p>Integer division by zero.
</p></dd>
<dt> <code>FPE_SUBRNG_TRAP</code></dt>
<dd><a name="IDX2410"></a>
<p>Subscript-range (something that C programs never check for).
</p></dd>
<dt> <code>FPE_FLTOVF_TRAP</code></dt>
<dd><a name="IDX2411"></a>
<p>Floating overflow trap.
</p></dd>
<dt> <code>FPE_FLTDIV_TRAP</code></dt>
<dd><a name="IDX2412"></a>
<p>Floating/decimal division by zero.
</p></dd>
<dt> <code>FPE_FLTUND_TRAP</code></dt>
<dd><a name="IDX2413"></a>
<p>Floating underflow trap.  (Trapping on floating underflow is not
normally enabled.)
</p></dd>
<dt> <code>FPE_DECOVF_TRAP</code></dt>
<dd><a name="IDX2414"></a>
<p>Decimal overflow trap.  (Only a few machines have decimal arithmetic and
C never uses it.)
</p></dd>
</dl>

<dl>
<dt><u>Macro:</u> int <b>SIGILL</b>
<a name="IDX2415"></a>
</dt>
<dd><p>The name of this signal is derived from &ldquo;illegal instruction&rdquo;; it
usually means your program is trying to execute garbage or a privileged
instruction.  Since the C compiler generates only valid instructions,
<code>SIGILL</code> typically indicates that the executable file is corrupted,
or that you are trying to execute data.  Some common ways of getting
into the latter situation are by passing an invalid object where a
pointer to a function was expected, or by writing past the end of an
automatic array (or similar problems with pointers to automatic
variables) and corrupting other data on the stack such as the return
address of a stack frame.
</p>
<p><code>SIGILL</code> can also be generated when the stack overflows, or when
the system has trouble running the handler for a signal.
</p></dd></dl>
<a name="IDX2416"></a>

<dl>
<dt><u>Macro:</u> int <b>SIGSEGV</b>
<a name="IDX2417"></a>
</dt>
<dd><a name="IDX2418"></a>
<p>This signal is generated when a program tries to read or write outside
the memory that is allocated for it, or to write memory that can only be
read.  (Actually, the signals only occur when the program goes far
enough outside to be detected by the system's memory protection
mechanism.)  The name is an abbreviation for &ldquo;segmentation violation&rdquo;.
</p>
<p>Common ways of getting a <code>SIGSEGV</code> condition include dereferencing
a null or uninitialized pointer, or when you use a pointer to step
through an array, but fail to check for the end of the array.  It varies
among systems whether dereferencing a null pointer generates
<code>SIGSEGV</code> or <code>SIGBUS</code>.
</p></dd></dl>

<dl>
<dt><u>Macro:</u> int <b>SIGBUS</b>
<a name="IDX2419"></a>
</dt>
<dd><p>This signal is generated when an invalid pointer is dereferenced.  Like
<code>SIGSEGV</code>, this signal is typically the result of dereferencing an
uninitialized pointer.  The difference between the two is that
<code>SIGSEGV</code> indicates an invalid access to valid memory, while
<code>SIGBUS</code> indicates an access to an invalid address.  In particular,
<code>SIGBUS</code> signals often result from dereferencing a misaligned
pointer, such as referring to a four-word integer at an address not
divisible by four.  (Each kind of computer has its own requirements for
address alignment.)
</p>
<p>The name of this signal is an abbreviation for &ldquo;bus error&rdquo;.
</p></dd></dl>
<a name="IDX2420"></a>

<dl>
<dt><u>Macro:</u> int <b>SIGABRT</b>
<a name="IDX2421"></a>
</dt>
<dd><a name="IDX2422"></a>
<p>This signal indicates an error detected by the program itself and
reported by calling <code>abort</code>.  See section <a href="libc_25.html#SEC566">Aborting a Program</a>.
</p></dd></dl>

<dl>
<dt><u>Macro:</u> int <b>SIGIOT</b>
<a name="IDX2423"></a>
</dt>
<dd><p>Generated by the PDP-11 &ldquo;iot&rdquo; instruction.  On most machines, this is
just another name for <code>SIGABRT</code>.
</p></dd></dl>

<dl>
<dt><u>Macro:</u> int <b>SIGTRAP</b>
<a name="IDX2424"></a>
</dt>
<dd><p>Generated by the machine's breakpoint instruction, and possibly other
trap instructions.  This signal is used by debuggers.  Your program will
probably only see <code>SIGTRAP</code> if it is somehow executing bad
instructions.
</p></dd></dl>

<dl>
<dt><u>Macro:</u> int <b>SIGEMT</b>
<a name="IDX2425"></a>
</dt>
<dd><p>Emulator trap; this results from certain unimplemented instructions
which might be emulated in software, or the operating system's
failure to properly emulate them.
</p></dd></dl>

<dl>
<dt><u>Macro:</u> int <b>SIGSYS</b>
<a name="IDX2426"></a>
</dt>
<dd><p>Bad system call; that is to say, the instruction to trap to the
operating system was executed, but the code number for the system call
to perform was invalid.
</p></dd></dl>

<hr size="6">
<a name="Termination-Signals"></a>
<a name="SEC478"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC477" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC479" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC471" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC476" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="libc_25.html#SEC525" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="libc.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="libc_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="libc_42.html#SEC712" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="libc_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h3 class="subsection"> 24.2.2 Termination Signals </h3>

<p>These signals are all used to tell a process to terminate, in one way
or another.  They have different names because they're used for slightly
different purposes, and programs might want to handle them differently.
</p>
<p>The reason for handling these signals is usually so your program can
tidy up as appropriate before actually terminating.  For example, you
might want to save state information, delete temporary files, or restore
the previous terminal modes.  Such a handler should end by specifying
the default action for the signal that happened and then reraising it;
this will cause the program to terminate with that signal, as if it had
not had a handler.  (See section <a href="#SEC494">Handlers That Terminate the Process</a>.)
</p>
<p>The (obvious) default action for all of these signals is to cause the
process to terminate.
</p>
<dl>
<dt><u>Macro:</u> int <b>SIGTERM</b>
<a name="IDX2427"></a>
</dt>
<dd><a name="IDX2428"></a>
<p>The <code>SIGTERM</code> signal is a generic signal used to cause program
termination.  Unlike <code>SIGKILL</code>, this signal can be blocked,
handled, and ignored.  It is the normal way to politely ask a program to
terminate.
</p>
<p>The shell command <code>kill</code> generates <code>SIGTERM</code> by default.
<a name="IDX2429"></a>
</p></dd></dl>

<dl>
<dt><u>Macro:</u> int <b>SIGINT</b>
<a name="IDX2430"></a>
</dt>
<dd><a name="IDX2431"></a>
<p>The <code>SIGINT</code> (&ldquo;program interrupt&rdquo;) signal is sent when the user
types the INTR character (normally <kbd>C-c</kbd>).  See section <a href="libc_17.html#SEC370">Special Characters</a>, for information about terminal driver support for
<kbd>C-c</kbd>.
</p></dd></dl>

<dl>
<dt><u>Macro:</u> int <b>SIGQUIT</b>
<a name="IDX2432"></a>
</dt>
<dd><a name="IDX2433"></a>
<a name="IDX2434"></a>
<p>The <code>SIGQUIT</code> signal is similar to <code>SIGINT</code>, except that it's
controlled by a different key&mdash;the QUIT character, usually
<kbd>C-\</kbd>&mdash;and produces a core dump when it terminates the process,
just like a program error signal.  You can think of this as a
program error condition &ldquo;detected&rdquo; by the user.
</p>
<p>See section <a href="#SEC477">Program Error Signals</a>, for information about core dumps.
See section <a href="libc_17.html#SEC370">Special Characters</a>, for information about terminal driver
support.
</p>
<p>Certain kinds of cleanups are best omitted in handling <code>SIGQUIT</code>.
For example, if the program creates temporary files, it should handle
the other termination requests by deleting the temporary files.  But it
is better for <code>SIGQUIT</code> not to delete them, so that the user can
examine them in conjunction with the core dump.
</p></dd></dl>

<dl>
<dt><u>Macro:</u> int <b>SIGKILL</b>
<a name="IDX2435"></a>
</dt>
<dd><p>The <code>SIGKILL</code> signal is used to cause immediate program termination.
It cannot be handled or ignored, and is therefore always fatal.  It is
also not possible to block this signal.
</p>
<p>This signal is usually generated only by explicit request.  Since it
cannot be handled, you should generate it only as a last resort, after
first trying a less drastic method such as <kbd>C-c</kbd> or <code>SIGTERM</code>.
If a process does not respond to any other termination signals, sending
it a <code>SIGKILL</code> signal will almost always cause it to go away.
</p>
<p>In fact, if <code>SIGKILL</code> fails to terminate a process, that by itself
constitutes an operating system bug which you should report.
</p>
<p>The system will generate <code>SIGKILL</code> for a process itself under some
unusual conditions where the program cannot possibly continue to run
(even to run a signal handler).
</p></dd></dl>
<a name="IDX2436"></a>

<dl>
<dt><u>Macro:</u> int <b>SIGHUP</b>
<a name="IDX2437"></a>
</dt>
<dd><a name="IDX2438"></a>
<p>The <code>SIGHUP</code> (&ldquo;hang-up&rdquo;) signal is used to report that the user's
terminal is disconnected, perhaps because a network or telephone
connection was broken.  For more information about this, see <a href="libc_17.html#SEC367">Control Modes</a>.
</p>
<p>This signal is also used to report the termination of the controlling
process on a terminal to jobs associated with that session; this
termination effectively disconnects all processes in the session from
the controlling terminal.  For more information, see <a href="libc_25.html#SEC567">Termination Internals</a>.
</p></dd></dl>

<hr size="6">
<a name="Alarm-Signals"></a>
<a name="SEC479"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC478" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC480" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC471" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC476" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="libc_25.html#SEC525" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="libc.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="libc_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="libc_42.html#SEC712" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="libc_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h3 class="subsection"> 24.2.3 Alarm Signals </h3>

<p>These signals are used to indicate the expiration of timers.
See section <a href="libc_21.html#SEC447">Setting an Alarm</a>, for information about functions that cause
these signals to be sent.
</p>
<p>The default behavior for these signals is to cause program termination.
This default is rarely useful, but no other default would be useful;
most of the ways of using these signals would require handler functions
in any case.
</p>
<dl>
<dt><u>Macro:</u> int <b>SIGALRM</b>
<a name="IDX2439"></a>
</dt>
<dd><p>This signal typically indicates expiration of a timer that measures real
or clock time.  It is used by the <code>alarm</code> function, for example.
</p></dd></dl>
<a name="IDX2440"></a>

<dl>
<dt><u>Macro:</u> int <b>SIGVTALRM</b>
<a name="IDX2441"></a>
</dt>
<dd><p>This signal typically indicates expiration of a timer that measures CPU
time used by the current process.  The name is an abbreviation for
&ldquo;virtual time alarm&rdquo;.
</p></dd></dl>
<a name="IDX2442"></a>

<dl>
<dt><u>Macro:</u> int <b>SIGPROF</b>
<a name="IDX2443"></a>
</dt>
<dd><p>This signal typically indicates expiration of a timer that measures
both CPU time used by the current process, and CPU time expended on
behalf of the process by the system.  Such a timer is used to implement
code profiling facilities, hence the name of this signal.
</p></dd></dl>
<a name="IDX2444"></a>


<hr size="6">
<a name="Asynchronous-I_002fO-Signals"></a>
<a name="SEC480"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC479" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC481" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC471" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC476" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="libc_25.html#SEC525" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="libc.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="libc_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="libc_42.html#SEC712" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="libc_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h3 class="subsection"> 24.2.4 Asynchronous I/O Signals </h3>

<p>The signals listed in this section are used in conjunction with
asynchronous I/O facilities.  You have to take explicit action by
calling <code>fcntl</code> to enable a particular file descriptor to generate
these signals (see section <a href="libc_13.html#SEC266">Interrupt-Driven Input</a>).  The default action for these
signals is to ignore them.
</p>
<dl>
<dt><u>Macro:</u> int <b>SIGIO</b>
<a name="IDX2445"></a>
</dt>
<dd><a name="IDX2446"></a>
<a name="IDX2447"></a>
<p>This signal is sent when a file descriptor is ready to perform input
or output.
</p>
<p>On most operating systems, terminals and sockets are the only kinds of
files that can generate <code>SIGIO</code>; other kinds, including ordinary
files, never generate <code>SIGIO</code> even if you ask them to.
</p>
<p>In the GNU system <code>SIGIO</code> will always be generated properly
if you successfully set asynchronous mode with <code>fcntl</code>.
</p></dd></dl>

<dl>
<dt><u>Macro:</u> int <b>SIGURG</b>
<a name="IDX2448"></a>
</dt>
<dd><a name="IDX2449"></a>
<p>This signal is sent when &ldquo;urgent&rdquo; or out-of-band data arrives on a
socket.  See section <a href="libc_16.html#SEC344">Out-of-Band Data</a>.
</p></dd></dl>

<dl>
<dt><u>Macro:</u> int <b>SIGPOLL</b>
<a name="IDX2450"></a>
</dt>
<dd><p>This is a System V signal name, more or less similar to <code>SIGIO</code>.
It is defined only for compatibility.
</p></dd></dl>

<hr size="6">
<a name="Job-Control-Signals"></a>
<a name="SEC481"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC480" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC482" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC471" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC476" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="libc_25.html#SEC525" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="libc.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="libc_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="libc_42.html#SEC712" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="libc_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h3 class="subsection"> 24.2.5 Job Control Signals </h3>

<p>These signals are used to support job control.  If your system
doesn't support job control, then these macros are defined but the
signals themselves can't be raised or handled.
</p>
<p>You should generally leave these signals alone unless you really
understand how job control works.  See section <a href="libc_27.html#SEC578">Job Control</a>.
</p>
<dl>
<dt><u>Macro:</u> int <b>SIGCHLD</b>
<a name="IDX2451"></a>
</dt>
<dd><a name="IDX2452"></a>
<p>This signal is sent to a parent process whenever one of its child
processes terminates or stops.
</p>
<p>The default action for this signal is to ignore it.  If you establish a
handler for this signal while there are child processes that have
terminated but not reported their status via <code>wait</code> or
<code>waitpid</code> (see section <a href="libc_26.html#SEC574">Process Completion</a>), whether your new handler
applies to those processes or not depends on the particular operating
system.
</p></dd></dl>

<dl>
<dt><u>Macro:</u> int <b>SIGCLD</b>
<a name="IDX2453"></a>
</dt>
<dd><p>This is an obsolete name for <code>SIGCHLD</code>.
</p></dd></dl>

<dl>
<dt><u>Macro:</u> int <b>SIGCONT</b>
<a name="IDX2454"></a>
</dt>
<dd><a name="IDX2455"></a>
<p>You can send a <code>SIGCONT</code> signal to a process to make it continue.
This signal is special&mdash;it always makes the process continue if it is
stopped, before the signal is delivered.  The default behavior is to do
nothing else.  You cannot block this signal.  You can set a handler, but
<code>SIGCONT</code> always makes the process continue regardless.
</p>
<p>Most programs have no reason to handle <code>SIGCONT</code>; they simply
resume execution without realizing they were ever stopped.  You can use
a handler for <code>SIGCONT</code> to make a program do something special when
it is stopped and continued&mdash;for example, to reprint a prompt when it
is suspended while waiting for input.
</p></dd></dl>

<dl>
<dt><u>Macro:</u> int <b>SIGSTOP</b>
<a name="IDX2456"></a>
</dt>
<dd><p>The <code>SIGSTOP</code> signal stops the process.  It cannot be handled,
ignored, or blocked.
</p></dd></dl>
<a name="IDX2457"></a>

<dl>
<dt><u>Macro:</u> int <b>SIGTSTP</b>
<a name="IDX2458"></a>
</dt>
<dd><p>The <code>SIGTSTP</code> signal is an interactive stop signal.  Unlike
<code>SIGSTOP</code>, this signal can be handled and ignored.
</p>
<p>Your program should handle this signal if you have a special need to
leave files or system tables in a secure state when a process is
stopped.  For example, programs that turn off echoing should handle
<code>SIGTSTP</code> so they can turn echoing back on before stopping.
</p>
<p>This signal is generated when the user types the SUSP character
(normally <kbd>C-z</kbd>).  For more information about terminal driver
support, see <a href="libc_17.html#SEC370">Special Characters</a>.
</p></dd></dl>
<a name="IDX2459"></a>

<dl>
<dt><u>Macro:</u> int <b>SIGTTIN</b>
<a name="IDX2460"></a>
</dt>
<dd><p>A process cannot read from the user's terminal while it is running
as a background job.  When any process in a background job tries to
read from the terminal, all of the processes in the job are sent a
<code>SIGTTIN</code> signal.  The default action for this signal is to
stop the process.  For more information about how this interacts with
the terminal driver, see <a href="libc_27.html#SEC582">Access to the Controlling Terminal</a>.
</p></dd></dl>
<a name="IDX2461"></a>

<dl>
<dt><u>Macro:</u> int <b>SIGTTOU</b>
<a name="IDX2462"></a>
</dt>
<dd><p>This is similar to <code>SIGTTIN</code>, but is generated when a process in a
background job attempts to write to the terminal or set its modes.
Again, the default action is to stop the process.  <code>SIGTTOU</code> is
only generated for an attempt to write to the terminal if the
<code>TOSTOP</code> output mode is set; see section <a href="libc_17.html#SEC366">Output Modes</a>.
</p></dd></dl>
<a name="IDX2463"></a>

<p>While a process is stopped, no more signals can be delivered to it until
it is continued, except <code>SIGKILL</code> signals and (obviously)
<code>SIGCONT</code> signals.  The signals are marked as pending, but not
delivered until the process is continued.  The <code>SIGKILL</code> signal
always causes termination of the process and can't be blocked, handled
or ignored.  You can ignore <code>SIGCONT</code>, but it always causes the
process to be continued anyway if it is stopped.  Sending a
<code>SIGCONT</code> signal to a process causes any pending stop signals for
that process to be discarded.  Likewise, any pending <code>SIGCONT</code>
signals for a process are discarded when it receives a stop signal.
</p>
<p>When a process in an orphaned process group (see section <a href="libc_27.html#SEC583">Orphaned Process Groups</a>) receives a <code>SIGTSTP</code>, <code>SIGTTIN</code>, or <code>SIGTTOU</code>
signal and does not handle it, the process does not stop.  Stopping the
process would probably not be very useful, since there is no shell
program that will notice it stop and allow the user to continue it.
What happens instead depends on the operating system you are using.
Some systems may do nothing; others may deliver another signal instead,
such as <code>SIGKILL</code> or <code>SIGHUP</code>.  In the GNU system, the process
dies with <code>SIGKILL</code>; this avoids the problem of many stopped,
orphaned processes lying around the system.
</p>

<hr size="6">
<a name="Operation-Error-Signals"></a>
<a name="SEC482"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC481" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC483" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC471" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC476" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="libc_25.html#SEC525" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="libc.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="libc_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="libc_42.html#SEC712" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="libc_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h3 class="subsection"> 24.2.6 Operation Error Signals </h3>

<p>These signals are used to report various errors generated by an
operation done by the program.  They do not necessarily indicate a
programming error in the program, but an error that prevents an
operating system call from completing.  The default action for all of
them is to cause the process to terminate.
</p>
<dl>
<dt><u>Macro:</u> int <b>SIGPIPE</b>
<a name="IDX2464"></a>
</dt>
<dd><a name="IDX2465"></a>
<a name="IDX2466"></a>
<p>Broken pipe.  If you use pipes or FIFOs, you have to design your
application so that one process opens the pipe for reading before
another starts writing.  If the reading process never starts, or
terminates unexpectedly, writing to the pipe or FIFO raises a
<code>SIGPIPE</code> signal.  If <code>SIGPIPE</code> is blocked, handled or
ignored, the offending call fails with <code>EPIPE</code> instead.
</p>
<p>Pipes and FIFO special files are discussed in more detail in <a href="libc_15.html#SEC297">Pipes and FIFOs</a>.
</p>
<p>Another cause of <code>SIGPIPE</code> is when you try to output to a socket
that isn't connected.  See section <a href="libc_16.html#SEC339">Sending Data</a>.
</p></dd></dl>

<dl>
<dt><u>Macro:</u> int <b>SIGLOST</b>
<a name="IDX2467"></a>
</dt>
<dd><a name="IDX2468"></a>
<p>Resource lost.  This signal is generated when you have an advisory lock
on an NFS file, and the NFS server reboots and forgets about your lock.
</p>
<p>In the GNU system, <code>SIGLOST</code> is generated when any server program
dies unexpectedly.  It is usually fine to ignore the signal; whatever
call was made to the server that died just returns an error.
</p></dd></dl>

<dl>
<dt><u>Macro:</u> int <b>SIGXCPU</b>
<a name="IDX2469"></a>
</dt>
<dd><p>CPU time limit exceeded.  This signal is generated when the process
exceeds its soft resource limit on CPU time.  See section <a href="libc_22.html#SEC451">Limiting Resource Usage</a>.
</p></dd></dl>

<dl>
<dt><u>Macro:</u> int <b>SIGXFSZ</b>
<a name="IDX2470"></a>
</dt>
<dd><p>File size limit exceeded.  This signal is generated when the process
attempts to extend a file so it exceeds the process's soft resource
limit on file size.  See section <a href="libc_22.html#SEC451">Limiting Resource Usage</a>.
</p></dd></dl>

<hr size="6">
<a name="Miscellaneous-Signals"></a>
<a name="SEC483"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC482" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC484" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC471" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC476" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="libc_25.html#SEC525" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="libc.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="libc_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="libc_42.html#SEC712" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="libc_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h3 class="subsection"> 24.2.7 Miscellaneous Signals </h3>

<p>These signals are used for various other purposes.  In general, they
will not affect your program unless it explicitly uses them for something.
</p>
<dl>
<dt><u>Macro:</u> int <b>SIGUSR1</b>
<a name="IDX2471"></a>
</dt>
<dt><u>Macro:</u> int <b>SIGUSR2</b>
<a name="IDX2472"></a>
</dt>
<dd><a name="IDX2473"></a>
<p>The <code>SIGUSR1</code> and <code>SIGUSR2</code> signals are set aside for you to
use any way you want.  They're useful for simple interprocess
communication, if you write a signal handler for them in the program
that receives the signal.
</p>
<p>There is an example showing the use of <code>SIGUSR1</code> and <code>SIGUSR2</code>
in <a href="#SEC506">Signaling Another Process</a>.
</p>
<p>The default action is to terminate the process.
</p></dd></dl>

<dl>
<dt><u>Macro:</u> int <b>SIGWINCH</b>
<a name="IDX2474"></a>
</dt>
<dd><p>Window size change.  This is generated on some systems (including GNU)
when the terminal driver's record of the number of rows and columns on
the screen is changed.  The default action is to ignore it.
</p>
<p>If a program does full-screen display, it should handle <code>SIGWINCH</code>.
When the signal arrives, it should fetch the new screen size and
reformat its display accordingly.
</p></dd></dl>

<dl>
<dt><u>Macro:</u> int <b>SIGINFO</b>
<a name="IDX2475"></a>
</dt>
<dd><p>Information request.  In 4.4 BSD and the GNU system, this signal is sent
to all the processes in the foreground process group of the controlling
terminal when the user types the STATUS character in canonical mode;
see section <a href="libc_17.html#SEC372">Characters that Cause Signals</a>.
</p>
<p>If the process is the leader of the process group, the default action is
to print some status information about the system and what the process
is doing.  Otherwise the default is to do nothing.
</p></dd></dl>

<hr size="6">
<a name="Signal-Messages"></a>
<a name="SEC484"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC483" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC485" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC471" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC476" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="libc_25.html#SEC525" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="libc.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="libc_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="libc_42.html#SEC712" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="libc_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h3 class="subsection"> 24.2.8 Signal Messages </h3>

<p>We mentioned above that the shell prints a message describing the signal
that terminated a child process.  The clean way to print a message
describing a signal is to use the functions <code>strsignal</code> and
<code>psignal</code>.  These functions use a signal number to specify which
kind of signal to describe.  The signal number may come from the
termination status of a child process (see section <a href="libc_26.html#SEC574">Process Completion</a>) or it
may come from a signal handler in the same process.
</p>
<dl>
<dt><u>Function:</u> char * <b>strsignal</b><i> (int <var>signum</var>)</i>
<a name="IDX2476"></a>
</dt>
<dd><p>This function returns a pointer to a statically-allocated string
containing a message describing the signal <var>signum</var>.  You
should not modify the contents of this string; and, since it can be
rewritten on subsequent calls, you should save a copy of it if you need
to reference it later.
</p>
<a name="IDX2477"></a>
<p>This function is a GNU extension, declared in the header file
&lsquo;<tt>string.h</tt>&rsquo;.
</p></dd></dl>

<dl>
<dt><u>Function:</u> void <b>psignal</b><i> (int <var>signum</var>, const char *<var>message</var>)</i>
<a name="IDX2478"></a>
</dt>
<dd><p>This function prints a message describing the signal <var>signum</var> to the
standard error output stream <code>stderr</code>; see <a href="libc_12.html#SEC179">Standard Streams</a>.
</p>
<p>If you call <code>psignal</code> with a <var>message</var> that is either a null
pointer or an empty string, <code>psignal</code> just prints the message
corresponding to <var>signum</var>, adding a trailing newline.
</p>
<p>If you supply a non-null <var>message</var> argument, then <code>psignal</code>
prefixes its output with this string.  It adds a colon and a space
character to separate the <var>message</var> from the string corresponding
to <var>signum</var>.
</p>
<a name="IDX2479"></a>
<p>This function is a BSD feature, declared in the header file &lsquo;<tt>signal.h</tt>&rsquo;.
</p></dd></dl>

<a name="IDX2480"></a>
<p>There is also an array <code>sys_siglist</code> which contains the messages
for the various signal codes.  This array exists on BSD systems, unlike
<code>strsignal</code>.
</p>
<hr size="6">
<a name="Signal-Actions"></a>
<a name="SEC485"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC484" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC486" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC471" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC471" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="libc_25.html#SEC525" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="libc.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="libc_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="libc_42.html#SEC712" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="libc_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="section"> 24.3 Specifying Signal Actions </h2>

<p>The simplest way to change the action for a signal is to use the
<code>signal</code> function.  You can specify a built-in action (such as to
ignore the signal), or you can <em>establish a handler</em>.
</p>
<p>The GNU library also implements the more versatile <code>sigaction</code>
facility.  This section describes both facilities and gives suggestions
on which to use when.
</p>
<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top"><a href="#SEC486">24.3.1 Basic Signal Handling</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">       The simple <code>signal</code> function.
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC487">24.3.2 Advanced Signal Handling</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">    The more powerful <code>sigaction</code> function.
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC488">24.3.3 Interaction of <code>signal</code> and <code>sigaction</code></a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">        How those two functions interact.
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC489">24.3.4 <code>sigaction</code> Function Example</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">  An example of using the sigaction function.
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC490">24.3.5 Flags for <code>sigaction</code></a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">         Specifying options for signal handling.
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC491">24.3.6 Initial Signal Actions</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">      How programs inherit signal actions.
</td></tr>
</table>

<hr size="6">
<a name="Basic-Signal-Handling"></a>
<a name="SEC486"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC485" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC487" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC471" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC485" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="libc_25.html#SEC525" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="libc.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="libc_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="libc_42.html#SEC712" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="libc_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h3 class="subsection"> 24.3.1 Basic Signal Handling </h3>

<p>The <code>signal</code> function provides a simple interface for establishing
an action for a particular signal.  The function and associated macros
are declared in the header file &lsquo;<tt>signal.h</tt>&rsquo;.
<a name="IDX2481"></a>
</p>
<dl>
<dt><u>Data Type:</u> <b>sighandler_t</b>
<a name="IDX2482"></a>
</dt>
<dd><p>This is the type of signal handler functions.  Signal handlers take one
integer argument specifying the signal number, and have return type
<code>void</code>.  So, you should define handler functions like this:
</p>
<table><tr><td>&nbsp;</td><td><pre class="smallexample">void <var>handler</var> (int <code>signum</code>) { &hellip; }
</pre></td></tr></table>

<p>The name <code>sighandler_t</code> for this data type is a GNU extension.
</p></dd></dl>

<dl>
<dt><u>Function:</u> sighandler_t <b>signal</b><i> (int <var>signum</var>, sighandler_t <var>action</var>)</i>
<a name="IDX2483"></a>
</dt>
<dd><p>The <code>signal</code> function establishes <var>action</var> as the action for
the signal <var>signum</var>.
</p>
<p>The first argument, <var>signum</var>, identifies the signal whose behavior
you want to control, and should be a signal number.  The proper way to
specify a signal number is with one of the symbolic signal names
(see section <a href="#SEC476">Standard Signals</a>)&mdash;don't use an explicit number, because
the numerical code for a given kind of signal may vary from operating
system to operating system.
</p>
<p>The second argument, <var>action</var>, specifies the action to use for the
signal <var>signum</var>.  This can be one of the following:
</p>
<dl compact="compact">
<dt> <code>SIG_DFL</code></dt>
<dd><a name="IDX2484"></a>
<a name="IDX2485"></a>
<p><code>SIG_DFL</code> specifies the default action for the particular signal.
The default actions for various kinds of signals are stated in
<a href="#SEC476">Standard Signals</a>.
</p>
</dd>
<dt> <code>SIG_IGN</code></dt>
<dd><a name="IDX2486"></a>
<a name="IDX2487"></a>
<p><code>SIG_IGN</code> specifies that the signal should be ignored.
</p>
<p>Your program generally should not ignore signals that represent serious
events or that are normally used to request termination.  You cannot
ignore the <code>SIGKILL</code> or <code>SIGSTOP</code> signals at all.  You can
ignore program error signals like <code>SIGSEGV</code>, but ignoring the error
won't enable the program to continue executing meaningfully.  Ignoring
user requests such as <code>SIGINT</code>, <code>SIGQUIT</code>, and <code>SIGTSTP</code>
is unfriendly.
</p>
<p>When you do not wish signals to be delivered during a certain part of
the program, the thing to do is to block them, not ignore them.
See section <a href="#SEC509">Blocking Signals</a>.
</p>
</dd>
<dt> <code><var>handler</var></code></dt>
<dd><p>Supply the address of a handler function in your program, to specify
running this handler as the way to deliver the signal.
</p>
<p>For more information about defining signal handler functions,
see <a href="#SEC492">Defining Signal Handlers</a>.
</p></dd>
</dl>

<p>If you set the action for a signal to <code>SIG_IGN</code>, or if you set it
to <code>SIG_DFL</code> and the default action is to ignore that signal, then
any pending signals of that type are discarded (even if they are
blocked).  Discarding the pending signals means that they will never be
delivered, not even if you subsequently specify another action and
unblock this kind of signal.
</p>
<p>The <code>signal</code> function returns the action that was previously in
effect for the specified <var>signum</var>.  You can save this value and
restore it later by calling <code>signal</code> again.
</p>
<p>If <code>signal</code> can't honor the request, it returns <code>SIG_ERR</code>
instead.  The following <code>errno</code> error conditions are defined for
this function:
</p>
<dl compact="compact">
<dt> <code>EINVAL</code></dt>
<dd><p>You specified an invalid <var>signum</var>; or you tried to ignore or provide
a handler for <code>SIGKILL</code> or <code>SIGSTOP</code>.
</p></dd>
</dl>
</dd></dl>

<p><strong>Compatibility Note:</strong> A problem encountered when working with the
<code>signal</code> function is that it has different semantics on BSD and
SVID systems.  The difference is that on SVID systems the signal handler
is deinstalled after signal delivery.  On BSD systems the
handler must be explicitly deinstalled.  In the GNU C Library we use the
BSD version by default.  To use the SVID version you can either use the
function <code>sysv_signal</code> (see below) or use the <code>_XOPEN_SOURCE</code>
feature select macro (see section <a href="libc_1.html#SEC13">Feature Test Macros</a>).  In general, use of these
functions should be avoided because of compatibility problems.  It
is better to use <code>sigaction</code> if it is available since the results
are much more reliable.
</p>
<p>Here is a simple example of setting up a handler to delete temporary
files when certain fatal signals happen:
</p>
<table><tr><td>&nbsp;</td><td><pre class="smallexample">#include &lt;signal.h&gt;

void
termination_handler (int signum)
{
  struct temp_file *p;

  for (p = temp_file_list; p; p = p-&gt;next)
    unlink (p-&gt;name);
}

int
main (void)
{
  &hellip;
  if (signal (SIGINT, termination_handler) == SIG_IGN)
    signal (SIGINT, SIG_IGN);
  if (signal (SIGHUP, termination_handler) == SIG_IGN)
    signal (SIGHUP, SIG_IGN);
  if (signal (SIGTERM, termination_handler) == SIG_IGN)
    signal (SIGTERM, SIG_IGN);
  &hellip;
}
</pre></td></tr></table>

<p>Note that if a given signal was previously set to be ignored, this code
avoids altering that setting.  This is because non-job-control shells
often ignore certain signals when starting children, and it is important
for the children to respect this.
</p>
<p>We do not handle <code>SIGQUIT</code> or the program error signals in this
example because these are designed to provide information for debugging
(a core dump), and the temporary files may give useful information.
</p>
<dl>
<dt><u>Function:</u> sighandler_t <b>sysv_signal</b><i> (int <var>signum</var>, sighandler_t <var>action</var>)</i>
<a name="IDX2488"></a>
</dt>
<dd><p>The <code>sysv_signal</code> implements the behavior of the standard
<code>signal</code> function as found on SVID systems.  The difference to BSD
systems is that the handler is deinstalled after a delivery of a signal.
</p>
<p><strong>Compatibility Note:</strong> As said above for <code>signal</code>, this
function should be avoided when possible.  <code>sigaction</code> is the
preferred method.
</p></dd></dl>

<dl>
<dt><u>Function:</u> sighandler_t <b>ssignal</b><i> (int <var>signum</var>, sighandler_t <var>action</var>)</i>
<a name="IDX2489"></a>
</dt>
<dd><p>The <code>ssignal</code> function does the same thing as <code>signal</code>; it is
provided only for compatibility with SVID.
</p></dd></dl>

<dl>
<dt><u>Macro:</u> sighandler_t <b>SIG_ERR</b>
<a name="IDX2490"></a>
</dt>
<dd><p>The value of this macro is used as the return value from <code>signal</code>
to indicate an error.
</p></dd></dl>



<hr size="6">
<a name="Advanced-Signal-Handling"></a>
<a name="SEC487"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC486" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC488" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC471" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC485" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="libc_25.html#SEC525" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="libc.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="libc_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="libc_42.html#SEC712" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="libc_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h3 class="subsection"> 24.3.2 Advanced Signal Handling </h3>

<p>The <code>sigaction</code> function has the same basic effect as
<code>signal</code>: to specify how a signal should be handled by the process.
However, <code>sigaction</code> offers more control, at the expense of more
complexity.  In particular, <code>sigaction</code> allows you to specify
additional flags to control when the signal is generated and how the
handler is invoked.
</p>
<p>The <code>sigaction</code> function is declared in &lsquo;<tt>signal.h</tt>&rsquo;.
<a name="IDX2491"></a>
</p>
<dl>
<dt><u>Data Type:</u> <b>struct sigaction</b>
<a name="IDX2492"></a>
</dt>
<dd><p>Structures of type <code>struct sigaction</code> are used in the
<code>sigaction</code> function to specify all the information about how to
handle a particular signal.  This structure contains at least the
following members:
</p>
<dl compact="compact">
<dt> <code>sighandler_t sa_handler</code></dt>
<dd><p>This is used in the same way as the <var>action</var> argument to the
<code>signal</code> function.  The value can be <code>SIG_DFL</code>,
<code>SIG_IGN</code>, or a function pointer.  See section <a href="#SEC486">Basic Signal Handling</a>.
</p>
</dd>
<dt> <code>sigset_t sa_mask</code></dt>
<dd><p>This specifies a set of signals to be blocked while the handler runs.
Blocking is explained in <a href="#SEC514">Blocking Signals for a Handler</a>.  Note that the
signal that was delivered is automatically blocked by default before its
handler is started; this is true regardless of the value in
<code>sa_mask</code>.  If you want that signal not to be blocked within its
handler, you must write code in the handler to unblock it.
</p>
</dd>
<dt> <code>int sa_flags</code></dt>
<dd><p>This specifies various flags which can affect the behavior of
the signal.  These are described in more detail in <a href="#SEC490">Flags for <code>sigaction</code></a>.
</p></dd>
</dl>
</dd></dl>

<dl>
<dt><u>Function:</u> int <b>sigaction</b><i> (int <var>signum</var>, const struct sigaction *restrict <var>action</var>, struct sigaction *restrict <var>old-action</var>)</i>
<a name="IDX2493"></a>
</dt>
<dd><p>The <var>action</var> argument is used to set up a new action for the signal
<var>signum</var>, while the <var>old-action</var> argument is used to return
information about the action previously associated with this symbol.
(In other words, <var>old-action</var> has the same purpose as the
<code>signal</code> function's return value&mdash;you can check to see what the
old action in effect for the signal was, and restore it later if you
want.)
</p>
<p>Either <var>action</var> or <var>old-action</var> can be a null pointer.  If
<var>old-action</var> is a null pointer, this simply suppresses the return
of information about the old action.  If <var>action</var> is a null pointer,
the action associated with the signal <var>signum</var> is unchanged; this
allows you to inquire about how a signal is being handled without changing
that handling.
</p>
<p>The return value from <code>sigaction</code> is zero if it succeeds, and
<code>-1</code> on failure.  The following <code>errno</code> error conditions are
defined for this function:
</p>
<dl compact="compact">
<dt> <code>EINVAL</code></dt>
<dd><p>The <var>signum</var> argument is not valid, or you are trying to
trap or ignore <code>SIGKILL</code> or <code>SIGSTOP</code>.
</p></dd>
</dl>
</dd></dl>

<hr size="6">
<a name="Signal-and-Sigaction"></a>
<a name="SEC488"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC487" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC489" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC471" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC485" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="libc_25.html#SEC525" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="libc.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="libc_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="libc_42.html#SEC712" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="libc_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h3 class="subsection"> 24.3.3 Interaction of <code>signal</code> and <code>sigaction</code> </h3>

<p>It's possible to use both the <code>signal</code> and <code>sigaction</code>
functions within a single program, but you have to be careful because
they can interact in slightly strange ways.
</p>
<p>The <code>sigaction</code> function specifies more information than the
<code>signal</code> function, so the return value from <code>signal</code> cannot
express the full range of <code>sigaction</code> possibilities.  Therefore, if
you use <code>signal</code> to save and later reestablish an action, it may
not be able to reestablish properly a handler that was established with
<code>sigaction</code>.
</p>
<p>To avoid having problems as a result, always use <code>sigaction</code> to
save and restore a handler if your program uses <code>sigaction</code> at all.
Since <code>sigaction</code> is more general, it can properly save and
reestablish any action, regardless of whether it was established
originally with <code>signal</code> or <code>sigaction</code>.
</p>
<p>On some systems if you establish an action with <code>signal</code> and then
examine it with <code>sigaction</code>, the handler address that you get may
not be the same as what you specified with <code>signal</code>.  It may not
even be suitable for use as an action argument with <code>signal</code>.  But
you can rely on using it as an argument to <code>sigaction</code>.  This
problem never happens on the GNU system.
</p>
<p>So, you're better off using one or the other of the mechanisms
consistently within a single program.
</p>
<p><strong>Portability Note:</strong> The basic <code>signal</code> function is a feature
of ISO C, while <code>sigaction</code> is part of the POSIX.1 standard.  If
you are concerned about portability to non-POSIX systems, then you
should use the <code>signal</code> function instead.
</p>
<hr size="6">
<a name="Sigaction-Function-Example"></a>
<a name="SEC489"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC488" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC490" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC471" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC485" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="libc_25.html#SEC525" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="libc.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="libc_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="libc_42.html#SEC712" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="libc_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h3 class="subsection"> 24.3.4 <code>sigaction</code> Function Example </h3>

<p>In <a href="#SEC486">Basic Signal Handling</a>, we gave an example of establishing a
simple handler for termination signals using <code>signal</code>.  Here is an
equivalent example using <code>sigaction</code>:
</p>
<table><tr><td>&nbsp;</td><td><pre class="smallexample">#include &lt;signal.h&gt;

void
termination_handler (int signum)
{
  struct temp_file *p;

  for (p = temp_file_list; p; p = p-&gt;next)
    unlink (p-&gt;name);
}

int
main (void)
{
  &hellip;
  struct sigaction new_action, old_action;

  /* <span class="roman">Set up the structure to specify the new action.</span> */
  new_action.sa_handler = termination_handler;
  sigemptyset (&amp;new_action.sa_mask);
  new_action.sa_flags = 0;

  sigaction (SIGINT, NULL, &amp;old_action);
  if (old_action.sa_handler != SIG_IGN)
    sigaction (SIGINT, &amp;new_action, NULL);
  sigaction (SIGHUP, NULL, &amp;old_action);
  if (old_action.sa_handler != SIG_IGN)
    sigaction (SIGHUP, &amp;new_action, NULL);
  sigaction (SIGTERM, NULL, &amp;old_action);
  if (old_action.sa_handler != SIG_IGN)
    sigaction (SIGTERM, &amp;new_action, NULL);
  &hellip;
}
</pre></td></tr></table>

<p>The program just loads the <code>new_action</code> structure with the desired
parameters and passes it in the <code>sigaction</code> call.  The usage of
<code>sigemptyset</code> is described later; see <a href="#SEC509">Blocking Signals</a>.
</p>
<p>As in the example using <code>signal</code>, we avoid handling signals
previously set to be ignored.  Here we can avoid altering the signal
handler even momentarily, by using the feature of <code>sigaction</code> that
lets us examine the current action without specifying a new one.
</p>
<p>Here is another example.  It retrieves information about the current
action for <code>SIGINT</code> without changing that action.
</p>
<table><tr><td>&nbsp;</td><td><pre class="smallexample">struct sigaction query_action;

if (sigaction (SIGINT, NULL, &amp;query_action) &lt; 0)
  /* <span class="roman"><code>sigaction</code> returns -1 in case of error.</span> */
else if (query_action.sa_handler == SIG_DFL)
  /* <span class="roman"><code>SIGINT</code> is handled in the default, fatal manner.</span> */
else if (query_action.sa_handler == SIG_IGN)
  /* <span class="roman"><code>SIGINT</code> is ignored.</span> */
else
  /* <span class="roman">A programmer-defined signal handler is in effect.</span> */
</pre></td></tr></table>

<hr size="6">
<a name="Flags-for-Sigaction"></a>
<a name="SEC490"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC489" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC491" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC471" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC485" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="libc_25.html#SEC525" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="libc.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="libc_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="libc_42.html#SEC712" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="libc_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h3 class="subsection"> 24.3.5 Flags for <code>sigaction</code> </h3>

<p>The <code>sa_flags</code> member of the <code>sigaction</code> structure is a
catch-all for special features.  Most of the time, <code>SA_RESTART</code> is
a good value to use for this field.
</p>
<p>The value of <code>sa_flags</code> is interpreted as a bit mask.  Thus, you
should choose the flags you want to set, <small>OR</small> those flags together,
and store the result in the <code>sa_flags</code> member of your
<code>sigaction</code> structure.
</p>
<p>Each signal number has its own set of flags.  Each call to
<code>sigaction</code> affects one particular signal number, and the flags
that you specify apply only to that particular signal.
</p>
<p>In the GNU C library, establishing a handler with <code>signal</code> sets all
the flags to zero except for <code>SA_RESTART</code>, whose value depends on
the settings you have made with <code>siginterrupt</code>.  See section <a href="#SEC503">Primitives Interrupted by Signals</a>, to see what this is about.
</p>
<a name="IDX2494"></a>
<p>These macros are defined in the header file &lsquo;<tt>signal.h</tt>&rsquo;.
</p>
<dl>
<dt><u>Macro:</u> int <b>SA_NOCLDSTOP</b>
<a name="IDX2495"></a>
</dt>
<dd><p>This flag is meaningful only for the <code>SIGCHLD</code> signal.  When the
flag is set, the system delivers the signal for a terminated child
process but not for one that is stopped.  By default, <code>SIGCHLD</code> is
delivered for both terminated children and stopped children.
</p>
<p>Setting this flag for a signal other than <code>SIGCHLD</code> has no effect.
</p></dd></dl>

<dl>
<dt><u>Macro:</u> int <b>SA_ONSTACK</b>
<a name="IDX2496"></a>
</dt>
<dd><p>If this flag is set for a particular signal number, the system uses the
signal stack when delivering that kind of signal.  See section <a href="#SEC521">Using a Separate Signal Stack</a>.
If a signal with this flag arrives and you have not set a signal stack,
the system terminates the program with <code>SIGILL</code>.
</p></dd></dl>

<dl>
<dt><u>Macro:</u> int <b>SA_RESTART</b>
<a name="IDX2497"></a>
</dt>
<dd><p>This flag controls what happens when a signal is delivered during
certain primitives (such as <code>open</code>, <code>read</code> or <code>write</code>),
and the signal handler returns normally.  There are two alternatives:
the library function can resume, or it can return failure with error
code <code>EINTR</code>.
</p>
<p>The choice is controlled by the <code>SA_RESTART</code> flag for the
particular kind of signal that was delivered.  If the flag is set,
returning from a handler resumes the library function.  If the flag is
clear, returning from a handler makes the function fail.
See section <a href="#SEC503">Primitives Interrupted by Signals</a>.
</p></dd></dl>

<hr size="6">
<a name="Initial-Signal-Actions"></a>
<a name="SEC491"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC490" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC492" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC471" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC485" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="libc_25.html#SEC525" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="libc.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="libc_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="libc_42.html#SEC712" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="libc_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h3 class="subsection"> 24.3.6 Initial Signal Actions </h3>

<p>When a new process is created (see section <a href="libc_26.html#SEC572">Creating a Process</a>), it inherits
handling of signals from its parent process.  However, when you load a
new process image using the <code>exec</code> function (see section <a href="libc_26.html#SEC573">Executing a File</a>), any signals that you've defined your own handlers for revert to
their <code>SIG_DFL</code> handling.  (If you think about it a little, this
makes sense; the handler functions from the old program are specific to
that program, and aren't even present in the address space of the new
program image.)  Of course, the new program can establish its own
handlers.
</p>
<p>When a program is run by a shell, the shell normally sets the initial
actions for the child process to <code>SIG_DFL</code> or <code>SIG_IGN</code>, as
appropriate.  It's a good idea to check to make sure that the shell has
not set up an initial action of <code>SIG_IGN</code> before you establish your
own signal handlers.
</p>
<p>Here is an example of how to establish a handler for <code>SIGHUP</code>, but
not if <code>SIGHUP</code> is currently ignored:
</p>
<table><tr><td>&nbsp;</td><td><pre class="smallexample">&hellip;
struct sigaction temp;

sigaction (SIGHUP, NULL, &amp;temp);

if (temp.sa_handler != SIG_IGN)
  {
    temp.sa_handler = handle_sighup;
    sigemptyset (&amp;temp.sa_mask);
    sigaction (SIGHUP, &amp;temp, NULL);
  }
</pre></td></tr></table>

<hr size="6">
<a name="Defining-Handlers"></a>
<a name="SEC492"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC491" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC493" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC471" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC471" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="libc_25.html#SEC525" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="libc.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="libc_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="libc_42.html#SEC712" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="libc_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="section"> 24.4 Defining Signal Handlers </h2>

<p>This section describes how to write a signal handler function that can
be established with the <code>signal</code> or <code>sigaction</code> functions.
</p>
<p>A signal handler is just a function that you compile together with the
rest of the program.  Instead of directly invoking the function, you use
<code>signal</code> or <code>sigaction</code> to tell the operating system to call
it when a signal arrives.  This is known as <em>establishing</em> the
handler.  See section <a href="#SEC485">Specifying Signal Actions</a>.
</p>
<p>There are two basic strategies you can use in signal handler functions:
</p>
<ul>
<li>
You can have the handler function note that the signal arrived by
tweaking some global data structures, and then return normally.

</li><li>
You can have the handler function terminate the program or transfer
control to a point where it can recover from the situation that caused
the signal.
</li></ul>

<p>You need to take special care in writing handler functions because they
can be called asynchronously.  That is, a handler might be called at any
point in the program, unpredictably.  If two signals arrive during a
very short interval, one handler can run within another.  This section
describes what your handler should do, and what you should avoid.
</p>
<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top"><a href="#SEC493">24.4.1 Signal Handlers that Return</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">             Handlers that return normally, and what
                                 this means.
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC494">24.4.2 Handlers That Terminate the Process</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">      How handler functions terminate a program.
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC495">24.4.3 Nonlocal Control Transfer in Handlers</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">          Nonlocal transfer of control out of a
                                 signal handler.
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC496">24.4.4 Signals Arriving While a Handler Runs</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">          What happens when signals arrive while
                                 the handler is already occupied.
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC497">24.4.5 Signals Close Together Merge into One</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">		When a second signal arrives before the
				 first is handled.
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC498">24.4.6 Signal Handling and Nonreentrant Functions</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">               Do not call any functions unless you know they
                                 are reentrant with respect to signals.
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC499">24.4.7 Atomic Data Access and Signal Handling</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">          A single handler can run in the middle of
                                 reading or writing a single object.
</td></tr>
</table>

<hr size="6">
<a name="Handler-Returns"></a>
<a name="SEC493"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC492" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC494" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC471" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC492" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="libc_25.html#SEC525" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="libc.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="libc_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="libc_42.html#SEC712" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="libc_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h3 class="subsection"> 24.4.1 Signal Handlers that Return </h3>

<p>Handlers which return normally are usually used for signals such as
<code>SIGALRM</code> and the I/O and interprocess communication signals.  But
a handler for <code>SIGINT</code> might also return normally after setting a
flag that tells the program to exit at a convenient time.
</p>
<p>It is not safe to return normally from the handler for a program error
signal, because the behavior of the program when the handler function
returns is not defined after a program error.  See section <a href="#SEC477">Program Error Signals</a>.
</p>
<p>Handlers that return normally must modify some global variable in order
to have any effect.  Typically, the variable is one that is examined
periodically by the program during normal operation.  Its data type
should be <code>sig_atomic_t</code> for reasons described in <a href="#SEC499">Atomic Data Access and Signal Handling</a>.
</p>
<p>Here is a simple example of such a program.  It executes the body of
the loop until it has noticed that a <code>SIGALRM</code> signal has arrived.
This technique is useful because it allows the iteration in progress
when the signal arrives to complete before the loop exits.
</p>
<table><tr><td>&nbsp;</td><td><pre class="smallexample">#include &lt;signal.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

/* <span class="roman">This flag controls termination of the main loop.</span> */
volatile sig_atomic_t keep_going = 1;

/* <span class="roman">The signal handler just clears the flag and re-enables itself.</span> */
void 
catch_alarm (int sig)
{
  keep_going = 0;
  signal (sig, catch_alarm);
}

void 
do_stuff (void)
{
  puts (&quot;Doing stuff while waiting for alarm....&quot;);
}

int
main (void)
{
  /* <span class="roman">Establish a handler for SIGALRM signals.</span> */
  signal (SIGALRM, catch_alarm);

  /* <span class="roman">Set an alarm to go off in a little while.</span> */
  alarm (2);

  /* <span class="roman">Check the flag once in a while to see when to quit.</span> */
  while (keep_going)
    do_stuff ();

  return EXIT_SUCCESS;
}
</pre></td></tr></table>

<hr size="6">
<a name="Termination-in-Handler"></a>
<a name="SEC494"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC493" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC495" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC471" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC492" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="libc_25.html#SEC525" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="libc.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="libc_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="libc_42.html#SEC712" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="libc_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h3 class="subsection"> 24.4.2 Handlers That Terminate the Process </h3>

<p>Handler functions that terminate the program are typically used to cause
orderly cleanup or recovery from program error signals and interactive
interrupts.
</p>
<p>The cleanest way for a handler to terminate the process is to raise the
same signal that ran the handler in the first place.  Here is how to do
this:
</p>
<table><tr><td>&nbsp;</td><td><pre class="smallexample">volatile sig_atomic_t fatal_error_in_progress = 0;

void
fatal_error_signal (int sig)
{
  /* <span class="roman">Since this handler is established for more than one kind of signal, </span>
     <span class="roman">it might still get invoked recursively by delivery of some other kind</span>
     <span class="roman">of signal.  Use a static variable to keep track of that.</span> */
  if (fatal_error_in_progress)
    raise (sig);
  fatal_error_in_progress = 1;

  /* <span class="roman">Now do the clean up actions:</span>
     <span class="roman">- reset terminal modes</span>
     <span class="roman">- kill child processes</span>
     <span class="roman">- remove lock files</span> */
  &hellip;

  /* <span class="roman">Now reraise the signal.  We reactivate the signal's</span>
     <span class="roman">default handling, which is to terminate the process.</span>
     <span class="roman">We could just call <code>exit</code> or <code>abort</code>,</span>
     <span class="roman">but reraising the signal sets the return status</span>
     <span class="roman">from the process correctly.</span> */
  signal (sig, SIG_DFL);
  raise (sig);
}
</pre></td></tr></table>

<hr size="6">
<a name="Longjmp-in-Handler"></a>
<a name="SEC495"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC494" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC496" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC471" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC492" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="libc_25.html#SEC525" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="libc.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="libc_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="libc_42.html#SEC712" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="libc_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h3 class="subsection"> 24.4.3 Nonlocal Control Transfer in Handlers </h3>

<p>You can do a nonlocal transfer of control out of a signal handler using
the <code>setjmp</code> and <code>longjmp</code> facilities (see section <a href="libc_23.html#SEC465">Non-Local Exits</a>).
</p>
<p>When the handler does a nonlocal control transfer, the part of the
program that was running will not continue.  If this part of the program
was in the middle of updating an important data structure, the data
structure will remain inconsistent.  Since the program does not
terminate, the inconsistency is likely to be noticed later on.
</p>
<p>There are two ways to avoid this problem.  One is to block the signal
for the parts of the program that update important data structures.
Blocking the signal delays its delivery until it is unblocked, once the
critical updating is finished.  See section <a href="#SEC509">Blocking Signals</a>.
</p>
<p>The other way to re-initialize the crucial data structures in the signal
handler, or make their values consistent.
</p>
<p>Here is a rather schematic example showing the reinitialization of one
global variable.
</p>
<table><tr><td>&nbsp;</td><td><pre class="smallexample">#include &lt;signal.h&gt;
#include &lt;setjmp.h&gt;

jmp_buf return_to_top_level;

volatile sig_atomic_t waiting_for_input;

void
handle_sigint (int signum)
{
  /* <span class="roman">We may have been waiting for input when the signal arrived,</span>
     <span class="roman">but we are no longer waiting once we transfer control.</span> */
  waiting_for_input = 0;
  longjmp (return_to_top_level, 1);
}

int
main (void)
{
  &hellip;
  signal (SIGINT, sigint_handler);
  &hellip;
  while (1) {
    prepare_for_command ();
    if (setjmp (return_to_top_level) == 0)
      read_and_execute_command ();
  }
}

/* <span class="roman">Imagine this is a subroutine used by various commands.</span> */
char *
read_data ()
{
  if (input_from_terminal) {
    waiting_for_input = 1;
    &hellip;
    waiting_for_input = 0;
  } else {
    &hellip;
  }
}
</pre></td></tr></table>


<hr size="6">
<a name="Signals-in-Handler"></a>
<a name="SEC496"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC495" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC497" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC471" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC492" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="libc_25.html#SEC525" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="libc.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="libc_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="libc_42.html#SEC712" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="libc_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h3 class="subsection"> 24.4.4 Signals Arriving While a Handler Runs </h3>

<p>What happens if another signal arrives while your signal handler
function is running?
</p>
<p>When the handler for a particular signal is invoked, that signal is
automatically blocked until the handler returns.  That means that if two
signals of the same kind arrive close together, the second one will be
held until the first has been handled.  (The handler can explicitly
unblock the signal using <code>sigprocmask</code>, if you want to allow more
signals of this type to arrive; see <a href="#SEC512">Process Signal Mask</a>.)
</p>
<p>However, your handler can still be interrupted by delivery of another
kind of signal.  To avoid this, you can use the <code>sa_mask</code> member of
the action structure passed to <code>sigaction</code> to explicitly specify
which signals should be blocked while the signal handler runs.  These
signals are in addition to the signal for which the handler was invoked,
and any other signals that are normally blocked by the process.
See section <a href="#SEC514">Blocking Signals for a Handler</a>.
</p>
<p>When the handler returns, the set of blocked signals is restored to the
value it had before the handler ran.  So using <code>sigprocmask</code> inside
the handler only affects what signals can arrive during the execution of
the handler itself, not what signals can arrive once the handler returns.
</p>
<p><strong>Portability Note:</strong> Always use <code>sigaction</code> to establish a
handler for a signal that you expect to receive asynchronously, if you
want your program to work properly on System V Unix.  On this system,
the handling of a signal whose handler was established with
<code>signal</code> automatically sets the signal's action back to
<code>SIG_DFL</code>, and the handler must re-establish itself each time it
runs.  This practice, while inconvenient, does work when signals cannot
arrive in succession.  However, if another signal can arrive right away,
it may arrive before the handler can re-establish itself.  Then the
second signal would receive the default handling, which could terminate
the process.
</p>
<hr size="6">
<a name="Merged-Signals"></a>
<a name="SEC497"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC496" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC498" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC471" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC492" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="libc_25.html#SEC525" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="libc.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="libc_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="libc_42.html#SEC712" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="libc_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h3 class="subsection"> 24.4.5 Signals Close Together Merge into One </h3>

<p>If multiple signals of the same type are delivered to your process
before your signal handler has a chance to be invoked at all, the
handler may only be invoked once, as if only a single signal had
arrived.  In effect, the signals merge into one.  This situation can
arise when the signal is blocked, or in a multiprocessing environment
where the system is busy running some other processes while the signals
are delivered.  This means, for example, that you cannot reliably use a
signal handler to count signals.  The only distinction you can reliably
make is whether at least one signal has arrived since a given time in
the past.
</p>
<p>Here is an example of a handler for <code>SIGCHLD</code> that compensates for
the fact that the number of signals received may not equal the number of
child processes that generate them.  It assumes that the program keeps track
of all the child processes with a chain of structures as follows:
</p>
<table><tr><td>&nbsp;</td><td><pre class="smallexample">struct process
{
  struct process *next;
  /* <span class="roman">The process ID of this child.</span>  */
  int pid;
  /* <span class="roman">The descriptor of the pipe or pseudo terminal</span>
     <span class="roman">on which output comes from this child.</span>  */
  int input_descriptor;
  /* <span class="roman">Nonzero if this process has stopped or terminated.</span>  */
  sig_atomic_t have_status;
  /* <span class="roman">The status of this child; 0 if running,</span>
     <span class="roman">otherwise a status value from <code>waitpid</code>.</span>  */
  int status;
};

struct process *process_list;
</pre></td></tr></table>

<p>This example also uses a flag to indicate whether signals have arrived
since some time in the past&mdash;whenever the program last cleared it to
zero.
</p>
<table><tr><td>&nbsp;</td><td><pre class="smallexample">/* <span class="roman">Nonzero means some child's status has changed</span>
   <span class="roman">so look at <code>process_list</code> for the details.</span>  */
int process_status_change;
</pre></td></tr></table>

<p>Here is the handler itself:
</p>
<table><tr><td>&nbsp;</td><td><pre class="smallexample">void
sigchld_handler (int signo)
{
  int old_errno = errno;

  while (1) {
    register int pid;
    int w;
    struct process *p;

    /* <span class="roman">Keep asking for a status until we get a definitive result.</span>  */
    do
      {
        errno = 0;
        pid = waitpid (WAIT_ANY, &amp;w, WNOHANG | WUNTRACED);
      }
    while (pid &lt;= 0 &amp;&amp; errno == EINTR);

    if (pid &lt;= 0) {
      /* <span class="roman">A real failure means there are no more</span>
         <span class="roman">stopped or terminated child processes, so return.</span>  */
      errno = old_errno;
      return;
    }

    /* <span class="roman">Find the process that signaled us, and record its status.</span>  */

    for (p = process_list; p; p = p-&gt;next)
      if (p-&gt;pid == pid) {
        p-&gt;status = w;
        /* <span class="roman">Indicate that the <code>status</code> field</span>
           <span class="roman">has data to look at.  We do this only after storing it.</span>  */
        p-&gt;have_status = 1;

        /* <span class="roman">If process has terminated, stop waiting for its output.</span>  */
        if (WIFSIGNALED (w) || WIFEXITED (w))
          if (p-&gt;input_descriptor)
            FD_CLR (p-&gt;input_descriptor, &amp;input_wait_mask);

        /* <span class="roman">The program should check this flag from time to time</span>
           <span class="roman">to see if there is any news in <code>process_list</code>.</span>  */
        ++process_status_change;
      }

    /* <span class="roman">Loop around to handle all the processes</span>
       <span class="roman">that have something to tell us.</span>  */
  }
}
</pre></td></tr></table>

<p>Here is the proper way to check the flag <code>process_status_change</code>:
</p>
<table><tr><td>&nbsp;</td><td><pre class="smallexample">if (process_status_change) {
  struct process *p;
  process_status_change = 0;
  for (p = process_list; p; p = p-&gt;next)
    if (p-&gt;have_status) {
      &hellip; <span class="roman">Examine <code>p-&gt;status</code></span> &hellip;
    }
}
</pre></td></tr></table>

<p>It is vital to clear the flag before examining the list; otherwise, if a
signal were delivered just before the clearing of the flag, and after
the appropriate element of the process list had been checked, the status
change would go unnoticed until the next signal arrived to set the flag
again.  You could, of course, avoid this problem by blocking the signal
while scanning the list, but it is much more elegant to guarantee
correctness by doing things in the right order.
</p>
<p>The loop which checks process status avoids examining <code>p-&gt;status</code>
until it sees that status has been validly stored.  This is to make sure
that the status cannot change in the middle of accessing it.  Once
<code>p-&gt;have_status</code> is set, it means that the child process is stopped
or terminated, and in either case, it cannot stop or terminate again
until the program has taken notice.  See section <a href="#SEC502">Atomic Usage Patterns</a>, for more
information about coping with interruptions during accesses of a
variable.
</p>
<p>Here is another way you can test whether the handler has run since the
last time you checked.  This technique uses a counter which is never
changed outside the handler.  Instead of clearing the count, the program
remembers the previous value and sees whether it has changed since the
previous check.  The advantage of this method is that different parts of
the program can check independently, each part checking whether there
has been a signal since that part last checked.
</p>
<table><tr><td>&nbsp;</td><td><pre class="smallexample">sig_atomic_t process_status_change;

sig_atomic_t last_process_status_change;

&hellip;
{
  sig_atomic_t prev = last_process_status_change;
  last_process_status_change = process_status_change;
  if (last_process_status_change != prev) {
    struct process *p;
    for (p = process_list; p; p = p-&gt;next)
      if (p-&gt;have_status) {
        &hellip; <span class="roman">Examine <code>p-&gt;status</code></span> &hellip;
      }
  }
}
</pre></td></tr></table>

<hr size="6">
<a name="Nonreentrancy"></a>
<a name="SEC498"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC497" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC499" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC471" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC492" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="libc_25.html#SEC525" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="libc.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="libc_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="libc_42.html#SEC712" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="libc_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h3 class="subsection"> 24.4.6 Signal Handling and Nonreentrant Functions </h3>

<p>Handler functions usually don't do very much.  The best practice is to
write a handler that does nothing but set an external variable that the
program checks regularly, and leave all serious work to the program.
This is best because the handler can be called asynchronously, at
unpredictable times&mdash;perhaps in the middle of a primitive function, or
even between the beginning and the end of a C operator that requires
multiple instructions.  The data structures being manipulated might
therefore be in an inconsistent state when the handler function is
invoked.  Even copying one <code>int</code> variable into another can take two
instructions on most machines.
</p>
<p>This means you have to be very careful about what you do in a signal
handler.
</p>
<ul>
<li>
<a name="IDX2498"></a>
If your handler needs to access any global variables from your program,
declare those variables <code>volatile</code>.  This tells the compiler that
the value of the variable might change asynchronously, and inhibits
certain optimizations that would be invalidated by such modifications.

</li><li>
<a name="IDX2499"></a>
If you call a function in the handler, make sure it is <em>reentrant</em>
with respect to signals, or else make sure that the signal cannot
interrupt a call to a related function.
</li></ul>

<p>A function can be non-reentrant if it uses memory that is not on the
stack.
</p>
<ul>
<li>
If a function uses a static variable or a global variable, or a
dynamically-allocated object that it finds for itself, then it is
non-reentrant and any two calls to the function can interfere.

<p>For example, suppose that the signal handler uses <code>gethostbyname</code>.
This function returns its value in a static object, reusing the same
object each time.  If the signal happens to arrive during a call to
<code>gethostbyname</code>, or even after one (while the program is still
using the value), it will clobber the value that the program asked for.
</p>
<p>However, if the program does not use <code>gethostbyname</code> or any other
function that returns information in the same object, or if it always
blocks signals around each use, then you are safe.
</p>
<p>There are a large number of library functions that return values in a
fixed object, always reusing the same object in this fashion, and all of
them cause the same problem.  Function descriptions in this manual
always mention this behavior.
</p>
</li><li>
If a function uses and modifies an object that you supply, then it is
potentially non-reentrant; two calls can interfere if they use the same
object.

<p>This case arises when you do I/O using streams.  Suppose that the
signal handler prints a message with <code>fprintf</code>.  Suppose that the
program was in the middle of an <code>fprintf</code> call using the same
stream when the signal was delivered.  Both the signal handler's message
and the program's data could be corrupted, because both calls operate on
the same data structure&mdash;the stream itself.
</p>
<p>However, if you know that the stream that the handler uses cannot
possibly be used by the program at a time when signals can arrive, then
you are safe.  It is no problem if the program uses some other stream.
</p>
</li><li>
On most systems, <code>malloc</code> and <code>free</code> are not reentrant,
because they use a static data structure which records what memory
blocks are free.  As a result, no library functions that allocate or
free memory are reentrant.  This includes functions that allocate space
to store a result.

<p>The best way to avoid the need to allocate memory in a handler is to
allocate in advance space for signal handlers to use.
</p>
<p>The best way to avoid freeing memory in a handler is to flag or record
the objects to be freed, and have the program check from time to time
whether anything is waiting to be freed.  But this must be done with
care, because placing an object on a chain is not atomic, and if it is
interrupted by another signal handler that does the same thing, you
could &ldquo;lose&rdquo; one of the objects.
</p>


</li><li>
Any function that modifies <code>errno</code> is non-reentrant, but you can
correct for this: in the handler, save the original value of
<code>errno</code> and restore it before returning normally.  This prevents
errors that occur within the signal handler from being confused with
errors from system calls at the point the program is interrupted to run
the handler.

<p>This technique is generally applicable; if you want to call in a handler
a function that modifies a particular object in memory, you can make
this safe by saving and restoring that object.
</p>
</li><li>
Merely reading from a memory object is safe provided that you can deal
with any of the values that might appear in the object at a time when
the signal can be delivered.  Keep in mind that assignment to some data
types requires more than one instruction, which means that the handler
could run &ldquo;in the middle of&rdquo; an assignment to the variable if its type
is not atomic.  See section <a href="#SEC499">Atomic Data Access and Signal Handling</a>.

</li><li>
Merely writing into a memory object is safe as long as a sudden change
in the value, at any time when the handler might run, will not disturb
anything.
</li></ul>

<hr size="6">
<a name="Atomic-Data-Access"></a>
<a name="SEC499"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC498" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC500" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC471" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC492" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="libc_25.html#SEC525" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="libc.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="libc_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="libc_42.html#SEC712" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="libc_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h3 class="subsection"> 24.4.7 Atomic Data Access and Signal Handling </h3>

<p>Whether the data in your application concerns atoms, or mere text, you
have to be careful about the fact that access to a single datum is not
necessarily <em>atomic</em>.  This means that it can take more than one
instruction to read or write a single object.  In such cases, a signal
handler might be invoked in the middle of reading or writing the object.
</p>
<p>There are three ways you can cope with this problem.  You can use data
types that are always accessed atomically; you can carefully arrange
that nothing untoward happens if an access is interrupted, or you can
block all signals around any access that had better not be interrupted
(see section <a href="#SEC509">Blocking Signals</a>).
</p>
<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top"><a href="#SEC500">24.4.7.1 Problems with Non-Atomic Access</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">		A program illustrating interrupted access.
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC501">24.4.7.2 Atomic Types</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">		Data types that guarantee no interruption.
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC502">24.4.7.3 Atomic Usage Patterns</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">		Proving that interruption is harmless.
</td></tr>
</table>

<hr size="6">
<a name="Non_002datomic-Example"></a>
<a name="SEC500"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC499" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC501" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC471" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC499" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="libc_25.html#SEC525" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="libc.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="libc_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="libc_42.html#SEC712" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="libc_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h4 class="subsubsection"> 24.4.7.1 Problems with Non-Atomic Access </h4>

<p>Here is an example which shows what can happen if a signal handler runs
in the middle of modifying a variable.  (Interrupting the reading of a
variable can also lead to paradoxical results, but here we only show
writing.)
</p>
<table><tr><td>&nbsp;</td><td><pre class="smallexample">#include &lt;signal.h&gt;
#include &lt;stdio.h&gt;

volatile struct two_words { int a, b; } memory;

void
handler(int signum)
{
   printf (&quot;%d,%d\n&quot;, memory.a, memory.b);
   alarm (1);
}

int
main (void)
{
   static struct two_words zeros = { 0, 0 }, ones = { 1, 1 };
   signal (SIGALRM, handler);
   memory = zeros;
   alarm (1);
   while (1)
     {
       memory = zeros;
       memory = ones;
     }
}
</pre></td></tr></table>

<p>This program fills <code>memory</code> with zeros, ones, zeros, ones,
alternating forever; meanwhile, once per second, the alarm signal handler
prints the current contents.  (Calling <code>printf</code> in the handler is
safe in this program because it is certainly not being called outside
the handler when the signal happens.)
</p>
<p>Clearly, this program can print a pair of zeros or a pair of ones.  But
that's not all it can do!  On most machines, it takes several
instructions to store a new value in <code>memory</code>, and the value is
stored one word at a time.  If the signal is delivered in between these
instructions, the handler might find that <code>memory.a</code> is zero and
<code>memory.b</code> is one (or vice versa).
</p>
<p>On some machines it may be possible to store a new value in
<code>memory</code> with just one instruction that cannot be interrupted.  On
these machines, the handler will always print two zeros or two ones.
</p>
<hr size="6">
<a name="Atomic-Types"></a>
<a name="SEC501"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC500" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC502" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC471" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC499" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="libc_25.html#SEC525" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="libc.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="libc_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="libc_42.html#SEC712" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="libc_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h4 class="subsubsection"> 24.4.7.2 Atomic Types </h4>

<p>To avoid uncertainty about interrupting access to a variable, you can
use a particular data type for which access is always atomic:
<code>sig_atomic_t</code>.  Reading and writing this data type is guaranteed
to happen in a single instruction, so there's no way for a handler to
run &ldquo;in the middle&rdquo; of an access.
</p>
<p>The type <code>sig_atomic_t</code> is always an integer data type, but which
one it is, and how many bits it contains, may vary from machine to
machine.
</p>
<dl>
<dt><u>Data Type:</u> <b>sig_atomic_t</b>
<a name="IDX2500"></a>
</dt>
<dd><p>This is an integer data type.  Objects of this type are always accessed
atomically.
</p></dd></dl>

<p>In practice, you can assume that <code>int</code> is atomic.
You can also assume that pointer
types are atomic; that is very convenient.  Both of these assumptions
are true on all of the machines that the GNU C library supports and on
all POSIX systems we know of.
</p>
<hr size="6">
<a name="Atomic-Usage"></a>
<a name="SEC502"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC501" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC503" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC471" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC499" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="libc_25.html#SEC525" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="libc.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="libc_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="libc_42.html#SEC712" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="libc_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h4 class="subsubsection"> 24.4.7.3 Atomic Usage Patterns </h4>

<p>Certain patterns of access avoid any problem even if an access is
interrupted.  For example, a flag which is set by the handler, and
tested and cleared by the main program from time to time, is always safe
even if access actually requires two instructions.  To show that this is
so, we must consider each access that could be interrupted, and show
that there is no problem if it is interrupted.
</p>
<p>An interrupt in the middle of testing the flag is safe because either it's
recognized to be nonzero, in which case the precise value doesn't
matter, or it will be seen to be nonzero the next time it's tested.
</p>
<p>An interrupt in the middle of clearing the flag is no problem because
either the value ends up zero, which is what happens if a signal comes
in just before the flag is cleared, or the value ends up nonzero, and
subsequent events occur as if the signal had come in just after the flag
was cleared.  As long as the code handles both of these cases properly,
it can also handle a signal in the middle of clearing the flag.  (This
is an example of the sort of reasoning you need to do to figure out
whether non-atomic usage is safe.)
</p>
<p>Sometimes you can insure uninterrupted access to one object by
protecting its use with another object, perhaps one whose type
guarantees atomicity.  See section <a href="#SEC497">Signals Close Together Merge into One</a>, for an example.
</p>
<hr size="6">
<a name="Interrupted-Primitives"></a>
<a name="SEC503"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC502" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC504" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC471" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC471" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="libc_25.html#SEC525" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="libc.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="libc_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="libc_42.html#SEC712" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="libc_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="section"> 24.5 Primitives Interrupted by Signals </h2>

<p>A signal can arrive and be handled while an I/O primitive such as
<code>open</code> or <code>read</code> is waiting for an I/O device.  If the signal
handler returns, the system faces the question: what should happen next?
</p>
<p>POSIX specifies one approach: make the primitive fail right away.  The
error code for this kind of failure is <code>EINTR</code>.  This is flexible,
but usually inconvenient.  Typically, POSIX applications that use signal
handlers must check for <code>EINTR</code> after each library function that
can return it, in order to try the call again.  Often programmers forget
to check, which is a common source of error.
</p>
<p>The GNU library provides a convenient way to retry a call after a
temporary failure, with the macro <code>TEMP_FAILURE_RETRY</code>:
</p>
<dl>
<dt><u>Macro:</u> <b>TEMP_FAILURE_RETRY</b><i> (<var>expression</var>)</i>
<a name="IDX2501"></a>
</dt>
<dd><p>This macro evaluates <var>expression</var> once, and examines its value as
type <code>long int</code>.  If the value equals <code>-1</code>, that indicates a
failure and <code>errno</code> should be set to show what kind of failure.
If it fails and reports error code <code>EINTR</code>,
<code>TEMP_FAILURE_RETRY</code> evaluates it again, and over and over until
the result is not a temporary failure.
</p>
<p>The value returned by <code>TEMP_FAILURE_RETRY</code> is whatever value
<var>expression</var> produced.
</p></dd></dl>

<p>BSD avoids <code>EINTR</code> entirely and provides a more convenient
approach: to restart the interrupted primitive, instead of making it
fail.  If you choose this approach, you need not be concerned with
<code>EINTR</code>.
</p>
<p>You can choose either approach with the GNU library.  If you use
<code>sigaction</code> to establish a signal handler, you can specify how that
handler should behave.  If you specify the <code>SA_RESTART</code> flag,
return from that handler will resume a primitive; otherwise, return from
that handler will cause <code>EINTR</code>.  See section <a href="#SEC490">Flags for <code>sigaction</code></a>.
</p>
<p>Another way to specify the choice is with the <code>siginterrupt</code>
function.  See section <a href="#SEC523">BSD Function to Establish a Handler</a>.
</p>
<p>When you don't specify with <code>sigaction</code> or <code>siginterrupt</code> what
a particular handler should do, it uses a default choice.  The default
choice in the GNU library depends on the feature test macros you have
defined.  If you define <code>_BSD_SOURCE</code> or <code>_GNU_SOURCE</code> before
calling <code>signal</code>, the default is to resume primitives; otherwise,
the default is to make them fail with <code>EINTR</code>.  (The library
contains alternate versions of the <code>signal</code> function, and the
feature test macros determine which one you really call.)  See section <a href="libc_1.html#SEC13">Feature Test Macros</a>.
<a name="IDX2502"></a>
<a name="IDX2503"></a>
<a name="IDX2504"></a>
<a name="IDX2505"></a>
</p>
<p>The description of each primitive affected by this issue
lists <code>EINTR</code> among the error codes it can return.
</p>
<p>There is one situation where resumption never happens no matter which
choice you make: when a data-transfer function such as <code>read</code> or
<code>write</code> is interrupted by a signal after transferring part of the
data.  In this case, the function returns the number of bytes already
transferred, indicating partial success.
</p>
<p>This might at first appear to cause unreliable behavior on
record-oriented devices (including datagram sockets; see section <a href="libc_16.html#SEC345">Datagram Socket Operations</a>),
where splitting one <code>read</code> or <code>write</code> into two would read or
write two records.  Actually, there is no problem, because interruption
after a partial transfer cannot happen on such devices; they always
transfer an entire record in one burst, with no waiting once data
transfer has started.
</p>
<hr size="6">
<a name="Generating-Signals"></a>
<a name="SEC504"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC503" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC505" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC471" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC471" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="libc_25.html#SEC525" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="libc.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="libc_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="libc_42.html#SEC712" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="libc_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="section"> 24.6 Generating Signals </h2>

<p>Besides signals that are generated as a result of a hardware trap or
interrupt, your program can explicitly send signals to itself or to
another process.
</p>
<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top"><a href="#SEC505">24.6.1 Signaling Yourself</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">          A process can send a signal to itself.
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC506">24.6.2 Signaling Another Process</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">   Send a signal to another process.
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC507">24.6.3 Permission for using <code>kill</code></a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top"></td></tr>
<tr><td align="left" valign="top"><a href="#SEC508">24.6.4 Using <code>kill</code> for Communication</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top"></td></tr>
</table>

<hr size="6">
<a name="Signaling-Yourself"></a>
<a name="SEC505"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC504" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC506" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC471" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC504" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="libc_25.html#SEC525" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="libc.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="libc_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="libc_42.html#SEC712" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="libc_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h3 class="subsection"> 24.6.1 Signaling Yourself </h3>

<p>A process can send itself a signal with the <code>raise</code> function.  This
function is declared in &lsquo;<tt>signal.h</tt>&rsquo;.
<a name="IDX2506"></a>
</p>
<dl>
<dt><u>Function:</u> int <b>raise</b><i> (int <var>signum</var>)</i>
<a name="IDX2507"></a>
</dt>
<dd><p>The <code>raise</code> function sends the signal <var>signum</var> to the calling
process.  It returns zero if successful and a nonzero value if it fails.
About the only reason for failure would be if the value of <var>signum</var>
is invalid.
</p></dd></dl>

<dl>
<dt><u>Function:</u> int <b>gsignal</b><i> (int <var>signum</var>)</i>
<a name="IDX2508"></a>
</dt>
<dd><p>The <code>gsignal</code> function does the same thing as <code>raise</code>; it is
provided only for compatibility with SVID.
</p></dd></dl>

<p>One convenient use for <code>raise</code> is to reproduce the default behavior
of a signal that you have trapped.  For instance, suppose a user of your
program types the SUSP character (usually <kbd>C-z</kbd>; see section <a href="libc_17.html#SEC370">Special Characters</a>) to send it an interactive stop signal
(<code>SIGTSTP</code>), and you want to clean up some internal data buffers
before stopping.  You might set this up like this:
</p>

<table><tr><td>&nbsp;</td><td><pre class="smallexample">#include &lt;signal.h&gt;

/* <span class="roman">When a stop signal arrives, set the action back to the default
   and then resend the signal after doing cleanup actions.</span> */

void
tstp_handler (int sig)
{
  signal (SIGTSTP, SIG_DFL);
  /* <span class="roman">Do cleanup actions here.</span> */
  &hellip;
  raise (SIGTSTP);
}

/* <span class="roman">When the process is continued again, restore the signal handler.</span> */

void
cont_handler (int sig)
{
  signal (SIGCONT, cont_handler);
  signal (SIGTSTP, tstp_handler);
}

/* <span class="roman">Enable both handlers during program initialization.</span> */

int
main (void)
{
  signal (SIGCONT, cont_handler);
  signal (SIGTSTP, tstp_handler);
  &hellip;
}
</pre></td></tr></table>

<p><strong>Portability note:</strong> <code>raise</code> was invented by the ISO C
committee.  Older systems may not support it, so using <code>kill</code> may
be more portable.  See section <a href="#SEC506">Signaling Another Process</a>.
</p>
<hr size="6">
<a name="Signaling-Another-Process"></a>
<a name="SEC506"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC505" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC507" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC471" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC504" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="libc_25.html#SEC525" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="libc.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="libc_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="libc_42.html#SEC712" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="libc_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h3 class="subsection"> 24.6.2 Signaling Another Process </h3>

<p>The <code>kill</code> function can be used to send a signal to another process.
In spite of its name, it can be used for a lot of things other than
causing a process to terminate.  Some examples of situations where you
might want to send signals between processes are:
</p>
<ul>
<li>
A parent process starts a child to perform a task&mdash;perhaps having the
child running an infinite loop&mdash;and then terminates the child when the
task is no longer needed.

</li><li>
A process executes as part of a group, and needs to terminate or notify
the other processes in the group when an error or other event occurs.

</li><li>
Two processes need to synchronize while working together.
</li></ul>

<p>This section assumes that you know a little bit about how processes
work.  For more information on this subject, see <a href="libc_26.html#SEC568">Processes</a>.
</p>
<p>The <code>kill</code> function is declared in &lsquo;<tt>signal.h</tt>&rsquo;.
<a name="IDX2509"></a>
</p>
<dl>
<dt><u>Function:</u> int <b>kill</b><i> (pid_t <var>pid</var>, int <var>signum</var>)</i>
<a name="IDX2510"></a>
</dt>
<dd><p>The <code>kill</code> function sends the signal <var>signum</var> to the process
or process group specified by <var>pid</var>.  Besides the signals listed in
<a href="#SEC476">Standard Signals</a>, <var>signum</var> can also have a value of zero to
check the validity of the <var>pid</var>.
</p>
<p>The <var>pid</var> specifies the process or process group to receive the
signal:
</p>
<dl compact="compact">
<dt> <code><var>pid</var> &gt; 0</code></dt>
<dd><p>The process whose identifier is <var>pid</var>.
</p>
</dd>
<dt> <code><var>pid</var> == 0</code></dt>
<dd><p>All processes in the same process group as the sender.
</p>
</dd>
<dt> <code><var>pid</var> &lt; -1</code></dt>
<dd><p>The process group whose identifier is -<var>pid</var>.
</p>
</dd>
<dt> <code><var>pid</var> == -1</code></dt>
<dd><p>If the process is privileged, send the signal to all processes except
for some special system processes.  Otherwise, send the signal to all
processes with the same effective user ID.
</p></dd>
</dl>

<p>A process can send a signal to itself with a call like <code>kill
(getpid(), <var>signum</var>)</code>.  If <code>kill</code> is used by a process to send
a signal to itself, and the signal is not blocked, then <code>kill</code>
delivers at least one signal (which might be some other pending
unblocked signal instead of the signal <var>signum</var>) to that process
before it returns.
</p>
<p>The return value from <code>kill</code> is zero if the signal can be sent
successfully.  Otherwise, no signal is sent, and a value of <code>-1</code> is
returned.  If <var>pid</var> specifies sending a signal to several processes,
<code>kill</code> succeeds if it can send the signal to at least one of them.
There's no way you can tell which of the processes got the signal
or whether all of them did.
</p>
<p>The following <code>errno</code> error conditions are defined for this function:
</p>
<dl compact="compact">
<dt> <code>EINVAL</code></dt>
<dd><p>The <var>signum</var> argument is an invalid or unsupported number.
</p>
</dd>
<dt> <code>EPERM</code></dt>
<dd><p>You do not have the privilege to send a signal to the process or any of
the processes in the process group named by <var>pid</var>.
</p>
</dd>
<dt> <code>ESRCH</code></dt>
<dd><p>The <var>pid</var> argument does not refer to an existing process or group.
</p></dd>
</dl>
</dd></dl>

<dl>
<dt><u>Function:</u> int <b>killpg</b><i> (int <var>pgid</var>, int <var>signum</var>)</i>
<a name="IDX2511"></a>
</dt>
<dd><p>This is similar to <code>kill</code>, but sends signal <var>signum</var> to the
process group <var>pgid</var>.  This function is provided for compatibility
with BSD; using <code>kill</code> to do this is more portable.
</p></dd></dl>

<p>As a simple example of <code>kill</code>, the call <code>kill (getpid (),
<var>sig</var>)</code> has the same effect as <code>raise (<var>sig</var>)</code>.
</p>
<hr size="6">
<a name="Permission-for-kill"></a>
<a name="SEC507"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC506" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC508" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC471" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC504" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="libc_25.html#SEC525" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="libc.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="libc_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="libc_42.html#SEC712" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="libc_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h3 class="subsection"> 24.6.3 Permission for using <code>kill</code> </h3>

<p>There are restrictions that prevent you from using <code>kill</code> to send
signals to any random process.  These are intended to prevent antisocial
behavior such as arbitrarily killing off processes belonging to another
user.  In typical use, <code>kill</code> is used to pass signals between
parent, child, and sibling processes, and in these situations you
normally do have permission to send signals.  The only common exception
is when you run a setuid program in a child process; if the program
changes its real UID as well as its effective UID, you may not have
permission to send a signal.  The <code>su</code> program does this.
</p>
<p>Whether a process has permission to send a signal to another process
is determined by the user IDs of the two processes.  This concept is
discussed in detail in <a href="libc_29.html#SEC610">The Persona of a Process</a>.
</p>
<p>Generally, for a process to be able to send a signal to another process,
either the sending process must belong to a privileged user (like
&lsquo;<samp>root</samp>&rsquo;), or the real or effective user ID of the sending process
must match the real or effective user ID of the receiving process.  If
the receiving process has changed its effective user ID from the
set-user-ID mode bit on its process image file, then the owner of the
process image file is used in place of its current effective user ID.
In some implementations, a parent process might be able to send signals
to a child process even if the user ID's don't match, and other
implementations might enforce other restrictions.
</p>
<p>The <code>SIGCONT</code> signal is a special case.  It can be sent if the
sender is part of the same session as the receiver, regardless of
user IDs.
</p>
<hr size="6">
<a name="Kill-Example"></a>
<a name="SEC508"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC507" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC509" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC471" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC504" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="libc_25.html#SEC525" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="libc.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="libc_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="libc_42.html#SEC712" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="libc_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h3 class="subsection"> 24.6.4 Using <code>kill</code> for Communication </h3>
<p>Here is a longer example showing how signals can be used for
interprocess communication.  This is what the <code>SIGUSR1</code> and
<code>SIGUSR2</code> signals are provided for.  Since these signals are fatal
by default, the process that is supposed to receive them must trap them
through <code>signal</code> or <code>sigaction</code>.
</p>
<p>In this example, a parent process forks a child process and then waits
for the child to complete its initialization.  The child process tells
the parent when it is ready by sending it a <code>SIGUSR1</code> signal, using
the <code>kill</code> function.
</p>
<table><tr><td>&nbsp;</td><td><pre class="smallexample">#include &lt;signal.h&gt;
#include &lt;stdio.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;unistd.h&gt;

/* <span class="roman">When a <code>SIGUSR1</code> signal arrives, set this variable.</span> */
volatile sig_atomic_t usr_interrupt = 0;

void 
synch_signal (int sig)
{
  usr_interrupt = 1;
}

/* <span class="roman">The child process executes this function.</span> */
void 
child_function (void)
{
  /* <span class="roman">Perform initialization.</span> */
  printf (&quot;I'm here!!!  My pid is %d.\n&quot;, (int) getpid ());

  /* <span class="roman">Let parent know you're done.</span> */
  kill (getppid (), SIGUSR1);

  /* <span class="roman">Continue with execution.</span> */
  puts (&quot;Bye, now....&quot;);
  exit (0);
}

int
main (void)
{
  struct sigaction usr_action;
  sigset_t block_mask;
  pid_t child_id;

  /* <span class="roman">Establish the signal handler.</span> */
  sigfillset (&amp;block_mask);
  usr_action.sa_handler = synch_signal;
  usr_action.sa_mask = block_mask;
  usr_action.sa_flags = 0;
  sigaction (SIGUSR1, &amp;usr_action, NULL);

  /* <span class="roman">Create the child process.</span> */
  child_id = fork ();
  if (child_id == 0)
    child_function ();          /* <span class="roman">Does not return.</span> */

  /* <span class="roman">Busy wait for the child to send a signal.</span> */
  while (!usr_interrupt)
    ;

  /* <span class="roman">Now continue execution.</span> */
  puts (&quot;That's all, folks!&quot;);

  return 0;
}
</pre></td></tr></table>

<p>This example uses a busy wait, which is bad, because it wastes CPU
cycles that other programs could otherwise use.  It is better to ask the
system to wait until the signal arrives.  See the example in
<a href="#SEC517">Waiting for a Signal</a>.
</p>
<hr size="6">
<a name="Blocking-Signals"></a>
<a name="SEC509"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC508" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC510" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC471" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC471" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="libc_25.html#SEC525" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="libc.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="libc_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="libc_42.html#SEC712" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="libc_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="section"> 24.7 Blocking Signals </h2>

<p>Blocking a signal means telling the operating system to hold it and
deliver it later.  Generally, a program does not block signals
indefinitely&mdash;it might as well ignore them by setting their actions to
<code>SIG_IGN</code>.  But it is useful to block signals briefly, to prevent
them from interrupting sensitive operations.  For instance:
</p>
<ul>
<li>
You can use the <code>sigprocmask</code> function to block signals while you
modify global variables that are also modified by the handlers for these
signals.

</li><li>
You can set <code>sa_mask</code> in your <code>sigaction</code> call to block
certain signals while a particular signal handler runs.  This way, the
signal handler can run without being interrupted itself by signals.
</li></ul>

<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top"><a href="#SEC510">24.7.1 Why Blocking Signals is Useful</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                           The purpose of blocking signals.
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC511">24.7.2 Signal Sets</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                         How to specify which signals to
                                         block.
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC512">24.7.3 Process Signal Mask</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                 Blocking delivery of signals to your
				         process during normal execution.
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC513">24.7.4 Blocking to Test for Delivery of a Signal</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top"></td></tr>
<tr><td align="left" valign="top"><a href="#SEC514">24.7.5 Blocking Signals for a Handler</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                Blocking additional signals while a
				         handler is being run.
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC515">24.7.6 Checking for Pending Signals</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top"></td></tr>
<tr><td align="left" valign="top"><a href="#SEC516">24.7.7 Remembering a Signal to Act On Later</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                How you can get almost the same
                                         effect as blocking a signal, by
                                         handling it and setting a flag
                                         to be tested later.
</td></tr>
</table>

<hr size="6">
<a name="Why-Block"></a>
<a name="SEC510"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC509" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC511" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC471" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC509" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="libc_25.html#SEC525" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="libc.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="libc_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="libc_42.html#SEC712" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="libc_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h3 class="subsection"> 24.7.1 Why Blocking Signals is Useful </h3>

<p>Temporary blocking of signals with <code>sigprocmask</code> gives you a way to
prevent interrupts during critical parts of your code.  If signals
arrive in that part of the program, they are delivered later, after you
unblock them.
</p>
<p>One example where this is useful is for sharing data between a signal
handler and the rest of the program.  If the type of the data is not
<code>sig_atomic_t</code> (see section <a href="#SEC499">Atomic Data Access and Signal Handling</a>), then the signal
handler could run when the rest of the program has only half finished
reading or writing the data.  This would lead to confusing consequences.
</p>
<p>To make the program reliable, you can prevent the signal handler from
running while the rest of the program is examining or modifying that
data&mdash;by blocking the appropriate signal around the parts of the
program that touch the data.
</p>
<p>Blocking signals is also necessary when you want to perform a certain
action only if a signal has not arrived.  Suppose that the handler for
the signal sets a flag of type <code>sig_atomic_t</code>; you would like to
test the flag and perform the action if the flag is not set.  This is
unreliable.  Suppose the signal is delivered immediately after you test
the flag, but before the consequent action: then the program will
perform the action even though the signal has arrived.
</p>
<p>The only way to test reliably for whether a signal has yet arrived is to
test while the signal is blocked.
</p>
<hr size="6">
<a name="Signal-Sets"></a>
<a name="SEC511"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC510" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC512" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC471" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC509" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="libc_25.html#SEC525" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="libc.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="libc_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="libc_42.html#SEC712" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="libc_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h3 class="subsection"> 24.7.2 Signal Sets </h3>

<p>All of the signal blocking functions use a data structure called a
<em>signal set</em> to specify what signals are affected.  Thus, every
activity involves two stages: creating the signal set, and then passing
it as an argument to a library function.
<a name="IDX2512"></a>
</p>
<p>These facilities are declared in the header file &lsquo;<tt>signal.h</tt>&rsquo;.
<a name="IDX2513"></a>
</p>
<dl>
<dt><u>Data Type:</u> <b>sigset_t</b>
<a name="IDX2514"></a>
</dt>
<dd><p>The <code>sigset_t</code> data type is used to represent a signal set.
Internally, it may be implemented as either an integer or structure
type.
</p>
<p>For portability, use only the functions described in this section to
initialize, change, and retrieve information from <code>sigset_t</code>
objects&mdash;don't try to manipulate them directly.
</p></dd></dl>

<p>There are two ways to initialize a signal set.  You can initially
specify it to be empty with <code>sigemptyset</code> and then add specified
signals individually.  Or you can specify it to be full with
<code>sigfillset</code> and then delete specified signals individually.
</p>
<p>You must always initialize the signal set with one of these two
functions before using it in any other way.  Don't try to set all the
signals explicitly because the <code>sigset_t</code> object might include some
other information (like a version field) that needs to be initialized as
well.  (In addition, it's not wise to put into your program an
assumption that the system has no signals aside from the ones you know
about.)
</p>
<dl>
<dt><u>Function:</u> int <b>sigemptyset</b><i> (sigset_t *<var>set</var>)</i>
<a name="IDX2515"></a>
</dt>
<dd><p>This function initializes the signal set <var>set</var> to exclude all of the
defined signals.  It always returns <code>0</code>.
</p></dd></dl>

<dl>
<dt><u>Function:</u> int <b>sigfillset</b><i> (sigset_t *<var>set</var>)</i>
<a name="IDX2516"></a>
</dt>
<dd><p>This function initializes the signal set <var>set</var> to include
all of the defined signals.  Again, the return value is <code>0</code>.
</p></dd></dl>

<dl>
<dt><u>Function:</u> int <b>sigaddset</b><i> (sigset_t *<var>set</var>, int <var>signum</var>)</i>
<a name="IDX2517"></a>
</dt>
<dd><p>This function adds the signal <var>signum</var> to the signal set <var>set</var>.
All <code>sigaddset</code> does is modify <var>set</var>; it does not block or
unblock any signals.
</p>
<p>The return value is <code>0</code> on success and <code>-1</code> on failure.
The following <code>errno</code> error condition is defined for this function:
</p>
<dl compact="compact">
<dt> <code>EINVAL</code></dt>
<dd><p>The <var>signum</var> argument doesn't specify a valid signal.
</p></dd>
</dl>
</dd></dl>

<dl>
<dt><u>Function:</u> int <b>sigdelset</b><i> (sigset_t *<var>set</var>, int <var>signum</var>)</i>
<a name="IDX2518"></a>
</dt>
<dd><p>This function removes the signal <var>signum</var> from the signal set
<var>set</var>.  All <code>sigdelset</code> does is modify <var>set</var>; it does not
block or unblock any signals.  The return value and error conditions are
the same as for <code>sigaddset</code>.
</p></dd></dl>

<p>Finally, there is a function to test what signals are in a signal set:
</p>
<dl>
<dt><u>Function:</u> int <b>sigismember</b><i> (const sigset_t *<var>set</var>, int <var>signum</var>)</i>
<a name="IDX2519"></a>
</dt>
<dd><p>The <code>sigismember</code> function tests whether the signal <var>signum</var> is
a member of the signal set <var>set</var>.  It returns <code>1</code> if the signal
is in the set, <code>0</code> if not, and <code>-1</code> if there is an error.
</p>
<p>The following <code>errno</code> error condition is defined for this function:
</p>
<dl compact="compact">
<dt> <code>EINVAL</code></dt>
<dd><p>The <var>signum</var> argument doesn't specify a valid signal.
</p></dd>
</dl>
</dd></dl>

<hr size="6">
<a name="Process-Signal-Mask"></a>
<a name="SEC512"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC511" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC513" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC471" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC509" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="libc_25.html#SEC525" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="libc.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="libc_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="libc_42.html#SEC712" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="libc_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h3 class="subsection"> 24.7.3 Process Signal Mask </h3>

<p>The collection of signals that are currently blocked is called the
<em>signal mask</em>.  Each process has its own signal mask.  When you
create a new process (see section <a href="libc_26.html#SEC572">Creating a Process</a>), it inherits its
parent's mask.  You can block or unblock signals with total flexibility
by modifying the signal mask.
</p>
<p>The prototype for the <code>sigprocmask</code> function is in &lsquo;<tt>signal.h</tt>&rsquo;.
<a name="IDX2520"></a>
</p>
<p>Note that you must not use <code>sigprocmask</code> in multi-threaded processes,
because each thread has its own signal mask and there is no single process
signal mask. According to POSIX, the behavior of <code>sigprocmask</code> in a
multi-threaded process is &ldquo;unspecified&rdquo;.
Instead, use <code>pthread_sigmask</code>.
</p>
<dl>
<dt><u>Function:</u> int <b>sigprocmask</b><i> (int <var>how</var>, const sigset_t *restrict <var>set</var>, sigset_t *restrict <var>oldset</var>)</i>
<a name="IDX2521"></a>
</dt>
<dd><p>The <code>sigprocmask</code> function is used to examine or change the calling
process's signal mask.  The <var>how</var> argument determines how the signal
mask is changed, and must be one of the following values:
</p>
<dl compact="compact">
<dd><a name="IDX2522"></a>
</dd>
<dt> <code>SIG_BLOCK</code></dt>
<dd><p>Block the signals in <code>set</code>&mdash;add them to the existing mask.  In
other words, the new mask is the union of the existing mask and
<var>set</var>.
</p>
<a name="IDX2523"></a>
</dd>
<dt> <code>SIG_UNBLOCK</code></dt>
<dd><p>Unblock the signals in <var>set</var>&mdash;remove them from the existing mask.
</p>
<a name="IDX2524"></a>
</dd>
<dt> <code>SIG_SETMASK</code></dt>
<dd><p>Use <var>set</var> for the mask; ignore the previous value of the mask.
</p></dd>
</dl>

<p>The last argument, <var>oldset</var>, is used to return information about the
old process signal mask.  If you just want to change the mask without
looking at it, pass a null pointer as the <var>oldset</var> argument.
Similarly, if you want to know what's in the mask without changing it,
pass a null pointer for <var>set</var> (in this case the <var>how</var> argument
is not significant).  The <var>oldset</var> argument is often used to
remember the previous signal mask in order to restore it later.  (Since
the signal mask is inherited over <code>fork</code> and <code>exec</code> calls, you
can't predict what its contents are when your program starts running.)
</p>
<p>If invoking <code>sigprocmask</code> causes any pending signals to be
unblocked, at least one of those signals is delivered to the process
before <code>sigprocmask</code> returns.  The order in which pending signals
are delivered is not specified, but you can control the order explicitly
by making multiple <code>sigprocmask</code> calls to unblock various signals
one at a time.
</p>
<p>The <code>sigprocmask</code> function returns <code>0</code> if successful, and <code>-1</code>
to indicate an error.  The following <code>errno</code> error conditions are
defined for this function:
</p>
<dl compact="compact">
<dt> <code>EINVAL</code></dt>
<dd><p>The <var>how</var> argument is invalid.
</p></dd>
</dl>

<p>You can't block the <code>SIGKILL</code> and <code>SIGSTOP</code> signals, but
if the signal set includes these, <code>sigprocmask</code> just ignores
them instead of returning an error status.
</p>
<p>Remember, too, that blocking program error signals such as <code>SIGFPE</code>
leads to undesirable results for signals generated by an actual program
error (as opposed to signals sent with <code>raise</code> or <code>kill</code>).
This is because your program may be too broken to be able to continue
executing to a point where the signal is unblocked again.
See section <a href="#SEC477">Program Error Signals</a>.
</p></dd></dl>

<hr size="6">
<a name="Testing-for-Delivery"></a>
<a name="SEC513"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC512" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC514" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC471" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC509" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="libc_25.html#SEC525" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="libc.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="libc_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="libc_42.html#SEC712" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="libc_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h3 class="subsection"> 24.7.4 Blocking to Test for Delivery of a Signal </h3>

<p>Now for a simple example.  Suppose you establish a handler for
<code>SIGALRM</code> signals that sets a flag whenever a signal arrives, and
your main program checks this flag from time to time and then resets it.
You can prevent additional <code>SIGALRM</code> signals from arriving in the
meantime by wrapping the critical part of the code with calls to
<code>sigprocmask</code>, like this:
</p>
<table><tr><td>&nbsp;</td><td><pre class="smallexample">/* <span class="roman">This variable is set by the SIGALRM signal handler.</span> */
volatile sig_atomic_t flag = 0;

int
main (void)
{
  sigset_t block_alarm;

  &hellip;

  /* <span class="roman">Initialize the signal mask.</span> */
  sigemptyset (&amp;block_alarm);
  sigaddset (&amp;block_alarm, SIGALRM);

  while (1)
    {
      /* <span class="roman">Check if a signal has arrived; if so, reset the flag.</span> */
      sigprocmask (SIG_BLOCK, &amp;block_alarm, NULL);
      if (flag)
        {
          <var>actions-if-not-arrived</var>
          flag = 0;
        }
      sigprocmask (SIG_UNBLOCK, &amp;block_alarm, NULL);

      &hellip;
    }
}
</pre></td></tr></table>

<hr size="6">
<a name="Blocking-for-Handler"></a>
<a name="SEC514"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC513" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC515" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC471" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC509" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="libc_25.html#SEC525" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="libc.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="libc_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="libc_42.html#SEC712" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="libc_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h3 class="subsection"> 24.7.5 Blocking Signals for a Handler </h3>

<p>When a signal handler is invoked, you usually want it to be able to
finish without being interrupted by another signal.  From the moment the
handler starts until the moment it finishes, you must block signals that
might confuse it or corrupt its data.
</p>
<p>When a handler function is invoked on a signal, that signal is
automatically blocked (in addition to any other signals that are already
in the process's signal mask) during the time the handler is running.
If you set up a handler for <code>SIGTSTP</code>, for instance, then the
arrival of that signal forces further <code>SIGTSTP</code> signals to wait
during the execution of the handler.
</p>
<p>However, by default, other kinds of signals are not blocked; they can
arrive during handler execution.
</p>
<p>The reliable way to block other kinds of signals during the execution of
the handler is to use the <code>sa_mask</code> member of the <code>sigaction</code>
structure.
</p>
<p>Here is an example:
</p>
<table><tr><td>&nbsp;</td><td><pre class="smallexample">#include &lt;signal.h&gt;
#include &lt;stddef.h&gt;

void catch_stop ();

void
install_handler (void)
{
  struct sigaction setup_action;
  sigset_t block_mask;

  sigemptyset (&amp;block_mask);
  /* <span class="roman">Block other terminal-generated signals while handler runs.</span> */
  sigaddset (&amp;block_mask, SIGINT);
  sigaddset (&amp;block_mask, SIGQUIT);
  setup_action.sa_handler = catch_stop;
  setup_action.sa_mask = block_mask;
  setup_action.sa_flags = 0;
  sigaction (SIGTSTP, &amp;setup_action, NULL);
}
</pre></td></tr></table>

<p>This is more reliable than blocking the other signals explicitly in the
code for the handler.  If you block signals explicitly in the handler,
you can't avoid at least a short interval at the beginning of the
handler where they are not yet blocked.
</p>
<p>You cannot remove signals from the process's current mask using this
mechanism.  However, you can make calls to <code>sigprocmask</code> within
your handler to block or unblock signals as you wish.
</p>
<p>In any case, when the handler returns, the system restores the mask that
was in place before the handler was entered.  If any signals that become
unblocked by this restoration are pending, the process will receive
those signals immediately, before returning to the code that was
interrupted.
</p>
<hr size="6">
<a name="Checking-for-Pending-Signals"></a>
<a name="SEC515"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC514" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC516" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC471" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC509" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="libc_25.html#SEC525" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="libc.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="libc_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="libc_42.html#SEC712" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="libc_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h3 class="subsection"> 24.7.6 Checking for Pending Signals </h3>

<p>You can find out which signals are pending at any time by calling
<code>sigpending</code>.  This function is declared in &lsquo;<tt>signal.h</tt>&rsquo;.
<a name="IDX2525"></a>
</p>
<dl>
<dt><u>Function:</u> int <b>sigpending</b><i> (sigset_t *<var>set</var>)</i>
<a name="IDX2526"></a>
</dt>
<dd><p>The <code>sigpending</code> function stores information about pending signals
in <var>set</var>.  If there is a pending signal that is blocked from
delivery, then that signal is a member of the returned set.  (You can
test whether a particular signal is a member of this set using
<code>sigismember</code>; see <a href="#SEC511">Signal Sets</a>.)
</p>
<p>The return value is <code>0</code> if successful, and <code>-1</code> on failure.
</p></dd></dl>

<p>Testing whether a signal is pending is not often useful.  Testing when
that signal is not blocked is almost certainly bad design.
</p>
<p>Here is an example.
</p>
<table><tr><td>&nbsp;</td><td><pre class="smallexample">#include &lt;signal.h&gt;
#include &lt;stddef.h&gt;

sigset_t base_mask, waiting_mask;

sigemptyset (&amp;base_mask);
sigaddset (&amp;base_mask, SIGINT);
sigaddset (&amp;base_mask, SIGTSTP);

/* <span class="roman">Block user interrupts while doing other processing.</span> */
sigprocmask (SIG_SETMASK, &amp;base_mask, NULL);
&hellip;

/* <span class="roman">After a while, check to see whether any signals are pending.</span> */
sigpending (&amp;waiting_mask);
if (sigismember (&amp;waiting_mask, SIGINT)) {
  /* <span class="roman">User has tried to kill the process.</span> */
}
else if (sigismember (&amp;waiting_mask, SIGTSTP)) {
  /* <span class="roman">User has tried to stop the process.</span> */
}
</pre></td></tr></table>

<p>Remember that if there is a particular signal pending for your process,
additional signals of that same type that arrive in the meantime might
be discarded.  For example, if a <code>SIGINT</code> signal is pending when
another <code>SIGINT</code> signal arrives, your program will probably only
see one of them when you unblock this signal.
</p>
<p><strong>Portability Note:</strong> The <code>sigpending</code> function is new in
POSIX.1.  Older systems have no equivalent facility.
</p>
<hr size="6">
<a name="Remembering-a-Signal"></a>
<a name="SEC516"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC515" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC517" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC471" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC509" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="libc_25.html#SEC525" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="libc.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="libc_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="libc_42.html#SEC712" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="libc_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h3 class="subsection"> 24.7.7 Remembering a Signal to Act On Later </h3>

<p>Instead of blocking a signal using the library facilities, you can get
almost the same results by making the handler set a flag to be tested
later, when you &ldquo;unblock&rdquo;.  Here is an example:
</p>
<table><tr><td>&nbsp;</td><td><pre class="smallexample">/* <span class="roman">If this flag is nonzero, don't handle the signal right away.</span> */
volatile sig_atomic_t signal_pending;

/* <span class="roman">This is nonzero if a signal arrived and was not handled.</span> */
volatile sig_atomic_t defer_signal;

void
handler (int signum)
{
  if (defer_signal)
    signal_pending = signum;
  else
    &hellip; /* <span class="roman">``Really'' handle the signal.</span> */
}

&hellip;

void
update_mumble (int frob)
{
  /* <span class="roman">Prevent signals from having immediate effect.</span> */
  defer_signal++;
  /* <span class="roman">Now update <code>mumble</code>, without worrying about interruption.</span> */
  mumble.a = 1;
  mumble.b = hack ();
  mumble.c = frob;
  /* <span class="roman">We have updated <code>mumble</code>.  Handle any signal that came in.</span> */
  defer_signal--;
  if (defer_signal == 0 &amp;&amp; signal_pending != 0)
    raise (signal_pending);
}
</pre></td></tr></table>

<p>Note how the particular signal that arrives is stored in
<code>signal_pending</code>.  That way, we can handle several types of
inconvenient signals with the same mechanism.
</p>
<p>We increment and decrement <code>defer_signal</code> so that nested critical
sections will work properly; thus, if <code>update_mumble</code> were called
with <code>signal_pending</code> already nonzero, signals would be deferred
not only within <code>update_mumble</code>, but also within the caller.  This
is also why we do not check <code>signal_pending</code> if <code>defer_signal</code>
is still nonzero.
</p>
<p>The incrementing and decrementing of <code>defer_signal</code> each require more
than one instruction; it is possible for a signal to happen in the
middle.  But that does not cause any problem.  If the signal happens
early enough to see the value from before the increment or decrement,
that is equivalent to a signal which came before the beginning of the
increment or decrement, which is a case that works properly.
</p>
<p>It is absolutely vital to decrement <code>defer_signal</code> before testing
<code>signal_pending</code>, because this avoids a subtle bug.  If we did
these things in the other order, like this,
</p>
<table><tr><td>&nbsp;</td><td><pre class="smallexample">  if (defer_signal == 1 &amp;&amp; signal_pending != 0)
    raise (signal_pending);
  defer_signal--;
</pre></td></tr></table>

<p>then a signal arriving in between the <code>if</code> statement and the decrement
would be effectively &ldquo;lost&rdquo; for an indefinite amount of time.  The
handler would merely set <code>defer_signal</code>, but the program having
already tested this variable, it would not test the variable again.
</p>
<a name="IDX2527"></a>
<p>Bugs like these are called <em>timing errors</em>.  They are especially bad
because they happen only rarely and are nearly impossible to reproduce.
You can't expect to find them with a debugger as you would find a
reproducible bug.  So it is worth being especially careful to avoid
them.
</p>
<p>(You would not be tempted to write the code in this order, given the use
of <code>defer_signal</code> as a counter which must be tested along with
<code>signal_pending</code>.  After all, testing for zero is cleaner than
testing for one.  But if you did not use <code>defer_signal</code> as a
counter, and gave it values of zero and one only, then either order
might seem equally simple.  This is a further advantage of using a
counter for <code>defer_signal</code>: it will reduce the chance you will
write the code in the wrong order and create a subtle bug.)
</p>
<hr size="6">
<a name="Waiting-for-a-Signal"></a>
<a name="SEC517"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC516" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC518" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC471" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC471" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="libc_25.html#SEC525" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="libc.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="libc_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="libc_42.html#SEC712" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="libc_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="section"> 24.8 Waiting for a Signal </h2>

<p>If your program is driven by external events, or uses signals for
synchronization, then when it has nothing to do it should probably wait
until a signal arrives.
</p>
<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top"><a href="#SEC518">24.8.1 Using <code>pause</code></a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                 The simple way, using <code>pause</code>.
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC519">24.8.2 Problems with <code>pause</code></a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">              Why the simple way is often not very good.
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC520">24.8.3 Using <code>sigsuspend</code></a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                  Reliably waiting for a specific signal.
</td></tr>
</table>

<hr size="6">
<a name="Using-Pause"></a>
<a name="SEC518"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC517" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC519" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC471" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC517" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="libc_25.html#SEC525" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="libc.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="libc_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="libc_42.html#SEC712" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="libc_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h3 class="subsection"> 24.8.1 Using <code>pause</code> </h3>

<p>The simple way to wait until a signal arrives is to call <code>pause</code>.
Please read about its disadvantages, in the following section, before
you use it.
</p>
<dl>
<dt><u>Function:</u> int <b>pause</b><i> ()</i>
<a name="IDX2528"></a>
</dt>
<dd><p>The <code>pause</code> function suspends program execution until a signal
arrives whose action is either to execute a handler function, or to
terminate the process.
</p>
<p>If the signal causes a handler function to be executed, then
<code>pause</code> returns.  This is considered an unsuccessful return (since
&ldquo;successful&rdquo; behavior would be to suspend the program forever), so the
return value is <code>-1</code>.  Even if you specify that other primitives
should resume when a system handler returns (see section <a href="#SEC503">Primitives Interrupted by Signals</a>), this has no effect on <code>pause</code>; it always fails when a
signal is handled.
</p>
<p>The following <code>errno</code> error conditions are defined for this function:
</p>
<dl compact="compact">
<dt> <code>EINTR</code></dt>
<dd><p>The function was interrupted by delivery of a signal.
</p></dd>
</dl>

<p>If the signal causes program termination, <code>pause</code> doesn't return
(obviously).
</p>
<p>This function is a cancellation point in multithreaded programs.  This
is a problem if the thread allocates some resources (like memory, file
descriptors, semaphores or whatever) at the time <code>pause</code> is
called.  If the thread gets cancelled these resources stay allocated
until the program ends.  To avoid this calls to <code>pause</code> should be
protected using cancellation handlers.
</p>
<p>The <code>pause</code> function is declared in  &lsquo;<tt>unistd.h</tt>&rsquo;.
</p></dd></dl>

<hr size="6">
<a name="Pause-Problems"></a>
<a name="SEC519"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC518" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC520" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC471" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC517" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="libc_25.html#SEC525" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="libc.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="libc_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="libc_42.html#SEC712" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="libc_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h3 class="subsection"> 24.8.2 Problems with <code>pause</code> </h3>

<p>The simplicity of <code>pause</code> can conceal serious timing errors that
can make a program hang mysteriously.
</p>
<p>It is safe to use <code>pause</code> if the real work of your program is done
by the signal handlers themselves, and the &ldquo;main program&rdquo; does nothing
but call <code>pause</code>.  Each time a signal is delivered, the handler
will do the next batch of work that is to be done, and then return, so
that the main loop of the program can call <code>pause</code> again.
</p>
<p>You can't safely use <code>pause</code> to wait until one more signal arrives,
and then resume real work.  Even if you arrange for the signal handler
to cooperate by setting a flag, you still can't use <code>pause</code>
reliably.  Here is an example of this problem:
</p>
<table><tr><td>&nbsp;</td><td><pre class="smallexample">/* <span class="roman"><code>usr_interrupt</code> is set by the signal handler.</span>  */
if (!usr_interrupt)
  pause ();

/* <span class="roman">Do work once the signal arrives.</span>  */
&hellip;
</pre></td></tr></table>

<p>This has a bug: the signal could arrive after the variable
<code>usr_interrupt</code> is checked, but before the call to <code>pause</code>.
If no further signals arrive, the process would never wake up again.
</p>
<p>You can put an upper limit on the excess waiting by using <code>sleep</code>
in a loop, instead of using <code>pause</code>.  (See section <a href="libc_21.html#SEC448">Sleeping</a>, for more
about <code>sleep</code>.)  Here is what this looks like:
</p>
<table><tr><td>&nbsp;</td><td><pre class="smallexample">/* <span class="roman"><code>usr_interrupt</code> is set by the signal handler.</span>
while (!usr_interrupt)
  sleep (1);

/* <span class="roman">Do work once the signal arrives.</span>  */
&hellip;
</pre></td></tr></table>

<p>For some purposes, that is good enough.  But with a little more
complexity, you can wait reliably until a particular signal handler is
run, using <code>sigsuspend</code>.
</p>
<hr size="6">
<a name="Sigsuspend"></a>
<a name="SEC520"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC519" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC521" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC471" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC517" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="libc_25.html#SEC525" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="libc.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="libc_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="libc_42.html#SEC712" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="libc_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h3 class="subsection"> 24.8.3 Using <code>sigsuspend</code> </h3>

<p>The clean and reliable way to wait for a signal to arrive is to block it
and then use <code>sigsuspend</code>.  By using <code>sigsuspend</code> in a loop,
you can wait for certain kinds of signals, while letting other kinds of
signals be handled by their handlers.
</p>
<dl>
<dt><u>Function:</u> int <b>sigsuspend</b><i> (const sigset_t *<var>set</var>)</i>
<a name="IDX2529"></a>
</dt>
<dd><p>This function replaces the process's signal mask with <var>set</var> and then
suspends the process until a signal is delivered whose action is either
to terminate the process or invoke a signal handling function.  In other
words, the program is effectively suspended until one of the signals that
is not a member of <var>set</var> arrives.
</p>
<p>If the process is woken up by delivery of a signal that invokes a handler
function, and the handler function returns, then <code>sigsuspend</code> also
returns.
</p>
<p>The mask remains <var>set</var> only as long as <code>sigsuspend</code> is waiting.
The function <code>sigsuspend</code> always restores the previous signal mask
when it returns.
</p>
<p>The return value and error conditions are the same as for <code>pause</code>.
</p></dd></dl>

<p>With <code>sigsuspend</code>, you can replace the <code>pause</code> or <code>sleep</code>
loop in the previous section with something completely reliable:
</p>
<table><tr><td>&nbsp;</td><td><pre class="smallexample">sigset_t mask, oldmask;

&hellip;

/* <span class="roman">Set up the mask of signals to temporarily block.</span> */
sigemptyset (&amp;mask);
sigaddset (&amp;mask, SIGUSR1);

&hellip;

/* <span class="roman">Wait for a signal to arrive.</span> */
sigprocmask (SIG_BLOCK, &amp;mask, &amp;oldmask);
while (!usr_interrupt)
  sigsuspend (&amp;oldmask);
sigprocmask (SIG_UNBLOCK, &amp;mask, NULL);
</pre></td></tr></table>

<p>This last piece of code is a little tricky.  The key point to remember
here is that when <code>sigsuspend</code> returns, it resets the process's
signal mask to the original value, the value from before the call to
<code>sigsuspend</code>&mdash;in this case, the <code>SIGUSR1</code> signal is once
again blocked.  The second call to <code>sigprocmask</code> is
necessary to explicitly unblock this signal.
</p>
<p>One other point: you may be wondering why the <code>while</code> loop is
necessary at all, since the program is apparently only waiting for one
<code>SIGUSR1</code> signal.  The answer is that the mask passed to
<code>sigsuspend</code> permits the process to be woken up by the delivery of
other kinds of signals, as well&mdash;for example, job control signals.  If
the process is woken up by a signal that doesn't set
<code>usr_interrupt</code>, it just suspends itself again until the &ldquo;right&rdquo;
kind of signal eventually arrives.
</p>
<p>This technique takes a few more lines of preparation, but that is needed
just once for each kind of wait criterion you want to use.  The code
that actually waits is just four lines.
</p>
<hr size="6">
<a name="Signal-Stack"></a>
<a name="SEC521"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC520" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC522" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC471" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC471" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="libc_25.html#SEC525" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="libc.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="libc_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="libc_42.html#SEC712" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="libc_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="section"> 24.9 Using a Separate Signal Stack </h2>

<p>A signal stack is a special area of memory to be used as the execution
stack during signal handlers.  It should be fairly large, to avoid any
danger that it will overflow in turn; the macro <code>SIGSTKSZ</code> is
defined to a canonical size for signal stacks.  You can use
<code>malloc</code> to allocate the space for the stack.  Then call
<code>sigaltstack</code> or <code>sigstack</code> to tell the system to use that
space for the signal stack.
</p>
<p>You don't need to write signal handlers differently in order to use a
signal stack.  Switching from one stack to the other happens
automatically.  (Some non-GNU debuggers on some machines may get
confused if you examine a stack trace while a handler that uses the
signal stack is running.)
</p>
<p>There are two interfaces for telling the system to use a separate signal
stack.  <code>sigstack</code> is the older interface, which comes from 4.2
BSD.  <code>sigaltstack</code> is the newer interface, and comes from 4.4
BSD.  The <code>sigaltstack</code> interface has the advantage that it does
not require your program to know which direction the stack grows, which
depends on the specific machine and operating system.
</p>
<dl>
<dt><u>Data Type:</u> <b>stack_t</b>
<a name="IDX2530"></a>
</dt>
<dd><p>This structure describes a signal stack.  It contains the following members:
</p>
<dl compact="compact">
<dt> <code>void *ss_sp</code></dt>
<dd><p>This points to the base of the signal stack.
</p>
</dd>
<dt> <code>size_t ss_size</code></dt>
<dd><p>This is the size (in bytes) of the signal stack which &lsquo;<samp>ss_sp</samp>&rsquo; points to.
You should set this to however much space you allocated for the stack.
</p>
<p>There are two macros defined in &lsquo;<tt>signal.h</tt>&rsquo; that you should use in
calculating this size:
</p>
<dl compact="compact">
<dt> <code>SIGSTKSZ</code>
<a name="IDX2531"></a>
</dt>
<dd><p>This is the canonical size for a signal stack.  It is judged to be
sufficient for normal uses.
</p>
</dd>
<dt> <code>MINSIGSTKSZ</code>
<a name="IDX2532"></a>
</dt>
<dd><p>This is the amount of signal stack space the operating system needs just
to implement signal delivery.  The size of a signal stack <strong>must</strong>
be greater than this.
</p>
<p>For most cases, just using <code>SIGSTKSZ</code> for <code>ss_size</code> is
sufficient.  But if you know how much stack space your program's signal
handlers will need, you may want to use a different size.  In this case,
you should allocate <code>MINSIGSTKSZ</code> additional bytes for the signal
stack and increase <code>ss_size</code> accordingly.
</p></dd>
</dl>

</dd>
<dt> <code>int ss_flags</code></dt>
<dd><p>This field contains the bitwise <small>OR</small> of these flags:
</p>
<dl compact="compact">
<dt> <code>SS_DISABLE</code>
<a name="IDX2533"></a>
</dt>
<dd><p>This tells the system that it should not use the signal stack.
</p>
</dd>
<dt> <code>SS_ONSTACK</code>
<a name="IDX2534"></a>
</dt>
<dd><p>This is set by the system, and indicates that the signal stack is
currently in use.  If this bit is not set, then signals will be
delivered on the normal user stack.
</p></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl>
<dt><u>Function:</u> int <b>sigaltstack</b><i> (const stack_t *restrict <var>stack</var>, stack_t *restrict <var>oldstack</var>)</i>
<a name="IDX2535"></a>
</dt>
<dd><p>The <code>sigaltstack</code> function specifies an alternate stack for use
during signal handling.  When a signal is received by the process and
its action indicates that the signal stack is used, the system arranges
a switch to the currently installed signal stack while the handler for
that signal is executed.
</p>
<p>If <var>oldstack</var> is not a null pointer, information about the currently
installed signal stack is returned in the location it points to.  If
<var>stack</var> is not a null pointer, then this is installed as the new
stack for use by signal handlers.
</p>
<p>The return value is <code>0</code> on success and <code>-1</code> on failure.  If
<code>sigaltstack</code> fails, it sets <code>errno</code> to one of these values:
</p>
<dl compact="compact">
<dt> <code>EINVAL</code></dt>
<dd><p>You tried to disable a stack that was in fact currently in use.
</p>
</dd>
<dt> <code>ENOMEM</code></dt>
<dd><p>The size of the alternate stack was too small.
It must be greater than <code>MINSIGSTKSZ</code>.
</p></dd>
</dl>
</dd></dl>

<p>Here is the older <code>sigstack</code> interface.  You should use
<code>sigaltstack</code> instead on systems that have it.
</p>
<dl>
<dt><u>Data Type:</u> <b>struct sigstack</b>
<a name="IDX2536"></a>
</dt>
<dd><p>This structure describes a signal stack.  It contains the following members:
</p>
<dl compact="compact">
<dt> <code>void *ss_sp</code></dt>
<dd><p>This is the stack pointer.  If the stack grows downwards on your
machine, this should point to the top of the area you allocated.  If the
stack grows upwards, it should point to the bottom.
</p>
</dd>
<dt> <code>int ss_onstack</code></dt>
<dd><p>This field is true if the process is currently using this stack.
</p></dd>
</dl>
</dd></dl>

<dl>
<dt><u>Function:</u> int <b>sigstack</b><i> (const struct sigstack *<var>stack</var>, struct sigstack *<var>oldstack</var>)</i>
<a name="IDX2537"></a>
</dt>
<dd><p>The <code>sigstack</code> function specifies an alternate stack for use during
signal handling.  When a signal is received by the process and its
action indicates that the signal stack is used, the system arranges a
switch to the currently installed signal stack while the handler for
that signal is executed.
</p>
<p>If <var>oldstack</var> is not a null pointer, information about the currently
installed signal stack is returned in the location it points to.  If
<var>stack</var> is not a null pointer, then this is installed as the new
stack for use by signal handlers.
</p>
<p>The return value is <code>0</code> on success and <code>-1</code> on failure.
</p></dd></dl>

<hr size="6">
<a name="BSD-Signal-Handling"></a>
<a name="SEC522"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC521" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC523" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC471" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC471" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="libc_25.html#SEC525" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="libc.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="libc_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="libc_42.html#SEC712" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="libc_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="section"> 24.10 BSD Signal Handling </h2>

<p>This section describes alternative signal handling functions derived
from BSD Unix.  These facilities were an advance, in their time; today,
they are mostly obsolete, and supported mainly for compatibility with
BSD Unix.
</p>
<p>There are many similarities between the BSD and POSIX signal handling
facilities, because the POSIX facilities were inspired by the BSD
facilities.  Besides having different names for all the functions to
avoid conflicts, the main differences between the two are:
</p>
<ul>
<li>
BSD Unix represents signal masks as an <code>int</code> bit mask, rather than
as a <code>sigset_t</code> object.

</li><li>
The BSD facilities use a different default for whether an interrupted
primitive should fail or resume.  The POSIX facilities make system
calls fail unless you specify that they should resume.  With the BSD
facility, the default is to make system calls resume unless you say they
should fail.  See section <a href="#SEC503">Primitives Interrupted by Signals</a>.
</li></ul>

<p>The BSD facilities are declared in &lsquo;<tt>signal.h</tt>&rsquo;.
<a name="IDX2538"></a>
</p>
<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top"><a href="#SEC523">24.10.1 BSD Function to Establish a Handler</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top"></td></tr>
<tr><td align="left" valign="top"><a href="#SEC524">24.10.2 BSD Functions for Blocking Signals</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top"></td></tr>
</table>

<hr size="6">
<a name="BSD-Handler"></a>
<a name="SEC523"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC522" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC524" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC471" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC522" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="libc_25.html#SEC525" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="libc.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="libc_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="libc_42.html#SEC712" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="libc_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h3 class="subsection"> 24.10.1 BSD Function to Establish a Handler </h3>

<dl>
<dt><u>Data Type:</u> <b>struct sigvec</b>
<a name="IDX2539"></a>
</dt>
<dd><p>This data type is the BSD equivalent of <code>struct sigaction</code>
(see section <a href="#SEC487">Advanced Signal Handling</a>); it is used to specify signal actions
to the <code>sigvec</code> function.  It contains the following members:
</p>
<dl compact="compact">
<dt> <code>sighandler_t sv_handler</code></dt>
<dd><p>This is the handler function.
</p>
</dd>
<dt> <code>int sv_mask</code></dt>
<dd><p>This is the mask of additional signals to be blocked while the handler
function is being called.
</p>
</dd>
<dt> <code>int sv_flags</code></dt>
<dd><p>This is a bit mask used to specify various flags which affect the
behavior of the signal.  You can also refer to this field as
<code>sv_onstack</code>.
</p></dd>
</dl>
</dd></dl>

<p>These symbolic constants can be used to provide values for the
<code>sv_flags</code> field of a <code>sigvec</code> structure.  This field is a bit
mask value, so you bitwise-OR the flags of interest to you together.
</p>
<dl>
<dt><u>Macro:</u> int <b>SV_ONSTACK</b>
<a name="IDX2540"></a>
</dt>
<dd><p>If this bit is set in the <code>sv_flags</code> field of a <code>sigvec</code>
structure, it means to use the signal stack when delivering the signal.
</p></dd></dl>

<dl>
<dt><u>Macro:</u> int <b>SV_INTERRUPT</b>
<a name="IDX2541"></a>
</dt>
<dd><p>If this bit is set in the <code>sv_flags</code> field of a <code>sigvec</code>
structure, it means that system calls interrupted by this kind of signal
should not be restarted if the handler returns; instead, the system
calls should return with a <code>EINTR</code> error status.  See section <a href="#SEC503">Primitives Interrupted by Signals</a>.
</p></dd></dl>

<dl>
<dt><u>Macro:</u> int <b>SV_RESETHAND</b>
<a name="IDX2542"></a>
</dt>
<dd><p>If this bit is set in the <code>sv_flags</code> field of a <code>sigvec</code>
structure, it means to reset the action for the signal back to
<code>SIG_DFL</code> when the signal is received.
</p></dd></dl>

<dl>
<dt><u>Function:</u> int <b>sigvec</b><i> (int <var>signum</var>, const struct sigvec *<var>action</var>,struct sigvec *<var>old-action</var>)</i>
<a name="IDX2543"></a>
</dt>
<dd><p>This function is the equivalent of <code>sigaction</code> (see section <a href="#SEC487">Advanced Signal Handling</a>); it installs the action <var>action</var> for the signal <var>signum</var>,
returning information about the previous action in effect for that signal
in <var>old-action</var>.
</p></dd></dl>

<dl>
<dt><u>Function:</u> int <b>siginterrupt</b><i> (int <var>signum</var>, int <var>failflag</var>)</i>
<a name="IDX2544"></a>
</dt>
<dd><p>This function specifies which approach to use when certain primitives
are interrupted by handling signal <var>signum</var>.  If <var>failflag</var> is
false, signal <var>signum</var> restarts primitives.  If <var>failflag</var> is
true, handling <var>signum</var> causes these primitives to fail with error
code <code>EINTR</code>.  See section <a href="#SEC503">Primitives Interrupted by Signals</a>.
</p></dd></dl>

<hr size="6">
<a name="Blocking-in-BSD"></a>
<a name="SEC524"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC523" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="libc_25.html#SEC525" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC471" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC522" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="libc_25.html#SEC525" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="libc.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="libc_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="libc_42.html#SEC712" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="libc_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h3 class="subsection"> 24.10.2 BSD Functions for Blocking Signals </h3>

<dl>
<dt><u>Macro:</u> int <b>sigmask</b><i> (int <var>signum</var>)</i>
<a name="IDX2545"></a>
</dt>
<dd><p>This macro returns a signal mask that has the bit for signal <var>signum</var>
set.  You can bitwise-OR the results of several calls to <code>sigmask</code>
together to specify more than one signal.  For example,
</p>
<table><tr><td>&nbsp;</td><td><pre class="smallexample">(sigmask (SIGTSTP) | sigmask (SIGSTOP)
 | sigmask (SIGTTIN) | sigmask (SIGTTOU))
</pre></td></tr></table>

<p>specifies a mask that includes all the job-control stop signals.
</p></dd></dl>

<dl>
<dt><u>Function:</u> int <b>sigblock</b><i> (int <var>mask</var>)</i>
<a name="IDX2546"></a>
</dt>
<dd><p>This function is equivalent to <code>sigprocmask</code> (see section <a href="#SEC512">Process Signal Mask</a>) with a <var>how</var> argument of <code>SIG_BLOCK</code>: it adds the
signals specified by <var>mask</var> to the calling process's set of blocked
signals.  The return value is the previous set of blocked signals.
</p></dd></dl>

<dl>
<dt><u>Function:</u> int <b>sigsetmask</b><i> (int <var>mask</var>)</i>
<a name="IDX2547"></a>
</dt>
<dd><p>This function equivalent to <code>sigprocmask</code> (see section <a href="#SEC512">Process Signal Mask</a>) with a <var>how</var> argument of <code>SIG_SETMASK</code>: it sets
the calling process's signal mask to <var>mask</var>.  The return value is
the previous set of blocked signals.
</p></dd></dl>

<dl>
<dt><u>Function:</u> int <b>sigpause</b><i> (int <var>mask</var>)</i>
<a name="IDX2548"></a>
</dt>
<dd><p>This function is the equivalent of <code>sigsuspend</code> (see section <a href="#SEC517">Waiting for a Signal</a>):  it sets the calling process's signal mask to <var>mask</var>,
and waits for a signal to arrive.  On return the previous set of blocked
signals is restored.
</p></dd></dl>
<hr size="6">
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC471" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="libc_25.html#SEC525" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="libc.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="libc_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="libc_42.html#SEC712" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="libc_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<p>
 <font size="-1">
  This document was generated by <em>root</em> on <em>February, 26 2009</em> using <a href="http://www.nongnu.org/texi2html/"><em>texi2html 1.78</em></a>.
 </font>
 <br>

</p>
</body>
</html>
