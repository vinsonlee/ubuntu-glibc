<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html401/loose.dtd">
<html>
<!-- This file documents the GNU C library.

This is Edition 0.12, last updated 2007-10-27,
of The GNU C Library Reference Manual, for version 2.8.

Copyright (C) 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2001, 2002,
2003, 2007, 2008 Free Software Foundation, Inc.

Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.2 or
any later version published by the Free Software Foundation; with the
Invariant Sections being "Free Software Needs Free Documentation"
and "GNU Lesser General Public License", the Front-Cover texts being
"A GNU Manual", and with the Back-Cover Texts as in (a) below.  A
copy of the license is included in the section entitled "GNU Free
Documentation License".

(a) The FSF's Back-Cover Text is: "You have the freedom to
copy and modify this GNU manual.  Buying copies from the FSF
supports it in developing GNU and promoting software freedom."
 -->
<!-- Created on February, 26 2009 by texi2html 1.78 -->
<!--
Written by: Lionel Cons <Lionel.Cons@cern.ch> (original author)
            Karl Berry  <karl@freefriends.org>
            Olaf Bachmann <obachman@mathematik.uni-kl.de>
            and many others.
Maintained by: Many creative people.
Send bugs and suggestions to <texi2html-bug@nongnu.org>

-->
<head>
<title>The GNU C Library: 30. System Management</title>

<meta name="description" content="The GNU C Library: 30. System Management">
<meta name="keywords" content="The GNU C Library: 30. System Management">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="texi2html 1.78">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
<!--
a.summary-letter {text-decoration: none}
pre.display {font-family: serif}
pre.format {font-family: serif}
pre.menu-comment {font-family: serif}
pre.menu-preformatted {font-family: serif}
pre.smalldisplay {font-family: serif; font-size: smaller}
pre.smallexample {font-size: smaller}
pre.smallformat {font-family: serif; font-size: smaller}
pre.smalllisp {font-size: smaller}
span.roman {font-family:serif; font-weight:normal;}
span.sansserif {font-family:sans-serif; font-weight:normal;}
ul.toc {list-style: none}
-->
</style>


</head>

<body lang="en" bgcolor="#FFFFFF" text="#000000" link="#0000FF" vlink="#800080" alink="#FF0000">

<a name="System-Management"></a>
<a name="SEC638"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="libc_29.html#SEC637" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC639" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="libc_29.html#SEC608" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="libc.html#SEC_Top" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="libc_31.html#SEC648" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="libc.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="libc_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="libc_42.html#SEC712" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="libc_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h1 class="chapter"> 30. System Management </h1>

<p>This chapter describes facilities for controlling the system that
underlies a process (including the operating system and hardware) and
for getting information about it.  Anyone can generally use the
informational facilities, but usually only a properly privileged process
can make changes.
</p>

<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top"><a href="#SEC639">30.1 Host Identification</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">         Determining the name of the machine.
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC640">30.2 Platform Type Identification</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">               Determining operating system and basic
                                  machine type
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC641">30.3 Controlling and Querying Mounts</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">         Controlling/querying mounts
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC647">30.4 System Parameters</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">           Getting and setting various system parameters
</td></tr>
</table>

<p>To get information on parameters of the system that are built into the
system, such as the maximum length of a filename, <a href="libc_31.html#SEC648">System Configuration Parameters</a>.
</p>
<hr size="6">
<a name="Host-Identification"></a>
<a name="SEC639"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC638" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC640" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC638" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC638" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="libc_31.html#SEC648" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="libc.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="libc_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="libc_42.html#SEC712" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="libc_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="section"> 30.1 Host Identification </h2>

<p>This section explains how to identify the particular system on which your
program is running.  First, let's review the various ways computer systems
are named, which is a little complicated because of the history of the
development of the Internet.
</p>
<p>Every Unix system (also known as a host) has a host name, whether it's
connected to a network or not.  In its simplest form, as used before
computer networks were an issue, it's just a word like &lsquo;<samp>chicken</samp>&rsquo;.
<a name="IDX2890"></a>
</p>
<p>But any system attached to the Internet or any network like it conforms
to a more rigorous naming convention as part of the Domain Name System
(DNS).  In DNS, every host name is composed of two parts:
<a name="IDX2891"></a>
<a name="IDX2892"></a>
</p>
<ol>
<li>
hostname
<a name="IDX2893"></a>
</li><li>
domain name
<a name="IDX2894"></a>
</li></ol>

<p>You will note that &ldquo;hostname&rdquo; looks a lot like &ldquo;host name&rdquo;, but is
not the same thing, and that people often incorrectly refer to entire
host names as &ldquo;domain names.&rdquo;
</p>
<p>In DNS, the full host name is properly called the FQDN (Fully Qualified
Domain Name) and consists of the hostname, then a period, then the
domain name.  The domain name itself usually has multiple components
separated by periods.  So for example, a system's hostname may be
&lsquo;<samp>chicken</samp>&rsquo; and its domain name might be &lsquo;<samp>ai.mit.edu</samp>&rsquo;, so
its FQDN (which is its host name) is &lsquo;<samp>chicken.ai.mit.edu</samp>&rsquo;.
<a name="IDX2895"></a>
</p>
<p>Adding to the confusion, though, is that DNS is not the only name space
in which a computer needs to be known.  Another name space is the
NIS (aka YP) name space.  For NIS purposes, there is another domain
name, which is called the NIS domain name or the YP domain name.  It
need not have anything to do with the DNS domain name.
<a name="IDX2896"></a>
<a name="IDX2897"></a>
<a name="IDX2898"></a>
<a name="IDX2899"></a>
</p>
<p>Confusing things even more is the fact that in DNS, it is possible for
multiple FQDNs to refer to the same system.  However, there is always
exactly one of them that is the true host name, and it is called the
canonical FQDN.
</p>
<p>In some contexts, the host name is called a &ldquo;node name.&rdquo;
</p>
<p>For more information on DNS host naming, see <a href="libc_16.html#SEC322">Host Names</a>.
</p>
<a name="IDX2900"></a>
<a name="IDX2901"></a>
<a name="IDX2902"></a>
<p>Prototypes for these functions appear in &lsquo;<tt>unistd.h</tt>&rsquo;.
</p>
<p>The programs <code>hostname</code>, <code>hostid</code>, and <code>domainname</code> work
by calling these functions.
</p>
<dl>
<dt><u>Function:</u> int <b>gethostname</b><i> (char *<var>name</var>, size_t <var>size</var>)</i>
<a name="IDX2903"></a>
</dt>
<dd><p>This function returns the host name of the system on which it is called,
in the array <var>name</var>.  The <var>size</var> argument specifies the size of
this array, in bytes.  Note that this is <em>not</em> the DNS hostname.
If the system participates in DNS, this is the FQDN (see above).
</p>
<p>The return value is <code>0</code> on success and <code>-1</code> on failure.  In
the GNU C library, <code>gethostname</code> fails if <var>size</var> is not large
enough; then you can try again with a larger array.  The following
<code>errno</code> error condition is defined for this function:
</p>
<dl compact="compact">
<dt> <code>ENAMETOOLONG</code></dt>
<dd><p>The <var>size</var> argument is less than the size of the host name plus one.
</p></dd>
</dl>

<a name="IDX2904"></a>
<p>On some systems, there is a symbol for the maximum possible host name
length: <code>MAXHOSTNAMELEN</code>.  It is defined in &lsquo;<tt>sys/param.h</tt>&rsquo;.
But you can't count on this to exist, so it is cleaner to handle
failure and try again.
</p>
<p><code>gethostname</code> stores the beginning of the host name in <var>name</var>
even if the host name won't entirely fit.  For some purposes, a
truncated host name is good enough.  If it is, you can ignore the
error code.
</p></dd></dl>

<dl>
<dt><u>Function:</u> int <b>sethostname</b><i> (const char *<var>name</var>, size_t <var>length</var>)</i>
<a name="IDX2905"></a>
</dt>
<dd><p>The <code>sethostname</code> function sets the host name of the system that
calls it to <var>name</var>, a string with length <var>length</var>.  Only
privileged processes are permitted to do this.
</p>
<p>Usually <code>sethostname</code> gets called just once, at system boot time.
Often, the program that calls it sets it to the value it finds in the
file <code>/etc/hostname</code>.
<a name="IDX2906"></a>
</p>
<p>Be sure to set the host name to the full host name, not just the DNS
hostname (see above).
</p>
<p>The return value is <code>0</code> on success and <code>-1</code> on failure.
The following <code>errno</code> error condition is defined for this function:
</p>
<dl compact="compact">
<dt> <code>EPERM</code></dt>
<dd><p>This process cannot set the host name because it is not privileged.
</p></dd>
</dl>
</dd></dl>

<dl>
<dt><u>Function:</u> int <b>getdomainnname</b><i> (char *<var>name</var>, size_t <var>length</var>)</i>
<a name="IDX2907"></a>
</dt>
<dd><a name="IDX2908"></a>
<a name="IDX2909"></a>

<p><code>getdomainname</code> returns the NIS (aka YP) domain name of the system
on which it is called.  Note that this is not the more popular DNS
domain name.  Get that with <code>gethostname</code>.
</p>
<p>The specifics of this function are analogous to <code>gethostname</code>, above.
</p>
</dd></dl>

<dl>
<dt><u>Function:</u> int <b>setdomainname</b><i> (const char *<var>name</var>, size_t <var>length</var>)</i>
<a name="IDX2910"></a>
</dt>
<dd><a name="IDX2911"></a>
<a name="IDX2912"></a>

<p><code>getdomainname</code> sets the NIS (aka YP) domain name of the system
on which it is called.  Note that this is not the more popular DNS
domain name.  Set that with <code>sethostname</code>.
</p>
<p>The specifics of this function are analogous to <code>sethostname</code>, above.
</p>
</dd></dl>

<dl>
<dt><u>Function:</u> long int <b>gethostid</b><i> (void)</i>
<a name="IDX2913"></a>
</dt>
<dd><p>This function returns the &ldquo;host ID&rdquo; of the machine the program is
running on.  By convention, this is usually the primary Internet IP address
of that machine, converted to a <code>long int</code>.  However, on some
systems it is a meaningless but unique number which is hard-coded for
each machine.
</p>
<p>This is not widely used.  It arose in BSD 4.2, but was dropped in BSD 4.4.
It is not required by POSIX.
</p>
<p>The proper way to query the IP address is to use <code>gethostbyname</code>
on the results of <code>gethostname</code>.  For more information on IP addresses,
See section <a href="libc_16.html#SEC316">Host Addresses</a>.
</p></dd></dl>

<dl>
<dt><u>Function:</u> int <b>sethostid</b><i> (long int <var>id</var>)</i>
<a name="IDX2914"></a>
</dt>
<dd><p>The <code>sethostid</code> function sets the &ldquo;host ID&rdquo; of the host machine
to <var>id</var>.  Only privileged processes are permitted to do this.  Usually
it happens just once, at system boot time.
</p>
<p>The proper way to establish the primary IP address of a system
is to configure the IP address resolver to associate that IP address with
the system's host name as returned by <code>gethostname</code>.  For example,
put a record for the system in &lsquo;<tt>/etc/hosts</tt>&rsquo;.
</p>
<p>See <code>gethostid</code> above for more information on host ids.
</p>
<p>The return value is <code>0</code> on success and <code>-1</code> on failure.
The following <code>errno</code> error conditions are defined for this function:
</p>
<dl compact="compact">
<dt> <code>EPERM</code></dt>
<dd><p>This process cannot set the host name because it is not privileged.
</p>
</dd>
<dt> <code>ENOSYS</code></dt>
<dd><p>The operating system does not support setting the host ID.  On some
systems, the host ID is a meaningless but unique number hard-coded for
each machine.
</p></dd>
</dl>
</dd></dl>

<hr size="6">
<a name="Platform-Type"></a>
<a name="SEC640"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC639" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC641" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC638" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC638" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="libc_31.html#SEC648" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="libc.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="libc_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="libc_42.html#SEC712" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="libc_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="section"> 30.2 Platform Type Identification </h2>

<p>You can use the <code>uname</code> function to find out some information about
the type of computer your program is running on.  This function and the
associated data type are declared in the header file
&lsquo;<tt>sys/utsname.h</tt>&rsquo;.
<a name="IDX2915"></a>
</p>
<p>As a bonus, <code>uname</code> also gives some information identifying the
particular system your program is running on.  This is the same information
which you can get with functions targetted to this purpose described in
<a href="#SEC639">Host Identification</a>.
</p>

<dl>
<dt><u>Data Type:</u> <b>struct utsname</b>
<a name="IDX2916"></a>
</dt>
<dd><p>The <code>utsname</code> structure is used to hold information returned
by the <code>uname</code> function.  It has the following members:
</p>
<dl compact="compact">
<dt> <code>char sysname[]</code></dt>
<dd><p>This is the name of the operating system in use.
</p>
</dd>
<dt> <code>char release[]</code></dt>
<dd><p>This is the current release level of the operating system implementation.
</p>
</dd>
<dt> <code>char version[]</code></dt>
<dd><p>This is the current version level within the release of the operating
system.
</p>
</dd>
<dt> <code>char machine[]</code></dt>
<dd><p>This is a description of the type of hardware that is in use.
</p>
<p>Some systems provide a mechanism to interrogate the kernel directly for
this information.  On systems without such a mechanism, the GNU C
library fills in this field based on the configuration name that was
specified when building and installing the library.
</p>
<p>GNU uses a three-part name to describe a system configuration; the three
parts are <var>cpu</var>, <var>manufacturer</var> and <var>system-type</var>, and they
are separated with dashes.  Any possible combination of three names is
potentially meaningful, but most such combinations are meaningless in
practice and even the meaningful ones are not necessarily supported by
any particular GNU program.
</p>
<p>Since the value in <code>machine</code> is supposed to describe just the
hardware, it consists of the first two parts of the configuration name:
&lsquo;<samp><var>cpu</var>-<var>manufacturer</var></samp>&rsquo;.  For example, it might be one of these:
</p>
<blockquote><p><code>&quot;sparc-sun&quot;</code>,
<code>&quot;i386-<var>anything</var>&quot;</code>,
<code>&quot;m68k-hp&quot;</code>,
<code>&quot;m68k-sony&quot;</code>,
<code>&quot;m68k-sun&quot;</code>,
<code>&quot;mips-dec&quot;</code>
</p></blockquote>

</dd>
<dt> <code>char nodename[]</code></dt>
<dd><p>This is the host name of this particular computer.  In the GNU C
library, the value is the same as that returned by <code>gethostname</code>;
see <a href="#SEC639">Host Identification</a>.
</p>
<p>&nbsp;gethostname() is implemented with a call to uname().
</p>
</dd>
<dt> <code>char domainname[]</code></dt>
<dd><p>This is the NIS or YP domain name.  It is the same value returned by
<code>getdomainname</code>; see <a href="#SEC639">Host Identification</a>.  This element
is a relatively recent invention and use of it is not as portable as
use of the rest of the structure.
</p>

</dd>
</dl>
</dd></dl>

<dl>
<dt><u>Function:</u> int <b>uname</b><i> (struct utsname *<var>info</var>)</i>
<a name="IDX2917"></a>
</dt>
<dd><p>The <code>uname</code> function fills in the structure pointed to by
<var>info</var> with information about the operating system and host machine.
A non-negative value indicates that the data was successfully stored.
</p>
<p><code>-1</code> as the value indicates an error.  The only error possible is
<code>EFAULT</code>, which we normally don't mention as it is always a
possibility.
</p></dd></dl>


<hr size="6">
<a name="Filesystem-Handling"></a>
<a name="SEC641"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC640" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC642" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC638" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC638" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="libc_31.html#SEC648" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="libc.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="libc_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="libc_42.html#SEC712" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="libc_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="section"> 30.3 Controlling and Querying Mounts </h2>

<p>All files are in filesystems, and before you can access any file, its
filesystem must be mounted.  Because of Unix's concept of
<em>Everything is a file</em>, mounting of filesystems is central to doing
almost anything.  This section explains how to find out what filesystems
are currently mounted and what filesystems are available for mounting,
and how to change what is mounted.
</p>
<p>The classic filesystem is the contents of a disk drive.  The concept is
considerably more abstract, though, and lots of things other than disk
drives can be mounted.
</p>
<p>Some block devices don't correspond to traditional devices like disk
drives.  For example, a loop device is a block device whose driver uses
a regular file in another filesystem as its medium.  So if that regular
file contains appropriate data for a filesystem, you can by mounting the
loop device essentially mount a regular file.
</p>
<p>Some filesystems aren't based on a device of any kind.  The &ldquo;proc&rdquo;
filesystem, for example, contains files whose data is made up by the
filesystem driver on the fly whenever you ask for it.  And when you
write to it, the data you write causes changes in the system.  No data
gets stored.
</p>

<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top"><a href="#SEC642">30.3.1 Mount Information</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">           What is or could be mounted?
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC646">30.3.2 Mount, Unmount, Remount</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">       Controlling what is mounted and how
</td></tr>
</table>

<hr size="6">
<a name="Mount-Information"></a>
<a name="SEC642"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC641" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC643" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC638" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC641" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="libc_31.html#SEC648" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="libc.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="libc_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="libc_42.html#SEC712" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="libc_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h3 class="subsection"> 30.3.1 Mount Information </h3>

<p>For some programs it is desirable and necessary to access information
about whether a certain filesystem is mounted and, if it is, where, or
simply to get lists of all the available filesystems.  The GNU libc
provides some functions to retrieve this information portably.
</p>
<p>Traditionally Unix systems have a file named &lsquo;<tt>/etc/fstab</tt>&rsquo; which
describes all possibly mounted filesystems.  The <code>mount</code> program
uses this file to mount at startup time of the system all the
necessary filesystems.  The information about all the filesystems
actually mounted is normally kept in a file named either
&lsquo;<tt>/var/run/mtab</tt>&rsquo; or &lsquo;<tt>/etc/mtab</tt>&rsquo;.  Both files share the same
syntax and it is crucial that this syntax is followed all the time.
Therefore it is best to never directly write the files.  The functions
described in this section can do this and they also provide the
functionality to convert the external textual representation to the
internal representation.
</p>
<p>Note that the &lsquo;<tt>fstab</tt>&rsquo; and &lsquo;<tt>mtab</tt>&rsquo; files are maintained on a
system by <em>convention</em>.  It is possible for the files not to exist
or not to be consistent with what is really mounted or available to
mount, if the system's administration policy allows it.  But programs
that mount and unmount filesystems typically maintain and use these
files as described herein.
</p>
<a name="IDX2918"></a>
<a name="IDX2919"></a>
<a name="IDX2920"></a>
<a name="IDX2921"></a>
<a name="IDX2922"></a>
<a name="IDX2923"></a>
<p>The filenames given above should never be used directly.  The portable
way to handle these file is to use the macro <code>_PATH_FSTAB</code>,
defined in &lsquo;<tt>fstab.h</tt>&rsquo;, or <code>_PATH_MNTTAB</code>, defined in
&lsquo;<tt>mntent.h</tt>&rsquo; and &lsquo;<tt>paths.h</tt>&rsquo;, for &lsquo;<tt>fstab</tt>&rsquo;; and the macro
<code>_PATH_MOUNTED</code>, also defined in &lsquo;<tt>mntent.h</tt>&rsquo; and
&lsquo;<tt>paths.h</tt>&rsquo;, for &lsquo;<tt>mtab</tt>&rsquo;.  There are also two alternate macro
names <code>FSTAB</code>, <code>MNTTAB</code>, and <code>MOUNTED</code> defined but
these names are deprecated and kept only for backward compatibility.
The names <code>_PATH_MNTTAB</code> and <code>_PATH_MOUNTED</code> should always be used.
</p>
<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top"><a href="#SEC643">30.3.1.1 The &lsquo;<tt>fstab</tt>&rsquo; file</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top"></td></tr>
<tr><td align="left" valign="top"><a href="#SEC644">30.3.1.2 The &lsquo;<tt>mtab</tt>&rsquo; file</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top"></td></tr>
<tr><td align="left" valign="top"><a href="#SEC645">30.3.1.3 Other (Non-libc) Sources of Mount Information</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">     Other (non-libc) sources of mount information
</td></tr>
</table>

<hr size="6">
<a name="fstab"></a>
<a name="SEC643"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC642" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC644" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC638" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC642" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="libc_31.html#SEC648" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="libc.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="libc_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="libc_42.html#SEC712" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="libc_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h4 class="subsubsection"> 30.3.1.1 The &lsquo;<tt>fstab</tt>&rsquo; file </h4>

<p>The internal representation for entries of the file is <code>struct
fstab</code>, defined in &lsquo;<tt>fstab.h</tt>&rsquo;.
</p>
<dl>
<dt><u>Data Type:</u> <b>struct fstab</b>
<a name="IDX2924"></a>
</dt>
<dd><p>This structure is used with the <code>getfsent</code>, <code>getfsspec</code>, and
<code>getfsfile</code> functions.
</p>
<dl compact="compact">
<dt> <code>char *fs_spec</code></dt>
<dd><p>This element describes the device from which the filesystem is mounted.
Normally this is the name of a special device, such as a hard disk
partition, but it could also be a more or less generic string.  For
<em>NFS</em> it would be a hostname and directory name combination.
</p>
<p>Even though the element is not declared <code>const</code> it shouldn't be
modified.  The missing <code>const</code> has historic reasons, since this
function predates ISO C.  The same is true for the other string
elements of this structure.
</p>
</dd>
<dt> <code>char *fs_file</code></dt>
<dd><p>This describes the mount point on the local system.  I.e., accessing any
file in this filesystem has implicitly or explicitly this string as a
prefix.
</p>
</dd>
<dt> <code>char *fs_vfstype</code></dt>
<dd><p>This is the type of the filesystem.  Depending on what the underlying
kernel understands it can be any string.
</p>
</dd>
<dt> <code>char *fs_mntops</code></dt>
<dd><p>This is a string containing options passed to the kernel with the
<code>mount</code> call.  Again, this can be almost anything.  There can be
more than one option, separated from the others by a comma.  Each option
consists of a name and an optional value part, introduced by an <code>=</code>
character.
</p>
<p>If the value of this element must be processed it should ideally be done
using the <code>getsubopt</code> function; see <a href="libc_25.html#SEC556">Parsing of Suboptions</a>.
</p>
</dd>
<dt> <code>const char *fs_type</code></dt>
<dd><p>This name is poorly chosen.  This element points to a string (possibly
in the <code>fs_mntops</code> string) which describes the modes with which the
filesystem is mounted.  &lsquo;<tt>fstab</tt>&rsquo; defines five macros to describe the
possible values:
</p>
<dl compact="compact">
<dt> <code>FSTAB_RW</code>
<a name="IDX2925"></a>
</dt>
<dd><p>The filesystems gets mounted with read and write enabled.
</p></dd>
<dt> <code>FSTAB_RQ</code>
<a name="IDX2926"></a>
</dt>
<dd><p>The filesystems gets mounted with read and write enabled.  Write access
is restricted by quotas.
</p></dd>
<dt> <code>FSTAB_RO</code>
<a name="IDX2927"></a>
</dt>
<dd><p>The filesystem gets mounted read-only.
</p></dd>
<dt> <code>FSTAB_SW</code>
<a name="IDX2928"></a>
</dt>
<dd><p>This is not a real filesystem, it is a swap device.
</p></dd>
<dt> <code>FSTAB_XX</code>
<a name="IDX2929"></a>
</dt>
<dd><p>This entry from the &lsquo;<tt>fstab</tt>&rsquo; file is totally ignored.
</p></dd>
</dl>

<p>Testing for equality with these value must happen using <code>strcmp</code>
since these are all strings.  Comparing the pointer will probably always
fail.
</p>
</dd>
<dt> <code>int fs_freq</code></dt>
<dd><p>This element describes the dump frequency in days.
</p>
</dd>
<dt> <code>int fs_passno</code></dt>
<dd><p>This element describes the pass number on parallel dumps.  It is closely
related to the <code>dump</code> utility used on Unix systems.
</p></dd>
</dl>
</dd></dl>


<p>To read the entire content of the of the &lsquo;<tt>fstab</tt>&rsquo; file the GNU libc
contains a set of three functions which are designed in the usual way.
</p>
<dl>
<dt><u>Function:</u> int <b>setfsent</b><i> (void)</i>
<a name="IDX2930"></a>
</dt>
<dd><p>This function makes sure that the internal read pointer for the
&lsquo;<tt>fstab</tt>&rsquo; file is at the beginning of the file.  This is done by
either opening the file or resetting the read pointer.
</p>
<p>Since the file handle is internal to the libc this function is not
thread-safe.
</p>
<p>This function returns a non-zero value if the operation was successful
and the <code>getfs*</code> functions can be used to read the entries of the
file.
</p></dd></dl>

<dl>
<dt><u>Function:</u> void <b>endfsent</b><i> (void)</i>
<a name="IDX2931"></a>
</dt>
<dd><p>This function makes sure that all resources acquired by a prior call to
<code>setfsent</code> (explicitly or implicitly by calling <code>getfsent</code>) are
freed.
</p></dd></dl>

<dl>
<dt><u>Function:</u> struct fstab * <b>getfsent</b><i> (void)</i>
<a name="IDX2932"></a>
</dt>
<dd><p>This function returns the next entry of the &lsquo;<tt>fstab</tt>&rsquo; file.  If this
is the first call to any of the functions handling &lsquo;<tt>fstab</tt>&rsquo; since
program start or the last call of <code>endfsent</code>, the file will be
opened.
</p>
<p>The function returns a pointer to a variable of type <code>struct
fstab</code>.  This variable is shared by all threads and therefore this
function is not thread-safe.  If an error occurred <code>getfsent</code>
returns a <code>NULL</code> pointer.
</p></dd></dl>

<dl>
<dt><u>Function:</u> struct fstab * <b>getfsspec</b><i> (const char *<var>name</var>)</i>
<a name="IDX2933"></a>
</dt>
<dd><p>This function returns the next entry of the &lsquo;<tt>fstab</tt>&rsquo; file which has
a string equal to <var>name</var> pointed to by the <code>fs_spec</code> element.
Since there is normally exactly one entry for each special device it
makes no sense to call this function more than once for the same
argument.  If this is the first call to any of the functions handling
&lsquo;<tt>fstab</tt>&rsquo; since program start or the last call of <code>endfsent</code>,
the file will be opened.
</p>
<p>The function returns a pointer to a variable of type <code>struct
fstab</code>.  This variable is shared by all threads and therefore this
function is not thread-safe.  If an error occurred <code>getfsent</code>
returns a <code>NULL</code> pointer.
</p></dd></dl>

<dl>
<dt><u>Function:</u> struct fstab * <b>getfsfile</b><i> (const char *<var>name</var>)</i>
<a name="IDX2934"></a>
</dt>
<dd><p>This function returns the next entry of the &lsquo;<tt>fstab</tt>&rsquo; file which has
a string equal to <var>name</var> pointed to by the <code>fs_file</code> element.
Since there is normally exactly one entry for each mount point it
makes no sense to call this function more than once for the same
argument.  If this is the first call to any of the functions handling
&lsquo;<tt>fstab</tt>&rsquo; since program start or the last call of <code>endfsent</code>,
the file will be opened.
</p>
<p>The function returns a pointer to a variable of type <code>struct
fstab</code>.  This variable is shared by all threads and therefore this
function is not thread-safe.  If an error occurred <code>getfsent</code>
returns a <code>NULL</code> pointer.
</p></dd></dl>


<hr size="6">
<a name="mtab"></a>
<a name="SEC644"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC643" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC645" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC638" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC642" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="libc_31.html#SEC648" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="libc.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="libc_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="libc_42.html#SEC712" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="libc_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h4 class="subsubsection"> 30.3.1.2 The &lsquo;<tt>mtab</tt>&rsquo; file </h4>
<p>The following functions and data structure access the &lsquo;<tt>mtab</tt>&rsquo; file.
</p>
<dl>
<dt><u>Data Type:</u> <b>struct mntent</b>
<a name="IDX2935"></a>
</dt>
<dd><p>This structure is used with the <code>getmntent</code>, <code>getmntent_t</code>,
<code>addmntent</code>, and <code>hasmntopt</code> functions.
</p>
<dl compact="compact">
<dt> <code>char *mnt_fsname</code></dt>
<dd><p>This element contains a pointer to a string describing the name of the
special device from which the filesystem is mounted.  It corresponds to
the <code>fs_spec</code> element in <code>struct fstab</code>.
</p>
</dd>
<dt> <code>char *mnt_dir</code></dt>
<dd><p>This element points to a string describing the mount point of the
filesystem.  It corresponds to the <code>fs_file</code> element in
<code>struct fstab</code>.
</p>
</dd>
<dt> <code>char *mnt_type</code></dt>
<dd><p><code>mnt_type</code> describes the filesystem type and is therefore
equivalent to <code>fs_vfstype</code> in <code>struct fstab</code>.  &lsquo;<tt>mntent.h</tt>&rsquo;
defines a few symbolic names for some of the values this string can have.
But since the kernel can support arbitrary filesystems it does not
make much sense to give them symbolic names.  If one knows the symbol
name one also knows the filesystem name.  Nevertheless here follows the
list of the symbols provided in &lsquo;<tt>mntent.h</tt>&rsquo;.
</p>
<dl compact="compact">
<dt> <code>MNTTYPE_IGNORE</code>
<a name="IDX2936"></a>
</dt>
<dd><p>This symbol expands to <code>&quot;ignore&quot;</code>.  The value is sometime used in
&lsquo;<tt>fstab</tt>&rsquo; files to make sure entries are not used without removing them.
</p></dd>
<dt> <code>MNTTYPE_NFS</code>
<a name="IDX2937"></a>
</dt>
<dd><p>Expands to <code>&quot;nfs&quot;</code>.  Using this macro sometimes could make sense
since it names the default NFS implementation, in case both version 2
and 3 are supported.
</p></dd>
<dt> <code>MNTTYPE_SWAP</code>
<a name="IDX2938"></a>
</dt>
<dd><p>This symbol expands to <code>&quot;swap&quot;</code>.  It names the special &lsquo;<tt>fstab</tt>&rsquo;
entry which names one of the possibly multiple swap partitions.
</p></dd>
</dl>

</dd>
<dt> <code>char *mnt_opts</code></dt>
<dd><p>The element contains a string describing the options used while mounting
the filesystem.  As for the equivalent element <code>fs_mntops</code> of
<code>struct fstab</code> it is best to use the function <code>getsubopt</code>
(see section <a href="libc_25.html#SEC556">Parsing of Suboptions</a>) to access the parts of this string.
</p>
<p>The &lsquo;<tt>mntent.h</tt>&rsquo; file defines a number of macros with string values
which correspond to some of the options understood by the kernel.  There
might be many more options which are possible so it doesn't make much sense
to rely on these macros but to be consistent here is the list:
</p>
<dl compact="compact">
<dt> <code>MNTOPT_DEFAULTS</code>
<a name="IDX2939"></a>
</dt>
<dd><p>Expands to <code>&quot;defaults&quot;</code>.  This option should be used alone since it
indicates all values for the customizable values are chosen to be the
default.
</p></dd>
<dt> <code>MNTOPT_RO</code>
<a name="IDX2940"></a>
</dt>
<dd><p>Expands to <code>&quot;ro&quot;</code>.  See the <code>FSTAB_RO</code> value, it means the
filesystem is mounted read-only.
</p></dd>
<dt> <code>MNTOPT_RW</code>
<a name="IDX2941"></a>
</dt>
<dd><p>Expand to <code>&quot;rw&quot;</code>.  See the <code>FSTAB_RW</code> value, it means the
filesystem is mounted with read and write permissions.
</p></dd>
<dt> <code>MNTOPT_SUID</code>
<a name="IDX2942"></a>
</dt>
<dd><p>Expands to <code>&quot;suid&quot;</code>.  This means that the SUID bit (see section <a href="libc_29.html#SEC612">How an Application Can Change Persona</a>) is respected when a program from the filesystem is
started.
</p></dd>
<dt> <code>MNTOPT_NOSUID</code>
<a name="IDX2943"></a>
</dt>
<dd><p>Expands to <code>&quot;nosuid&quot;</code>.  This is the opposite of <code>MNTOPT_SUID</code>,
the SUID bit for all files from the filesystem is ignored.
</p></dd>
<dt> <code>MNTOPT_NOAUTO</code>
<a name="IDX2944"></a>
</dt>
<dd><p>Expands to <code>&quot;noauto&quot;</code>.  At startup time the <code>mount</code> program
will ignore this entry if it is started with the <code>-a</code> option to
mount all filesystems mentioned in the &lsquo;<tt>fstab</tt>&rsquo; file.
</p></dd>
</dl>

<p>As for the <code>FSTAB_*</code> entries introduced above it is important to
use <code>strcmp</code> to check for equality.
</p>
</dd>
<dt> <code>mnt_freq</code></dt>
<dd><p>This elements corresponds to <code>fs_freq</code> and also specifies the
frequency in days in which dumps are made.
</p>
</dd>
<dt> <code>mnt_passno</code></dt>
<dd><p>This element is equivalent to <code>fs_passno</code> with the same meaning
which is uninteresting for all programs beside <code>dump</code>.
</p></dd>
</dl>
</dd></dl>

<p>For accessing the &lsquo;<tt>mtab</tt>&rsquo; file there is again a set of three
functions to access all entries in a row.  Unlike the functions to
handle &lsquo;<tt>fstab</tt>&rsquo; these functions do not access a fixed file and there
is even a thread safe variant of the get function.  Beside this the GNU
libc contains functions to alter the file and test for specific options.
</p>
<dl>
<dt><u>Function:</u> FILE * <b>setmntent</b><i> (const char *<var>file</var>, const char *<var>mode</var>)</i>
<a name="IDX2945"></a>
</dt>
<dd><p>The <code>setmntent</code> function prepares the file named <var>FILE</var> which
must be in the format of a &lsquo;<tt>fstab</tt>&rsquo; and &lsquo;<tt>mtab</tt>&rsquo; file for the
upcoming processing through the other functions of the family.  The
<var>mode</var> parameter can be chosen in the way the <var>opentype</var>
parameter for <code>fopen</code> (see section <a href="libc_12.html#SEC180">Opening Streams</a>) can be chosen.  If
the file is opened for writing the file is also allowed to be empty.
</p>
<p>If the file was successfully opened <code>setmntent</code> returns a file
descriptor for future use.  Otherwise the return value is <code>NULL</code>
and <code>errno</code> is set accordingly.
</p></dd></dl>

<dl>
<dt><u>Function:</u> int <b>endmntent</b><i> (FILE *<var>stream</var>)</i>
<a name="IDX2946"></a>
</dt>
<dd><p>This function takes for the <var>stream</var> parameter a file handle which
previously was returned from the <code>setmntent</code> call.
<code>endmntent</code> closes the stream and frees all resources.
</p>
<p>The return value is <em>1</em> unless an error occurred in which case it
is <em>0</em>.
</p></dd></dl>

<dl>
<dt><u>Function:</u> struct mntent * <b>getmntent</b><i> (FILE *<var>stream</var>)</i>
<a name="IDX2947"></a>
</dt>
<dd><p>The <code>getmntent</code> function takes as the parameter a file handle
previously returned by successful call to <code>setmntent</code>.  It returns
a pointer to a static variable of type <code>struct mntent</code> which is
filled with the information from the next entry from the file currently
read.
</p>
<p>The file format used prescribes the use of spaces or tab characters to
separate the fields.  This makes it harder to use name containing one
of these characters (e.g., mount points using spaces).  Therefore
these characters are encoded in the files and the <code>getmntent</code>
function takes care of the decoding while reading the entries back in.
<code>'\040'</code> is used to encode a space character, <code>'\011'</code> to
encode a tab character, <code>'\012'</code> to encode a newline character,
and <code>'\\'</code> to encode a backslash.
</p>
<p>If there was an error or the end of the file is reached the return value
is <code>NULL</code>.
</p>
<p>This function is not thread-safe since all calls to this function return
a pointer to the same static variable.  <code>getmntent_r</code> should be
used in situations where multiple threads access the file.
</p></dd></dl>

<dl>
<dt><u>Function:</u> struct mntent * <b>getmntent_r</b><i> (FILE *<var>stream</var>, struct mentent *<var>result</var>, char *<var>buffer</var>, int <var>bufsize</var>)</i>
<a name="IDX2948"></a>
</dt>
<dd><p>The <code>getmntent_r</code> function is the reentrant variant of
<code>getmntent</code>.  It also returns the next entry from the file and
returns a pointer.  The actual variable the values are stored in is not
static, though.  Instead the function stores the values in the variable
pointed to by the <var>result</var> parameter.  Additional information (e.g.,
the strings pointed to by the elements of the result) are kept in the
buffer of size <var>bufsize</var> pointed to by <var>buffer</var>.
</p>
<p>Escaped characters (space, tab, backslash) are converted back in the
same way as it happens for <code>getmentent</code>.
</p>
<p>The function returns a <code>NULL</code> pointer in error cases.  Errors could be:
</p><ul>
<li>
error while reading the file,
</li><li>
end of file reached,
</li><li>
<var>bufsize</var> is too small for reading a complete new entry.
</li></ul>
</dd></dl>

<dl>
<dt><u>Function:</u> int <b>addmntent</b><i> (FILE *<var>stream</var>, const struct mntent *<var>mnt</var>)</i>
<a name="IDX2949"></a>
</dt>
<dd><p>The <code>addmntent</code> function allows adding a new entry to the file
previously opened with <code>setmntent</code>.  The new entries are always
appended.  I.e., even if the position of the file descriptor is not at
the end of the file this function does not overwrite an existing entry
following the current position.
</p>
<p>The implication of this is that to remove an entry from a file one has
to create a new file while leaving out the entry to be removed and after
closing the file remove the old one and rename the new file to the
chosen name.
</p>
<p>This function takes care of spaces and tab characters in the names to be
written to the file.  It converts them and the backslash character into
the format describe in the <code>getmntent</code> description above.
</p>
<p>This function returns <em>0</em> in case the operation was successful.
Otherwise the return value is <em>1</em> and <code>errno</code> is set
appropriately.
</p></dd></dl>

<dl>
<dt><u>Function:</u> char * <b>hasmntopt</b><i> (const struct mntent *<var>mnt</var>, const char *<var>opt</var>)</i>
<a name="IDX2950"></a>
</dt>
<dd><p>This function can be used to check whether the string pointed to by the
<code>mnt_opts</code> element of the variable pointed to by <var>mnt</var> contains
the option <var>opt</var>.  If this is true a pointer to the beginning of the
option in the <code>mnt_opts</code> element is returned.  If no such option
exists the function returns <code>NULL</code>.
</p>
<p>This function is useful to test whether a specific option is present but
when all options have to be processed one is better off with using the
<code>getsubopt</code> function to iterate over all options in the string.
</p></dd></dl>

<hr size="6">
<a name="Other-Mount-Information"></a>
<a name="SEC645"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC644" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC646" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC638" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC642" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="libc_31.html#SEC648" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="libc.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="libc_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="libc_42.html#SEC712" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="libc_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h4 class="subsubsection"> 30.3.1.3 Other (Non-libc) Sources of Mount Information </h4>

<p>On a system with a Linux kernel and the <code>proc</code> filesystem, you can
get information on currently mounted filesystems from the file
&lsquo;<tt>mounts</tt>&rsquo; in the <code>proc</code> filesystem.  Its format is similar to
that of the &lsquo;<tt>mtab</tt>&rsquo; file, but represents what is truly mounted
without relying on facilities outside the kernel to keep &lsquo;<tt>mtab</tt>&rsquo; up
to date.
</p>

<hr size="6">
<a name="Mount_002dUnmount_002dRemount"></a>
<a name="SEC646"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC645" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC647" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC638" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC641" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="libc_31.html#SEC648" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="libc.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="libc_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="libc_42.html#SEC712" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="libc_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h3 class="subsection"> 30.3.2 Mount, Unmount, Remount </h3>

<p>This section describes the functions for mounting, unmounting, and
remounting filesystems.
</p>
<p>Only the superuser can mount, unmount, or remount a filesystem.
</p>
<p>These functions do not access the &lsquo;<tt>fstab</tt>&rsquo; and &lsquo;<tt>mtab</tt>&rsquo; files.  You
should maintain and use these separately.  See section <a href="#SEC642">Mount Information</a>.
</p>
<p>The symbols in this section are declared in &lsquo;<tt>sys/mount.h</tt>&rsquo;.
</p>
<dl>
<dt><u>Function:</u> int <b>mount</b><i> (const char *<var>special_file</var>, const char *<var>dir</var>, const char *<var>fstype</var>, unsigned long int <var>options</var>, const void *<var>data</var>)</i>
<a name="IDX2951"></a>
</dt>
<dd><p><code>mount</code> mounts or remounts a filesystem.  The two operations are
quite different and are merged rather unnaturally into this one function.
The <code>MS_REMOUNT</code> option, explained below, determines whether
<code>mount</code> mounts or remounts.
</p>
<p>For a mount, the filesystem on the block device represented by the
device special file named <var>special_file</var> gets mounted over the mount
point <var>dir</var>.  This means that the directory <var>dir</var> (along with any
files in it) is no longer visible; in its place (and still with the name
<var>dir</var>) is the root directory of the filesystem on the device.
</p>
<p>As an exception, if the filesystem type (see below) is one which is not
based on a device (e.g. &ldquo;proc&rdquo;), <code>mount</code> instantiates a
filesystem and mounts it over <var>dir</var> and ignores <var>special_file</var>.
</p>
<p>For a remount, <var>dir</var> specifies the mount point where the filesystem
to be remounted is (and remains) mounted and <var>special_file</var> is
ignored.  Remounting a filesystem means changing the options that control
operations on the filesystem while it is mounted.  It does not mean
unmounting and mounting again.
</p>
<p>For a mount, you must identify the type of the filesystem as
<var>fstype</var>.  This type tells the kernel how to access the filesystem
and can be thought of as the name of a filesystem driver.  The
acceptable values are system dependent.  On a system with a Linux kernel
and the <code>proc</code> filesystem, the list of possible values is in the
file &lsquo;<tt>filesystems</tt>&rsquo; in the <code>proc</code> filesystem (e.g. type
<kbd>cat /proc/filesystems</kbd> to see the list).  With a Linux kernel, the
types of filesystems that <code>mount</code> can mount, and their type names,
depends on what filesystem drivers are configured into the kernel or
loaded as loadable kernel modules.  An example of a common value for
<var>fstype</var> is <code>ext2</code>.
</p>
<p>For a remount, <code>mount</code> ignores <var>fstype</var>.
</p>
<p><var>options</var> specifies a variety of options that apply until the
filesystem is unmounted or remounted.  The precise meaning of an option
depends on the filesystem and with some filesystems, an option may have
no effect at all.  Furthermore, for some filesystems, some of these
options (but never <code>MS_RDONLY</code>) can be overridden for individual
file accesses via <code>ioctl</code>.
</p>
<p><var>options</var> is a bit string with bit fields defined using the
following mask and masked value macros:
</p>
<dl compact="compact">
<dt> <code>MS_MGC_MASK</code></dt>
<dd><p>This multibit field contains a magic number.  If it does not have the value
<code>MS_MGC_VAL</code>, <code>mount</code> assumes all the following bits are zero and
the <var>data</var> argument is a null string, regardless of their actual values.
</p>
</dd>
<dt> <code>MS_REMOUNT</code></dt>
<dd><p>This bit on means to remount the filesystem.  Off means to mount it.
</p>
</dd>
<dt> <code>MS_RDONLY</code></dt>
<dd><p>This bit on specifies that no writing to the filesystem shall be allowed
while it is mounted.  This cannot be overridden by <code>ioctl</code>.  This
option is available on nearly all filesystems.
</p>
</dd>
<dt> <code>S_IMMUTABLE</code></dt>
<dd><p>This bit on specifies that no writing to the files in the filesystem
shall be allowed while it is mounted.  This can be overridden for a
particular file access by a properly privileged call to <code>ioctl</code>.
This option is a relatively new invention and is not available on many
filesystems.
</p>
</dd>
<dt> <code>S_APPEND</code></dt>
<dd><p>This bit on specifies that the only file writing that shall be allowed
while the filesystem is mounted is appending.  Some filesystems allow
this to be overridden for a particular process by a properly privileged
call to <code>ioctl</code>.  This is a relatively new invention and is not
available on many filesystems.
</p>
</dd>
<dt> <code>MS_NOSUID</code></dt>
<dd><p>This bit on specifies that Setuid and Setgid permissions on files in the
filesystem shall be ignored while it is mounted.
</p>
</dd>
<dt> <code>MS_NOEXEC</code></dt>
<dd><p>This bit on specifies that no files in the filesystem shall be executed
while the filesystem is mounted.
</p>
</dd>
<dt> <code>MS_NODEV</code></dt>
<dd><p>This bit on specifies that no device special files in the filesystem
shall be accessible while the filesystem is mounted.
</p>
</dd>
<dt> <code>MS_SYNCHRONOUS</code></dt>
<dd><p>This bit on specifies that all writes to the filesystem while it is
mounted shall be synchronous; i.e., data shall be synced before each
write completes rather than held in the buffer cache.
</p>
</dd>
<dt> <code>MS_MANDLOCK</code></dt>
<dd><p>This bit on specifies that mandatory locks on files shall be permitted while
the filesystem is mounted.
</p>
</dd>
<dt> <code>MS_NOATIME</code></dt>
<dd><p>This bit on specifies that access times of files shall not be updated when
the files are accessed while the filesystem is mounted.
</p>
</dd>
<dt> <code>MS_NODIRATIME</code></dt>
<dd><p>This bit on specifies that access times of directories shall not be updated
when the directories are accessed while the filesystem in mounted.
</p>

</dd>
</dl>

<p>Any bits not covered by the above masks should be set off; otherwise,
results are undefined.
</p>
<p>The meaning of <var>data</var> depends on the filesystem type and is controlled
entirely by the filesystem driver in the kernel.
</p>
<p>Example:
</p>
<table><tr><td>&nbsp;</td><td><pre class="smallexample">#include &lt;sys/mount.h&gt;

mount(&quot;/dev/hdb&quot;, &quot;/cdrom&quot;, MS_MGC_VAL | MS_RDONLY | MS_NOSUID, &quot;&quot;);

mount(&quot;/dev/hda2&quot;, &quot;/mnt&quot;, MS_MGC_VAL | MS_REMOUNT, &quot;&quot;);

</pre></td></tr></table>

<p>Appropriate arguments for <code>mount</code> are conventionally recorded in
the &lsquo;<tt>fstab</tt>&rsquo; table.  See section <a href="#SEC642">Mount Information</a>.
</p>
<p>The return value is zero if the mount or remount is successful.  Otherwise,
it is <code>-1</code> and <code>errno</code> is set appropriately.  The values of
<code>errno</code> are filesystem dependent, but here is a general list:
</p>
<dl compact="compact">
<dt> <code>EPERM</code></dt>
<dd><p>The process is not superuser.
</p></dd>
<dt> <code>ENODEV</code></dt>
<dd><p>The file system type <var>fstype</var> is not known to the kernel.
</p></dd>
<dt> <code>ENOTBLK</code></dt>
<dd><p>The file <var>dev</var> is not a block device special file.
</p></dd>
<dt> <code>EBUSY</code></dt>
<dd>
<ul>
<li>
The device is already mounted.

</li><li>
The mount point is busy.  (E.g. it is some process' working directory or
has a filesystem mounted on it already).

</li><li>
The request is to remount read-only, but there are files open for write.
</li></ul>

</dd>
<dt> <code>EINVAL</code></dt>
<dd><ul>
<li>
A remount was attempted, but there is no filesystem mounted over the
specified mount point.

</li><li>
The supposed filesystem has an invalid superblock.

</li></ul>

</dd>
<dt> <code>EACCES</code></dt>
<dd><ul>
<li>
The filesystem is inherently read-only (possibly due to a switch on the
device) and the process attempted to mount it read/write (by setting the
<code>MS_RDONLY</code> bit off).

</li><li>
<var>special_file</var> or <var>dir</var> is not accessible due to file permissions.

</li><li>
<var>special_file</var> is not accessible because it is in a filesystem that is
mounted with the <code>MS_NODEV</code> option.

</li></ul>

</dd>
<dt> <code>EM_FILE</code></dt>
<dd><p>The table of dummy devices is full.  <code>mount</code> needs to create a
dummy device (aka &ldquo;unnamed&rdquo; device) if the filesystem being mounted is
not one that uses a device.
</p>
</dd>
</dl>

</dd></dl>


<dl>
<dt><u>Function:</u> int <b>umount2</b><i> (const char *<var>file</var>, int <var>flags</var>)</i>
<a name="IDX2952"></a>
</dt>
<dd><p><code>umount2</code> unmounts a filesystem.
</p>
<p>You can identify the filesystem to unmount either by the device special
file that contains the filesystem or by the mount point.  The effect is
the same.  Specify either as the string <var>file</var>.
</p>
<p><var>flags</var> contains the one-bit field identified by the following
mask macro:
</p>
<dl compact="compact">
<dt> <code>MNT_FORCE</code></dt>
<dd><p>This bit on means to force the unmounting even if the filesystem is
busy, by making it unbusy first.  If the bit is off and the filesystem is
busy, <code>umount2</code> fails with <code>errno</code> = <code>EBUSY</code>.  Depending
on the filesystem, this may override all, some, or no busy conditions.
</p>
</dd>
</dl>

<p>All other bits in <var>flags</var> should be set to zero; otherwise, the result
is undefined.
</p>
<p>Example:
</p>
<table><tr><td>&nbsp;</td><td><pre class="smallexample">#include &lt;sys/mount.h&gt;

umount2(&quot;/mnt&quot;, MNT_FORCE);

umount2(&quot;/dev/hdd1&quot;, 0);

</pre></td></tr></table>

<p>After the filesystem is unmounted, the directory that was the mount point
is visible, as are any files in it.
</p>
<p>As part of unmounting, <code>umount2</code> syncs the filesystem.
</p>
<p>If the unmounting is successful, the return value is zero.  Otherwise, it
is <code>-1</code> and <code>errno</code> is set accordingly:
</p>
<dl compact="compact">
<dt> <code>EPERM</code></dt>
<dd><p>The process is not superuser.
</p></dd>
<dt> <code>EBUSY</code></dt>
<dd><p>The filesystem cannot be unmounted because it is busy.  E.g. it contains
a directory that is some process's working directory or a file that some
process has open.  With some filesystems in some cases, you can avoid
this failure with the <code>MNT_FORCE</code> option.
</p>
</dd>
<dt> <code>EINVAL</code></dt>
<dd><p><var>file</var> validly refers to a file, but that file is neither a mount
point nor a device special file of a currently mounted filesystem.
</p>
</dd>
</dl>

<p>This function is not available on all systems.
</p></dd></dl>

<dl>
<dt><u>Function:</u> int <b>umount</b><i> (const char *<var>file</var>)</i>
<a name="IDX2953"></a>
</dt>
<dd><p><code>umount</code> does the same thing as <code>umount2</code> with <var>flags</var> set
to zeroes.  It is more widely available than <code>umount2</code> but since it
lacks the possibility to forcefully unmount a filesystem is deprecated
when <code>umount2</code> is also available.
</p></dd></dl>



<hr size="6">
<a name="System-Parameters"></a>
<a name="SEC647"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC646" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="libc_31.html#SEC648" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC638" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC638" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="libc_31.html#SEC648" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="libc.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="libc_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="libc_42.html#SEC712" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="libc_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="section"> 30.4 System Parameters </h2>

<p>This section describes the <code>sysctl</code> function, which gets and sets
a variety of system parameters.
</p>
<p>The symbols used in this section are declared in the file &lsquo;<tt>sysctl.h</tt>&rsquo;.
</p>
<dl>
<dt><u>Function:</u> int <b>sysctl</b><i> (int *<var>names</var>, int <var>nlen</var>, void *<var>oldval</var>, size_t *<var>oldlenp</var>, void *<var>newval</var>, size_t <var>newlen</var>)</i>
<a name="IDX2954"></a>
</dt>
<dd><p><code>sysctl</code> gets or sets a specified system parameter.  There are so
many of these parameters that it is not practical to list them all here,
but here are some examples:
</p>
<ul>
<li> network domain name
</li><li> paging parameters
</li><li> network Address Resolution Protocol timeout time
</li><li> maximum number of files that may be open
</li><li> root filesystem device
</li><li> when kernel was built
</li></ul>

<p>The set of available parameters depends on the kernel configuration and
can change while the system is running, particularly when you load and
unload loadable kernel modules.
</p>
<p>The system parameters with which <code>syslog</code> is concerned are arranged
in a hierarchical structure like a hierarchical filesystem.  To identify
a particular parameter, you specify a path through the structure in a
way analogous to specifying the pathname of a file.  Each component of
the path is specified by an integer and each of these integers has a
macro defined for it by &lsquo;<tt>sysctl.h</tt>&rsquo;.  <var>names</var> is the path, in
the form of an array of integers.  Each component of the path is one
element of the array, in order.  <var>nlen</var> is the number of components
in the path.
</p>
<p>For example, the first component of the path for all the paging
parameters is the value <code>CTL_VM</code>.  For the free page thresholds, the
second component of the path is <code>VM_FREEPG</code>.  So to get the free
page threshold values, make <var>names</var> an array containing the two
elements <code>CTL_VM</code> and <code>VM_FREEPG</code> and make <var>nlen</var> = 2.
</p>

<p>The format of the value of a parameter depends on the parameter.
Sometimes it is an integer; sometimes it is an ASCII string; sometimes
it is an elaborate structure.  In the case of the free page thresholds
used in the example above, the parameter value is a structure containing
several integers.
</p>
<p>In any case, you identify a place to return the parameter's value with
<var>oldval</var> and specify the amount of storage available at that
location as *<var>oldlenp</var>.  *<var>oldlenp</var> does double duty because it
is also the output location that contains the actual length of the
returned value.
</p>
<p>If you don't want the parameter value returned, specify a null pointer
for <var>oldval</var>.
</p>
<p>To set the parameter, specify the address and length of the new value
as <var>newval</var> and <var>newlen</var>.  If you don't want to set the parameter,
specify a null pointer as <var>newval</var>.
</p>
<p>If you get and set a parameter in the same <code>sysctl</code> call, the value
returned is the value of the parameter before it was set.
</p>
<p>Each system parameter has a set of permissions similar to the
permissions for a file (including the permissions on directories in its
path) that determine whether you may get or set it.  For the purposes of
these permissions, every parameter is considered to be owned by the
superuser and Group 0 so processes with that effective uid or gid may
have more access to system parameters.  Unlike with files, the superuser
does not invariably have full permission to all system parameters, because
some of them are designed not to be changed ever.
</p>

<p><code>sysctl</code> returns a zero return value if it succeeds.  Otherwise, it
returns <code>-1</code> and sets <code>errno</code> appropriately.  Besides the
failures that apply to all system calls, the following are the
<code>errno</code> codes for all possible failures:
</p>
<dl compact="compact">
<dt> <code>EPERM</code></dt>
<dd><p>The process is not permitted to access one of the components of the
path of the system parameter or is not permitted to access the system parameter
itself in the way (read or write) that it requested.
</p></dd>
<dt> <code>ENOTDIR</code></dt>
<dd><p>There is no system parameter corresponding to <var>name</var>.
</p></dd>
<dt> <code>EFAULT</code></dt>
<dd><p><var>oldval</var> is not null, which means the process wanted to read the parameter,
but *<var>oldlenp</var> is zero, so there is no place to return it.
</p></dd>
<dt> <code>EINVAL</code></dt>
<dd><ul>
<li>
The process attempted to set a system parameter to a value that is not valid
for that parameter.
</li><li>
The space provided for the return of the system parameter is not the right
size for that parameter.
</li></ul>
</dd>
<dt> <code>ENOMEM</code></dt>
<dd><p>This value may be returned instead of the more correct <code>EINVAL</code> in some
cases where the space provided for the return of the system parameter is too
small.
</p>
</dd>
</dl>

</dd></dl>

<p>If you have a Linux kernel with the <code>proc</code> filesystem, you can get
and set most of the same parameters by reading and writing to files in
the <code>sys</code> directory of the <code>proc</code> filesystem.  In the <code>sys</code>
directory, the directory structure represents the hierarchical structure
of the parameters.  E.g. you can display the free page thresholds with
</p><table><tr><td>&nbsp;</td><td><pre class="smallexample">cat /proc/sys/vm/freepages
</pre></td></tr></table>

<p>Some more traditional and more widely available, though less general,
GNU C library functions for getting and setting some of the same system
parameters are:
</p>
<ul>
<li>
<code>getdomainname</code>, <code>setdomainname</code>
</li><li>
<code>gethostname</code>, <code>sethostname</code> (See section <a href="#SEC639">Host Identification</a>.)
</li><li>
<code>uname</code> (See section <a href="#SEC640">Platform Type Identification</a>.)
</li><li>
<code>bdflush</code>
</li></ul>
<hr size="6">
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC638" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="libc_31.html#SEC648" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="libc.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="libc_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="libc_42.html#SEC712" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="libc_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<p>
 <font size="-1">
  This document was generated by <em>root</em> on <em>February, 26 2009</em> using <a href="http://www.nongnu.org/texi2html/"><em>texi2html 1.78</em></a>.
 </font>
 <br>

</p>
</body>
</html>
