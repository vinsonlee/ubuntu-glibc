<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html401/loose.dtd">
<html>
<!-- This file documents the GNU C library.

This is Edition 0.12, last updated 2007-10-27,
of The GNU C Library Reference Manual, for version 2.8.

Copyright (C) 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2001, 2002,
2003, 2007, 2008 Free Software Foundation, Inc.

Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.2 or
any later version published by the Free Software Foundation; with the
Invariant Sections being "Free Software Needs Free Documentation"
and "GNU Lesser General Public License", the Front-Cover texts being
"A GNU Manual", and with the Back-Cover Texts as in (a) below.  A
copy of the license is included in the section entitled "GNU Free
Documentation License".

(a) The FSF's Back-Cover Text is: "You have the freedom to
copy and modify this GNU manual.  Buying copies from the FSF
supports it in developing GNU and promoting software freedom."
 -->
<!-- Created on April, 29 2009 by texi2html 1.78 -->
<!--
Written by: Lionel Cons <Lionel.Cons@cern.ch> (original author)
            Karl Berry  <karl@freefriends.org>
            Olaf Bachmann <obachman@mathematik.uni-kl.de>
            and many others.
Maintained by: Many creative people.
Send bugs and suggestions to <texi2html-bug@nongnu.org>

-->
<head>
<title>The GNU C Library: 27. Job Control</title>

<meta name="description" content="The GNU C Library: 27. Job Control">
<meta name="keywords" content="The GNU C Library: 27. Job Control">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="texi2html 1.78">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
<!--
a.summary-letter {text-decoration: none}
pre.display {font-family: serif}
pre.format {font-family: serif}
pre.menu-comment {font-family: serif}
pre.menu-preformatted {font-family: serif}
pre.smalldisplay {font-family: serif; font-size: smaller}
pre.smallexample {font-size: smaller}
pre.smallformat {font-family: serif; font-size: smaller}
pre.smalllisp {font-size: smaller}
span.roman {font-family:serif; font-weight:normal;}
span.sansserif {font-family:sans-serif; font-weight:normal;}
ul.toc {list-style: none}
-->
</style>


</head>

<body lang="en" bgcolor="#FFFFFF" text="#000000" link="#0000FF" vlink="#800080" alink="#FF0000">

<a name="Job-Control"></a>
<a name="SEC578"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="libc_26.html#SEC577" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC579" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="libc_26.html#SEC568" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="libc.html#SEC_Top" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="libc_28.html#SEC596" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="libc.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="libc_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="libc_42.html#SEC712" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="libc_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h1 class="chapter"> 27. Job Control </h1>

<p><em>Job control</em> refers to the protocol for allowing a user to move
between multiple <em>process groups</em> (or <em>jobs</em>) within a single
<em>login session</em>.  The job control facilities are set up so that
appropriate behavior for most programs happens automatically and they
need not do anything special about job control.  So you can probably
ignore the material in this chapter unless you are writing a shell or
login program.
</p>
<p>You need to be familiar with concepts relating to process creation
(see section <a href="libc_26.html#SEC570">Process Creation Concepts</a>) and signal handling (see section <a href="libc_24.html#SEC471">Signal Handling</a>) in order to understand this material presented in this
chapter.
</p>
<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top"><a href="#SEC579">27.1 Concepts of Job Control</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">     Jobs can be controlled by a shell.
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC580">27.2 Job Control is Optional</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">     Not all POSIX systems support job control.
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC581">27.3 Controlling Terminal of a Process</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">        How a process gets its controlling terminal.
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC582">27.4 Access to the Controlling Terminal</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">      How processes share the controlling terminal.
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC583">27.5 Orphaned Process Groups</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">     Jobs left after the user logs out.
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC584">27.6 Implementing a Job Control Shell</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">        What a shell must do to implement job control.
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC592">27.7 Functions for Job Control</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">   Functions to control process groups.
</td></tr>
</table>

<hr size="6">
<a name="Concepts-of-Job-Control"></a>
<a name="SEC579"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC578" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC580" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC578" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC578" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="libc_28.html#SEC596" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="libc.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="libc_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="libc_42.html#SEC712" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="libc_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="section"> 27.1 Concepts of Job Control </h2>

<p>The fundamental purpose of an interactive shell is to read
commands from the user's terminal and create processes to execute the
programs specified by those commands.  It can do this using the
<code>fork</code> (see section <a href="libc_26.html#SEC572">Creating a Process</a>) and <code>exec</code>
(see section <a href="libc_26.html#SEC573">Executing a File</a>) functions.
</p>
<p>A single command may run just one process&mdash;but often one command uses
several processes.  If you use the &lsquo;<samp>|</samp>&rsquo; operator in a shell command,
you explicitly request several programs in their own processes.  But
even if you run just one program, it can use multiple processes
internally.  For example, a single compilation command such as &lsquo;<samp>cc
-c foo.c</samp>&rsquo; typically uses four processes (though normally only two at any
given time).  If you run <code>make</code>, its job is to run other programs
in separate processes.
</p>
<p>The processes belonging to a single command are called a <em>process
group</em> or <em>job</em>.  This is so that you can operate on all of them at
once.  For example, typing <kbd>C-c</kbd> sends the signal <code>SIGINT</code> to
terminate all the processes in the foreground process group.
</p>
<a name="IDX2704"></a>
<p>A <em>session</em> is a larger group of processes.  Normally all the
processes that stem from a single login belong to the same session.
</p>
<p>Every process belongs to a process group.  When a process is created, it
becomes a member of the same process group and session as its parent
process.  You can put it in another process group using the
<code>setpgid</code> function, provided the process group belongs to the same
session.
</p>
<a name="IDX2705"></a>
<p>The only way to put a process in a different session is to make it the
initial process of a new session, or a <em>session leader</em>, using the
<code>setsid</code> function.  This also puts the session leader into a new
process group, and you can't move it out of that process group again.
</p>
<p>Usually, new sessions are created by the system login program, and the
session leader is the process running the user's login shell.
</p>
<a name="IDX2706"></a>
<p>A shell that supports job control must arrange to control which job can
use the terminal at any time.  Otherwise there might be multiple jobs
trying to read from the terminal at once, and confusion about which
process should receive the input typed by the user.  To prevent this,
the shell must cooperate with the terminal driver using the protocol
described in this chapter.
</p>
<a name="IDX2707"></a>
<a name="IDX2708"></a>
<p>The shell can give unlimited access to the controlling terminal to only
one process group at a time.  This is called the <em>foreground job</em> on
that controlling terminal.  Other process groups managed by the shell
that are executing without such access to the terminal are called
<em>background jobs</em>.
</p>
<a name="IDX2709"></a>
<p>If a background job needs to read from its controlling
terminal, it is <em>stopped</em> by the terminal driver; if the
<code>TOSTOP</code> mode is set, likewise for writing.  The user can stop
a foreground job by typing the SUSP character (see section <a href="libc_17.html#SEC370">Special Characters</a>) and a program can stop any job by sending it a
<code>SIGSTOP</code> signal.  It's the responsibility of the shell to notice
when jobs stop, to notify the user about them, and to provide mechanisms
for allowing the user to interactively continue stopped jobs and switch
jobs between foreground and background.
</p>
<p>See section <a href="#SEC582">Access to the Controlling Terminal</a>, for more information about I/O to the
controlling terminal,
</p>
<hr size="6">
<a name="Job-Control-is-Optional"></a>
<a name="SEC580"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC579" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC581" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC578" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC578" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="libc_28.html#SEC596" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="libc.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="libc_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="libc_42.html#SEC712" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="libc_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="section"> 27.2 Job Control is Optional </h2>

<p>Not all operating systems support job control.  The GNU system does
support job control, but if you are using the GNU library on some other
system, that system may not support job control itself.
</p>
<p>You can use the <code>_POSIX_JOB_CONTROL</code> macro to test at compile-time
whether the system supports job control.  See section <a href="libc_31.html#SEC650">Overall System Options</a>.
</p>
<p>If job control is not supported, then there can be only one process
group per session, which behaves as if it were always in the foreground.
The functions for creating additional process groups simply fail with
the error code <code>ENOSYS</code>.
</p>
<p>The macros naming the various job control signals (see section <a href="libc_24.html#SEC481">Job Control Signals</a>) are defined even if job control is not supported.  However,
the system never generates these signals, and attempts to send a job
control signal or examine or specify their actions report errors or do
nothing.
</p>

<hr size="6">
<a name="Controlling-Terminal"></a>
<a name="SEC581"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC580" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC582" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC578" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC578" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="libc_28.html#SEC596" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="libc.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="libc_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="libc_42.html#SEC712" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="libc_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="section"> 27.3 Controlling Terminal of a Process </h2>

<p>One of the attributes of a process is its controlling terminal.  Child
processes created with <code>fork</code> inherit the controlling terminal from
their parent process.  In this way, all the processes in a session
inherit the controlling terminal from the session leader.  A session
leader that has control of a terminal is called the <em>controlling
process</em> of that terminal.
</p>
<a name="IDX2710"></a>
<p>You generally do not need to worry about the exact mechanism used to
allocate a controlling terminal to a session, since it is done for you
by the system when you log in.
</p>
<p>An individual process disconnects from its controlling terminal when it
calls <code>setsid</code> to become the leader of a new session.
See section <a href="#SEC594">Process Group Functions</a>.
</p>

<hr size="6">
<a name="Access-to-the-Terminal"></a>
<a name="SEC582"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC581" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC583" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC578" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC578" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="libc_28.html#SEC596" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="libc.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="libc_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="libc_42.html#SEC712" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="libc_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="section"> 27.4 Access to the Controlling Terminal </h2>

<p>Processes in the foreground job of a controlling terminal have
unrestricted access to that terminal; background processes do not.  This
section describes in more detail what happens when a process in a
background job tries to access its controlling terminal.
</p>
<a name="IDX2711"></a>
<p>When a process in a background job tries to read from its controlling
terminal, the process group is usually sent a <code>SIGTTIN</code> signal.
This normally causes all of the processes in that group to stop (unless
they handle the signal and don't stop themselves).  However, if the
reading process is ignoring or blocking this signal, then <code>read</code>
fails with an <code>EIO</code> error instead.
</p>
<a name="IDX2712"></a>
<p>Similarly, when a process in a background job tries to write to its
controlling terminal, the default behavior is to send a <code>SIGTTOU</code>
signal to the process group.  However, the behavior is modified by the
<code>TOSTOP</code> bit of the local modes flags (see section <a href="libc_17.html#SEC368">Local Modes</a>).  If
this bit is not set (which is the default), then writing to the
controlling terminal is always permitted without sending a signal.
Writing is also permitted if the <code>SIGTTOU</code> signal is being ignored
or blocked by the writing process.
</p>
<p>Most other terminal operations that a program can do are treated as
reading or as writing.  (The description of each operation should say
which.)
</p>
<p>For more information about the primitive <code>read</code> and <code>write</code>
functions, see <a href="libc_13.html#SEC240">Input and Output Primitives</a>.
</p>

<hr size="6">
<a name="Orphaned-Process-Groups"></a>
<a name="SEC583"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC582" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC584" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC578" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC578" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="libc_28.html#SEC596" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="libc.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="libc_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="libc_42.html#SEC712" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="libc_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="section"> 27.5 Orphaned Process Groups </h2>

<p>When a controlling process terminates, its terminal becomes free and a
new session can be established on it.  (In fact, another user could log
in on the terminal.)  This could cause a problem if any processes from
the old session are still trying to use that terminal.
</p>
<p>To prevent problems, process groups that continue running even after the
session leader has terminated are marked as <em>orphaned process
groups</em>.
</p>
<p>When a process group becomes an orphan, its processes are sent a
<code>SIGHUP</code> signal.  Ordinarily, this causes the processes to
terminate.  However, if a program ignores this signal or establishes a
handler for it (see section <a href="libc_24.html#SEC471">Signal Handling</a>), it can continue running as in
the orphan process group even after its controlling process terminates;
but it still cannot access the terminal any more.
</p>
<hr size="6">
<a name="Implementing-a-Shell"></a>
<a name="SEC584"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC583" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC585" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC578" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC578" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="libc_28.html#SEC596" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="libc.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="libc_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="libc_42.html#SEC712" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="libc_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="section"> 27.6 Implementing a Job Control Shell </h2>

<p>This section describes what a shell must do to implement job control, by
presenting an extensive sample program to illustrate the concepts
involved.
</p>

<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top"><a href="#SEC585">27.6.1 Data Structures for the Shell</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">             Introduction to the sample shell.
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC586">27.6.2 Initializing the Shell</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">      What the shell must do to take
				 responsibility for job control.
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC587">27.6.3 Launching Jobs</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">              Creating jobs to execute commands.
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC588">27.6.4 Foreground and Background</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">   Putting a job in foreground of background.
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC589">27.6.5 Stopped and Terminated Jobs</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">  Reporting job status.
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC590">27.6.6 Continuing Stopped Jobs</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">     How to continue a stopped job in
				 the foreground or background.
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC591">27.6.7 The Missing Pieces</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">              Other parts of the shell.
</td></tr>
</table>

<hr size="6">
<a name="Data-Structures"></a>
<a name="SEC585"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC584" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC586" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC578" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC584" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="libc_28.html#SEC596" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="libc.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="libc_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="libc_42.html#SEC712" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="libc_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h3 class="subsection"> 27.6.1 Data Structures for the Shell </h3>

<p>All of the program examples included in this chapter are part of
a simple shell program.  This section presents data structures
and utility functions which are used throughout the example.
</p>
<p>The sample shell deals mainly with two data structures.  The
<code>job</code> type contains information about a job, which is a
set of subprocesses linked together with pipes.  The <code>process</code> type
holds information about a single subprocess.  Here are the relevant
data structure declarations:
</p>
<table><tr><td>&nbsp;</td><td><pre class="smallexample">/* <span class="roman">A process is a single process.</span>  */
typedef struct process
{
  struct process *next;       /* <span class="roman">next process in pipeline</span> */
  char **argv;                /* <span class="roman">for exec</span> */
  pid_t pid;                  /* <span class="roman">process ID</span> */
  char completed;             /* <span class="roman">true if process has completed</span> */
  char stopped;               /* <span class="roman">true if process has stopped</span> */
  int status;                 /* <span class="roman">reported status value</span> */
} process;

/* <span class="roman">A job is a pipeline of processes.</span>  */
typedef struct job
{
  struct job *next;           /* <span class="roman">next active job</span> */
  char *command;              /* <span class="roman">command line, used for messages</span> */
  process *first_process;     /* <span class="roman">list of processes in this job</span> */
  pid_t pgid;                 /* <span class="roman">process group ID</span> */
  char notified;              /* <span class="roman">true if user told about stopped job</span> */
  struct termios tmodes;      /* <span class="roman">saved terminal modes</span> */
  int stdin, stdout, stderr;  /* <span class="roman">standard i/o channels</span> */
} job;

/* <span class="roman">The active jobs are linked into a list.  This is its head.</span>   */
job *first_job = NULL;
</pre></td></tr></table>

<p>Here are some utility functions that are used for operating on <code>job</code>
objects.
</p>
<table><tr><td>&nbsp;</td><td><pre class="smallexample">/* <span class="roman">Find the active job with the indicated <var>pgid</var>.</span>  */
job *
find_job (pid_t pgid)
{
  job *j;

  for (j = first_job; j; j = j-&gt;next)
    if (j-&gt;pgid == pgid)
      return j;
  return NULL;
}

/* <span class="roman">Return true if all processes in the job have stopped or completed.</span>  */
int
job_is_stopped (job *j)
{
  process *p;

  for (p = j-&gt;first_process; p; p = p-&gt;next)
    if (!p-&gt;completed &amp;&amp; !p-&gt;stopped)
      return 0;
  return 1;
}

/* <span class="roman">Return true if all processes in the job have completed.</span>  */
int
job_is_completed (job *j)
{
  process *p;

  for (p = j-&gt;first_process; p; p = p-&gt;next)
    if (!p-&gt;completed)
      return 0;
  return 1;
}
</pre></td></tr></table>


<hr size="6">
<a name="Initializing-the-Shell"></a>
<a name="SEC586"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC585" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC587" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC578" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC584" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="libc_28.html#SEC596" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="libc.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="libc_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="libc_42.html#SEC712" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="libc_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h3 class="subsection"> 27.6.2 Initializing the Shell </h3>

<p>When a shell program that normally performs job control is started, it
has to be careful in case it has been invoked from another shell that is
already doing its own job control.
</p>
<p>A subshell that runs interactively has to ensure that it has been placed
in the foreground by its parent shell before it can enable job control
itself.  It does this by getting its initial process group ID with the
<code>getpgrp</code> function, and comparing it to the process group ID of the
current foreground job associated with its controlling terminal (which
can be retrieved using the <code>tcgetpgrp</code> function).
</p>
<p>If the subshell is not running as a foreground job, it must stop itself
by sending a <code>SIGTTIN</code> signal to its own process group.  It may not
arbitrarily put itself into the foreground; it must wait for the user to
tell the parent shell to do this.  If the subshell is continued again,
it should repeat the check and stop itself again if it is still not in
the foreground.
</p>
<a name="IDX2713"></a>
<p>Once the subshell has been placed into the foreground by its parent
shell, it can enable its own job control.  It does this by calling
<code>setpgid</code> to put itself into its own process group, and then
calling <code>tcsetpgrp</code> to place this process group into the
foreground.
</p>
<p>When a shell enables job control, it should set itself to ignore all the
job control stop signals so that it doesn't accidentally stop itself.
You can do this by setting the action for all the stop signals to
<code>SIG_IGN</code>.
</p>
<p>A subshell that runs non-interactively cannot and should not support job
control.  It must leave all processes it creates in the same process
group as the shell itself; this allows the non-interactive shell and its
child processes to be treated as a single job by the parent shell.  This
is easy to do&mdash;just don't use any of the job control primitives&mdash;but
you must remember to make the shell do it.
</p>

<p>Here is the initialization code for the sample shell that shows how to
do all of this.
</p>
<table><tr><td>&nbsp;</td><td><pre class="smallexample">/* <span class="roman">Keep track of attributes of the shell.</span>  */

#include &lt;sys/types.h&gt;
#include &lt;termios.h&gt;
#include &lt;unistd.h&gt;

pid_t shell_pgid;
struct termios shell_tmodes;
int shell_terminal;
int shell_is_interactive;


/* <span class="roman">Make sure the shell is running interactively as the foreground job</span>
   <span class="roman">before proceeding.</span> */

void
init_shell ()
{

  /* <span class="roman">See if we are running interactively.</span>  */
  shell_terminal = STDIN_FILENO;
  shell_is_interactive = isatty (shell_terminal);

  if (shell_is_interactive)
    {
      /* <span class="roman">Loop until we are in the foreground.</span>  */
      while (tcgetpgrp (shell_terminal) != (shell_pgid = getpgrp ()))
        kill (- shell_pgid, SIGTTIN);

      /* <span class="roman">Ignore interactive and job-control signals.</span>  */
      signal (SIGINT, SIG_IGN);
      signal (SIGQUIT, SIG_IGN);
      signal (SIGTSTP, SIG_IGN);
      signal (SIGTTIN, SIG_IGN);
      signal (SIGTTOU, SIG_IGN);
      signal (SIGCHLD, SIG_IGN);

      /* <span class="roman">Put ourselves in our own process group.</span>  */
      shell_pgid = getpid ();
      if (setpgid (shell_pgid, shell_pgid) &lt; 0)
        {
          perror (&quot;Couldn't put the shell in its own process group&quot;);
          exit (1);
        }

      /* <span class="roman">Grab control of the terminal.</span>  */
      tcsetpgrp (shell_terminal, shell_pgid);

      /* <span class="roman">Save default terminal attributes for shell.</span>  */
      tcgetattr (shell_terminal, &amp;shell_tmodes);
    }
}
</pre></td></tr></table>


<hr size="6">
<a name="Launching-Jobs"></a>
<a name="SEC587"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC586" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC588" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC578" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC584" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="libc_28.html#SEC596" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="libc.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="libc_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="libc_42.html#SEC712" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="libc_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h3 class="subsection"> 27.6.3 Launching Jobs </h3>

<p>Once the shell has taken responsibility for performing job control on
its controlling terminal, it can launch jobs in response to commands
typed by the user.
</p>
<p>To create the processes in a process group, you use the same <code>fork</code>
and <code>exec</code> functions described in <a href="libc_26.html#SEC570">Process Creation Concepts</a>.
Since there are multiple child processes involved, though, things are a
little more complicated and you must be careful to do things in the
right order.  Otherwise, nasty race conditions can result.
</p>
<p>You have two choices for how to structure the tree of parent-child
relationships among the processes.  You can either make all the
processes in the process group be children of the shell process, or you
can make one process in group be the ancestor of all the other processes
in that group.  The sample shell program presented in this chapter uses
the first approach because it makes bookkeeping somewhat simpler.
</p>
<a name="IDX2714"></a>
<a name="IDX2715"></a>
<p>As each process is forked, it should put itself in the new process group
by calling <code>setpgid</code>; see <a href="#SEC594">Process Group Functions</a>.  The first
process in the new group becomes its <em>process group leader</em>, and its
process ID becomes the <em>process group ID</em> for the group.
</p>
<a name="IDX2716"></a>
<p>The shell should also call <code>setpgid</code> to put each of its child
processes into the new process group.  This is because there is a
potential timing problem: each child process must be put in the process
group before it begins executing a new program, and the shell depends on
having all the child processes in the group before it continues
executing.  If both the child processes and the shell call
<code>setpgid</code>, this ensures that the right things happen no matter which
process gets to it first.
</p>
<p>If the job is being launched as a foreground job, the new process group
also needs to be put into the foreground on the controlling terminal
using <code>tcsetpgrp</code>.  Again, this should be done by the shell as well
as by each of its child processes, to avoid race conditions.
</p>
<p>The next thing each child process should do is to reset its signal
actions.
</p>
<p>During initialization, the shell process set itself to ignore job
control signals; see <a href="#SEC586">Initializing the Shell</a>.  As a result, any child
processes it creates also ignore these signals by inheritance.  This is
definitely undesirable, so each child process should explicitly set the
actions for these signals back to <code>SIG_DFL</code> just after it is forked.
</p>
<p>Since shells follow this convention, applications can assume that they
inherit the correct handling of these signals from the parent process.
But every application has a responsibility not to mess up the handling
of stop signals.  Applications that disable the normal interpretation of
the SUSP character should provide some other mechanism for the user to
stop the job.  When the user invokes this mechanism, the program should
send a <code>SIGTSTP</code> signal to the process group of the process, not
just to the process itself.  See section <a href="libc_24.html#SEC506">Signaling Another Process</a>.
</p>
<p>Finally, each child process should call <code>exec</code> in the normal way.
This is also the point at which redirection of the standard input and
output channels should be handled.  See section <a href="libc_13.html#SEC258">Duplicating Descriptors</a>,
for an explanation of how to do this.
</p>
<p>Here is the function from the sample shell program that is responsible
for launching a program.  The function is executed by each child process
immediately after it has been forked by the shell, and never returns.
</p>
<table><tr><td>&nbsp;</td><td><pre class="smallexample">void
launch_process (process *p, pid_t pgid,
                int infile, int outfile, int errfile,
                int foreground)
{
  pid_t pid;

  if (shell_is_interactive)
    {
      /* <span class="roman">Put the process into the process group and give the process group</span>
         <span class="roman">the terminal, if appropriate.</span>
         <span class="roman">This has to be done both by the shell and in the individual</span>
         <span class="roman">child processes because of potential race conditions.</span>  */
      pid = getpid ();
      if (pgid == 0) pgid = pid;
      setpgid (pid, pgid);
      if (foreground)
        tcsetpgrp (shell_terminal, pgid);

      /* <span class="roman">Set the handling for job control signals back to the default.</span>  */
      signal (SIGINT, SIG_DFL);
      signal (SIGQUIT, SIG_DFL);
      signal (SIGTSTP, SIG_DFL);
      signal (SIGTTIN, SIG_DFL);
      signal (SIGTTOU, SIG_DFL);
      signal (SIGCHLD, SIG_DFL);
    }

  /* <span class="roman">Set the standard input/output channels of the new process.</span>  */
  if (infile != STDIN_FILENO)
    {
      dup2 (infile, STDIN_FILENO);
      close (infile);
    }
  if (outfile != STDOUT_FILENO)
    {
      dup2 (outfile, STDOUT_FILENO);
      close (outfile);
    }
  if (errfile != STDERR_FILENO)
    {
      dup2 (errfile, STDERR_FILENO);
      close (errfile);
    }

  /* <span class="roman">Exec the new process.  Make sure we exit.</span>  */
  execvp (p-&gt;argv[0], p-&gt;argv);
  perror (&quot;execvp&quot;);
  exit (1);
}
</pre></td></tr></table>

<p>If the shell is not running interactively, this function does not do
anything with process groups or signals.  Remember that a shell not
performing job control must keep all of its subprocesses in the same
process group as the shell itself.
</p>
<p>Next, here is the function that actually launches a complete job.
After creating the child processes, this function calls some other
functions to put the newly created job into the foreground or background;
these are discussed in <a href="#SEC588">Foreground and Background</a>.
</p>
<table><tr><td>&nbsp;</td><td><pre class="smallexample">void
launch_job (job *j, int foreground)
{
  process *p;
  pid_t pid;
  int mypipe[2], infile, outfile;

  infile = j-&gt;stdin;
  for (p = j-&gt;first_process; p; p = p-&gt;next)
    {
      /* <span class="roman">Set up pipes, if necessary.</span>  */
      if (p-&gt;next)
        {
          if (pipe (mypipe) &lt; 0)
            {
              perror (&quot;pipe&quot;);
              exit (1);
            }
          outfile = mypipe[1];
        }
      else
        outfile = j-&gt;stdout;

      /* <span class="roman">Fork the child processes.</span>  */
      pid = fork ();
      if (pid == 0)
        /* <span class="roman">This is the child process.</span>  */
        launch_process (p, j-&gt;pgid, infile,
                        outfile, j-&gt;stderr, foreground);
      else if (pid &lt; 0)
        {
          /* <span class="roman">The fork failed.</span>  */
          perror (&quot;fork&quot;);
          exit (1);
        }
      else
        {
          /* <span class="roman">This is the parent process.</span>  */
          p-&gt;pid = pid;
          if (shell_is_interactive)
            {
              if (!j-&gt;pgid)
                j-&gt;pgid = pid;
              setpgid (pid, j-&gt;pgid);
            }
        }

      /* <span class="roman">Clean up after pipes.</span>  */
      if (infile != j-&gt;stdin)
        close (infile);
      if (outfile != j-&gt;stdout)
        close (outfile);
      infile = mypipe[0];
    }

  format_job_info (j, &quot;launched&quot;);

  if (!shell_is_interactive)
    wait_for_job (j);
  else if (foreground)
    put_job_in_foreground (j, 0);
  else
    put_job_in_background (j, 0);
}
</pre></td></tr></table>


<hr size="6">
<a name="Foreground-and-Background"></a>
<a name="SEC588"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC587" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC589" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC578" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC584" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="libc_28.html#SEC596" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="libc.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="libc_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="libc_42.html#SEC712" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="libc_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h3 class="subsection"> 27.6.4 Foreground and Background </h3>

<p>Now let's consider what actions must be taken by the shell when it
launches a job into the foreground, and how this differs from what
must be done when a background job is launched.
</p>
<a name="IDX2717"></a>
<p>When a foreground job is launched, the shell must first give it access
to the controlling terminal by calling <code>tcsetpgrp</code>.  Then, the
shell should wait for processes in that process group to terminate or
stop.  This is discussed in more detail in <a href="#SEC589">Stopped and Terminated Jobs</a>.
</p>
<p>When all of the processes in the group have either completed or stopped,
the shell should regain control of the terminal for its own process
group by calling <code>tcsetpgrp</code> again.  Since stop signals caused by
I/O from a background process or a SUSP character typed by the user
are sent to the process group, normally all the processes in the job
stop together.
</p>
<p>The foreground job may have left the terminal in a strange state, so the
shell should restore its own saved terminal modes before continuing.  In
case the job is merely stopped, the shell should first save the current
terminal modes so that it can restore them later if the job is
continued.  The functions for dealing with terminal modes are
<code>tcgetattr</code> and <code>tcsetattr</code>; these are described in
<a href="libc_17.html#SEC361">Terminal Modes</a>.
</p>
<p>Here is the sample shell's function for doing all of this.
</p>
<table><tr><td>&nbsp;</td><td><pre class="smallexample">/* <span class="roman">Put job <var>j</var> in the foreground.  If <var>cont</var> is nonzero,</span>
   <span class="roman">restore the saved terminal modes and send the process group a</span>
   <span class="roman"><code>SIGCONT</code> signal to wake it up before we block.</span>  */

void
put_job_in_foreground (job *j, int cont)
{
  /* <span class="roman">Put the job into the foreground.</span>  */
  tcsetpgrp (shell_terminal, j-&gt;pgid);

  /* <span class="roman">Send the job a continue signal, if necessary.</span>  */
  if (cont)
    {
      tcsetattr (shell_terminal, TCSADRAIN, &amp;j-&gt;tmodes);
      if (kill (- j-&gt;pgid, SIGCONT) &lt; 0)
        perror (&quot;kill (SIGCONT)&quot;);
    }

  /* <span class="roman">Wait for it to report.</span>  */
  wait_for_job (j);

  /* <span class="roman">Put the shell back in the foreground.</span>  */
  tcsetpgrp (shell_terminal, shell_pgid);

  /* <span class="roman">Restore the shell's terminal modes.</span>  */
  tcgetattr (shell_terminal, &amp;j-&gt;tmodes);
  tcsetattr (shell_terminal, TCSADRAIN, &amp;shell_tmodes);
}
</pre></td></tr></table>

<a name="IDX2718"></a>
<p>If the process group is launched as a background job, the shell should
remain in the foreground itself and continue to read commands from
the terminal.
</p>
<p>In the sample shell, there is not much that needs to be done to put
a job into the background.  Here is the function it uses:
</p>
<table><tr><td>&nbsp;</td><td><pre class="smallexample">/* <span class="roman">Put a job in the background.  If the cont argument is true, send</span>
   <span class="roman">the process group a <code>SIGCONT</code> signal to wake it up.</span>  */

void
put_job_in_background (job *j, int cont)
{
  /* <span class="roman">Send the job a continue signal, if necessary.</span>  */
  if (cont)
    if (kill (-j-&gt;pgid, SIGCONT) &lt; 0)
      perror (&quot;kill (SIGCONT)&quot;);
}
</pre></td></tr></table>


<hr size="6">
<a name="Stopped-and-Terminated-Jobs"></a>
<a name="SEC589"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC588" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC590" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC578" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC584" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="libc_28.html#SEC596" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="libc.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="libc_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="libc_42.html#SEC712" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="libc_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h3 class="subsection"> 27.6.5 Stopped and Terminated Jobs </h3>

<p>When a foreground process is launched, the shell must block until all of
the processes in that job have either terminated or stopped.  It can do
this by calling the <code>waitpid</code> function; see <a href="libc_26.html#SEC574">Process Completion</a>.  Use the <code>WUNTRACED</code> option so that status is reported
for processes that stop as well as processes that terminate.
</p>
<p>The shell must also check on the status of background jobs so that it
can report terminated and stopped jobs to the user; this can be done by
calling <code>waitpid</code> with the <code>WNOHANG</code> option.  A good place to
put a such a check for terminated and stopped jobs is just before
prompting for a new command.
</p>
<a name="IDX2719"></a>
<p>The shell can also receive asynchronous notification that there is
status information available for a child process by establishing a
handler for <code>SIGCHLD</code> signals.  See section <a href="libc_24.html#SEC471">Signal Handling</a>.
</p>
<p>In the sample shell program, the <code>SIGCHLD</code> signal is normally
ignored.  This is to avoid reentrancy problems involving the global data
structures the shell manipulates.  But at specific times when the shell
is not using these data structures&mdash;such as when it is waiting for
input on the terminal&mdash;it makes sense to enable a handler for
<code>SIGCHLD</code>.  The same function that is used to do the synchronous
status checks (<code>do_job_notification</code>, in this case) can also be
called from within this handler.
</p>
<p>Here are the parts of the sample shell program that deal with checking
the status of jobs and reporting the information to the user.
</p>
<table><tr><td>&nbsp;</td><td><pre class="smallexample">/* <span class="roman">Store the status of the process <var>pid</var> that was returned by waitpid.</span>
   <span class="roman">Return 0 if all went well, nonzero otherwise.</span>  */

int
mark_process_status (pid_t pid, int status)
{
  job *j;
  process *p;

  if (pid &gt; 0)
    {
      /* <span class="roman">Update the record for the process.</span>  */
      for (j = first_job; j; j = j-&gt;next)
        for (p = j-&gt;first_process; p; p = p-&gt;next)
          if (p-&gt;pid == pid)
            {
              p-&gt;status = status;
              if (WIFSTOPPED (status))
                p-&gt;stopped = 1;
              else
                {
                  p-&gt;completed = 1;
                  if (WIFSIGNALED (status))
                    fprintf (stderr, &quot;%d: Terminated by signal %d.\n&quot;,
                             (int) pid, WTERMSIG (p-&gt;status));
                }
              return 0;
             }
      fprintf (stderr, &quot;No child process %d.\n&quot;, pid);
      return -1;
    }
  else if (pid == 0 || errno == ECHILD)
    /* <span class="roman">No processes ready to report.</span>  */
    return -1;
  else {
    /* <span class="roman">Other weird errors.</span>  */
    perror (&quot;waitpid&quot;);
    return -1;
  }
}

/* <span class="roman">Check for processes that have status information available,</span>
   <span class="roman">without blocking.</span>  */

void
update_status (void)
{
  int status;
  pid_t pid;

  do
    pid = waitpid (WAIT_ANY, &amp;status, WUNTRACED|WNOHANG);
  while (!mark_process_status (pid, status));
}

/* <span class="roman">Check for processes that have status information available,</span>
   <span class="roman">blocking until all processes in the given job have reported.</span>  */

void
wait_for_job (job *j)
{
  int status;
  pid_t pid;

  do
    pid = waitpid (WAIT_ANY, &amp;status, WUNTRACED);
  while (!mark_process_status (pid, status)
         &amp;&amp; !job_is_stopped (j)
         &amp;&amp; !job_is_completed (j));
}

/* <span class="roman">Format information about job status for the user to look at.</span>  */

void
format_job_info (job *j, const char *status)
{
  fprintf (stderr, &quot;%ld (%s): %s\n&quot;, (long)j-&gt;pgid, status, j-&gt;command);
}

/* <span class="roman">Notify the user about stopped or terminated jobs.</span>
   <span class="roman">Delete terminated jobs from the active job list.</span>  */

void
do_job_notification (void)
{
  job *j, *jlast, *jnext;
  process *p;

  /* <span class="roman">Update status information for child processes.</span>  */
  update_status ();

  jlast = NULL;
  for (j = first_job; j; j = jnext)
    {
      jnext = j-&gt;next;

      /* <span class="roman">If all processes have completed, tell the user the job has</span>
         <span class="roman">completed and delete it from the list of active jobs.</span>  */
      if (job_is_completed (j)) {
        format_job_info (j, &quot;completed&quot;);
        if (jlast)
          jlast-&gt;next = jnext;
        else
          first_job = jnext;
        free_job (j);
      }

      /* <span class="roman">Notify the user about stopped jobs,</span>
         <span class="roman">marking them so that we won't do this more than once.</span>  */
      else if (job_is_stopped (j) &amp;&amp; !j-&gt;notified) {
        format_job_info (j, &quot;stopped&quot;);
        j-&gt;notified = 1;
        jlast = j;
      }

      /* <span class="roman">Don't say anything about jobs that are still running.</span>  */
      else
        jlast = j;
    }
}
</pre></td></tr></table>

<hr size="6">
<a name="Continuing-Stopped-Jobs"></a>
<a name="SEC590"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC589" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC591" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC578" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC584" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="libc_28.html#SEC596" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="libc.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="libc_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="libc_42.html#SEC712" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="libc_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h3 class="subsection"> 27.6.6 Continuing Stopped Jobs </h3>

<p>The shell can continue a stopped job by sending a <code>SIGCONT</code> signal
to its process group.  If the job is being continued in the foreground,
the shell should first invoke <code>tcsetpgrp</code> to give the job access to
the terminal, and restore the saved terminal settings.  After continuing
a job in the foreground, the shell should wait for the job to stop or
complete, as if the job had just been launched in the foreground.
</p>
<p>The sample shell program handles both newly created and continued jobs
with the same pair of functions, <code>put_job_in_foreground</code> and
<code>put_job_in_background</code>.  The definitions of these functions
were given in <a href="#SEC588">Foreground and Background</a>.  When continuing a
stopped job, a nonzero value is passed as the <var>cont</var> argument to
ensure that the <code>SIGCONT</code> signal is sent and the terminal modes
reset, as appropriate.
</p>
<p>This leaves only a function for updating the shell's internal bookkeeping
about the job being continued:
</p>
<table><tr><td>&nbsp;</td><td><pre class="smallexample">/* <span class="roman">Mark a stopped job J as being running again.</span>  */

void
mark_job_as_running (job *j)
{
  Process *p;

  for (p = j-&gt;first_process; p; p = p-&gt;next)
    p-&gt;stopped = 0;
  j-&gt;notified = 0;
}

/* <span class="roman">Continue the job J.</span>  */

void
continue_job (job *j, int foreground)
{
  mark_job_as_running (j);
  if (foreground)
    put_job_in_foreground (j, 1);
  else
    put_job_in_background (j, 1);
}
</pre></td></tr></table>

<hr size="6">
<a name="Missing-Pieces"></a>
<a name="SEC591"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC590" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC592" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC578" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC584" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="libc_28.html#SEC596" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="libc.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="libc_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="libc_42.html#SEC712" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="libc_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h3 class="subsection"> 27.6.7 The Missing Pieces </h3>

<p>The code extracts for the sample shell included in this chapter are only
a part of the entire shell program.  In particular, nothing at all has
been said about how <code>job</code> and <code>program</code> data structures are
allocated and initialized.
</p>
<p>Most real shells provide a complex user interface that has support for
a command language; variables; abbreviations, substitutions, and pattern
matching on file names; and the like.  All of this is far too complicated
to explain here!  Instead, we have concentrated on showing how to
implement the core process creation and job control functions that can
be called from such a shell.
</p>
<p>Here is a table summarizing the major entry points we have presented:
</p>
<dl compact="compact">
<dt> <code>void init_shell (void)</code></dt>
<dd><p>Initialize the shell's internal state.  See section <a href="#SEC586">Initializing the Shell</a>.
</p>
</dd>
<dt> <code>void launch_job (job *<var>j</var>, int <var>foreground</var>)</code></dt>
<dd><p>Launch the job <var>j</var> as either a foreground or background job.
See section <a href="#SEC587">Launching Jobs</a>.
</p>
</dd>
<dt> <code>void do_job_notification (void)</code></dt>
<dd><p>Check for and report any jobs that have terminated or stopped.  Can be
called synchronously or within a handler for <code>SIGCHLD</code> signals.
See section <a href="#SEC589">Stopped and Terminated Jobs</a>.
</p>
</dd>
<dt> <code>void continue_job (job *<var>j</var>, int <var>foreground</var>)</code></dt>
<dd><p>Continue the job <var>j</var>.  See section <a href="#SEC590">Continuing Stopped Jobs</a>.
</p></dd>
</dl>

<p>Of course, a real shell would also want to provide other functions for
managing jobs.  For example, it would be useful to have commands to list
all active jobs or to send a signal (such as <code>SIGKILL</code>) to a job.
</p>

<hr size="6">
<a name="Functions-for-Job-Control"></a>
<a name="SEC592"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC591" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC593" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC578" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC578" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="libc_28.html#SEC596" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="libc.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="libc_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="libc_42.html#SEC712" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="libc_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="section"> 27.7 Functions for Job Control </h2>

<p>This section contains detailed descriptions of the functions relating
to job control.
</p>
<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top"><a href="#SEC593">27.7.1 Identifying the Controlling Terminal</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">    Determining the controlling terminal's name.
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC594">27.7.2 Process Group Functions</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">     Functions for manipulating process groups.
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC595">27.7.3 Functions for Controlling Terminal Access</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">   Functions for controlling terminal access.
</td></tr>
</table>


<hr size="6">
<a name="Identifying-the-Terminal"></a>
<a name="SEC593"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC592" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC594" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC578" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC592" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="libc_28.html#SEC596" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="libc.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="libc_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="libc_42.html#SEC712" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="libc_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h3 class="subsection"> 27.7.1 Identifying the Controlling Terminal </h3>

<p>You can use the <code>ctermid</code> function to get a file name that you can
use to open the controlling terminal.  In the GNU library, it returns
the same string all the time: <code>&quot;/dev/tty&quot;</code>.  That is a special
&ldquo;magic&rdquo; file name that refers to the controlling terminal of the
current process (if it has one).  To find the name of the specific
terminal device, use <code>ttyname</code>; see section <a href="libc_17.html#SEC358">Identifying Terminals</a>.
</p>
<p>The function <code>ctermid</code> is declared in the header file
&lsquo;<tt>stdio.h</tt>&rsquo;.
<a name="IDX2720"></a>
</p>
<dl>
<dt><u>Function:</u> char * <b>ctermid</b><i> (char *<var>string</var>)</i>
<a name="IDX2721"></a>
</dt>
<dd><p>The <code>ctermid</code> function returns a string containing the file name of
the controlling terminal for the current process.  If <var>string</var> is
not a null pointer, it should be an array that can hold at least
<code>L_ctermid</code> characters; the string is returned in this array.
Otherwise, a pointer to a string in a static area is returned, which
might get overwritten on subsequent calls to this function.
</p>
<p>An empty string is returned if the file name cannot be determined for
any reason.  Even if a file name is returned, access to the file it
represents is not guaranteed.
</p></dd></dl>

<dl>
<dt><u>Macro:</u> int <b>L_ctermid</b>
<a name="IDX2722"></a>
</dt>
<dd><p>The value of this macro is an integer constant expression that
represents the size of a string large enough to hold the file name
returned by <code>ctermid</code>.
</p></dd></dl>

<p>See also the <code>isatty</code> and <code>ttyname</code> functions, in
<a href="libc_17.html#SEC358">Identifying Terminals</a>.
</p>

<hr size="6">
<a name="Process-Group-Functions"></a>
<a name="SEC594"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC593" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC595" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC578" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC592" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="libc_28.html#SEC596" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="libc.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="libc_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="libc_42.html#SEC712" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="libc_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h3 class="subsection"> 27.7.2 Process Group Functions </h3>

<p>Here are descriptions of the functions for manipulating process groups.
Your program should include the header files &lsquo;<tt>sys/types.h</tt>&rsquo; and
&lsquo;<tt>unistd.h</tt>&rsquo; to use these functions.
<a name="IDX2723"></a>
<a name="IDX2724"></a>
</p>
<dl>
<dt><u>Function:</u> pid_t <b>setsid</b><i> (void)</i>
<a name="IDX2725"></a>
</dt>
<dd><p>The <code>setsid</code> function creates a new session.  The calling process
becomes the session leader, and is put in a new process group whose
process group ID is the same as the process ID of that process.  There
are initially no other processes in the new process group, and no other
process groups in the new session.
</p>
<p>This function also makes the calling process have no controlling terminal.
</p>
<p>The <code>setsid</code> function returns the new process group ID of the
calling process if successful.  A return value of <code>-1</code> indicates an
error.  The following <code>errno</code> error conditions are defined for this
function:
</p>
<dl compact="compact">
<dt> <code>EPERM</code></dt>
<dd><p>The calling process is already a process group leader, or there is
already another process group around that has the same process group ID.
</p></dd>
</dl>
</dd></dl>

<dl>
<dt><u>Function:</u> pid_t <b>getsid</b><i> (pid_t <var>pid</var>)</i>
<a name="IDX2726"></a>
</dt>
<dd><p>The <code>getsid</code> function returns the process group ID of the session
leader of the specified process.  If a <var>pid</var> is <code>0</code>, the
process group ID of the session leader of the current process is
returned.
</p>
<p>In case of error <code>-1</code> is returned and <code>errno</code> is set.  The
following <code>errno</code> error conditions are defined for this function:
</p>
<dl compact="compact">
<dt> <code>ESRCH</code></dt>
<dd><p>There is no process with the given process ID <var>pid</var>.
</p></dd>
<dt> <code>EPERM</code></dt>
<dd><p>The calling process and the process specified by <var>pid</var> are in
different sessions, and the implementation doesn't allow to access the
process group ID of the session leader of the process with ID <var>pid</var>
from the calling process.
</p></dd>
</dl>
</dd></dl>

<p>The <code>getpgrp</code> function has two definitions: one derived from BSD
Unix, and one from the POSIX.1 standard.  The feature test macros you
have selected (see section <a href="libc_1.html#SEC13">Feature Test Macros</a>) determine which definition
you get.  Specifically, you get the BSD version if you define
<code>_BSD_SOURCE</code>; otherwise, you get the POSIX version if you define
<code>_POSIX_SOURCE</code> or <code>_GNU_SOURCE</code>.  Programs written for old
BSD systems will not include &lsquo;<tt>unistd.h</tt>&rsquo;, which defines
<code>getpgrp</code> specially under <code>_BSD_SOURCE</code>.  You must link such
programs with the <code>-lbsd-compat</code> option to get the BSD definition.
<a name="IDX2727"></a>
<a name="IDX2728"></a>
<a name="IDX2729"></a>
</p>
<dl>
<dt><u>POSIX.1 Function:</u> pid_t <b>getpgrp</b><i> (void)</i>
<a name="IDX2730"></a>
</dt>
<dd><p>The POSIX.1 definition of <code>getpgrp</code> returns the process group ID of
the calling process.
</p></dd></dl>

<dl>
<dt><u>BSD Function:</u> pid_t <b>getpgrp</b><i> (pid_t <var>pid</var>)</i>
<a name="IDX2731"></a>
</dt>
<dd><p>The BSD definition of <code>getpgrp</code> returns the process group ID of the
process <var>pid</var>.  You can supply a value of <code>0</code> for the <var>pid</var>
argument to get information about the calling process.
</p></dd></dl>

<dl>
<dt><u>System V Function:</u> int <b>getpgid</b><i> (pid_t <var>pid</var>)</i>
<a name="IDX2732"></a>
</dt>
<dd><p><code>getpgid</code> is the same as the BSD function <code>getpgrp</code>.  It
returns the process group ID of the process <var>pid</var>.  You can supply a
value of <code>0</code> for the <var>pid</var> argument to get information about
the calling process.
</p>
<p>In case of error <code>-1</code> is returned and <code>errno</code> is set.  The
following <code>errno</code> error conditions are defined for this function:
</p>
<dl compact="compact">
<dt> <code>ESRCH</code></dt>
<dd><p>There is no process with the given process ID <var>pid</var>.
The calling process and the process specified by <var>pid</var> are in
different sessions, and the implementation doesn't allow to access the
process group ID of the process with ID <var>pid</var> from the calling
process.
</p></dd>
</dl>
</dd></dl>

<dl>
<dt><u>Function:</u> int <b>setpgid</b><i> (pid_t <var>pid</var>, pid_t <var>pgid</var>)</i>
<a name="IDX2733"></a>
</dt>
<dd><p>The <code>setpgid</code> function puts the process <var>pid</var> into the process
group <var>pgid</var>.  As a special case, either <var>pid</var> or <var>pgid</var> can
be zero to indicate the process ID of the calling process.
</p>
<p>This function fails on a system that does not support job control.
See section <a href="#SEC580">Job Control is Optional</a>, for more information.
</p>
<p>If the operation is successful, <code>setpgid</code> returns zero.  Otherwise
it returns <code>-1</code>.  The following <code>errno</code> error conditions are
defined for this function:
</p>
<dl compact="compact">
<dt> <code>EACCES</code></dt>
<dd><p>The child process named by <var>pid</var> has executed an <code>exec</code>
function since it was forked.
</p>
</dd>
<dt> <code>EINVAL</code></dt>
<dd><p>The value of the <var>pgid</var> is not valid.
</p>
</dd>
<dt> <code>ENOSYS</code></dt>
<dd><p>The system doesn't support job control.
</p>
</dd>
<dt> <code>EPERM</code></dt>
<dd><p>The process indicated by the <var>pid</var> argument is a session leader,
or is not in the same session as the calling process, or the value of
the <var>pgid</var> argument doesn't match a process group ID in the same
session as the calling process.
</p>
</dd>
<dt> <code>ESRCH</code></dt>
<dd><p>The process indicated by the <var>pid</var> argument is not the calling
process or a child of the calling process.
</p></dd>
</dl>
</dd></dl>

<dl>
<dt><u>Function:</u> int <b>setpgrp</b><i> (pid_t <var>pid</var>, pid_t <var>pgid</var>)</i>
<a name="IDX2734"></a>
</dt>
<dd><p>This is the BSD Unix name for <code>setpgid</code>.  Both functions do exactly
the same thing.
</p></dd></dl>


<hr size="6">
<a name="Terminal-Access-Functions"></a>
<a name="SEC595"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC594" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="libc_28.html#SEC596" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC578" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC592" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="libc_28.html#SEC596" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="libc.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="libc_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="libc_42.html#SEC712" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="libc_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h3 class="subsection"> 27.7.3 Functions for Controlling Terminal Access </h3>

<p>These are the functions for reading or setting the foreground
process group of a terminal.  You should include the header files
&lsquo;<tt>sys/types.h</tt>&rsquo; and &lsquo;<tt>unistd.h</tt>&rsquo; in your application to use
these functions.
<a name="IDX2735"></a>
<a name="IDX2736"></a>
</p>
<p>Although these functions take a file descriptor argument to specify
the terminal device, the foreground job is associated with the terminal
file itself and not a particular open file descriptor.
</p>
<dl>
<dt><u>Function:</u> pid_t <b>tcgetpgrp</b><i> (int <var>filedes</var>)</i>
<a name="IDX2737"></a>
</dt>
<dd><p>This function returns the process group ID of the foreground process
group associated with the terminal open on descriptor <var>filedes</var>.
</p>
<p>If there is no foreground process group, the return value is a number
greater than <code>1</code> that does not match the process group ID of any
existing process group.  This can happen if all of the processes in the
job that was formerly the foreground job have terminated, and no other
job has yet been moved into the foreground.
</p>
<p>In case of an error, a value of <code>-1</code> is returned.  The
following <code>errno</code> error conditions are defined for this function:
</p>
<dl compact="compact">
<dt> <code>EBADF</code></dt>
<dd><p>The <var>filedes</var> argument is not a valid file descriptor.
</p>
</dd>
<dt> <code>ENOSYS</code></dt>
<dd><p>The system doesn't support job control.
</p>
</dd>
<dt> <code>ENOTTY</code></dt>
<dd><p>The terminal file associated with the <var>filedes</var> argument isn't the
controlling terminal of the calling process.
</p></dd>
</dl>
</dd></dl>

<dl>
<dt><u>Function:</u> int <b>tcsetpgrp</b><i> (int <var>filedes</var>, pid_t <var>pgid</var>)</i>
<a name="IDX2738"></a>
</dt>
<dd><p>This function is used to set a terminal's foreground process group ID.
The argument <var>filedes</var> is a descriptor which specifies the terminal;
<var>pgid</var> specifies the process group.  The calling process must be a
member of the same session as <var>pgid</var> and must have the same
controlling terminal.
</p>
<p>For terminal access purposes, this function is treated as output.  If it
is called from a background process on its controlling terminal,
normally all processes in the process group are sent a <code>SIGTTOU</code>
signal.  The exception is if the calling process itself is ignoring or
blocking <code>SIGTTOU</code> signals, in which case the operation is
performed and no signal is sent.
</p>
<p>If successful, <code>tcsetpgrp</code> returns <code>0</code>.  A return value of
<code>-1</code> indicates an error.  The following <code>errno</code> error
conditions are defined for this function:
</p>
<dl compact="compact">
<dt> <code>EBADF</code></dt>
<dd><p>The <var>filedes</var> argument is not a valid file descriptor.
</p>
</dd>
<dt> <code>EINVAL</code></dt>
<dd><p>The <var>pgid</var> argument is not valid.
</p>
</dd>
<dt> <code>ENOSYS</code></dt>
<dd><p>The system doesn't support job control.
</p>
</dd>
<dt> <code>ENOTTY</code></dt>
<dd><p>The <var>filedes</var> isn't the controlling terminal of the calling process.
</p>
</dd>
<dt> <code>EPERM</code></dt>
<dd><p>The <var>pgid</var> isn't a process group in the same session as the calling
process.
</p></dd>
</dl>
</dd></dl>

<dl>
<dt><u>Function:</u> pid_t <b>tcgetsid</b><i> (int <var>fildes</var>)</i>
<a name="IDX2739"></a>
</dt>
<dd><p>This function is used to obtain the process group ID of the session
for which the terminal specified by <var>fildes</var> is the controlling terminal.
If the call is successful the group ID is returned.  Otherwise the
return value is <code>(pid_t) -1</code> and the global variable <var>errno</var>
is set to the following value:
</p><dl compact="compact">
<dt> <code>EBADF</code></dt>
<dd><p>The <var>filedes</var> argument is not a valid file descriptor.
</p>
</dd>
<dt> <code>ENOTTY</code></dt>
<dd><p>The calling process does not have a controlling terminal, or the file
is not the controlling terminal.
</p></dd>
</dl>
</dd></dl>
<hr size="6">
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC578" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="libc_28.html#SEC596" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="libc.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="libc_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="libc_42.html#SEC712" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="libc_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<p>
 <font size="-1">
  This document was generated by <em>root</em> on <em>April, 29 2009</em> using <a href="http://www.nongnu.org/texi2html/"><em>texi2html 1.78</em></a>.
 </font>
 <br>

</p>
</body>
</html>
