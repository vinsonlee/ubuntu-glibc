<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html401/loose.dtd">
<html>
<!-- This file documents the GNU C library.

This is Edition 0.12, last updated 2007-10-27,
of The GNU C Library Reference Manual, for version 2.8.

Copyright (C) 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2001, 2002,
2003, 2007, 2008 Free Software Foundation, Inc.

Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.2 or
any later version published by the Free Software Foundation; with the
Invariant Sections being "Free Software Needs Free Documentation"
and "GNU Lesser General Public License", the Front-Cover texts being
"A GNU Manual", and with the Back-Cover Texts as in (a) below.  A
copy of the license is included in the section entitled "GNU Free
Documentation License".

(a) The FSF's Back-Cover Text is: "You have the freedom to
copy and modify this GNU manual.  Buying copies from the FSF
supports it in developing GNU and promoting software freedom."
 -->
<!-- Created on January, 19 2009 by texi2html 1.78 -->
<!--
Written by: Lionel Cons <Lionel.Cons@cern.ch> (original author)
            Karl Berry  <karl@freefriends.org>
            Olaf Bachmann <obachman@mathematik.uni-kl.de>
            and many others.
Maintained by: Many creative people.
Send bugs and suggestions to <texi2html-bug@nongnu.org>

-->
<head>
<title>The GNU C Library: 25. The Basic Program/System Interface</title>

<meta name="description" content="The GNU C Library: 25. The Basic Program/System Interface">
<meta name="keywords" content="The GNU C Library: 25. The Basic Program/System Interface">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="texi2html 1.78">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
<!--
a.summary-letter {text-decoration: none}
pre.display {font-family: serif}
pre.format {font-family: serif}
pre.menu-comment {font-family: serif}
pre.menu-preformatted {font-family: serif}
pre.smalldisplay {font-family: serif; font-size: smaller}
pre.smallexample {font-size: smaller}
pre.smallformat {font-family: serif; font-size: smaller}
pre.smalllisp {font-size: smaller}
span.roman {font-family:serif; font-weight:normal;}
span.sansserif {font-family:sans-serif; font-weight:normal;}
ul.toc {list-style: none}
-->
</style>


</head>

<body lang="en" bgcolor="#FFFFFF" text="#000000" link="#0000FF" vlink="#800080" alink="#FF0000">

<a name="Program-Basics"></a>
<a name="SEC525"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="libc_24.html#SEC524" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC526" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="libc_24.html#SEC471" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="libc.html#SEC_Top" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="libc_26.html#SEC568" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="libc.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="libc_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="libc_42.html#SEC712" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="libc_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h1 class="chapter"> 25. The Basic Program/System Interface </h1>

<p><em>Processes</em> are the primitive units for allocation of system
resources.  Each process has its own address space and (usually) one
thread of control.  A process executes a program; you can have multiple
processes executing the same program, but each process has its own copy
of the program within its own address space and executes it
independently of the other copies.  Though it may have multiple threads
of control within the same program and a program may be composed of
multiple logically separate modules, a process always executes exactly
one program.
</p>
<p>Note that we are using a specific definition of &ldquo;program&rdquo; for the
purposes of this manual, which corresponds to a common definition in the
context of Unix system.  In popular usage, &ldquo;program&rdquo; enjoys a much
broader definition; it can refer for example to a system's kernel, an
editor macro, a complex package of software, or a discrete section of
code executing within a process.
</p>
<p>Writing the program is what this manual is all about.  This chapter
explains the most basic interface between your program and the system
that runs, or calls, it.  This includes passing of parameters (arguments
and environment) from the system, requesting basic services from the
system, and telling the system the program is done.
</p>
<p>A program starts another program with the <code>exec</code> family of system calls.
This chapter looks at program startup from the execee's point of view.  To
see the event from the execor's point of view, see <a href="libc_26.html#SEC573">Executing a File</a>.
</p>
<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top"><a href="#SEC526">25.1 Program Arguments</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">           Parsing your program's command-line arguments.
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC558">25.4 Environment Variables</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">       Less direct parameters affecting your program
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC561">25.5 System Calls</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                Requesting service from the system
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC562">25.6 Program Termination</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">         Telling the system you're done; return status
</td></tr>
</table>

<hr size="6">
<a name="Program-Arguments"></a>
<a name="SEC526"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC525" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC527" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC525" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC525" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="libc_26.html#SEC568" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="libc.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="libc_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="libc_42.html#SEC712" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="libc_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="section"> 25.1 Program Arguments </h2>

<p>The system starts a C program by calling the function <code>main</code>.  It
is up to you to write a function named <code>main</code>&mdash;otherwise, you
won't even be able to link your program without errors.
</p>
<p>In ISO C you can define <code>main</code> either to take no arguments, or to
take two arguments that represent the command line arguments to the
program, like this:
</p>
<table><tr><td>&nbsp;</td><td><pre class="smallexample">int main (int <var>argc</var>, char *<var>argv</var>[])
</pre></td></tr></table>

<a name="IDX2549"></a>
<a name="IDX2550"></a>
<p>The command line arguments are the whitespace-separated tokens given in
the shell command used to invoke the program; thus, in &lsquo;<samp>cat foo
bar</samp>&rsquo;, the arguments are &lsquo;<samp>foo</samp>&rsquo; and &lsquo;<samp>bar</samp>&rsquo;.  The only way a
program can look at its command line arguments is via the arguments of
<code>main</code>.  If <code>main</code> doesn't take arguments, then you cannot get
at the command line.
</p>
<p>The value of the <var>argc</var> argument is the number of command line
arguments.  The <var>argv</var> argument is a vector of C strings; its
elements are the individual command line argument strings.  The file
name of the program being run is also included in the vector as the
first element; the value of <var>argc</var> counts this element.  A null
pointer always follows the last element: <code><var>argv</var>[<var>argc</var>]</code>
is this null pointer.
</p>
<p>For the command &lsquo;<samp>cat foo bar</samp>&rsquo;, <var>argc</var> is 3 and <var>argv</var> has
three elements, <code>&quot;cat&quot;</code>, <code>&quot;foo&quot;</code> and <code>&quot;bar&quot;</code>.
</p>
<p>In Unix systems you can define <code>main</code> a third way, using three arguments:
</p>
<table><tr><td>&nbsp;</td><td><pre class="smallexample">int main (int <var>argc</var>, char *<var>argv</var>[], char *<var>envp</var>[])
</pre></td></tr></table>

<p>The first two arguments are just the same.  The third argument
<var>envp</var> gives the program's environment; it is the same as the value
of <code>environ</code>.  See section <a href="#SEC558">Environment Variables</a>.  POSIX.1 does not
allow this three-argument form, so to be portable it is best to write
<code>main</code> to take two arguments, and use the value of <code>environ</code>.
</p>
<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top"><a href="#SEC527">25.1.1 Program Argument Syntax Conventions</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">             By convention, options start with a hyphen.
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC528">25.1.2 Parsing Program Arguments</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">   Ways to parse program options and arguments.
</td></tr>
</table>

<hr size="6">
<a name="Argument-Syntax"></a>
<a name="SEC527"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC526" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC528" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC525" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC526" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="libc_26.html#SEC568" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="libc.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="libc_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="libc_42.html#SEC712" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="libc_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h3 class="subsection"> 25.1.1 Program Argument Syntax Conventions </h3>

<p>POSIX recommends these conventions for command line arguments.
<code>getopt</code> (see section <a href="#SEC529">Parsing program options using <code>getopt</code></a>) and <code>argp_parse</code> (see section <a href="#SEC534">Parsing Program Options with Argp</a>) make
it easy to implement them.
</p>
<ul>
<li>
Arguments are options if they begin with a hyphen delimiter (&lsquo;<samp>-</samp>&rsquo;).

</li><li>
Multiple options may follow a hyphen delimiter in a single token if
the options do not take arguments.  Thus, &lsquo;<samp>-abc</samp>&rsquo; is equivalent to
&lsquo;<samp>-a -b -c</samp>&rsquo;.

</li><li>
Option names are single alphanumeric characters (as for <code>isalnum</code>;
see section <a href="libc_4.html#SEC65">Classification of Characters</a>).

</li><li>
Certain options require an argument.  For example, the &lsquo;<samp>-o</samp>&rsquo; command
of the <code>ld</code> command requires an argument&mdash;an output file name.

</li><li>
An option and its argument may or may not appear as separate tokens.  (In
other words, the whitespace separating them is optional.)  Thus,
&lsquo;<samp>-o foo</samp>&rsquo; and &lsquo;<samp>-ofoo</samp>&rsquo; are equivalent.

</li><li>
Options typically precede other non-option arguments.

<p>The implementations of <code>getopt</code> and <code>argp_parse</code> in the GNU C
library normally make it appear as if all the option arguments were
specified before all the non-option arguments for the purposes of
parsing, even if the user of your program intermixed option and
non-option arguments.  They do this by reordering the elements of the
<var>argv</var> array.  This behavior is nonstandard; if you want to suppress
it, define the <code>_POSIX_OPTION_ORDER</code> environment variable.
See section <a href="#SEC560">Standard Environment Variables</a>.
</p>
</li><li>
The argument &lsquo;<samp>--</samp>&rsquo; terminates all options; any following arguments
are treated as non-option arguments, even if they begin with a hyphen.

</li><li>
A token consisting of a single hyphen character is interpreted as an
ordinary non-option argument.  By convention, it is used to specify
input from or output to the standard input and output streams.

</li><li>
Options may be supplied in any order, or appear multiple times.  The
interpretation is left up to the particular application program.
</li></ul>

<a name="IDX2551"></a>
<p>GNU adds <em>long options</em> to these conventions.  Long options consist
of &lsquo;<samp>--</samp>&rsquo; followed by a name made of alphanumeric characters and
dashes.  Option names are typically one to three words long, with
hyphens to separate words.  Users can abbreviate the option names as
long as the abbreviations are unique.
</p>
<p>To specify an argument for a long option, write
&lsquo;<samp>--<var>name</var>=<var>value</var></samp>&rsquo;.  This syntax enables a long option to
accept an argument that is itself optional.
</p>
<p>Eventually, the GNU system will provide completion for long option names
in the shell.
</p>
<hr size="6">
<a name="Parsing-Program-Arguments"></a>
<a name="SEC528"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC527" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC529" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC525" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC526" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="libc_26.html#SEC568" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="libc.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="libc_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="libc_42.html#SEC712" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="libc_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h3 class="subsection"> 25.1.2 Parsing Program Arguments </h3>

<p>If the syntax for the command line arguments to your program is simple
enough, you can simply pick the arguments off from <var>argv</var> by hand.
But unless your program takes a fixed number of arguments, or all of the
arguments are interpreted in the same way (as file names, for example),
you are usually better off using <code>getopt</code> (see section <a href="#SEC529">Parsing program options using <code>getopt</code></a>) or
<code>argp_parse</code> (see section <a href="#SEC534">Parsing Program Options with Argp</a>) to do the parsing.
</p>
<p><code>getopt</code> is more standard (the short-option only version of it is a
part of the POSIX standard), but using <code>argp_parse</code> is often
easier, both for very simple and very complex option structures, because
it does more of the dirty work for you.
</p>
<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top"><a href="#SEC529">25.2 Parsing program options using <code>getopt</code></a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top"></td></tr>
<tr><td align="left" valign="top"><a href="#SEC534">25.3 Parsing Program Options with Argp</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                        Parsing program options using <code>argp_parse</code>.
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC556">25.3.12.1 Parsing of Suboptions</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                  Some programs need more detailed options.
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC557">25.3.13 Parsing of Suboptions Example</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">          This shows how it could be done for <code>mount</code>.
</td></tr>
</table>


<hr size="6">
<a name="Getopt"></a>
<a name="SEC529"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC528" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC530" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC525" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC525" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="libc_26.html#SEC568" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="libc.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="libc_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="libc_42.html#SEC712" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="libc_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="section"> 25.2 Parsing program options using <code>getopt</code> </h2>

<p>The <code>getopt</code> and <code>getopt_long</code> functions automate some of the
chore involved in parsing typical unix command line options.
</p>
<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top"><a href="#SEC530">25.2.1 Using the <code>getopt</code> function</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top"></td></tr>
<tr><td align="left" valign="top"><a href="#SEC531">25.2.2 Example of Parsing Arguments with <code>getopt</code></a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">           An example of parsing options with <code>getopt</code>.
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC532">25.2.3 Parsing Long Options with <code>getopt_long</code></a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">         GNU suggests utilities accept long-named
                                 options; here is one way to do.
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC533">25.2.4 Example of Parsing Long Options with <code>getopt_long</code></a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">  An example of using <code>getopt_long</code>.
</td></tr>
</table>

<hr size="6">
<a name="Using-Getopt"></a>
<a name="SEC530"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC529" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC531" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC525" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC529" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="libc_26.html#SEC568" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="libc.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="libc_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="libc_42.html#SEC712" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="libc_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h3 class="subsection"> 25.2.1 Using the <code>getopt</code> function </h3>

<p>Here are the details about how to call the <code>getopt</code> function.  To
use this facility, your program must include the header file
&lsquo;<tt>unistd.h</tt>&rsquo;.
<a name="IDX2552"></a>
</p>
<dl>
<dt><u>Variable:</u> int <b>opterr</b>
<a name="IDX2553"></a>
</dt>
<dd><p>If the value of this variable is nonzero, then <code>getopt</code> prints an
error message to the standard error stream if it encounters an unknown
option character or an option with a missing required argument.  This is
the default behavior.  If you set this variable to zero, <code>getopt</code>
does not print any messages, but it still returns the character <code>?</code>
to indicate an error.
</p></dd></dl>

<dl>
<dt><u>Variable:</u> int <b>optopt</b>
<a name="IDX2554"></a>
</dt>
<dd><p>When <code>getopt</code> encounters an unknown option character or an option
with a missing required argument, it stores that option character in
this variable.  You can use this for providing your own diagnostic
messages.
</p></dd></dl>

<dl>
<dt><u>Variable:</u> int <b>optind</b>
<a name="IDX2555"></a>
</dt>
<dd><p>This variable is set by <code>getopt</code> to the index of the next element
of the <var>argv</var> array to be processed.  Once <code>getopt</code> has found
all of the option arguments, you can use this variable to determine
where the remaining non-option arguments begin.  The initial value of
this variable is <code>1</code>.
</p></dd></dl>

<dl>
<dt><u>Variable:</u> char * <b>optarg</b>
<a name="IDX2556"></a>
</dt>
<dd><p>This variable is set by <code>getopt</code> to point at the value of the
option argument, for those options that accept arguments.
</p></dd></dl>

<dl>
<dt><u>Function:</u> int <b>getopt</b><i> (int <var>argc</var>, char **<var>argv</var>, const char *<var>options</var>)</i>
<a name="IDX2557"></a>
</dt>
<dd><p>The <code>getopt</code> function gets the next option argument from the
argument list specified by the <var>argv</var> and <var>argc</var> arguments.
Normally these values come directly from the arguments received by
<code>main</code>.
</p>
<p>The <var>options</var> argument is a string that specifies the option
characters that are valid for this program.  An option character in this
string can be followed by a colon (&lsquo;<samp>:</samp>&rsquo;) to indicate that it takes a
required argument.  If an option character is followed by two colons
(&lsquo;<samp>::</samp>&rsquo;), its argument is optional; this is a GNU extension.
</p>
<p><code>getopt</code> has three ways to deal with options that follow
non-options <var>argv</var> elements.  The special argument &lsquo;<samp>--</samp>&rsquo; forces
in all cases the end of option scanning.
</p>
<ul>
<li>
The default is to permute the contents of <var>argv</var> while scanning it
so that eventually all the non-options are at the end.  This allows
options to be given in any order, even with programs that were not
written to expect this.

</li><li>
If the <var>options</var> argument string begins with a hyphen (&lsquo;<samp>-</samp>&rsquo;), this
is treated specially.  It permits arguments that are not options to be
returned as if they were associated with option character &lsquo;<samp>\1</samp>&rsquo;.

</li><li>
POSIX demands the following behavior: The first non-option stops option
processing.  This mode is selected by either setting the environment
variable <code>POSIXLY_CORRECT</code> or beginning the <var>options</var> argument
string with a plus sign (&lsquo;<samp>+</samp>&rsquo;).
</li></ul>

<p>The <code>getopt</code> function returns the option character for the next
command line option.  When no more option arguments are available, it
returns <code>-1</code>.  There may still be more non-option arguments; you
must compare the external variable <code>optind</code> against the <var>argc</var>
parameter to check this.
</p>
<p>If the option has an argument, <code>getopt</code> returns the argument by
storing it in the variable <var>optarg</var>.  You don't ordinarily need to
copy the <code>optarg</code> string, since it is a pointer into the original
<var>argv</var> array, not into a static area that might be overwritten.
</p>
<p>If <code>getopt</code> finds an option character in <var>argv</var> that was not
included in <var>options</var>, or a missing option argument, it returns
&lsquo;<samp>?</samp>&rsquo; and sets the external variable <code>optopt</code> to the actual
option character.  If the first character of <var>options</var> is a colon
(&lsquo;<samp>:</samp>&rsquo;), then <code>getopt</code> returns &lsquo;<samp>:</samp>&rsquo; instead of &lsquo;<samp>?</samp>&rsquo; to
indicate a missing option argument.  In addition, if the external
variable <code>opterr</code> is nonzero (which is the default), <code>getopt</code>
prints an error message.
</p></dd></dl>

<hr size="6">
<a name="Example-of-Getopt"></a>
<a name="SEC531"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC530" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC532" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC525" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC529" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="libc_26.html#SEC568" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="libc.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="libc_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="libc_42.html#SEC712" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="libc_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h3 class="subsection"> 25.2.2 Example of Parsing Arguments with <code>getopt</code> </h3>

<p>Here is an example showing how <code>getopt</code> is typically used.  The
key points to notice are:
</p>
<ul>
<li>
Normally, <code>getopt</code> is called in a loop.  When <code>getopt</code> returns
<code>-1</code>, indicating no more options are present, the loop terminates.

</li><li>
A <code>switch</code> statement is used to dispatch on the return value from
<code>getopt</code>.  In typical use, each case just sets a variable that
is used later in the program.

</li><li>
A second loop is used to process the remaining non-option arguments.
</li></ul>

<table><tr><td>&nbsp;</td><td><pre class="smallexample">#include &lt;ctype.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;

int
main (int argc, char **argv)
{
  int aflag = 0;
  int bflag = 0;
  char *cvalue = NULL;
  int index;
  int c;

  opterr = 0;

  while ((c = getopt (argc, argv, &quot;abc:&quot;)) != -1)
    switch (c)
      {
      case 'a':
        aflag = 1;
        break;
      case 'b':
        bflag = 1;
        break;
      case 'c':
        cvalue = optarg;
        break;
      case '?':
        if (optopt == 'c')
          fprintf (stderr, &quot;Option -%c requires an argument.\n&quot;, optopt);
        else if (isprint (optopt))
          fprintf (stderr, &quot;Unknown option `-%c'.\n&quot;, optopt);
        else
          fprintf (stderr,
                   &quot;Unknown option character `\\x%x'.\n&quot;,
                   optopt);
        return 1;
      default:
        abort ();
      }

  printf (&quot;aflag = %d, bflag = %d, cvalue = %s\n&quot;,
          aflag, bflag, cvalue);

  for (index = optind; index &lt; argc; index++)
    printf (&quot;Non-option argument %s\n&quot;, argv[index]);
  return 0;
}
</pre></td></tr></table>

<p>Here are some examples showing what this program prints with different
combinations of arguments:
</p>
<table><tr><td>&nbsp;</td><td><pre class="smallexample">% testopt
aflag = 0, bflag = 0, cvalue = (null)

% testopt -a -b
aflag = 1, bflag = 1, cvalue = (null)

% testopt -ab
aflag = 1, bflag = 1, cvalue = (null)

% testopt -c foo
aflag = 0, bflag = 0, cvalue = foo

% testopt -cfoo
aflag = 0, bflag = 0, cvalue = foo

% testopt arg1
aflag = 0, bflag = 0, cvalue = (null)
Non-option argument arg1

% testopt -a arg1
aflag = 1, bflag = 0, cvalue = (null)
Non-option argument arg1

% testopt -c foo arg1
aflag = 0, bflag = 0, cvalue = foo
Non-option argument arg1

% testopt -a -- -b
aflag = 1, bflag = 0, cvalue = (null)
Non-option argument -b

% testopt -a -
aflag = 1, bflag = 0, cvalue = (null)
Non-option argument -
</pre></td></tr></table>

<hr size="6">
<a name="Getopt-Long-Options"></a>
<a name="SEC532"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC531" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC533" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC525" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC529" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="libc_26.html#SEC568" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="libc.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="libc_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="libc_42.html#SEC712" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="libc_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h3 class="subsection"> 25.2.3 Parsing Long Options with <code>getopt_long</code> </h3>

<p>To accept GNU-style long options as well as single-character options,
use <code>getopt_long</code> instead of <code>getopt</code>.  This function is
declared in &lsquo;<tt>getopt.h</tt>&rsquo;, not &lsquo;<tt>unistd.h</tt>&rsquo;.  You should make every
program accept long options if it uses any options, for this takes
little extra work and helps beginners remember how to use the program.
</p>
<dl>
<dt><u>Data Type:</u> <b>struct option</b>
<a name="IDX2558"></a>
</dt>
<dd><p>This structure describes a single long option name for the sake of
<code>getopt_long</code>.  The argument <var>longopts</var> must be an array of
these structures, one for each long option.  Terminate the array with an
element containing all zeros.
</p>
<p>The <code>struct option</code> structure has these fields:
</p>
<dl compact="compact">
<dt> <code>const char *name</code></dt>
<dd><p>This field is the name of the option.  It is a string.
</p>
</dd>
<dt> <code>int has_arg</code></dt>
<dd><p>This field says whether the option takes an argument.  It is an integer,
and there are three legitimate values: <code>no_argument</code>,
<code>required_argument</code> and <code>optional_argument</code>.
</p>
</dd>
<dt> <code>int *flag</code></dt>
<dt> <code>int val</code></dt>
<dd><p>These fields control how to report or act on the option when it occurs.
</p>
<p>If <code>flag</code> is a null pointer, then the <code>val</code> is a value which
identifies this option.  Often these values are chosen to uniquely
identify particular long options.
</p>
<p>If <code>flag</code> is not a null pointer, it should be the address of an
<code>int</code> variable which is the flag for this option.  The value in
<code>val</code> is the value to store in the flag to indicate that the option
was seen.
</p></dd>
</dl>
</dd></dl>

<dl>
<dt><u>Function:</u> int <b>getopt_long</b><i> (int <var>argc</var>, char *const *<var>argv</var>, const char *<var>shortopts</var>, const struct option *<var>longopts</var>, int *<var>indexptr</var>)</i>
<a name="IDX2559"></a>
</dt>
<dd><p>Decode options from the vector <var>argv</var> (whose length is <var>argc</var>).
The argument <var>shortopts</var> describes the short options to accept, just as
it does in <code>getopt</code>.  The argument <var>longopts</var> describes the long
options to accept (see above).
</p>
<p>When <code>getopt_long</code> encounters a short option, it does the same
thing that <code>getopt</code> would do: it returns the character code for the
option, and stores the options argument (if it has one) in <code>optarg</code>.
</p>
<p>When <code>getopt_long</code> encounters a long option, it takes actions based
on the <code>flag</code> and <code>val</code> fields of the definition of that
option.
</p>
<p>If <code>flag</code> is a null pointer, then <code>getopt_long</code> returns the
contents of <code>val</code> to indicate which option it found.  You should
arrange distinct values in the <code>val</code> field for options with
different meanings, so you can decode these values after
<code>getopt_long</code> returns.  If the long option is equivalent to a short
option, you can use the short option's character code in <code>val</code>.
</p>
<p>If <code>flag</code> is not a null pointer, that means this option should just
set a flag in the program.  The flag is a variable of type <code>int</code>
that you define.  Put the address of the flag in the <code>flag</code> field.
Put in the <code>val</code> field the value you would like this option to
store in the flag.  In this case, <code>getopt_long</code> returns <code>0</code>.
</p>
<p>For any long option, <code>getopt_long</code> tells you the index in the array
<var>longopts</var> of the options definition, by storing it into
<code>*<var>indexptr</var></code>.  You can get the name of the option with
<code><var>longopts</var>[*<var>indexptr</var>].name</code>.  So you can distinguish among
long options either by the values in their <code>val</code> fields or by their
indices.  You can also distinguish in this way among long options that
set flags.
</p>
<p>When a long option has an argument, <code>getopt_long</code> puts the argument
value in the variable <code>optarg</code> before returning.  When the option
has no argument, the value in <code>optarg</code> is a null pointer.  This is
how you can tell whether an optional argument was supplied.
</p>
<p>When <code>getopt_long</code> has no more options to handle, it returns
<code>-1</code>, and leaves in the variable <code>optind</code> the index in
<var>argv</var> of the next remaining argument.
</p></dd></dl>

<p>Since long option names were used before before the <code>getopt_long</code>
options was invented there are program interfaces which require programs
to recognize options like &lsquo;<samp>-option value</samp>&rsquo; instead of
&lsquo;<samp>--option value</samp>&rsquo;.  To enable these programs to use the GNU
getopt functionality there is one more function available.
</p>
<dl>
<dt><u>Function:</u> int <b>getopt_long_only</b><i> (int <var>argc</var>, char *const *<var>argv</var>, const char *<var>shortopts</var>, const struct option *<var>longopts</var>, int *<var>indexptr</var>)</i>
<a name="IDX2560"></a>
</dt>
<dd><p>The <code>getopt_long_only</code> function is equivalent to the
<code>getopt_long</code> function but it allows to specify the user of the
application to pass long options with only &lsquo;<samp>-</samp>&rsquo; instead of
&lsquo;<samp>--</samp>&rsquo;.  The &lsquo;<samp>--</samp>&rsquo; prefix is still recognized but instead of
looking through the short options if a &lsquo;<samp>-</samp>&rsquo; is seen it is first
tried whether this parameter names a long option.  If not, it is parsed
as a short option.
</p>
<p>Assuming <code>getopt_long_only</code> is used starting an application with
</p>
<table><tr><td>&nbsp;</td><td><pre class="smallexample">  app -foo
</pre></td></tr></table>

<p>the <code>getopt_long_only</code> will first look for a long option named
&lsquo;<samp>foo</samp>&rsquo;.  If this is not found, the short options &lsquo;<samp>f</samp>&rsquo;, &lsquo;<samp>o</samp>&rsquo;,
and again &lsquo;<samp>o</samp>&rsquo; are recognized.
</p></dd></dl>

<hr size="6">
<a name="Getopt-Long-Option-Example"></a>
<a name="SEC533"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC532" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC534" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC525" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC529" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="libc_26.html#SEC568" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="libc.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="libc_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="libc_42.html#SEC712" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="libc_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h3 class="subsection"> 25.2.4 Example of Parsing Long Options with <code>getopt_long</code> </h3>

<table><tr><td>&nbsp;</td><td><pre class="smallexample">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;getopt.h&gt;

/* <span class="roman">Flag set by &lsquo;<samp>--verbose</samp>&rsquo;.</span> */
static int verbose_flag;

int
main (argc, argv)
     int argc;
     char **argv;
{
  int c;

  while (1)
    {
      static struct option long_options[] =
        {
          /* <span class="roman">These options set a flag.</span> */
          {&quot;verbose&quot;, no_argument,       &amp;verbose_flag, 1},
          {&quot;brief&quot;,   no_argument,       &amp;verbose_flag, 0},
          /* <span class="roman">These options don't set a flag.
             We distinguish them by their indices.</span> */
          {&quot;add&quot;,     no_argument,       0, 'a'},
          {&quot;append&quot;,  no_argument,       0, 'b'},
          {&quot;delete&quot;,  required_argument, 0, 'd'},
          {&quot;create&quot;,  required_argument, 0, 'c'},
          {&quot;file&quot;,    required_argument, 0, 'f'},
          {0, 0, 0, 0}
        };
      /* <span class="roman"><code>getopt_long</code> stores the option index here.</span> */
      int option_index = 0;

      c = getopt_long (argc, argv, &quot;abc:d:f:&quot;,
                       long_options, &amp;option_index);

      /* <span class="roman">Detect the end of the options.</span> */
      if (c == -1)
        break;

      switch (c)
        {
        case 0:
          /* <span class="roman">If this option set a flag, do nothing else now.</span> */
          if (long_options[option_index].flag != 0)
            break;
          printf (&quot;option %s&quot;, long_options[option_index].name);
          if (optarg)
            printf (&quot; with arg %s&quot;, optarg);
          printf (&quot;\n&quot;);
          break;

        case 'a':
          puts (&quot;option -a\n&quot;);
          break;

        case 'b':
          puts (&quot;option -b\n&quot;);
          break;

        case 'c':
          printf (&quot;option -c with value `%s'\n&quot;, optarg);
          break;

        case 'd':
          printf (&quot;option -d with value `%s'\n&quot;, optarg);
          break;

        case 'f':
          printf (&quot;option -f with value `%s'\n&quot;, optarg);
          break;

        case '?':
          /* <span class="roman"><code>getopt_long</code> already printed an error message.</span> */
          break;

        default:
          abort ();
        }
    }

  /* <span class="roman">Instead of reporting &lsquo;<samp>--verbose</samp>&rsquo;
     and &lsquo;<samp>--brief</samp>&rsquo; as they are encountered,
     we report the final status resulting from them.</span> */
  if (verbose_flag)
    puts (&quot;verbose flag is set&quot;);

  /* <span class="roman">Print any remaining command line arguments (not options).</span> */
  if (optind &lt; argc)
    {
      printf (&quot;non-option ARGV-elements: &quot;);
      while (optind &lt; argc)
        printf (&quot;%s &quot;, argv[optind++]);
      putchar ('\n');
    }

  exit (0);
}
</pre></td></tr></table>
<hr size="6">
<a name="Argp"></a>
<a name="SEC534"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC533" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC535" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC525" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC525" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="libc_26.html#SEC568" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="libc.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="libc_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="libc_42.html#SEC712" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="libc_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="section"> 25.3 Parsing Program Options with Argp </h2>

<p><em>Argp</em> is an interface for parsing unix-style argument vectors.
See section <a href="#SEC526">Program Arguments</a>.
</p>
<p>Argp provides features unavailable in the more commonly used
<code>getopt</code> interface.  These features include automatically producing
output in response to the &lsquo;<samp>--help</samp>&rsquo; and &lsquo;<samp>--version</samp>&rsquo; options, as
described in the GNU coding standards.  Using argp makes it less likely
that programmers will neglect to implement these additional options or
keep them up to date.
</p>
<p>Argp also provides the ability to merge several independently defined
option parsers into one, mediating conflicts between them and making the
result appear seamless.  A library can export an argp option parser that
user programs might employ in conjunction with their own option parsers,
resulting in less work for the user programs.  Some programs may use only
argument parsers exported by libraries, thereby achieving consistent and
efficient option-parsing for abstractions implemented by the libraries.
</p>
<a name="IDX2561"></a>
<p>The header file &lsquo;<tt>&lt;argp.h&gt;</tt>&rsquo; should be included to use argp.
</p>
<hr size="6">
<a name="SEC535"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC534" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC536" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC525" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC534" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="libc_26.html#SEC568" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="libc.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="libc_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="libc_42.html#SEC712" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="libc_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h3 class="subsection"> 25.3.1 The <code>argp_parse</code> Function </h3>

<p>The main interface to argp is the <code>argp_parse</code> function.  In many
cases, calling <code>argp_parse</code> is the only argument-parsing code
needed in <code>main</code>.
See section <a href="#SEC526">Program Arguments</a>.
</p>
<dl>
<dt><u>Function:</u> error_t <b>argp_parse</b><i> (const struct argp *<var>argp</var>, int <var>argc</var>, char **<var>argv</var>, unsigned <var>flags</var>, int *<var>arg_index</var>, void *<var>input</var>)</i>
<a name="IDX2562"></a>
</dt>
<dd><p>The <code>argp_parse</code> function parses the arguments in <var>argv</var>, of
length <var>argc</var>, using the argp parser <var>argp</var>.  See section <a href="#SEC537">Specifying Argp Parsers</a>.
</p>
<p>A value of zero is the same as a <code>struct argp</code>containing all
zeros.  <var>flags</var> is a set of flag bits that modify the parsing
behavior.  See section <a href="#SEC545">Flags for <code>argp_parse</code></a>.  <var>input</var> is passed through to the argp
parser <var>argp</var>, and has meaning defined by <var>argp</var>.  A typical
usage is to pass a pointer to a structure which is used for specifying
parameters to the parser and passing back the results.
</p>
<p>Unless the <code>ARGP_NO_EXIT</code> or <code>ARGP_NO_HELP</code> flags are included
in <var>flags</var>, calling <code>argp_parse</code> may result in the program
exiting.  This behavior is true if an error is detected, or when an
unknown option is encountered.  See section <a href="#SEC562">Program Termination</a>.
</p>
<p>If <var>arg_index</var> is non-null, the index of the first unparsed option
in <var>argv</var> is returned as a value.
</p>
<p>The return value is zero for successful parsing, or an error code
(see section <a href="libc_2.html#SEC17">Error Codes</a>) if an error is detected.  Different argp parsers
may return arbitrary error codes, but the standard error codes are:
<code>ENOMEM</code> if a memory allocation error occurred, or <code>EINVAL</code> if
an unknown option or option argument is encountered.
</p></dd></dl>

<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top"><a href="#SEC536">25.3.2 Argp Global Variables</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">  Global argp parameters.
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC537">25.3.3 Specifying Argp Parsers</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">        Defining parsers for use with <code>argp_parse</code>.
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC545">25.3.7 Flags for <code>argp_parse</code></a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">            Flags that modify the behavior of <code>argp_parse</code>.
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC548">25.3.9 The <code>argp_help</code> Function</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">              Printing help messages when not parsing.
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC550">25.3.11 Argp Examples</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">      Simple examples of programs using argp.
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC555">25.3.12 Argp User Customization</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
                                Users may control the &lsquo;<samp>--help</samp>&rsquo; output format.
</td></tr>
</table>

<hr size="6">
<a name="Argp-Global-Variables"></a>
<a name="SEC536"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC535" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC537" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC525" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC534" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="libc_26.html#SEC568" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="libc.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="libc_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="libc_42.html#SEC712" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="libc_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h3 class="subsection"> 25.3.2 Argp Global Variables </h3>

<p>These variables make it easy for user programs to implement the
&lsquo;<samp>--version</samp>&rsquo; option and provide a bug-reporting address in the
&lsquo;<samp>--help</samp>&rsquo; output.  These are implemented in argp by default.
</p>
<dl>
<dt><u>Variable:</u> const char * <b>argp_program_version</b>
<a name="IDX2563"></a>
</dt>
<dd><p>If defined or set by the user program to a non-zero value, then a
&lsquo;<samp>--version</samp>&rsquo; option is added when parsing with <code>argp_parse</code>,
which will print the &lsquo;<samp>--version</samp>&rsquo; string followed by a newline and
exit.  The exception to this is if the <code>ARGP_NO_EXIT</code> flag is used.
</p></dd></dl>

<dl>
<dt><u>Variable:</u> const char * <b>argp_program_bug_address</b>
<a name="IDX2564"></a>
</dt>
<dd><p>If defined or set by the user program to a non-zero value,
<code>argp_program_bug_address</code> should point to a string that will be
printed at the end of the standard output for the &lsquo;<samp>--help</samp>&rsquo; option,
embedded in a sentence that says &lsquo;<samp>Report bugs to <var>address</var>.</samp>&rsquo;.
</p></dd></dl>

<dl>
<dt><u>Variable:</u> <b>argp_program_version_hook</b>
<a name="IDX2565"></a>
</dt>
<dd><p>If defined or set by the user program to a non-zero value, a
&lsquo;<samp>--version</samp>&rsquo; option is added when parsing with <code>arg_parse</code>,
which prints the program version and exits with a status of zero.  This
is not the case if the <code>ARGP_NO_HELP</code> flag is used.  If the
<code>ARGP_NO_EXIT</code> flag is set, the exit behavior of the program is
suppressed or modified, as when the argp parser is going to be used by
other programs.
</p>
<p>It should point to a function with this type of signature:
</p>
<table><tr><td>&nbsp;</td><td><pre class="smallexample">void <var>print-version</var> (FILE *<var>stream</var>, struct argp_state *<var>state</var>)
</pre></td></tr></table>

<p>See section <a href="#SEC543">Argp Parsing State</a>, for an explanation of <var>state</var>.
</p>
<p>This variable takes precedence over <code>argp_program_version</code>, and is
useful if a program has version information not easily expressed in a
simple string.
</p></dd></dl>

<dl>
<dt><u>Variable:</u> error_t <b>argp_err_exit_status</b>
<a name="IDX2566"></a>
</dt>
<dd><p>This is the exit status used when argp exits due to a parsing error.  If
not defined or set by the user program, this defaults to:
<code>EX_USAGE</code> from &lsquo;<tt>&lt;sysexits.h&gt;</tt>&rsquo;.
</p></dd></dl>

<hr size="6">
<a name="Argp-Parsers"></a>
<a name="SEC537"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC536" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC538" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC525" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC534" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="libc_26.html#SEC568" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="libc.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="libc_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="libc_42.html#SEC712" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="libc_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h3 class="subsection"> 25.3.3 Specifying Argp Parsers </h3>

<p>The first argument to the <code>argp_parse</code> function is a pointer to a
<code>struct argp</code>, which is known as an <em>argp parser</em>:
</p>
<dl>
<dt><u>Data Type:</u> <b>struct argp</b>
<a name="IDX2567"></a>
</dt>
<dd><p>This structure specifies how to parse a given set of options and
arguments, perhaps in conjunction with other argp parsers.  It has the
following fields:
</p>
<dl compact="compact">
<dt> <code>const struct argp_option *options</code></dt>
<dd><p>A pointer to a vector of <code>argp_option</code> structures specifying which
options this argp parser understands; it may be zero if there are no
options at all.  See section <a href="#SEC538">Specifying Options in an Argp Parser</a>.
</p>
</dd>
<dt> <code>argp_parser_t parser</code></dt>
<dd><p>A pointer to a function that defines actions for this parser; it is
called for each option parsed, and at other well-defined points in the
parsing process.  A value of zero is the same as a pointer to a function
that always returns <code>ARGP_ERR_UNKNOWN</code>.  See section <a href="#SEC540">Argp Parser Functions</a>.
</p>
</dd>
<dt> <code>const char *args_doc</code></dt>
<dd><p>If non-zero, a string describing what non-option arguments are called by
this parser.  This is only used to print the &lsquo;<samp>Usage:</samp>&rsquo; message.  If
it contains newlines, the strings separated by them are considered
alternative usage patterns and printed on separate lines.  Lines after
the first are prefixed by &lsquo;<samp> or: </samp>&rsquo; instead of &lsquo;<samp>Usage:</samp>&rsquo;.
</p>
</dd>
<dt> <code>const char *doc</code></dt>
<dd><p>If non-zero, a string containing extra text to be printed before and
after the options in a long help message, with the two sections
separated by a vertical tab (<code>'\v'</code>, <code>'\013'</code>) character.  By
convention, the documentation before the options is just a short string
explaining what the program does.  Documentation printed after the
options describe behavior in more detail.
</p>
</dd>
<dt> <code>const struct argp_child *children</code></dt>
<dd><p>A pointer to a vector of <code>argp_children</code> structures.  This pointer
specifies which additional argp parsers should be combined with this
one.  See section <a href="#SEC544">Combining Multiple Argp Parsers</a>.
</p>
</dd>
<dt> <code>char *(*help_filter)(int <var>key</var>, const char *<var>text</var>, void *<var>input</var>)</code></dt>
<dd><p>If non-zero, a pointer to a function that filters the output of help
messages.  See section <a href="#SEC546">Customizing Argp Help Output</a>.
</p>
</dd>
<dt> <code>const char *argp_domain</code></dt>
<dd><p>If non-zero, the strings used in the argp library are translated using
the domain described by this string.  If zero, the current default domain
is used.
</p>
</dd>
</dl>
</dd></dl>

<p>Of the above group, <code>options</code>, <code>parser</code>, <code>args_doc</code>, and
the <code>doc</code> fields are usually all that are needed.  If an argp
parser is defined as an initialized C variable, only the fields used
need be specified in the initializer.  The rest will default to zero due
to the way C structure initialization works.  This design is exploited in
most argp structures; the most-used fields are grouped near the
beginning, the unused fields left unspecified.
</p>
<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top"><a href="#SEC538">25.3.4 Specifying Options in an Argp Parser</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">   Specifying options in an argp parser.
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC540">25.3.5 Argp Parser Functions</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">         Defining actions for an argp parser.
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC544">25.3.6 Combining Multiple Argp Parsers</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">        Combining multiple argp parsers.
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC546">25.3.8 Customizing Argp Help Output</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">  Customizing help output for an argp parser.
</td></tr>
</table>

<hr size="6">
<a name="Argp-Option-Vectors"></a>
<a name="SEC538"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC537" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC539" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC525" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC534" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="libc_26.html#SEC568" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="libc.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="libc_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="libc_42.html#SEC712" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="libc_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h3 class="subsection"> 25.3.4 Specifying Options in an Argp Parser </h3>

<p>The <code>options</code> field in a <code>struct argp</code> points to a vector of
<code>struct argp_option</code> structures, each of which specifies an option
that the argp parser supports.  Multiple entries may be used for a single
option provided it has multiple names.  This should be terminated by an
entry with zero in all fields.  Note that when using an initialized C
array for options, writing <code>{ 0 }</code> is enough to achieve this.
</p>
<dl>
<dt><u>Data Type:</u> <b>struct argp_option</b>
<a name="IDX2568"></a>
</dt>
<dd><p>This structure specifies a single option that an argp parser
understands, as well as how to parse and document that option.  It has
the following fields:
</p>
<dl compact="compact">
<dt> <code>const char *name</code></dt>
<dd><p>The long name for this option, corresponding to the long option
&lsquo;<samp>--<var>name</var></samp>&rsquo;; this field may be zero if this option <em>only</em>
has a short name.  To specify multiple names for an option, additional
entries may follow this one, with the <code>OPTION_ALIAS</code> flag
set.  See section <a href="#SEC539">Flags for Argp Options</a>.
</p>
</dd>
<dt> <code>int key</code></dt>
<dd><p>The integer key provided by the current option to the option parser.  If
<var>key</var> has a value that is a printable <small>ASCII</small> character (i.e.,
<code>isascii (<var>key</var>)</code> is true), it <em>also</em> specifies a short
option &lsquo;<samp>-<var>char</var></samp>&rsquo;, where <var>char</var> is the <small>ASCII</small> character
with the code <var>key</var>.
</p>
</dd>
<dt> <code>const char *arg</code></dt>
<dd><p>If non-zero, this is the name of an argument associated with this
option, which must be provided (e.g., with the
&lsquo;<samp>--<var>name</var>=<var>value</var></samp>&rsquo; or &lsquo;<samp>-<var>char</var> <var>value</var></samp>&rsquo;
syntaxes), unless the <code>OPTION_ARG_OPTIONAL</code> flag (see section <a href="#SEC539">Flags for Argp Options</a>) is set, in which case it <em>may</em> be provided.
</p>
</dd>
<dt> <code>int flags</code></dt>
<dd><p>Flags associated with this option, some of which are referred to above.
See section <a href="#SEC539">Flags for Argp Options</a>.
</p>
</dd>
<dt> <code>const char *doc</code></dt>
<dd><p>A documentation string for this option, for printing in help messages.
</p>
<p>If both the <code>name</code> and <code>key</code> fields are zero, this string
will be printed tabbed left from the normal option column, making it
useful as a group header.  This will be the first thing printed in its
group.  In this usage, it's conventional to end the string with a
&lsquo;<samp>:</samp>&rsquo; character.
</p>
</dd>
<dt> <code>int group</code></dt>
<dd><p>Group identity for this option.
</p>
<p>In a long help message, options are sorted alphabetically within each
group, and the groups presented in the order 0, 1, 2, &hellip;, <var>n</var>,
-<var>m</var>, &hellip;, -2, -1.
</p>
<p>Every entry in an options array with this field 0 will inherit the group
number of the previous entry, or zero if it's the first one.  If it's a
group header with <code>name</code> and <code>key</code> fields both zero, the
previous entry + 1 is the default.  Automagic options such as
&lsquo;<samp>--help</samp>&rsquo; are put into group -1.
</p>
<p>Note that because of C structure initialization rules, this field often
need not be specified, because 0 is the correct value.
</p></dd>
</dl>
</dd></dl>


<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top"><a href="#SEC539">25.3.4.1 Flags for Argp Options</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">     Flags for options.
</td></tr>
</table>

<hr size="6">
<a name="Argp-Option-Flags"></a>
<a name="SEC539"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC538" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC540" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC525" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC538" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="libc_26.html#SEC568" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="libc.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="libc_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="libc_42.html#SEC712" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="libc_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h4 class="subsubsection"> 25.3.4.1 Flags for Argp Options </h4>

<p>The following flags may be or'd together in the <code>flags</code> field of a
<code>struct argp_option</code>.  These flags control various aspects of how
that option is parsed or displayed in help messages:
</p>

<dl compact="compact">
<dt> <code>OPTION_ARG_OPTIONAL</code>
<a name="IDX2569"></a>
</dt>
<dd><p>The argument associated with this option is optional.
</p>
</dd>
<dt> <code>OPTION_HIDDEN</code>
<a name="IDX2570"></a>
</dt>
<dd><p>This option isn't displayed in any help messages.
</p>
</dd>
<dt> <code>OPTION_ALIAS</code>
<a name="IDX2571"></a>
</dt>
<dd><p>This option is an alias for the closest previous non-alias option.  This
means that it will be displayed in the same help entry, and will inherit
fields other than <code>name</code> and <code>key</code> from the option being
aliased.
</p>

</dd>
<dt> <code>OPTION_DOC</code>
<a name="IDX2572"></a>
</dt>
<dd><p>This option isn't actually an option and should be ignored by the actual
option parser.  It is an arbitrary section of documentation that should
be displayed in much the same manner as the options.  This is known as a
<em>documentation option</em>.
</p>
<p>If this flag is set, then the option <code>name</code> field is displayed
unmodified (e.g., no &lsquo;<samp>--</samp>&rsquo; prefix is added) at the left-margin where
a <em>short</em> option would normally be displayed, and this
documentation string is left in it's usual place.  For purposes of
sorting, any leading whitespace and punctuation is ignored, unless the
first non-whitespace character is &lsquo;<samp>-</samp>&rsquo;.  This entry is displayed
after all options, after <code>OPTION_DOC</code> entries with a leading
&lsquo;<samp>-</samp>&rsquo;, in the same group.
</p>
</dd>
<dt> <code>OPTION_NO_USAGE</code>
<a name="IDX2573"></a>
</dt>
<dd><p>This option shouldn't be included in `long' usage messages, but should
still be included in other help messages.  This is intended for options
that are completely documented in an argp's <code>args_doc</code>
field.  See section <a href="#SEC537">Specifying Argp Parsers</a>.  Including this option in the generic usage
list would be redundant, and should be avoided.
</p>
<p>For instance, if <code>args_doc</code> is <code>&quot;FOO BAR\n-x BLAH&quot;</code>, and the
&lsquo;<samp>-x</samp>&rsquo; option's purpose is to distinguish these two cases, &lsquo;<samp>-x</samp>&rsquo;
should probably be marked <code>OPTION_NO_USAGE</code>.
</p></dd>
</dl>

<hr size="6">
<a name="Argp-Parser-Functions"></a>
<a name="SEC540"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC539" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC541" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC525" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC534" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="libc_26.html#SEC568" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="libc.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="libc_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="libc_42.html#SEC712" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="libc_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h3 class="subsection"> 25.3.5 Argp Parser Functions </h3>

<p>The function pointed to by the <code>parser</code> field in a <code>struct
argp</code> (see section <a href="#SEC537">Specifying Argp Parsers</a>) defines what actions take place in response
to each option or argument parsed.  It is also used as a hook, allowing a
parser to perform tasks at certain other points during parsing.
</p>
<p>Argp parser functions have the following type signature:
</p>
<a name="IDX2574"></a>
<table><tr><td>&nbsp;</td><td><pre class="smallexample">error_t <var>parser</var> (int <var>key</var>, char *<var>arg</var>, struct argp_state *<var>state</var>)
</pre></td></tr></table>

<p>where the arguments are as follows:
</p>
<dl compact="compact">
<dt> <var>key</var></dt>
<dd><p>For each option that is parsed, <var>parser</var> is called with a value of
<var>key</var> from that option's <code>key</code> field in the option
vector.  See section <a href="#SEC538">Specifying Options in an Argp Parser</a>.  <var>parser</var> is also called at
other times with special reserved keys, such as <code>ARGP_KEY_ARG</code> for
non-option arguments.  See section <a href="#SEC541">Special Keys for Argp Parser Functions</a>.
</p>
</dd>
<dt> <var>arg</var></dt>
<dd><p>If <var>key</var> is an option, <var>arg</var> is its given value.  This defaults
to zero if no value is specified.  Only options that have a non-zero
<code>arg</code> field can ever have a value.  These must <em>always</em> have a
value unless the <code>OPTION_ARG_OPTIONAL</code> flag is specified.  If the
input being parsed specifies a value for an option that doesn't allow
one, an error results before <var>parser</var> ever gets called.
</p>
<p>If <var>key</var> is <code>ARGP_KEY_ARG</code>, <var>arg</var> is a non-option
argument.  Other special keys always have a zero <var>arg</var>.
</p>
</dd>
<dt> <var>state</var></dt>
<dd><p><var>state</var> points to a <code>struct argp_state</code>, containing useful
information about the current parsing state for use by
<var>parser</var>.  See section <a href="#SEC543">Argp Parsing State</a>.
</p></dd>
</dl>

<p>When <var>parser</var> is called, it should perform whatever action is
appropriate for <var>key</var>, and return <code>0</code> for success,
<code>ARGP_ERR_UNKNOWN</code> if the value of <var>key</var> is not handled by this
parser function, or a unix error code if a real error
occurred.  See section <a href="libc_2.html#SEC17">Error Codes</a>.
</p>
<dl>
<dt><u>Macro:</u> int <b>ARGP_ERR_UNKNOWN</b>
<a name="IDX2575"></a>
</dt>
<dd><p>Argp parser functions should return <code>ARGP_ERR_UNKNOWN</code> for any
<var>key</var> value they do not recognize, or for non-option arguments
(<code><var>key</var> == ARGP_KEY_ARG</code>) that they are not equipped to handle.
</p></dd></dl>

<p>A typical parser function uses a switch statement on <var>key</var>:
</p>
<table><tr><td>&nbsp;</td><td><pre class="smallexample">error_t
parse_opt (int key, char *arg, struct argp_state *state)
{
  switch (key)
    {
    case <var>option_key</var>:
      <var>action</var>
      break;
    &hellip;
    default:
      return ARGP_ERR_UNKNOWN;
    }
  return 0;
}
</pre></td></tr></table>

<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top"><a href="#SEC541">25.3.5.1 Special Keys for Argp Parser Functions</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">           Special values for the <var>key</var> argument.
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC543">25.3.5.3 Argp Parsing State</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">         What the <var>state</var> argument refers to.
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC542">25.3.5.2 Functions For Use in Argp Parsers</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">  Functions to help during argp parsing.
</td></tr>
</table>

<hr size="6">
<a name="Argp-Special-Keys"></a>
<a name="SEC541"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC540" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC542" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC525" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC540" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="libc_26.html#SEC568" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="libc.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="libc_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="libc_42.html#SEC712" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="libc_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h4 class="subsubsection"> 25.3.5.1 Special Keys for Argp Parser Functions </h4>

<p>In addition to key values corresponding to user options, the <var>key</var>
argument to argp parser functions may have a number of other special
values.  In the following example <var>arg</var> and <var>state</var> refer to
parser function arguments.  See section <a href="#SEC540">Argp Parser Functions</a>.
</p>
<dl compact="compact">
<dt> <code>ARGP_KEY_ARG</code>
<a name="IDX2576"></a>
</dt>
<dd><p>This is not an option at all, but rather a command line argument, whose
value is pointed to by <var>arg</var>.
</p>
<p>When there are multiple parser functions in play due to argp parsers
being combined, it's impossible to know which one will handle a specific
argument.  Each is called until one returns 0 or an error other than
<code>ARGP_ERR_UNKNOWN</code>; if an argument is not handled,
<code>argp_parse</code> immediately returns success, without parsing any more
arguments.
</p>
<p>Once a parser function returns success for this key, that fact is
recorded, and the <code>ARGP_KEY_NO_ARGS</code> case won't be
used.  <em>However</em>, if while processing the argument a parser function
decrements the <code>next</code> field of its <var>state</var> argument, the option
won't be considered processed; this is to allow you to actually modify
the argument, perhaps into an option, and have it processed again.
</p>
</dd>
<dt> <code>ARGP_KEY_ARGS</code>
<a name="IDX2577"></a>
</dt>
<dd><p>If a parser function returns <code>ARGP_ERR_UNKNOWN</code> for
<code>ARGP_KEY_ARG</code>, it is immediately called again with the key
<code>ARGP_KEY_ARGS</code>, which has a similar meaning, but is slightly more
convenient for consuming all remaining arguments.  <var>arg</var> is 0, and
the tail of the argument vector may be found at <code><var>state</var>-&gt;argv
+ <var>state</var>-&gt;next</code>.  If success is returned for this key, and
<code><var>state</var>-&gt;next</code> is unchanged, all remaining arguments are
considered to have been consumed.  Otherwise, the amount by which
<code><var>state</var>-&gt;next</code> has been adjusted indicates how many were used.
Here's an example that uses both, for different args:
</p>

<table><tr><td>&nbsp;</td><td><pre class="smallexample">&hellip;
case ARGP_KEY_ARG:
  if (<var>state</var>-&gt;arg_num == 0)
    /* First argument */
    first_arg = <var>arg</var>;
  else
    /* Let the next case parse it.  */
    return ARGP_KEY_UNKNOWN;
  break;
case ARGP_KEY_ARGS:
  remaining_args = <var>state</var>-&gt;argv + <var>state</var>-&gt;next;
  num_remaining_args = <var>state</var>-&gt;argc - <var>state</var>-&gt;next;
  break;
</pre></td></tr></table>

</dd>
<dt> <code>ARGP_KEY_END</code>
<a name="IDX2578"></a>
</dt>
<dd><p>This indicates that there are no more command line arguments.  Parser
functions are called in a different order, children first.  This allows
each parser to clean up its state for the parent.
</p>
</dd>
<dt> <code>ARGP_KEY_NO_ARGS</code>
<a name="IDX2579"></a>
</dt>
<dd><p>Because it's common to do some special processing if there aren't any
non-option args, parser functions are called with this key if they
didn't successfully process any non-option arguments.  This is called
just before <code>ARGP_KEY_END</code>, where more general validity checks on
previously parsed arguments take place.
</p>
</dd>
<dt> <code>ARGP_KEY_INIT</code>
<a name="IDX2580"></a>
</dt>
<dd><p>This is passed in before any parsing is done.  Afterwards, the values of
each element of the <code>child_input</code> field of <var>state</var>, if any, are
copied to each child's state to be the initial value of the <code>input</code>
when <em>their</em> parsers are called.
</p>
</dd>
<dt> <code>ARGP_KEY_SUCCESS</code>
<a name="IDX2581"></a>
</dt>
<dd><p>Passed in when parsing has successfully been completed, even if
arguments remain.
</p>
</dd>
<dt> <code>ARGP_KEY_ERROR</code>
<a name="IDX2582"></a>
</dt>
<dd><p>Passed in if an error has occurred and parsing is terminated.  In this
case a call with a key of <code>ARGP_KEY_SUCCESS</code> is never made.
</p>
</dd>
<dt> <code>ARGP_KEY_FINI</code>
<a name="IDX2583"></a>
</dt>
<dd><p>The final key ever seen by any parser, even after
<code>ARGP_KEY_SUCCESS</code> and <code>ARGP_KEY_ERROR</code>.  Any resources
allocated by <code>ARGP_KEY_INIT</code> may be freed here.  At times, certain
resources allocated are to be returned to the caller after a successful
parse.  In that case, those particular resources can be freed in the
<code>ARGP_KEY_ERROR</code> case.
</p></dd>
</dl>

<p>In all cases, <code>ARGP_KEY_INIT</code> is the first key seen by parser
functions, and <code>ARGP_KEY_FINI</code> the last, unless an error was
returned by the parser for <code>ARGP_KEY_INIT</code>.  Other keys can occur
in one the following orders.  <var>opt</var> refers to an arbitrary option
key:
</p>
<dl compact="compact">
<dt> <var>opt</var>&hellip; <code>ARGP_KEY_NO_ARGS</code> <code>ARGP_KEY_END</code> <code>ARGP_KEY_SUCCESS</code></dt>
<dd><p>The arguments being parsed did not contain any non-option arguments.
</p>
</dd>
<dt> ( <var>opt</var> | <code>ARGP_KEY_ARG</code> )&hellip; <code>ARGP_KEY_END</code> <code>ARGP_KEY_SUCCESS</code></dt>
<dd><p>All non-option arguments were successfully handled by a parser
function.  There may be multiple parser functions if multiple argp
parsers were combined.
</p>
</dd>
<dt> ( <var>opt</var> | <code>ARGP_KEY_ARG</code> )&hellip; <code>ARGP_KEY_SUCCESS</code></dt>
<dd><p>Some non-option argument went unrecognized.
</p>
<p>This occurs when every parser function returns <code>ARGP_KEY_UNKNOWN</code>
for an argument, in which case parsing stops at that argument if
<var>arg_index</var> is a null pointer.  Otherwise an error occurs.
</p></dd>
</dl>

<p>In all cases, if a non-null value for <var>arg_index</var> gets passed to
<code>argp_parse</code>, the index of the first unparsed command-line argument
is passed back in that value.
</p>
<p>If an error occurs and is either detected by argp or because a parser
function returned an error value, each parser is called with
<code>ARGP_KEY_ERROR</code>.  No further calls are made, except the final call
with <code>ARGP_KEY_FINI</code>.
</p>
<hr size="6">
<a name="Argp-Helper-Functions"></a>
<a name="SEC542"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC541" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC543" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC525" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC540" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="libc_26.html#SEC568" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="libc.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="libc_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="libc_42.html#SEC712" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="libc_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h4 class="subsubsection"> 25.3.5.2 Functions For Use in Argp Parsers </h4>

<p>Argp provides a number of functions available to the user of argp
(see section <a href="#SEC540">Argp Parser Functions</a>), mostly for producing error messages.
These take as their first argument the <var>state</var> argument to the
parser function.  See section <a href="#SEC543">Argp Parsing State</a>.
</p>

<a name="IDX2584"></a>
<dl>
<dt><u>Function:</u> void <b>argp_usage</b><i> (const struct argp_state *<var>state</var>)</i>
<a name="IDX2585"></a>
</dt>
<dd><p>Outputs the standard usage message for the argp parser referred to by
<var>state</var> to <code><var>state</var>-&gt;err_stream</code> and terminate the program
with <code>exit (argp_err_exit_status)</code>.  See section <a href="#SEC536">Argp Global Variables</a>.
</p></dd></dl>

<a name="IDX2586"></a>
<dl>
<dt><u>Function:</u> void <b>argp_error</b><i> (const struct argp_state *<var>state</var>, const char *<var>fmt</var>, &hellip;)</i>
<a name="IDX2587"></a>
</dt>
<dd><p>Prints the printf format string <var>fmt</var> and following args, preceded
by the program name and &lsquo;<samp>:</samp>&rsquo;, and followed by a &lsquo;<samp>Try &hellip;
--help</samp>&rsquo; message, and terminates the program with an exit status of
<code>argp_err_exit_status</code>.  See section <a href="#SEC536">Argp Global Variables</a>.
</p></dd></dl>

<a name="IDX2588"></a>
<dl>
<dt><u>Function:</u> void <b>argp_failure</b><i> (const struct argp_state *<var>state</var>, int <var>status</var>, int <var>errnum</var>, const char *<var>fmt</var>, &hellip;)</i>
<a name="IDX2589"></a>
</dt>
<dd><p>Similar to the standard gnu error-reporting function <code>error</code>, this
prints the program name and &lsquo;<samp>:</samp>&rsquo;, the printf format string
<var>fmt</var>, and the appropriate following args.  If it is non-zero, the
standard unix error text for <var>errnum</var> is printed.  If <var>status</var> is
non-zero, it terminates the program with that value as its exit status.
</p>
<p>The difference between <code>argp_failure</code> and <code>argp_error</code> is that
<code>argp_error</code> is for <em>parsing errors</em>, whereas
<code>argp_failure</code> is for other problems that occur during parsing but
don't reflect a syntactic problem with the input, such as illegal values
for options, bad phase of the moon, etc.
</p></dd></dl>

<dl>
<dt><u>Function:</u> void <b>argp_state_help</b><i> (const struct argp_state *<var>state</var>, FILE *<var>stream</var>, unsigned <var>flags</var>)</i>
<a name="IDX2590"></a>
</dt>
<dd><p>Outputs a help message for the argp parser referred to by <var>state</var>,
to <var>stream</var>.  The <var>flags</var> argument determines what sort of help
message is produced.  See section <a href="#SEC549">Flags for the <code>argp_help</code> Function</a>.
</p></dd></dl>

<p>Error output is sent to <code><var>state</var>-&gt;err_stream</code>, and the program
name printed is <code><var>state</var>-&gt;name</code>.
</p>
<p>The output or program termination behavior of these functions may be
suppressed if the <code>ARGP_NO_EXIT</code> or <code>ARGP_NO_ERRS</code> flags are
passed to <code>argp_parse</code>.  See section <a href="#SEC545">Flags for <code>argp_parse</code></a>.
</p>
<p>This behavior is useful if an argp parser is exported for use by other
programs (e.g., by a library), and may be used in a context where it is
not desirable to terminate the program in response to parsing errors.  In
argp parsers intended for such general use, and for the case where the
program <em>doesn't</em> terminate, calls to any of these functions should
be followed by code that returns the appropriate error code:
</p>
<table><tr><td>&nbsp;</td><td><pre class="smallexample">if (<var>bad argument syntax</var>)
  {
     argp_usage (<var>state</var>);
     return EINVAL;
  }
</pre></td></tr></table>

<p>If a parser function will <em>only</em> be used when <code>ARGP_NO_EXIT</code>
is not set, the return may be omitted.
</p>
<hr size="6">
<a name="Argp-Parsing-State"></a>
<a name="SEC543"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC542" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC544" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC525" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC540" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="libc_26.html#SEC568" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="libc.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="libc_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="libc_42.html#SEC712" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="libc_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h4 class="subsubsection"> 25.3.5.3 Argp Parsing State </h4>

<p>The third argument to argp parser functions (see section <a href="#SEC540">Argp Parser Functions</a>) is a pointer to a <code>struct argp_state</code>, which contains
information about the state of the option parsing.
</p>
<dl>
<dt><u>Data Type:</u> <b>struct argp_state</b>
<a name="IDX2591"></a>
</dt>
<dd><p>This structure has the following fields, which may be modified as noted:
</p>
<dl compact="compact">
<dt> <code>const struct argp *const root_argp</code></dt>
<dd><p>The top level argp parser being parsed.  Note that this is often
<em>not</em> the same <code>struct argp</code> passed into <code>argp_parse</code> by
the invoking program.  See section <a href="#SEC534">Parsing Program Options with Argp</a>.  It is an internal argp parser that
contains options implemented by <code>argp_parse</code> itself, such as
&lsquo;<samp>--help</samp>&rsquo;.
</p>
</dd>
<dt> <code>int argc</code></dt>
<dt> <code>char **argv</code></dt>
<dd><p>The argument vector being parsed.  This may be modified.
</p>
</dd>
<dt> <code>int next</code></dt>
<dd><p>The index in <code>argv</code> of the next argument to be parsed.  This may be
modified.
</p>
<p>One way to consume all remaining arguments in the input is to set
<code><var>state</var>-&gt;next = <var>state</var>-&gt;argc</code>, perhaps after recording
the value of the <code>next</code> field to find the consumed arguments.  The
current option can be re-parsed immediately by decrementing this field,
then modifying <code><var>state</var>-&gt;argv[<var>state</var>-&gt;next]</code> to reflect
the option that should be reexamined.
</p>
</dd>
<dt> <code>unsigned flags</code></dt>
<dd><p>The flags supplied to <code>argp_parse</code>.  These may be modified, although
some flags may only take effect when <code>argp_parse</code> is first
invoked.  See section <a href="#SEC545">Flags for <code>argp_parse</code></a>.
</p>
</dd>
<dt> <code>unsigned arg_num</code></dt>
<dd><p>While calling a parsing function with the <var>key</var> argument
<code>ARGP_KEY_ARG</code>, this represents the number of the current arg,
starting at 0.  It is incremented after each <code>ARGP_KEY_ARG</code> call
returns.  At all other times, this is the number of <code>ARGP_KEY_ARG</code>
arguments that have been processed.
</p>
</dd>
<dt> <code>int quoted</code></dt>
<dd><p>If non-zero, the index in <code>argv</code> of the first argument following a
special &lsquo;<samp>--</samp>&rsquo; argument.  This prevents anything that follows from
being interpreted as an option.  It is only set after argument parsing
has proceeded past this point.
</p>
</dd>
<dt> <code>void *input</code></dt>
<dd><p>An arbitrary pointer passed in from the caller of <code>argp_parse</code>, in
the <var>input</var> argument.
</p>
</dd>
<dt> <code>void **child_inputs</code></dt>
<dd><p>These are values that will be passed to child parsers.  This vector will
be the same length as the number of children in the current parser.  Each
child parser will be given the value of
<code><var>state</var>-&gt;child_inputs[<var>i</var>]</code> as <em>its</em>
<code><var>state</var>-&gt;input</code> field, where <var>i</var> is the index of the child
in the this parser's <code>children</code> field.  See section <a href="#SEC544">Combining Multiple Argp Parsers</a>.
</p>
</dd>
<dt> <code>void *hook</code></dt>
<dd><p>For the parser function's use.  Initialized to 0, but otherwise ignored
by argp.
</p>
</dd>
<dt> <code>char *name</code></dt>
<dd><p>The name used when printing messages.  This is initialized to
<code>argv[0]</code>, or <code>program_invocation_name</code> if <code>argv[0]</code> is
unavailable.
</p>
</dd>
<dt> <code>FILE *err_stream</code></dt>
<dt> <code>FILE *out_stream</code></dt>
<dd><p>The stdio streams used when argp prints.  Error messages are printed to
<code>err_stream</code>, all other output, such as &lsquo;<samp>--help</samp>&rsquo; output) to
<code>out_stream</code>.  These are initialized to <code>stderr</code> and
<code>stdout</code> respectively.  See section <a href="libc_12.html#SEC179">Standard Streams</a>.
</p>
</dd>
<dt> <code>void *pstate</code></dt>
<dd><p>Private, for use by the argp implementation.
</p></dd>
</dl>
</dd></dl>

<hr size="6">
<a name="Argp-Children"></a>
<a name="SEC544"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC543" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC545" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC525" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC534" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="libc_26.html#SEC568" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="libc.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="libc_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="libc_42.html#SEC712" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="libc_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h3 class="subsection"> 25.3.6 Combining Multiple Argp Parsers </h3>

<p>The <code>children</code> field in a <code>struct argp</code> enables other argp
parsers to be combined with the referencing one for the parsing of a
single set of arguments.  This field should point to a vector of
<code>struct argp_child</code>, which is terminated by an entry having a value
of zero in the <code>argp</code> field.
</p>
<p>Where conflicts between combined parsers arise, as when two specify an
option with the same name, the parser conflicts are resolved in favor of
the parent argp parser(s), or the earlier of the argp parsers in the
list of children.
</p>
<dl>
<dt><u>Data Type:</u> <b>struct argp_child</b>
<a name="IDX2592"></a>
</dt>
<dd><p>An entry in the list of subsidiary argp parsers pointed to by the
<code>children</code> field in a <code>struct argp</code>.  The fields are as
follows:
</p>
<dl compact="compact">
<dt> <code>const struct argp *argp</code></dt>
<dd><p>The child argp parser, or zero to end of the list.
</p>
</dd>
<dt> <code>int flags</code></dt>
<dd><p>Flags for this child.
</p>
</dd>
<dt> <code>const char *header</code></dt>
<dd><p>If non-zero, this is an optional header to be printed within help output
before the child options.  As a side-effect, a non-zero value forces the
child options to be grouped together.  To achieve this effect without
actually printing a header string, use a value of <code>&quot;&quot;</code>.  As with
header strings specified in an option entry, the conventional value of
the last character is &lsquo;<samp>:</samp>&rsquo;.  See section <a href="#SEC538">Specifying Options in an Argp Parser</a>.
</p>
</dd>
<dt> <code>int group</code></dt>
<dd><p>This is where the child options are grouped relative to the other
`consolidated' options in the parent argp parser.  The values are the
same as the <code>group</code> field in <code>struct argp_option</code>.  See section <a href="#SEC538">Specifying Options in an Argp Parser</a>.  All child-groupings follow parent options at a
particular group level.  If both this field and <code>header</code> are zero,
then the child's options aren't grouped together, they are merged with
parent options at the parent option group level.
</p>
</dd>
</dl>
</dd></dl>

<hr size="6">
<a name="Argp-Flags"></a>
<a name="SEC545"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC544" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC546" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC525" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC534" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="libc_26.html#SEC568" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="libc.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="libc_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="libc_42.html#SEC712" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="libc_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h3 class="subsection"> 25.3.7 Flags for <code>argp_parse</code> </h3>

<p>The default behavior of <code>argp_parse</code> is designed to be convenient
for the most common case of parsing program command line argument.  To
modify these defaults, the following flags may be or'd together in the
<var>flags</var> argument to <code>argp_parse</code>:
</p>
<dl compact="compact">
<dt> <code>ARGP_PARSE_ARGV0</code>
<a name="IDX2593"></a>
</dt>
<dd><p>Don't ignore the first element of the <var>argv</var> argument to
<code>argp_parse</code>.  Unless <code>ARGP_NO_ERRS</code> is set, the first element
of the argument vector is skipped for option parsing purposes, as it
corresponds to the program name in a command line.
</p>
</dd>
<dt> <code>ARGP_NO_ERRS</code>
<a name="IDX2594"></a>
</dt>
<dd><p>Don't print error messages for unknown options to <code>stderr</code>; unless
this flag is set, <code>ARGP_PARSE_ARGV0</code> is ignored, as <code>argv[0]</code>
is used as the program name in the error messages.  This flag implies
<code>ARGP_NO_EXIT</code>.  This is based on the assumption that silent exiting
upon errors is bad behavior.
</p>
</dd>
<dt> <code>ARGP_NO_ARGS</code>
<a name="IDX2595"></a>
</dt>
<dd><p>Don't parse any non-option args.  Normally these are parsed by calling
the parse functions with a key of <code>ARGP_KEY_ARG</code>, the actual
argument being the value.  This flag needn't normally be set, as the
default behavior is to stop parsing as soon as an argument fails to be
parsed.  See section <a href="#SEC540">Argp Parser Functions</a>.
</p>
</dd>
<dt> <code>ARGP_IN_ORDER</code>
<a name="IDX2596"></a>
</dt>
<dd><p>Parse options and arguments in the same order they occur on the command
line.  Normally they're rearranged so that all options come first.
</p>
</dd>
<dt> <code>ARGP_NO_HELP</code>
<a name="IDX2597"></a>
</dt>
<dd><p>Don't provide the standard long option &lsquo;<samp>--help</samp>&rsquo;, which ordinarily
causes usage and option help information to be output to <code>stdout</code>
and <code>exit (0)</code>.
</p>
</dd>
<dt> <code>ARGP_NO_EXIT</code>
<a name="IDX2598"></a>
</dt>
<dd><p>Don't exit on errors, although they may still result in error messages.
</p>
</dd>
<dt> <code>ARGP_LONG_ONLY</code>
<a name="IDX2599"></a>
</dt>
<dd><p>Use the gnu getopt `long-only' rules for parsing arguments.  This allows
long-options to be recognized with only a single &lsquo;<samp>-</samp>&rsquo;
(i.e., &lsquo;<samp>-help</samp>&rsquo;).  This results in a less useful interface, and its
use is discouraged as it conflicts with the way most GNU programs work
as well as the GNU coding standards.
</p>
</dd>
<dt> <code>ARGP_SILENT</code>
<a name="IDX2600"></a>
</dt>
<dd><p>Turns off any message-printing/exiting options, specifically
<code>ARGP_NO_EXIT</code>, <code>ARGP_NO_ERRS</code>, and <code>ARGP_NO_HELP</code>.
</p></dd>
</dl>

<hr size="6">
<a name="Argp-Help-Filtering"></a>
<a name="SEC546"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC545" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC547" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC525" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC534" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="libc_26.html#SEC568" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="libc.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="libc_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="libc_42.html#SEC712" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="libc_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h3 class="subsection"> 25.3.8 Customizing Argp Help Output </h3>

<p>The <code>help_filter</code> field in a <code>struct argp</code> is a pointer to a
function that filters the text of help messages before displaying
them.  They have a function signature like:
</p>
<table><tr><td>&nbsp;</td><td><pre class="smallexample">char *<var>help-filter</var> (int <var>key</var>, const char *<var>text</var>, void *<var>input</var>)
</pre></td></tr></table>


<p>Where <var>key</var> is either a key from an option, in which case <var>text</var>
is that option's help text.  See section <a href="#SEC538">Specifying Options in an Argp Parser</a>.  Alternately, one
of the special keys with names beginning with &lsquo;<samp>ARGP_KEY_HELP_</samp>&rsquo;
might be used, describing which other help text <var>text</var> will contain.
See section <a href="#SEC547">Special Keys for Argp Help Filter Functions</a>.
</p>
<p>The function should return either <var>text</var> if it remains as-is, or a
replacement string allocated using <code>malloc</code>.  This will be either be
freed by argp or zero, which prints nothing.  The value of <var>text</var> is
supplied <em>after</em> any translation has been done, so if any of the
replacement text needs translation, it will be done by the filter
function.  <var>input</var> is either the input supplied to <code>argp_parse</code>
or it is zero, if <code>argp_help</code> was called directly by the user.
</p>
<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top"><a href="#SEC547">25.3.8.1 Special Keys for Argp Help Filter Functions</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">  Special <var>key</var> values for help filter functions.
</td></tr>
</table>

<hr size="6">
<a name="Argp-Help-Filter-Keys"></a>
<a name="SEC547"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC546" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC548" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC525" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC546" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="libc_26.html#SEC568" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="libc.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="libc_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="libc_42.html#SEC712" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="libc_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h4 class="subsubsection"> 25.3.8.1 Special Keys for Argp Help Filter Functions </h4>

<p>The following special values may be passed to an argp help filter
function as the first argument in addition to key values for user
options.  They specify which help text the <var>text</var> argument contains:
</p>
<dl compact="compact">
<dt> <code>ARGP_KEY_HELP_PRE_DOC</code>
<a name="IDX2601"></a>
</dt>
<dd><p>The help text preceding options.
</p>
</dd>
<dt> <code>ARGP_KEY_HELP_POST_DOC</code>
<a name="IDX2602"></a>
</dt>
<dd><p>The help text following options.
</p>
</dd>
<dt> <code>ARGP_KEY_HELP_HEADER</code>
<a name="IDX2603"></a>
</dt>
<dd><p>The option header string.
</p>
</dd>
<dt> <code>ARGP_KEY_HELP_EXTRA</code>
<a name="IDX2604"></a>
</dt>
<dd><p>This is used after all other documentation; <var>text</var> is zero for this key.
</p>
</dd>
<dt> <code>ARGP_KEY_HELP_DUP_ARGS_NOTE</code>
<a name="IDX2605"></a>
</dt>
<dd><p>The explanatory note printed when duplicate option arguments have been suppressed.
</p>
</dd>
<dt> <code>ARGP_KEY_HELP_ARGS_DOC</code>
<a name="IDX2606"></a>
</dt>
<dd><p>The argument doc string; formally the <code>args_doc</code> field from the argp parser.  See section <a href="#SEC537">Specifying Argp Parsers</a>.
</p></dd>
</dl>

<hr size="6">
<a name="Argp-Help"></a>
<a name="SEC548"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC547" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC549" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC525" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC534" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="libc_26.html#SEC568" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="libc.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="libc_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="libc_42.html#SEC712" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="libc_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h3 class="subsection"> 25.3.9 The <code>argp_help</code> Function </h3>

<p>Normally programs using argp need not be written with particular
printing argument-usage-type help messages in mind as the standard
&lsquo;<samp>--help</samp>&rsquo; option is handled automatically by argp.  Typical error
cases can be handled using <code>argp_usage</code> and
<code>argp_error</code>.  See section <a href="#SEC542">Functions For Use in Argp Parsers</a>.  However, if it's
desirable to print a help message in some context other than parsing the
program options, argp offers the <code>argp_help</code> interface.
</p>
<dl>
<dt><u>Function:</u> void <b>argp_help</b><i> (const struct argp *<var>argp</var>, FILE *<var>stream</var>, unsigned <var>flags</var>, char *<var>name</var>)</i>
<a name="IDX2607"></a>
</dt>
<dd><p>This outputs a help message for the argp parser <var>argp</var> to
<var>stream</var>.  The type of messages printed will be determined by
<var>flags</var>.
</p>
<p>Any options such as &lsquo;<samp>--help</samp>&rsquo; that are implemented automatically by
argp itself will <em>not</em> be present in the help output; for this
reason it is best to use <code>argp_state_help</code> if calling from within
an argp parser function.  See section <a href="#SEC542">Functions For Use in Argp Parsers</a>.
</p></dd></dl>

<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top"><a href="#SEC549">25.3.10 Flags for the <code>argp_help</code> Function</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">       Specifying what sort of help message to print.
</td></tr>
</table>

<hr size="6">
<a name="Argp-Help-Flags"></a>
<a name="SEC549"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC548" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC550" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC525" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC534" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="libc_26.html#SEC568" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="libc.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="libc_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="libc_42.html#SEC712" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="libc_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h3 class="subsection"> 25.3.10 Flags for the <code>argp_help</code> Function </h3>

<p>When calling <code>argp_help</code> (see section <a href="#SEC548">The <code>argp_help</code> Function</a>) or
<code>argp_state_help</code> (see section <a href="#SEC542">Functions For Use in Argp Parsers</a>) the exact output
is determined by the <var>flags</var> argument.  This should consist of any of
the following flags, or'd together:
</p>
<dl compact="compact">
<dt> <code>ARGP_HELP_USAGE</code>
<a name="IDX2608"></a>
</dt>
<dd><p>A unix &lsquo;<samp>Usage:</samp>&rsquo; message that explicitly lists all options.
</p>
</dd>
<dt> <code>ARGP_HELP_SHORT_USAGE</code>
<a name="IDX2609"></a>
</dt>
<dd><p>A unix &lsquo;<samp>Usage:</samp>&rsquo; message that displays an appropriate placeholder to
indicate where the options go; useful for showing the non-option
argument syntax.
</p>
</dd>
<dt> <code>ARGP_HELP_SEE</code>
<a name="IDX2610"></a>
</dt>
<dd><p>A &lsquo;<samp>Try &hellip; for more help</samp>&rsquo; message; &lsquo;<samp>&hellip;</samp>&rsquo; contains the
program name and &lsquo;<samp>--help</samp>&rsquo;.
</p>
</dd>
<dt> <code>ARGP_HELP_LONG</code>
<a name="IDX2611"></a>
</dt>
<dd><p>A verbose option help message that gives each option available along
with its documentation string.
</p>
</dd>
<dt> <code>ARGP_HELP_PRE_DOC</code>
<a name="IDX2612"></a>
</dt>
<dd><p>The part of the argp parser doc string preceding the verbose option help.
</p>
</dd>
<dt> <code>ARGP_HELP_POST_DOC</code>
<a name="IDX2613"></a>
</dt>
<dd><p>The part of the argp parser doc string that following the verbose option help.
</p>
</dd>
<dt> <code>ARGP_HELP_DOC</code>
<a name="IDX2614"></a>
</dt>
<dd><p><code>(ARGP_HELP_PRE_DOC | ARGP_HELP_POST_DOC)</code>
</p>
</dd>
<dt> <code>ARGP_HELP_BUG_ADDR</code>
<a name="IDX2615"></a>
</dt>
<dd><p>A message that prints where to report bugs for this program, if the
<code>argp_program_bug_address</code> variable contains this information.
</p>
</dd>
<dt> <code>ARGP_HELP_LONG_ONLY</code>
<a name="IDX2616"></a>
</dt>
<dd><p>This will modify any output to reflect the <code>ARGP_LONG_ONLY</code> mode.
</p></dd>
</dl>

<p>The following flags are only understood when used with
<code>argp_state_help</code>.  They control whether the function returns after
printing its output, or terminates the program:
</p>
<dl compact="compact">
<dt> <code>ARGP_HELP_EXIT_ERR</code>
<a name="IDX2617"></a>
</dt>
<dd><p>This will terminate the program with <code>exit (argp_err_exit_status)</code>.
</p>
</dd>
<dt> <code>ARGP_HELP_EXIT_OK</code>
<a name="IDX2618"></a>
</dt>
<dd><p>This will terminate the program with <code>exit (0)</code>.
</p></dd>
</dl>

<p>The following flags are combinations of the basic flags for printing
standard messages:
</p>
<dl compact="compact">
<dt> <code>ARGP_HELP_STD_ERR</code>
<a name="IDX2619"></a>
</dt>
<dd><p>Assuming that an error message for a parsing error has printed, this
prints a message on how to get help, and terminates the program with an
error.
</p>
</dd>
<dt> <code>ARGP_HELP_STD_USAGE</code>
<a name="IDX2620"></a>
</dt>
<dd><p>This prints a standard usage message and terminates the program with an
error.  This is used when no other specific error messages are
appropriate or available.
</p>
</dd>
<dt> <code>ARGP_HELP_STD_HELP</code>
<a name="IDX2621"></a>
</dt>
<dd><p>This prints the standard response for a &lsquo;<samp>--help</samp>&rsquo; option, and
terminates the program successfully.
</p></dd>
</dl>

<hr size="6">
<a name="Argp-Examples"></a>
<a name="SEC550"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC549" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC551" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC525" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC534" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="libc_26.html#SEC568" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="libc.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="libc_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="libc_42.html#SEC712" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="libc_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h3 class="subsection"> 25.3.11 Argp Examples </h3>

<p>These example programs demonstrate the basic usage of argp.
</p>
<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top"><a href="#SEC551">25.3.11.1 A Minimal Program Using Argp</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">            A minimal program using argp.
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC552">25.3.11.2 A Program Using Argp with Only Default Options</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">            A program using only default options.
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC553">25.3.11.3 A Program Using Argp with User Options</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">            A simple program with user options.
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC554">25.3.11.4 A Program Using Multiple Combined Argp Parsers</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">            Combining multiple argp parsers.
</td></tr>
</table>

<hr size="6">
<a name="Argp-Example-1"></a>
<a name="SEC551"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC550" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC552" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC525" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC550" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="libc_26.html#SEC568" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="libc.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="libc_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="libc_42.html#SEC712" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="libc_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h4 class="subsubsection"> 25.3.11.1 A Minimal Program Using Argp </h4>

<p>This is perhaps the smallest program possible that uses argp.  It won't
do much except give an error messages and exit when there are any
arguments, and prints a rather pointless message for &lsquo;<samp>--help</samp>&rsquo;.
</p>
<table><tr><td>&nbsp;</td><td><pre class="smallexample">/* <span class="roman">Argp example #1 -- a minimal program using argp</span> */

/* <span class="roman">This is (probably) the smallest possible program that
   uses argp.  It won't do much except give an error
   messages and exit when there are any arguments, and print
   a (rather pointless) messages for --help.</span> */

#include &lt;argp.h&gt;

int main (int argc, char **argv)
{
  argp_parse (0, argc, argv, 0, 0, 0);
  exit (0);
}
</pre></td></tr></table>

<hr size="6">
<a name="Argp-Example-2"></a>
<a name="SEC552"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC551" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC553" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC525" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC550" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="libc_26.html#SEC568" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="libc.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="libc_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="libc_42.html#SEC712" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="libc_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h4 class="subsubsection"> 25.3.11.2 A Program Using Argp with Only Default Options </h4>

<p>This program doesn't use any options or arguments, it uses argp to be
compliant with the GNU standard command line format.
</p>
<p>In addition to giving no arguments and implementing a &lsquo;<samp>--help</samp>&rsquo;
option, this example has a &lsquo;<samp>--version</samp>&rsquo; option, which will put the
given documentation string and bug address in the &lsquo;<samp>--help</samp>&rsquo; output,
as per GNU standards.
</p>
<p>The variable <code>argp</code> contains the argument parser
specification.  Adding fields to this structure is the way most
parameters are passed to <code>argp_parse</code>.  The first three fields are
normally used, but they are not in this small program.  There are also
two global variables that argp can use defined here,
<code>argp_program_version</code> and <code>argp_program_bug_address</code>.  They
are considered global variables because they will almost always be
constant for a given program, even if they use different argument
parsers for various tasks.
</p>
<table><tr><td>&nbsp;</td><td><pre class="smallexample">/* <span class="roman">Argp example #2 -- a pretty minimal program using argp</span> */

/* <span class="roman">This program doesn't use any options or arguments, but uses
   argp to be compliant with the GNU standard command line
   format.

   In addition to making sure no arguments are given, and
   implementing a --help option, this example will have a
   --version option, and will put the given documentation string
   and bug address in the --help output, as per GNU standards.

   The variable ARGP contains the argument parser specification;
   adding fields to this structure is the way most parameters are
   passed to argp_parse (the first three fields are usually used,
   but not in this small program).  There are also two global
   variables that argp knows about defined here,
   ARGP_PROGRAM_VERSION and ARGP_PROGRAM_BUG_ADDRESS (they are
   global variables because they will almost always be constant
   for a given program, even if it uses different argument
   parsers for various tasks).</span> */

#include &lt;argp.h&gt;

const char *argp_program_version =
  &quot;argp-ex2 1.0&quot;;
const char *argp_program_bug_address =
  &quot;&lt;bug-gnu-utils@gnu.org&gt;&quot;;

/* <span class="roman">Program documentation.</span> */
static char doc[] =
  &quot;Argp example #2 -- a pretty minimal program using argp&quot;;

/* <span class="roman">Our argument parser.  The <code>options</code>, <code>parser</code>, and
   <code>args_doc</code> fields are zero because we have neither options or
   arguments; <code>doc</code> and <code>argp_program_bug_address</code> will be
   used in the output for &lsquo;<samp>--help</samp>&rsquo;, and the &lsquo;<samp>--version</samp>&rsquo;
   option will print out <code>argp_program_version</code>.</span> */
static struct argp argp = { 0, 0, 0, doc };

int main (int argc, char **argv)
{
  argp_parse (&amp;argp, argc, argv, 0, 0, 0);
  exit (0);
}
</pre></td></tr></table>

<hr size="6">
<a name="Argp-Example-3"></a>
<a name="SEC553"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC552" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC554" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC525" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC550" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="libc_26.html#SEC568" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="libc.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="libc_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="libc_42.html#SEC712" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="libc_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h4 class="subsubsection"> 25.3.11.3 A Program Using Argp with User Options </h4>

<p>This program uses the same features as example 2, adding user options
and arguments.
</p>
<p>We now use the first four fields in <code>argp</code> (see section <a href="#SEC537">Specifying Argp Parsers</a>)
and specify <code>parse_opt</code> as the parser function.  See section <a href="#SEC540">Argp Parser Functions</a>.
</p>
<p>Note that in this example, <code>main</code> uses a structure to communicate
with the <code>parse_opt</code> function, a pointer to which it passes in the
<code>input</code> argument to <code>argp_parse</code>.  See section <a href="#SEC534">Parsing Program Options with Argp</a>.  It is retrieved
by <code>parse_opt</code> through the <code>input</code> field in its <code>state</code>
argument.  See section <a href="#SEC543">Argp Parsing State</a>.  Of course, it's also possible to
use global variables instead, but using a structure like this is
somewhat more flexible and clean.
</p>
<table><tr><td>&nbsp;</td><td><pre class="smallexample">/* <span class="roman">Argp example #3 -- a program with options and arguments using argp</span> */

/* <span class="roman">This program uses the same features as example 2, and uses options and
   arguments.

   We now use the first four fields in ARGP, so here's a description of them:
     OPTIONS  -- A pointer to a vector of struct argp_option (see below)
     PARSER   -- A function to parse a single option, called by argp
     ARGS_DOC -- A string describing how the non-option arguments should look
     DOC      -- A descriptive string about this program; if it contains a
                 vertical tab character (\v), the part after it will be
                 printed *following* the options

   The function PARSER takes the following arguments:
     KEY  -- An integer specifying which option this is (taken
             from the KEY field in each struct argp_option), or
             a special key specifying something else; the only
             special keys we use here are ARGP_KEY_ARG, meaning
             a non-option argument, and ARGP_KEY_END, meaning
             that all arguments have been parsed
     ARG  -- For an option KEY, the string value of its
             argument, or NULL if it has none
     STATE-- A pointer to a struct argp_state, containing
             various useful information about the parsing state; used here
             are the INPUT field, which reflects the INPUT argument to
             argp_parse, and the ARG_NUM field, which is the number of the
             current non-option argument being parsed
   It should return either 0, meaning success, ARGP_ERR_UNKNOWN, meaning the
   given KEY wasn't recognized, or an errno value indicating some other
   error.

   Note that in this example, main uses a structure to communicate with the
   parse_opt function, a pointer to which it passes in the INPUT argument to
   argp_parse.  Of course, it's also possible to use global variables
   instead, but this is somewhat more flexible.

   The OPTIONS field contains a pointer to a vector of struct argp_option's;
   that structure has the following fields (if you assign your option
   structures using array initialization like this example, unspecified
   fields will be defaulted to 0, and need not be specified):
     NAME   -- The name of this option's long option (may be zero)
     KEY    -- The KEY to pass to the PARSER function when parsing this option,
               *and* the name of this option's short option, if it is a
               printable ascii character
     ARG    -- The name of this option's argument, if any
     FLAGS  -- Flags describing this option; some of them are:
                 OPTION_ARG_OPTIONAL -- The argument to this option is optional
                 OPTION_ALIAS        -- This option is an alias for the
                                        previous option
                 OPTION_HIDDEN       -- Don't show this option in --help output
     DOC    -- A documentation string for this option, shown in --help output

   An options vector should be terminated by an option with all fields zero.</span> */

#include &lt;argp.h&gt;

const char *argp_program_version =
  &quot;argp-ex3 1.0&quot;;
const char *argp_program_bug_address =
  &quot;&lt;bug-gnu-utils@gnu.org&gt;&quot;;

/* <span class="roman">Program documentation.</span> */
static char doc[] =
  &quot;Argp example #3 -- a program with options and arguments using argp&quot;;

/* <span class="roman">A description of the arguments we accept.</span> */
static char args_doc[] = &quot;ARG1 ARG2&quot;;

/* <span class="roman">The options we understand.</span> */
static struct argp_option options[] = {
  {&quot;verbose&quot;,  'v', 0,      0,  &quot;Produce verbose output&quot; },
  {&quot;quiet&quot;,    'q', 0,      0,  &quot;Don't produce any output&quot; },
  {&quot;silent&quot;,   's', 0,      OPTION_ALIAS },
  {&quot;output&quot;,   'o', &quot;FILE&quot;, 0,
   &quot;Output to FILE instead of standard output&quot; },
  { 0 }
};

/* <span class="roman">Used by <code>main</code> to communicate with <code>parse_opt</code>.</span> */
struct arguments
{
  char *args[2];                /* <span class="roman"><var>arg1</var> &amp; <var>arg2</var></span> */
  int silent, verbose;
  char *output_file;
};

/* <span class="roman">Parse a single option.</span> */
static error_t
parse_opt (int key, char *arg, struct argp_state *state)
{
  /* <span class="roman">Get the <var>input</var> argument from <code>argp_parse</code>, which we
     know is a pointer to our arguments structure.</span> */
  struct arguments *arguments = state-&gt;input;

  switch (key)
    {
    case 'q': case 's':
      arguments-&gt;silent = 1;
      break;
    case 'v':
      arguments-&gt;verbose = 1;
      break;
    case 'o':
      arguments-&gt;output_file = arg;
      break;

    case ARGP_KEY_ARG:
      if (state-&gt;arg_num &gt;= 2)
        /* <span class="roman">Too many arguments.</span> */
        argp_usage (state);

      arguments-&gt;args[state-&gt;arg_num] = arg;

      break;

    case ARGP_KEY_END:
      if (state-&gt;arg_num &lt; 2)
        /* <span class="roman">Not enough arguments.</span> */
        argp_usage (state);
      break;

    default:
      return ARGP_ERR_UNKNOWN;
    }
  return 0;
}

/* <span class="roman">Our argp parser.</span> */
static struct argp argp = { options, parse_opt, args_doc, doc };

int main (int argc, char **argv)
{
  struct arguments arguments;

  /* <span class="roman">Default values.</span> */
  arguments.silent = 0;
  arguments.verbose = 0;
  arguments.output_file = &quot;-&quot;;

  /* <span class="roman">Parse our arguments; every option seen by <code>parse_opt</code> will
     be reflected in <code>arguments</code>.</span> */
  argp_parse (&amp;argp, argc, argv, 0, 0, &amp;arguments);

  printf (&quot;ARG1 = %s\nARG2 = %s\nOUTPUT_FILE = %s\n&quot;
          &quot;VERBOSE = %s\nSILENT = %s\n&quot;,
          arguments.args[0], arguments.args[1],
          arguments.output_file,
          arguments.verbose ? &quot;yes&quot; : &quot;no&quot;,
          arguments.silent ? &quot;yes&quot; : &quot;no&quot;);

  exit (0);
}
</pre></td></tr></table>

<hr size="6">
<a name="Argp-Example-4"></a>
<a name="SEC554"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC553" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC555" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC525" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC550" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="libc_26.html#SEC568" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="libc.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="libc_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="libc_42.html#SEC712" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="libc_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h4 class="subsubsection"> 25.3.11.4 A Program Using Multiple Combined Argp Parsers </h4>

<p>This program uses the same features as example 3, but has more options,
and presents more structure in the &lsquo;<samp>--help</samp>&rsquo; output.  It also
illustrates how you can `steal' the remainder of the input arguments
past a certain point for programs that accept a list of items.  It also
illustrates the <var>key</var> value <code>ARGP_KEY_NO_ARGS</code>, which is only
given if no non-option arguments were supplied to the
program.  See section <a href="#SEC541">Special Keys for Argp Parser Functions</a>.
</p>
<p>For structuring help output, two features are used: <em>headers</em> and a
two part option string.  The <em>headers</em> are entries in the options
vector.  See section <a href="#SEC538">Specifying Options in an Argp Parser</a>.  The first four fields are zero.  The
two part documentation string are in the variable <code>doc</code>, which
allows documentation both before and after the options.  See section <a href="#SEC537">Specifying Argp Parsers</a>, the two parts of <code>doc</code> are separated by a vertical-tab
character (<code>'\v'</code>, or <code>'\013'</code>).  By convention, the
documentation before the options is a short string stating what the
program does, and after any options it is longer, describing the
behavior in more detail.  All documentation strings are automatically
filled for output, although newlines may be included to force a line
break at a particular point.  In addition, documentation strings are
passed to the <code>gettext</code> function, for possible translation into the
current locale.
</p>
<table><tr><td>&nbsp;</td><td><pre class="smallexample">/* <span class="roman">Argp example #4 -- a program with somewhat more complicated options</span> */

/* <span class="roman">This program uses the same features as example 3, but has more
   options, and somewhat more structure in the -help output.  It
   also shows how you can `steal' the remainder of the input
   arguments past a certain point, for programs that accept a
   list of items.  It also shows the special argp KEY value
   ARGP_KEY_NO_ARGS, which is only given if no non-option
   arguments were supplied to the program.

   For structuring the help output, two features are used,
   *headers* which are entries in the options vector with the
   first four fields being zero, and a two part documentation
   string (in the variable DOC), which allows documentation both
   before and after the options; the two parts of DOC are
   separated by a vertical-tab character ('\v', or '\013').  By
   convention, the documentation before the options is just a
   short string saying what the program does, and that afterwards
   is longer, describing the behavior in more detail.  All
   documentation strings are automatically filled for output,
   although newlines may be included to force a line break at a
   particular point.  All documentation strings are also passed to
   the `gettext' function, for possible translation into the
   current locale.</span> */

#include &lt;stdlib.h&gt;
#include &lt;error.h&gt;
#include &lt;argp.h&gt;

const char *argp_program_version =
  &quot;argp-ex4 1.0&quot;;
const char *argp_program_bug_address =
  &quot;&lt;bug-gnu-utils@prep.ai.mit.edu&gt;&quot;;

/* <span class="roman">Program documentation.</span> */
static char doc[] =
  &quot;Argp example #4 -- a program with somewhat more complicated\
options\
\vThis part of the documentation comes *after* the options;\
 note that the text is automatically filled, but it's possible\
 to force a line-break, e.g.\n&lt;-- here.&quot;;

/* <span class="roman">A description of the arguments we accept.</span> */
static char args_doc[] = &quot;ARG1 [STRING...]&quot;;

/* <span class="roman">Keys for options without short-options.</span> */
#define OPT_ABORT  1            /* <span class="roman">--abort</span> */

/* <span class="roman">The options we understand.</span> */
static struct argp_option options[] = {
  {&quot;verbose&quot;,  'v', 0,       0, &quot;Produce verbose output&quot; },
  {&quot;quiet&quot;,    'q', 0,       0, &quot;Don't produce any output&quot; },
  {&quot;silent&quot;,   's', 0,       OPTION_ALIAS },
  {&quot;output&quot;,   'o', &quot;FILE&quot;,  0,
   &quot;Output to FILE instead of standard output&quot; },

  {0,0,0,0, &quot;The following options should be grouped together:&quot; },
  {&quot;repeat&quot;,   'r', &quot;COUNT&quot;, OPTION_ARG_OPTIONAL,
   &quot;Repeat the output COUNT (default 10) times&quot;},
  {&quot;abort&quot;,    OPT_ABORT, 0, 0, &quot;Abort before showing any output&quot;},

  { 0 }
};

/* <span class="roman">Used by <code>main</code> to communicate with <code>parse_opt</code>.</span> */
struct arguments
{
  char *arg1;                   /* <span class="roman"><var>arg1</var></span> */
  char **strings;               /* <span class="roman">[<var>string</var>&hellip;]</span> */
  int silent, verbose, abort;   /* <span class="roman">&lsquo;<samp>-s</samp>&rsquo;, &lsquo;<samp>-v</samp>&rsquo;, &lsquo;<samp>--abort</samp>&rsquo;</span> */
  char *output_file;            /* <span class="roman"><var>file</var> arg to &lsquo;<samp>--output</samp>&rsquo;</span> */
  int repeat_count;             /* <span class="roman"><var>count</var> arg to &lsquo;<samp>--repeat</samp>&rsquo;</span> */
};

/* <span class="roman">Parse a single option.</span> */
static error_t
parse_opt (int key, char *arg, struct argp_state *state)
{
  /* <span class="roman">Get the <code>input</code> argument from <code>argp_parse</code>, which we
     know is a pointer to our arguments structure.</span> */
  struct arguments *arguments = state-&gt;input;

  switch (key)
    {
    case 'q': case 's':
      arguments-&gt;silent = 1;
      break;
    case 'v':
      arguments-&gt;verbose = 1;
      break;
    case 'o':
      arguments-&gt;output_file = arg;
      break;
    case 'r':
      arguments-&gt;repeat_count = arg ? atoi (arg) : 10;
      break;
    case OPT_ABORT:
      arguments-&gt;abort = 1;
      break;

    case ARGP_KEY_NO_ARGS:
      argp_usage (state);

    case ARGP_KEY_ARG:
      /* <span class="roman">Here we know that <code>state-&gt;arg_num == 0</code>, since we
         force argument parsing to end before any more arguments can
         get here.</span> */
      arguments-&gt;arg1 = arg;

      /* <span class="roman">Now we consume all the rest of the arguments.
         <code>state-&gt;next</code> is the index in <code>state-&gt;argv</code> of the
         next argument to be parsed, which is the first <var>string</var>
         we're interested in, so we can just use
         <code>&amp;state-&gt;argv[state-&gt;next]</code> as the value for
         arguments-&gt;strings.

         <em>In addition</em>, by setting <code>state-&gt;next</code> to the end
         of the arguments, we can force argp to stop parsing here and
         return.</span> */
      arguments-&gt;strings = &amp;state-&gt;argv[state-&gt;next];
      state-&gt;next = state-&gt;argc;

      break;

    default:
      return ARGP_ERR_UNKNOWN;
    }
  return 0;
}

/* <span class="roman">Our argp parser.</span> */
static struct argp argp = { options, parse_opt, args_doc, doc };

int main (int argc, char **argv)
{
  int i, j;
  struct arguments arguments;

  /* <span class="roman">Default values.</span> */
  arguments.silent = 0;
  arguments.verbose = 0;
  arguments.output_file = &quot;-&quot;;
  arguments.repeat_count = 1;
  arguments.abort = 0;

  /* <span class="roman">Parse our arguments; every option seen by <code>parse_opt</code> will be
     reflected in <code>arguments</code>.</span> */
  argp_parse (&amp;argp, argc, argv, 0, 0, &amp;arguments);

  if (arguments.abort)
    error (10, 0, &quot;ABORTED&quot;);

  for (i = 0; i &lt; arguments.repeat_count; i++)
    {
      printf (&quot;ARG1 = %s\n&quot;, arguments.arg1);
      printf (&quot;STRINGS = &quot;);
      for (j = 0; arguments.strings[j]; j++)
        printf (j == 0 ? &quot;%s&quot; : &quot;, %s&quot;, arguments.strings[j]);
      printf (&quot;\n&quot;);
      printf (&quot;OUTPUT_FILE = %s\nVERBOSE = %s\nSILENT = %s\n&quot;,
              arguments.output_file,
              arguments.verbose ? &quot;yes&quot; : &quot;no&quot;,
              arguments.silent ? &quot;yes&quot; : &quot;no&quot;);
    }

  exit (0);
}
</pre></td></tr></table>

<hr size="6">
<a name="Argp-User-Customization"></a>
<a name="SEC555"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC554" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC556" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC525" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC534" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="libc_26.html#SEC568" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="libc.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="libc_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="libc_42.html#SEC712" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="libc_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h3 class="subsection"> 25.3.12 Argp User Customization </h3>

<p>The formatting of argp &lsquo;<samp>--help</samp>&rsquo; output may be controlled to some
extent by a program's users, by setting the <code>ARGP_HELP_FMT</code>
environment variable to a comma-separated list of tokens.  Whitespace is
ignored:
</p>
<dl compact="compact">
<dt> &lsquo;<samp>dup-args</samp>&rsquo;</dt>
<dt> &lsquo;<samp>no-dup-args</samp>&rsquo;</dt>
<dd><p>These turn <em>duplicate-argument-mode</em> on or off.  In duplicate
argument mode, if an option that accepts an argument has multiple names,
the argument is shown for each name.  Otherwise, it is only shown for the
first long option.  A note is subsequently printed so the user knows that
it applies to other names as well.  The default is &lsquo;<samp>no-dup-args</samp>&rsquo;,
which is less consistent, but prettier.
</p>
</dd>
<dt> &lsquo;<samp>dup-args-note</samp>&rsquo;</dt>
<dt> &lsquo;<samp>no-dup-args-note</samp>&rsquo;</dt>
<dd><p>These will enable or disable the note informing the user of suppressed
option argument duplication.  The default is &lsquo;<samp>dup-args-note</samp>&rsquo;.
</p>
</dd>
<dt> &lsquo;<samp>short-opt-col=<var>n</var></samp>&rsquo;</dt>
<dd><p>This prints the first short option in column <var>n</var>.  The default is 2.
</p>
</dd>
<dt> &lsquo;<samp>long-opt-col=<var>n</var></samp>&rsquo;</dt>
<dd><p>This prints the first long option in column <var>n</var>.  The default is 6.
</p>
</dd>
<dt> &lsquo;<samp>doc-opt-col=<var>n</var></samp>&rsquo;</dt>
<dd><p>This prints `documentation options' (see section <a href="#SEC539">Flags for Argp Options</a>) in
column <var>n</var>.  The default is 2.
</p>
</dd>
<dt> &lsquo;<samp>opt-doc-col=<var>n</var></samp>&rsquo;</dt>
<dd><p>This prints the documentation for options starting in column
<var>n</var>.  The default is 29.
</p>
</dd>
<dt> &lsquo;<samp>header-col=<var>n</var></samp>&rsquo;</dt>
<dd><p>This will indent the group headers that document groups of options to
column <var>n</var>.  The default is 1.
</p>
</dd>
<dt> &lsquo;<samp>usage-indent=<var>n</var></samp>&rsquo;</dt>
<dd><p>This will indent continuation lines in &lsquo;<samp>Usage:</samp>&rsquo; messages to column
<var>n</var>.  The default is 12.
</p>
</dd>
<dt> &lsquo;<samp>rmargin=<var>n</var></samp>&rsquo;</dt>
<dd><p>This will word wrap help output at or before column <var>n</var>.  The default
is 79.
</p></dd>
</dl>

<hr size="6">
<a name="Suboptions"></a>
<a name="SEC556"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC555" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC557" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC525" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC555" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="libc_26.html#SEC568" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="libc.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="libc_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="libc_42.html#SEC712" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="libc_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h4 class="subsubsection"> 25.3.12.1 Parsing of Suboptions </h4>

<p>Having a single level of options is sometimes not enough.  There might
be too many options which have to be available or a set of options is
closely related.
</p>
<p>For this case some programs use suboptions.  One of the most prominent
programs is certainly <code>mount</code>(8).  The <code>-o</code> option take one
argument which itself is a comma separated list of options.  To ease the
programming of code like this the function <code>getsubopt</code> is
available.
</p>
<dl>
<dt><u>Function:</u> int <b>getsubopt</b><i> (char **<var>optionp</var>, const char* const *<var>tokens</var>, char **<var>valuep</var>)</i>
<a name="IDX2622"></a>
</dt>
<dd><p>The <var>optionp</var> parameter must be a pointer to a variable containing
the address of the string to process.  When the function returns the
reference is updated to point to the next suboption or to the
terminating &lsquo;<samp>\0</samp>&rsquo; character if there is no more suboption available.
</p>
<p>The <var>tokens</var> parameter references an array of strings containing the
known suboptions.  All strings must be &lsquo;<samp>\0</samp>&rsquo; terminated and to mark
the end a null pointer must be stored.  When <code>getsubopt</code> finds a
possible legal suboption it compares it with all strings available in
the <var>tokens</var> array and returns the index in the string as the
indicator.
</p>
<p>In case the suboption has an associated value introduced by a &lsquo;<samp>=</samp>&rsquo;
character, a pointer to the value is returned in <var>valuep</var>.  The
string is &lsquo;<samp>\0</samp>&rsquo; terminated.  If no argument is available
<var>valuep</var> is set to the null pointer.  By doing this the caller can
check whether a necessary value is given or whether no unexpected value
is present.
</p>
<p>In case the next suboption in the string is not mentioned in the
<var>tokens</var> array the starting address of the suboption including a
possible value is returned in <var>valuep</var> and the return value of the
function is &lsquo;<samp>-1</samp>&rsquo;.
</p></dd></dl>

<hr size="6">
<a name="Suboptions-Example"></a>
<a name="SEC557"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC556" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC558" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC525" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC534" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="libc_26.html#SEC568" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="libc.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="libc_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="libc_42.html#SEC712" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="libc_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h3 class="subsection"> 25.3.13 Parsing of Suboptions Example </h3>

<p>The code which might appear in the <code>mount</code>(8) program is a perfect
example of the use of <code>getsubopt</code>:
</p>
<table><tr><td>&nbsp;</td><td><pre class="smallexample">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;

int do_all;
const char *type;
int read_size;
int write_size;
int read_only;

enum
{
  RO_OPTION = 0,
  RW_OPTION,
  READ_SIZE_OPTION,
  WRITE_SIZE_OPTION,
  THE_END
};

const char *mount_opts[] =
{
  [RO_OPTION] = &quot;ro&quot;,
  [RW_OPTION] = &quot;rw&quot;,
  [READ_SIZE_OPTION] = &quot;rsize&quot;,
  [WRITE_SIZE_OPTION] = &quot;wsize&quot;,
  [THE_END] = NULL
};

int
main (int argc, char *argv[])
{
  char *subopts, *value;
  int opt;

  while ((opt = getopt (argc, argv, &quot;at:o:&quot;)) != -1)
    switch (opt)
      {
      case 'a':
        do_all = 1;
        break;
      case 't':
        type = optarg;
        break;
      case 'o':
        subopts = optarg;
        while (*subopts != '\0')
          switch (getsubopt (&amp;subopts, mount_opts, &amp;value))
            {
            case RO_OPTION:
              read_only = 1;
              break;
            case RW_OPTION:
              read_only = 0;
              break;
            case READ_SIZE_OPTION:
              if (value == NULL)
                abort ();
              read_size = atoi (value);
              break;
            case WRITE_SIZE_OPTION:
              if (value == NULL)
                abort ();
              write_size = atoi (value);
              break;
            default:
              /* <span class="roman">Unknown suboption.</span> */
              printf (&quot;Unknown suboption `%s'\n&quot;, value);
              break;
            }
        break;
      default:
        abort ();
      }

  /* <span class="roman">Do the real work.</span> */

  return 0;
}
</pre></td></tr></table>


<hr size="6">
<a name="Environment-Variables"></a>
<a name="SEC558"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC557" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC559" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC525" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC525" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="libc_26.html#SEC568" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="libc.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="libc_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="libc_42.html#SEC712" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="libc_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="section"> 25.4 Environment Variables </h2>

<p>When a program is executed, it receives information about the context in
which it was invoked in two ways.  The first mechanism uses the
<var>argv</var> and <var>argc</var> arguments to its <code>main</code> function, and is
discussed in <a href="#SEC526">Program Arguments</a>.  The second mechanism uses
<em>environment variables</em> and is discussed in this section.
</p>
<p>The <var>argv</var> mechanism is typically used to pass command-line
arguments specific to the particular program being invoked.  The
environment, on the other hand, keeps track of information that is
shared by many programs, changes infrequently, and that is less
frequently used.
</p>
<p>The environment variables discussed in this section are the same
environment variables that you set using assignments and the
<code>export</code> command in the shell.  Programs executed from the shell
inherit all of the environment variables from the shell.
</p>
<a name="IDX2623"></a>
<p>Standard environment variables are used for information about the user's
home directory, terminal type, current locale, and so on; you can define
additional variables for other purposes.  The set of all environment
variables that have values is collectively known as the
<em>environment</em>.
</p>
<p>Names of environment variables are case-sensitive and must not contain
the character &lsquo;<samp>=</samp>&rsquo;.  System-defined environment variables are
invariably uppercase.
</p>
<p>The values of environment variables can be anything that can be
represented as a string.  A value must not contain an embedded null
character, since this is assumed to terminate the string.
</p>

<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top"><a href="#SEC559">25.4.1 Environment Access</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">          How to get and set the values of
				 environment variables.
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC560">25.4.2 Standard Environment Variables</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">        These environment variables have
                		 standard interpretations.
</td></tr>
</table>

<hr size="6">
<a name="Environment-Access"></a>
<a name="SEC559"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC558" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC560" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC525" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC558" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="libc_26.html#SEC568" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="libc.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="libc_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="libc_42.html#SEC712" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="libc_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h3 class="subsection"> 25.4.1 Environment Access </h3>

<p>The value of an environment variable can be accessed with the
<code>getenv</code> function.  This is declared in the header file
&lsquo;<tt>stdlib.h</tt>&rsquo;.  Modifications of enviroment variables are not
allowed in Multi-threaded programs.  The <code>getenv</code> function
can be safely used in multi-threaded programs
<a name="IDX2624"></a>
</p>
<dl>
<dt><u>Function:</u> char * <b>getenv</b><i> (const char *<var>name</var>)</i>
<a name="IDX2625"></a>
</dt>
<dd><p>This function returns a string that is the value of the environment
variable <var>name</var>.  You must not modify this string.  In some non-Unix
systems not using the GNU library, it might be overwritten by subsequent
calls to <code>getenv</code> (but not by any other library function).  If the
environment variable <var>name</var> is not defined, the value is a null
pointer.
</p></dd></dl>


<dl>
<dt><u>Function:</u> int <b>putenv</b><i> (char *<var>string</var>)</i>
<a name="IDX2626"></a>
</dt>
<dd><p>The <code>putenv</code> function adds or removes definitions from the environment.
If the <var>string</var> is of the form &lsquo;<samp><var>name</var>=<var>value</var></samp>&rsquo;, the
definition is added to the environment.  Otherwise, the <var>string</var> is
interpreted as the name of an environment variable, and any definition
for this variable in the environment is removed.
</p>
<p>The difference to the <code>setenv</code> function is that the exact string
given as the parameter <var>string</var> is put into the environment.  If the
user should change the string after the <code>putenv</code> call this will
reflect in automatically in the environment.  This also requires that
<var>string</var> is no automatic variable which scope is left before the
variable is removed from the environment.  The same applies of course to
dynamically allocated variables which are freed later.
</p>
<p>This function is part of the extended Unix interface.  Since it was also
available in old SVID libraries you should define either
<var>_XOPEN_SOURCE</var> or <var>_SVID_SOURCE</var> before including any header.
</p></dd></dl>


<dl>
<dt><u>Function:</u> int <b>setenv</b><i> (const char *<var>name</var>, const char *<var>value</var>, int <var>replace</var>)</i>
<a name="IDX2627"></a>
</dt>
<dd><p>The <code>setenv</code> function can be used to add a new definition to the
environment.  The entry with the name <var>name</var> is replaced by the
value &lsquo;<samp><var>name</var>=<var>value</var></samp>&rsquo;.  Please note that this is also true
if <var>value</var> is the empty string.  To do this a new string is created
and the strings <var>name</var> and <var>value</var> are copied.  A null pointer
for the <var>value</var> parameter is illegal.  If the environment already
contains an entry with key <var>name</var> the <var>replace</var> parameter
controls the action.  If replace is zero, nothing happens.  Otherwise
the old entry is replaced by the new one.
</p>
<p>Please note that you cannot remove an entry completely using this function.
</p>
<p>This function was originally part of the BSD library but is now part of
the Unix standard.
</p></dd></dl>

<dl>
<dt><u>Function:</u> int <b>unsetenv</b><i> (const char *<var>name</var>)</i>
<a name="IDX2628"></a>
</dt>
<dd><p>Using this function one can remove an entry completely from the
environment.  If the environment contains an entry with the key
<var>name</var> this whole entry is removed.  A call to this function is
equivalent to a call to <code>putenv</code> when the <var>value</var> part of the
string is empty.
</p>
<p>The function return <code>-1</code> if <var>name</var> is a null pointer, points to
an empty string, or points to a string containing a <code>=</code> character.
It returns <code>0</code> if the call succeeded.
</p>
<p>This function was originally part of the BSD library but is now part of
the Unix standard.  The BSD version had no return value, though.
</p></dd></dl>

<p>There is one more function to modify the whole environment.  This
function is said to be used in the POSIX.9 (POSIX bindings for Fortran
77) and so one should expect it did made it into POSIX.1.  But this
never happened.  But we still provide this function as a GNU extension
to enable writing standard compliant Fortran environments.
</p>
<dl>
<dt><u>Function:</u> int <b>clearenv</b><i> (void)</i>
<a name="IDX2629"></a>
</dt>
<dd><p>The <code>clearenv</code> function removes all entries from the environment.
Using <code>putenv</code> and <code>setenv</code> new entries can be added again
later.
</p>
<p>If the function is successful it returns <code>0</code>.  Otherwise the return
value is nonzero.
</p></dd></dl>


<p>You can deal directly with the underlying representation of environment
objects to add more variables to the environment (for example, to
communicate with another program you are about to execute;
see section <a href="libc_26.html#SEC573">Executing a File</a>).
</p>
<dl>
<dt><u>Variable:</u> char ** <b>environ</b>
<a name="IDX2630"></a>
</dt>
<dd><p>The environment is represented as an array of strings.  Each string is
of the format &lsquo;<samp><var>name</var>=<var>value</var></samp>&rsquo;.  The order in which
strings appear in the environment is not significant, but the same
<var>name</var> must not appear more than once.  The last element of the
array is a null pointer.
</p>
<p>This variable is declared in the header file &lsquo;<tt>unistd.h</tt>&rsquo;.
</p>
<p>If you just want to get the value of an environment variable, use
<code>getenv</code>.
</p></dd></dl>

<p>Unix systems, and the GNU system, pass the initial value of
<code>environ</code> as the third argument to <code>main</code>.
See section <a href="#SEC526">Program Arguments</a>.
</p>
<hr size="6">
<a name="Standard-Environment"></a>
<a name="SEC560"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC559" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC561" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC525" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC558" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="libc_26.html#SEC568" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="libc.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="libc_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="libc_42.html#SEC712" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="libc_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h3 class="subsection"> 25.4.2 Standard Environment Variables </h3>

<p>These environment variables have standard meanings.  This doesn't mean
that they are always present in the environment; but if these variables
<em>are</em> present, they have these meanings.  You shouldn't try to use
these environment variable names for some other purpose.
</p>
<dl compact="compact">
<dt> <code>HOME</code></dt>
<dd><a name="IDX2631"></a>
<a name="IDX2632"></a>

<p>This is a string representing the user's <em>home directory</em>, or
initial default working directory.
</p>
<p>The user can set <code>HOME</code> to any value.
If you need to make sure to obtain the proper home directory
for a particular user, you should not use <code>HOME</code>; instead,
look up the user's name in the user database (see section <a href="libc_29.html#SEC624">User Database</a>).
</p>
<p>For most purposes, it is better to use <code>HOME</code>, precisely because
this lets the user specify the value.
</p>
</dd>
<dt> <code>LOGNAME</code></dt>
<dd><a name="IDX2633"></a>

<p>This is the name that the user used to log in.  Since the value in the
environment can be tweaked arbitrarily, this is not a reliable way to
identify the user who is running a program; a function like
<code>getlogin</code> (see section <a href="libc_29.html#SEC619">Identifying Who Logged In</a>) is better for that purpose.
</p>
<p>For most purposes, it is better to use <code>LOGNAME</code>, precisely because
this lets the user specify the value.
</p>
</dd>
<dt> <code>PATH</code></dt>
<dd><a name="IDX2634"></a>

<p>A <em>path</em> is a sequence of directory names which is used for
searching for a file.  The variable <code>PATH</code> holds a path used
for searching for programs to be run.
</p>
<p>The <code>execlp</code> and <code>execvp</code> functions (see section <a href="libc_26.html#SEC573">Executing a File</a>)
use this environment variable, as do many shells and other utilities
which are implemented in terms of those functions.
</p>
<p>The syntax of a path is a sequence of directory names separated by
colons.  An empty string instead of a directory name stands for the
current directory (see section <a href="libc_14.html#SEC269">Working Directory</a>).
</p>
<p>A typical value for this environment variable might be a string like:
</p>
<table><tr><td>&nbsp;</td><td><pre class="smallexample">:/bin:/etc:/usr/bin:/usr/new/X11:/usr/new:/usr/local/bin
</pre></td></tr></table>

<p>This means that if the user tries to execute a program named <code>foo</code>,
the system will look for files named &lsquo;<tt>foo</tt>&rsquo;, &lsquo;<tt>/bin/foo</tt>&rsquo;,
&lsquo;<tt>/etc/foo</tt>&rsquo;, and so on.  The first of these files that exists is
the one that is executed.
</p>
</dd>
<dt> <code>TERM</code></dt>
<dd><a name="IDX2635"></a>

<p>This specifies the kind of terminal that is receiving program output.
Some programs can make use of this information to take advantage of
special escape sequences or terminal modes supported by particular kinds
of terminals.  Many programs which use the termcap library
(see <a href="../termcap/Finding-a-Terminal-Description.html#Finding-a-Terminal-Description">Find: (termcap)Finding a Terminal Description</a> section `Finding a Terminal Description' in <cite>The Termcap Library Manual</cite>) use the <code>TERM</code> environment variable, for example.
</p>
</dd>
<dt> <code>TZ</code></dt>
<dd><a name="IDX2636"></a>

<p>This specifies the time zone.  See section <a href="libc_21.html#SEC444">Specifying the Time Zone with <code>TZ</code></a>, for information about
the format of this string and how it is used.
</p>
</dd>
<dt> <code>LANG</code></dt>
<dd><a name="IDX2637"></a>

<p>This specifies the default locale to use for attribute categories where
neither <code>LC_ALL</code> nor the specific environment variable for that
category is set.  See section <a href="libc_7.html#SEC108">Locales and Internationalization</a>, for more information about
locales.
</p>

</dd>
<dt> <code>LC_ALL</code></dt>
<dd><a name="IDX2638"></a>

<p>If this environment variable is set it overrides the selection for all
the locales done using the other <code>LC_*</code> environment variables.  The
value of the other <code>LC_*</code> environment variables is simply ignored
in this case.
</p>
</dd>
<dt> <code>LC_COLLATE</code></dt>
<dd><a name="IDX2639"></a>

<p>This specifies what locale to use for string sorting.
</p>
</dd>
<dt> <code>LC_CTYPE</code></dt>
<dd><a name="IDX2640"></a>

<p>This specifies what locale to use for character sets and character
classification.
</p>
</dd>
<dt> <code>LC_MESSAGES</code></dt>
<dd><a name="IDX2641"></a>

<p>This specifies what locale to use for printing messages and to parse
responses.
</p>
</dd>
<dt> <code>LC_MONETARY</code></dt>
<dd><a name="IDX2642"></a>

<p>This specifies what locale to use for formatting monetary values.
</p>
</dd>
<dt> <code>LC_NUMERIC</code></dt>
<dd><a name="IDX2643"></a>

<p>This specifies what locale to use for formatting numbers.
</p>
</dd>
<dt> <code>LC_TIME</code></dt>
<dd><a name="IDX2644"></a>

<p>This specifies what locale to use for formatting date/time values.
</p>
</dd>
<dt> <code>NLSPATH</code></dt>
<dd><a name="IDX2645"></a>

<p>This specifies the directories in which the <code>catopen</code> function
looks for message translation catalogs.
</p>
</dd>
<dt> <code>_POSIX_OPTION_ORDER</code></dt>
<dd><a name="IDX2646"></a>

<p>If this environment variable is defined, it suppresses the usual
reordering of command line arguments by <code>getopt</code> and
<code>argp_parse</code>.  See section <a href="#SEC527">Program Argument Syntax Conventions</a>.
</p>
</dd>
</dl>

<hr size="6">
<a name="System-Calls"></a>
<a name="SEC561"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC560" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC562" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC525" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC525" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="libc_26.html#SEC568" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="libc.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="libc_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="libc_42.html#SEC712" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="libc_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="section"> 25.5 System Calls </h2>

<p>A system call is a request for service that a program makes of the
kernel.  The service is generally something that only the kernel has
the privilege to do, such as doing I/O.  Programmers don't normally
need to be concerned with system calls because there are functions in
the GNU C library to do virtually everything that system calls do.
These functions work by making system calls themselves.  For example,
there is a system call that changes the permissions of a file, but
you don't need to know about it because you can just use the GNU C
library's <code>chmod</code> function.
</p>
<a name="IDX2647"></a>
<p>System calls are sometimes called kernel calls.
</p>
<p>However, there are times when you want to make a system call explicitly,
and for that, the GNU C library provides the <code>syscall</code> function.
<code>syscall</code> is harder to use and less portable than functions like
<code>chmod</code>, but easier and more portable than coding the system call
in assembler instructions.
</p>
<p><code>syscall</code> is most useful when you are working with a system call
which is special to your system or is newer than the GNU C library you
are using.  <code>syscall</code> is implemented in an entirely generic way;
the function does not know anything about what a particular system
call does or even if it is valid.
</p>
<p>The description of <code>syscall</code> in this section assumes a certain
protocol for system calls on the various platforms on which the GNU C
library runs.  That protocol is not defined by any strong authority, but
we won't describe it here either because anyone who is coding
<code>syscall</code> probably won't accept anything less than kernel and C
library source code as a specification of the interface between them
anyway.
</p>

<p><code>syscall</code> is declared in &lsquo;<tt>unistd.h</tt>&rsquo;.
</p>
<dl>
<dt><u>Function:</u> long int <b>syscall</b><i> (long int <var>sysno</var>, ...)</i>
<a name="IDX2648"></a>
</dt>
<dd><p><code>syscall</code> performs a generic system call.
</p>
<a name="IDX2649"></a>
<p><var>sysno</var> is the system call number.  Each kind of system call is
identified by a number.  Macros for all the possible system call numbers
are defined in &lsquo;<tt>sys/syscall.h</tt>&rsquo;
</p>
<p>The remaining arguments are the arguments for the system call, in
order, and their meanings depend on the kind of system call.  Each kind
of system call has a definite number of arguments, from zero to five.
If you code more arguments than the system call takes, the extra ones to
the right are ignored.
</p>
<p>The return value is the return value from the system call, unless the
system call failed.  In that case, <code>syscall</code> returns <code>-1</code> and
sets <code>errno</code> to an error code that the system call returned.  Note
that system calls do not return <code>-1</code> when they succeed.
<a name="IDX2650"></a>
</p>
<p>If you specify an invalid <var>sysno</var>, <code>syscall</code> returns <code>-1</code>
with <code>errno</code> = <code>ENOSYS</code>.
</p>
<p>Example:
</p>
<table><tr><td>&nbsp;</td><td><pre class="smallexample">
#include &lt;unistd.h&gt;
#include &lt;sys/syscall.h&gt;
#include &lt;errno.h&gt;

&hellip;

int rc;

rc = syscall(SYS_chmod, &quot;/etc/passwd&quot;, 0444);

if (rc == -1)
   fprintf(stderr, &quot;chmod failed, errno = %d\n&quot;, errno);

</pre></td></tr></table>

<p>This, if all the compatibility stars are aligned, is equivalent to the
following preferable code:
</p>
<table><tr><td>&nbsp;</td><td><pre class="smallexample">
#include &lt;sys/types.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;errno.h&gt;

&hellip;

int rc;

rc = chmod(&quot;/etc/passwd&quot;, 0444);
if (rc == -1)
   fprintf(stderr, &quot;chmod failed, errno = %d\n&quot;, errno);

</pre></td></tr></table>

</dd></dl>


<hr size="6">
<a name="Program-Termination"></a>
<a name="SEC562"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC561" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC563" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC525" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC525" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="libc_26.html#SEC568" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="libc.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="libc_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="libc_42.html#SEC712" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="libc_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="section"> 25.6 Program Termination </h2>

<p>The usual way for a program to terminate is simply for its <code>main</code>
function to return.  The <em>exit status value</em> returned from the
<code>main</code> function is used to report information back to the process's
parent process or shell.
</p>
<p>A program can also terminate normally by calling the <code>exit</code>
function.
</p>
<p>In addition, programs can be terminated by signals; this is discussed in
more detail in <a href="libc_24.html#SEC471">Signal Handling</a>.  The <code>abort</code> function causes
a signal that kills the program.
</p>
<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top"><a href="#SEC563">25.6.1 Normal Termination</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">          If a program calls <code>exit</code>, a
                                 process terminates normally.
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC564">25.6.2 Exit Status</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                 The <code>exit status</code> provides information
                                 about why the process terminated.
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC565">25.6.3 Cleanups on Exit</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">            A process can run its own cleanup
                                 functions upon normal termination.
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC566">25.6.4 Aborting a Program</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">          The <code>abort</code> function causes
                                 abnormal program termination.
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC567">25.6.5 Termination Internals</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">       What happens when a process terminates.
</td></tr>
</table>

<hr size="6">
<a name="Normal-Termination"></a>
<a name="SEC563"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC562" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC564" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC525" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC562" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="libc_26.html#SEC568" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="libc.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="libc_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="libc_42.html#SEC712" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="libc_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h3 class="subsection"> 25.6.1 Normal Termination </h3>

<p>A process terminates normally when its program signals it is done by
calling <code>exit</code>.  Returning from <code>main</code> is equivalent to
calling <code>exit</code>, and the value that <code>main</code> returns is used as
the argument to <code>exit</code>.
</p>
<dl>
<dt><u>Function:</u> void <b>exit</b><i> (int <var>status</var>)</i>
<a name="IDX2651"></a>
</dt>
<dd><p>The <code>exit</code> function tells the system that the program is done, which
causes it to terminate the process.
</p>
<p><var>status</var> is the program's exit status, which becomes part of the
process' termination status.  This function does not return.
</p></dd></dl>

<p>Normal termination causes the following actions:
</p>
<ol>
<li>
Functions that were registered with the <code>atexit</code> or <code>on_exit</code>
functions are called in the reverse order of their registration.  This
mechanism allows your application to specify its own &ldquo;cleanup&rdquo; actions
to be performed at program termination.  Typically, this is used to do
things like saving program state information in a file, or unlocking
locks in shared data bases.

</li><li>
All open streams are closed, writing out any buffered output data.  See
<a href="libc_12.html#SEC181">Closing Streams</a>.  In addition, temporary files opened
with the <code>tmpfile</code> function are removed; see <a href="libc_14.html#SEC296">Temporary Files</a>.

</li><li>
<code>_exit</code> is called, terminating the program.  See section <a href="#SEC567">Termination Internals</a>.
</li></ol>

<hr size="6">
<a name="Exit-Status"></a>
<a name="SEC564"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC563" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC565" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC525" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC562" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="libc_26.html#SEC568" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="libc.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="libc_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="libc_42.html#SEC712" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="libc_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h3 class="subsection"> 25.6.2 Exit Status </h3>

<p>When a program exits, it can return to the parent process a small
amount of information about the cause of termination, using the
<em>exit status</em>.  This is a value between 0 and 255 that the exiting
process passes as an argument to <code>exit</code>.
</p>
<p>Normally you should use the exit status to report very broad information
about success or failure.  You can't provide a lot of detail about the
reasons for the failure, and most parent processes would not want much
detail anyway.
</p>
<p>There are conventions for what sorts of status values certain programs
should return.  The most common convention is simply 0 for success and 1
for failure.  Programs that perform comparison use a different
convention: they use status 1 to indicate a mismatch, and status 2 to
indicate an inability to compare.  Your program should follow an
existing convention if an existing convention makes sense for it.
</p>
<p>A general convention reserves status values 128 and up for special
purposes.  In particular, the value 128 is used to indicate failure to
execute another program in a subprocess.  This convention is not
universally obeyed, but it is a good idea to follow it in your programs.
</p>
<p><strong>Warning:</strong> Don't try to use the number of errors as the exit
status.  This is actually not very useful; a parent process would
generally not care how many errors occurred.  Worse than that, it does
not work, because the status value is truncated to eight bits.
Thus, if the program tried to report 256 errors, the parent would
receive a report of 0 errors&mdash;that is, success.
</p>
<p>For the same reason, it does not work to use the value of <code>errno</code>
as the exit status&mdash;these can exceed 255.
</p>
<p><strong>Portability note:</strong> Some non-POSIX systems use different
conventions for exit status values.  For greater portability, you can
use the macros <code>EXIT_SUCCESS</code> and <code>EXIT_FAILURE</code> for the
conventional status value for success and failure, respectively.  They
are declared in the file &lsquo;<tt>stdlib.h</tt>&rsquo;.
<a name="IDX2652"></a>
</p>
<dl>
<dt><u>Macro:</u> int <b>EXIT_SUCCESS</b>
<a name="IDX2653"></a>
</dt>
<dd><p>This macro can be used with the <code>exit</code> function to indicate
successful program completion.
</p>
<p>On POSIX systems, the value of this macro is <code>0</code>.  On other
systems, the value might be some other (possibly non-constant) integer
expression.
</p></dd></dl>

<dl>
<dt><u>Macro:</u> int <b>EXIT_FAILURE</b>
<a name="IDX2654"></a>
</dt>
<dd><p>This macro can be used with the <code>exit</code> function to indicate
unsuccessful program completion in a general sense.
</p>
<p>On POSIX systems, the value of this macro is <code>1</code>.  On other
systems, the value might be some other (possibly non-constant) integer
expression.  Other nonzero status values also indicate failures.  Certain
programs use different nonzero status values to indicate particular
kinds of &quot;non-success&quot;.  For example, <code>diff</code> uses status value
<code>1</code> to mean that the files are different, and <code>2</code> or more to
mean that there was difficulty in opening the files.
</p></dd></dl>

<p>Don't confuse a program's exit status with a process' termination status.
There are lots of ways a process can terminate besides having it's program
finish.  In the event that the process termination <em>is</em> caused by program
termination (i.e., <code>exit</code>), though, the program's exit status becomes
part of the process' termination status.
</p>
<hr size="6">
<a name="Cleanups-on-Exit"></a>
<a name="SEC565"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC564" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC566" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC525" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC562" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="libc_26.html#SEC568" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="libc.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="libc_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="libc_42.html#SEC712" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="libc_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h3 class="subsection"> 25.6.3 Cleanups on Exit </h3>

<p>Your program can arrange to run its own cleanup functions if normal
termination happens.  If you are writing a library for use in various
application programs, then it is unreliable to insist that all
applications call the library's cleanup functions explicitly before
exiting.  It is much more robust to make the cleanup invisible to the
application, by setting up a cleanup function in the library itself
using <code>atexit</code> or <code>on_exit</code>.
</p>
<dl>
<dt><u>Function:</u> int <b>atexit</b><i> (void (*<var>function</var>) (void))</i>
<a name="IDX2655"></a>
</dt>
<dd><p>The <code>atexit</code> function registers the function <var>function</var> to be
called at normal program termination.  The <var>function</var> is called with
no arguments.
</p>
<p>The return value from <code>atexit</code> is zero on success and nonzero if
the function cannot be registered.
</p></dd></dl>

<dl>
<dt><u>Function:</u> int <b>on_exit</b><i> (void (*<var>function</var>)(int <var>status</var>, void *<var>arg</var>), void *<var>arg</var>)</i>
<a name="IDX2656"></a>
</dt>
<dd><p>This function is a somewhat more powerful variant of <code>atexit</code>.  It
accepts two arguments, a function <var>function</var> and an arbitrary
pointer <var>arg</var>.  At normal program termination, the <var>function</var> is
called with two arguments:  the <var>status</var> value passed to <code>exit</code>,
and the <var>arg</var>.
</p>
<p>This function is included in the GNU C library only for compatibility
for SunOS, and may not be supported by other implementations.
</p></dd></dl>

<p>Here's a trivial program that illustrates the use of <code>exit</code> and
<code>atexit</code>:
</p>
<table><tr><td>&nbsp;</td><td><pre class="smallexample">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

void 
bye (void)
{
  puts (&quot;Goodbye, cruel world....&quot;);
}

int
main (void)
{
  atexit (bye);
  exit (EXIT_SUCCESS);
}
</pre></td></tr></table>

<p>When this program is executed, it just prints the message and exits.
</p>
<hr size="6">
<a name="Aborting-a-Program"></a>
<a name="SEC566"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC565" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC567" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC525" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC562" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="libc_26.html#SEC568" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="libc.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="libc_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="libc_42.html#SEC712" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="libc_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h3 class="subsection"> 25.6.4 Aborting a Program </h3>

<p>You can abort your program using the <code>abort</code> function.  The prototype
for this function is in &lsquo;<tt>stdlib.h</tt>&rsquo;.
<a name="IDX2657"></a>
</p>
<dl>
<dt><u>Function:</u> void <b>abort</b><i> (void)</i>
<a name="IDX2658"></a>
</dt>
<dd><p>The <code>abort</code> function causes abnormal program termination.  This
does not execute cleanup functions registered with <code>atexit</code> or
<code>on_exit</code>.
</p>
<p>This function actually terminates the process by raising a
<code>SIGABRT</code> signal, and your program can include a handler to
intercept this signal; see <a href="libc_24.html#SEC471">Signal Handling</a>.
</p></dd></dl>

<table class="cartouche" border="1"><tr><td>
<p><strong>Future Change Warning:</strong> Proposed Federal censorship regulations
may prohibit us from giving you information about the possibility of
calling this function.  We would be required to say that this is not an
acceptable way of terminating a program.
</p></td></tr></table>

<hr size="6">
<a name="Termination-Internals"></a>
<a name="SEC567"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC566" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="libc_26.html#SEC568" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC525" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC562" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="libc_26.html#SEC568" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="libc.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="libc_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="libc_42.html#SEC712" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="libc_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h3 class="subsection"> 25.6.5 Termination Internals </h3>

<p>The <code>_exit</code> function is the primitive used for process termination
by <code>exit</code>.  It is declared in the header file &lsquo;<tt>unistd.h</tt>&rsquo;.
<a name="IDX2659"></a>
</p>
<dl>
<dt><u>Function:</u> void <b>_exit</b><i> (int <var>status</var>)</i>
<a name="IDX2660"></a>
</dt>
<dd><p>The <code>_exit</code> function is the primitive for causing a process to
terminate with status <var>status</var>.  Calling this function does not
execute cleanup functions registered with <code>atexit</code> or
<code>on_exit</code>.
</p></dd></dl>

<dl>
<dt><u>Function:</u> void <b>_Exit</b><i> (int <var>status</var>)</i>
<a name="IDX2661"></a>
</dt>
<dd><p>The <code>_Exit</code> function is the ISO C equivalent to <code>_exit</code>.
The ISO C committee members were not sure whether the definitions of
<code>_exit</code> and <code>_Exit</code> were compatible so they have not used the
POSIX name.
</p>
<p>This function was introduced in ISO C99 and is declared in
&lsquo;<tt>stdlib.h</tt>&rsquo;.
</p></dd></dl>

<p>When a process terminates for any reason&mdash;either because the program
terminates, or as a result of a signal&mdash;the
following things happen:
</p>
<ul>
<li>
All open file descriptors in the process are closed.  See section <a href="libc_13.html#SEC238">Low-Level Input/Output</a>.
Note that streams are not flushed automatically when the process
terminates; see <a href="libc_12.html#SEC177">Input/Output on Streams</a>.

</li><li>
A process exit status is saved to be reported back to the parent process
via <code>wait</code> or <code>waitpid</code>; see <a href="libc_26.html#SEC574">Process Completion</a>.  If the
program exited, this status includes as its low-order 8 bits the program
exit status.


</li><li>
Any child processes of the process being terminated are assigned a new
parent process.  (On most systems, including GNU, this is the <code>init</code>
process, with process ID 1.)

</li><li>
A <code>SIGCHLD</code> signal is sent to the parent process.

</li><li>
If the process is a session leader that has a controlling terminal, then
a <code>SIGHUP</code> signal is sent to each process in the foreground job,
and the controlling terminal is disassociated from that session.
See section <a href="libc_27.html#SEC578">Job Control</a>.

</li><li>
If termination of a process causes a process group to become orphaned,
and any member of that process group is stopped, then a <code>SIGHUP</code>
signal and a <code>SIGCONT</code> signal are sent to each process in the
group.  See section <a href="libc_27.html#SEC578">Job Control</a>.
</li></ul>
<hr size="6">
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC525" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="libc_26.html#SEC568" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="libc.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="libc_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="libc_42.html#SEC712" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="libc_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<p>
 <font size="-1">
  This document was generated by <em>root</em> on <em>January, 19 2009</em> using <a href="http://www.nongnu.org/texi2html/"><em>texi2html 1.78</em></a>.
 </font>
 <br>

</p>
</body>
</html>
