<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html401/loose.dtd">
<html>
<!-- This file documents the GNU C library.

This is Edition 0.12, last updated 2007-10-27,
of The GNU C Library Reference Manual, for version 2.8.

Copyright (C) 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2001, 2002,
2003, 2007, 2008 Free Software Foundation, Inc.

Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.2 or
any later version published by the Free Software Foundation; with the
Invariant Sections being "Free Software Needs Free Documentation"
and "GNU Lesser General Public License", the Front-Cover texts being
"A GNU Manual", and with the Back-Cover Texts as in (a) below.  A
copy of the license is included in the section entitled "GNU Free
Documentation License".

(a) The FSF's Back-Cover Text is: "You have the freedom to
copy and modify this GNU manual.  Buying copies from the FSF
supports it in developing GNU and promoting software freedom."
 -->
<!-- Created on February, 13 2009 by texi2html 1.78 -->
<!--
Written by: Lionel Cons <Lionel.Cons@cern.ch> (original author)
            Karl Berry  <karl@freefriends.org>
            Olaf Bachmann <obachman@mathematik.uni-kl.de>
            and many others.
Maintained by: Many creative people.
Send bugs and suggestions to <texi2html-bug@nongnu.org>

-->
<head>
<title>The GNU C Library: 22. Resource Usage And Limitation</title>

<meta name="description" content="The GNU C Library: 22. Resource Usage And Limitation">
<meta name="keywords" content="The GNU C Library: 22. Resource Usage And Limitation">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="texi2html 1.78">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
<!--
a.summary-letter {text-decoration: none}
pre.display {font-family: serif}
pre.format {font-family: serif}
pre.menu-comment {font-family: serif}
pre.menu-preformatted {font-family: serif}
pre.smalldisplay {font-family: serif; font-size: smaller}
pre.smallexample {font-size: smaller}
pre.smallformat {font-family: serif; font-size: smaller}
pre.smalllisp {font-size: smaller}
span.roman {font-family:serif; font-weight:normal;}
span.sansserif {font-family:sans-serif; font-weight:normal;}
ul.toc {list-style: none}
-->
</style>


</head>

<body lang="en" bgcolor="#FFFFFF" text="#000000" link="#0000FF" vlink="#800080" alink="#FF0000">

<a name="Resource-Usage-And-Limitation"></a>
<a name="SEC449"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="libc_21.html#SEC448" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC450" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="libc_21.html#SEC429" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="libc.html#SEC_Top" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="libc_23.html#SEC465" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="libc.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="libc_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="libc_42.html#SEC712" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="libc_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h1 class="chapter"> 22. Resource Usage And Limitation </h1>
<p>This chapter describes functions for examining how much of various kinds of
resources (CPU time, memory, etc.) a process has used and getting and setting
limits on future usage.
</p>
<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top"><a href="#SEC450">22.1 Resource Usage</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">		Measuring various resources used.
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC451">22.2 Limiting Resource Usage</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">		Specifying limits on resource usage.
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC452">22.3 Process CPU Priority And Scheduling</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">			Reading or setting process run priority.
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC461">22.4 Querying memory available resources</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top"></td></tr>
<tr><td align="left" valign="top"><a href="#SEC464">22.5 Learn about the processors available</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top"></td></tr>
</table>


<hr size="6">
<a name="Resource-Usage"></a>
<a name="SEC450"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC449" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC451" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC449" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC449" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="libc_23.html#SEC465" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="libc.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="libc_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="libc_42.html#SEC712" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="libc_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="section"> 22.1 Resource Usage </h2>

<p>The function <code>getrusage</code> and the data type <code>struct rusage</code>
are used to examine the resource usage of a process.  They are declared
in &lsquo;<tt>sys/resource.h</tt>&rsquo;.
</p>
<dl>
<dt><u>Function:</u> int <b>getrusage</b><i> (int <var>processes</var>, struct rusage *<var>rusage</var>)</i>
<a name="IDX2305"></a>
</dt>
<dd><p>This function reports resource usage totals for processes specified by
<var>processes</var>, storing the information in <code>*<var>rusage</var></code>.
</p>
<p>In most systems, <var>processes</var> has only two valid values:
</p>
<dl compact="compact">
<dt> <code>RUSAGE_SELF</code></dt>
<dd><p>Just the current process.
</p>
</dd>
<dt> <code>RUSAGE_CHILDREN</code></dt>
<dd><p>All child processes (direct and indirect) that have already terminated.
</p></dd>
</dl>

<p>In the GNU system, you can also inquire about a particular child process
by specifying its process ID.
</p>
<p>The return value of <code>getrusage</code> is zero for success, and <code>-1</code>
for failure.
</p>
<dl compact="compact">
<dt> <code>EINVAL</code></dt>
<dd><p>The argument <var>processes</var> is not valid.
</p></dd>
</dl>
</dd></dl>

<p>One way of getting resource usage for a particular child process is with
the function <code>wait4</code>, which returns totals for a child when it
terminates.  See section <a href="libc_26.html#SEC576">BSD Process Wait Functions</a>.
</p>
<dl>
<dt><u>Data Type:</u> <b>struct rusage</b>
<a name="IDX2306"></a>
</dt>
<dd><p>This data type stores various resource usage statistics.  It has the
following members, and possibly others:
</p>
<dl compact="compact">
<dt> <code>struct timeval ru_utime</code></dt>
<dd><p>Time spent executing user instructions.
</p>
</dd>
<dt> <code>struct timeval ru_stime</code></dt>
<dd><p>Time spent in operating system code on behalf of <var>processes</var>.
</p>
</dd>
<dt> <code>long int ru_maxrss</code></dt>
<dd><p>The maximum resident set size used, in kilobytes.  That is, the maximum
number of kilobytes of physical memory that <var>processes</var> used
simultaneously.
</p>
</dd>
<dt> <code>long int ru_ixrss</code></dt>
<dd><p>An integral value expressed in kilobytes times ticks of execution, which
indicates the amount of memory used by text that was shared with other
processes.
</p>
</dd>
<dt> <code>long int ru_idrss</code></dt>
<dd><p>An integral value expressed the same way, which is the amount of
unshared memory used for data.
</p>
</dd>
<dt> <code>long int ru_isrss</code></dt>
<dd><p>An integral value expressed the same way, which is the amount of
unshared memory used for stack space.
</p>
</dd>
<dt> <code>long int ru_minflt</code></dt>
<dd><p>The number of page faults which were serviced without requiring any I/O.
</p>
</dd>
<dt> <code>long int ru_majflt</code></dt>
<dd><p>The number of page faults which were serviced by doing I/O.
</p>
</dd>
<dt> <code>long int ru_nswap</code></dt>
<dd><p>The number of times <var>processes</var> was swapped entirely out of main memory.
</p>
</dd>
<dt> <code>long int ru_inblock</code></dt>
<dd><p>The number of times the file system had to read from the disk on behalf
of <var>processes</var>.
</p>
</dd>
<dt> <code>long int ru_oublock</code></dt>
<dd><p>The number of times the file system had to write to the disk on behalf
of <var>processes</var>.
</p>
</dd>
<dt> <code>long int ru_msgsnd</code></dt>
<dd><p>Number of IPC messages sent.
</p>
</dd>
<dt> <code>long int ru_msgrcv</code></dt>
<dd><p>Number of IPC messages received.
</p>
</dd>
<dt> <code>long int ru_nsignals</code></dt>
<dd><p>Number of signals received.
</p>
</dd>
<dt> <code>long int ru_nvcsw</code></dt>
<dd><p>The number of times <var>processes</var> voluntarily invoked a context switch
(usually to wait for some service).
</p>
</dd>
<dt> <code>long int ru_nivcsw</code></dt>
<dd><p>The number of times an involuntary context switch took place (because
a time slice expired, or another process of higher priority was
scheduled).
</p></dd>
</dl>
</dd></dl>

<p><code>vtimes</code> is a historical function that does some of what
<code>getrusage</code> does.  <code>getrusage</code> is a better choice.
</p>
<p><code>vtimes</code> and its <code>vtimes</code> data structure are declared in
&lsquo;<tt>sys/vtimes.h</tt>&rsquo;.
<a name="IDX2307"></a>
</p>
<dl>
<dt><u>Function:</u> int <b>vtimes</b><i> (struct vtimes <var>current</var>, struct vtimes <var>child</var>)</i>
<a name="IDX2308"></a>
</dt>
<dd><p><code>vtimes</code> reports resource usage totals for a process.
</p>
<p>If <var>current</var> is non-null, <code>vtimes</code> stores resource usage totals for
the invoking process alone in the structure to which it points.  If
<var>child</var> is non-null, <code>vtimes</code> stores resource usage totals for all
past children (which have terminated) of the invoking process in the structure
to which it points.
</p>
<dl>
<dt><u>Data Type:</u> <b>struct vtimes</b>
<a name="IDX2309"></a>
</dt>
<dd><p>This data type contains information about the resource usage of a process.
Each member corresponds to a member of the <code>struct rusage</code> data type
described above.
</p>
<dl compact="compact">
<dt> <code>vm_utime</code></dt>
<dd><p>User CPU time.  Analogous to <code>ru_utime</code> in <code>struct rusage</code>
</p></dd>
<dt> <code>vm_stime</code></dt>
<dd><p>System CPU time.  Analogous to <code>ru_stime</code> in <code>struct rusage</code>
</p></dd>
<dt> <code>vm_idsrss</code></dt>
<dd><p>Data and stack memory.  The sum of the values that would be reported as
<code>ru_idrss</code> and <code>ru_isrss</code> in <code>struct rusage</code>
</p></dd>
<dt> <code>vm_ixrss</code></dt>
<dd><p>Shared memory.  Analogous to <code>ru_ixrss</code> in <code>struct rusage</code>
</p></dd>
<dt> <code>vm_maxrss</code></dt>
<dd><p>Maximent resident set size.  Analogous to <code>ru_maxrss</code> in
<code>struct rusage</code>
</p></dd>
<dt> <code>vm_majflt</code></dt>
<dd><p>Major page faults.  Analogous to <code>ru_majflt</code> in <code>struct rusage</code>
</p></dd>
<dt> <code>vm_minflt</code></dt>
<dd><p>Minor page faults.  Analogous to <code>ru_minflt</code> in <code>struct rusage</code>
</p></dd>
<dt> <code>vm_nswap</code></dt>
<dd><p>Swap count.  Analogous to <code>ru_nswap</code> in <code>struct rusage</code>
</p></dd>
<dt> <code>vm_inblk</code></dt>
<dd><p>Disk reads.  Analogous to <code>ru_inblk</code> in <code>struct rusage</code>
</p></dd>
<dt> <code>vm_oublk</code></dt>
<dd><p>Disk writes.  Analogous to <code>ru_oublk</code> in <code>struct rusage</code>
</p></dd>
</dl>
</dd></dl>


<p>The return value is zero if the function succeeds; <code>-1</code> otherwise.
</p>


</dd></dl>
<p>An additional historical function for examining resource usage,
<code>vtimes</code>, is supported but not documented here.  It is declared in
&lsquo;<tt>sys/vtimes.h</tt>&rsquo;.
</p>
<hr size="6">
<a name="Limits-on-Resources"></a>
<a name="SEC451"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC450" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC452" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC449" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC449" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="libc_23.html#SEC465" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="libc.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="libc_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="libc_42.html#SEC712" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="libc_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="section"> 22.2 Limiting Resource Usage </h2>

<p>You can specify limits for the resource usage of a process.  When the
process tries to exceed a limit, it may get a signal, or the system call
by which it tried to do so may fail, depending on the resource.  Each
process initially inherits its limit values from its parent, but it can
subsequently change them.
</p>
<p>There are two per-process limits associated with a resource:
<a name="IDX2310"></a>
</p>
<dl compact="compact">
<dt> <em>current limit</em></dt>
<dd><p>The current limit is the value the system will not allow usage to
exceed.  It is also called the &ldquo;soft limit&rdquo; because the process being
limited can generally raise the current limit at will.
<a name="IDX2311"></a>
<a name="IDX2312"></a>
</p>
</dd>
<dt> <em>maximum limit</em></dt>
<dd><p>The maximum limit is the maximum value to which a process is allowed to
set its current limit.  It is also called the &ldquo;hard limit&rdquo; because
there is no way for a process to get around it.  A process may lower
its own maximum limit, but only the superuser may increase a maximum
limit.
<a name="IDX2313"></a>
<a name="IDX2314"></a>
</p></dd>
</dl>

<a name="IDX2315"></a>
<p>The symbols for use with <code>getrlimit</code>, <code>setrlimit</code>,
<code>getrlimit64</code>, and <code>setrlimit64</code> are defined in
&lsquo;<tt>sys/resource.h</tt>&rsquo;.
</p>
<dl>
<dt><u>Function:</u> int <b>getrlimit</b><i> (int <var>resource</var>, struct rlimit *<var>rlp</var>)</i>
<a name="IDX2316"></a>
</dt>
<dd><p>Read the current and maximum limits for the resource <var>resource</var>
and store them in <code>*<var>rlp</var></code>.
</p>
<p>The return value is <code>0</code> on success and <code>-1</code> on failure.  The
only possible <code>errno</code> error condition is <code>EFAULT</code>.
</p>
<p>When the sources are compiled with <code>_FILE_OFFSET_BITS == 64</code> on a
32-bit system this function is in fact <code>getrlimit64</code>.  Thus, the
LFS interface transparently replaces the old interface.
</p></dd></dl>

<dl>
<dt><u>Function:</u> int <b>getrlimit64</b><i> (int <var>resource</var>, struct rlimit64 *<var>rlp</var>)</i>
<a name="IDX2317"></a>
</dt>
<dd><p>This function is similar to <code>getrlimit</code> but its second parameter is
a pointer to a variable of type <code>struct rlimit64</code>, which allows it
to read values which wouldn't fit in the member of a <code>struct
rlimit</code>.
</p>
<p>If the sources are compiled with <code>_FILE_OFFSET_BITS == 64</code> on a
32-bit machine, this function is available under the name
<code>getrlimit</code> and so transparently replaces the old interface.
</p></dd></dl>

<dl>
<dt><u>Function:</u> int <b>setrlimit</b><i> (int <var>resource</var>, const struct rlimit *<var>rlp</var>)</i>
<a name="IDX2318"></a>
</dt>
<dd><p>Store the current and maximum limits for the resource <var>resource</var>
in <code>*<var>rlp</var></code>.
</p>
<p>The return value is <code>0</code> on success and <code>-1</code> on failure.  The
following <code>errno</code> error condition is possible:
</p>
<dl compact="compact">
<dt> <code>EPERM</code></dt>
<dd><ul>
<li>
The process tried to raise a current limit beyond the maximum limit.

</li><li>
The process tried to raise a maximum limit, but is not superuser.
</li></ul>
</dd>
</dl>

<p>When the sources are compiled with <code>_FILE_OFFSET_BITS == 64</code> on a
32-bit system this function is in fact <code>setrlimit64</code>.  Thus, the
LFS interface transparently replaces the old interface.
</p></dd></dl>

<dl>
<dt><u>Function:</u> int <b>setrlimit64</b><i> (int <var>resource</var>, const struct rlimit64 *<var>rlp</var>)</i>
<a name="IDX2319"></a>
</dt>
<dd><p>This function is similar to <code>setrlimit</code> but its second parameter is
a pointer to a variable of type <code>struct rlimit64</code> which allows it
to set values which wouldn't fit in the member of a <code>struct
rlimit</code>.
</p>
<p>If the sources are compiled with <code>_FILE_OFFSET_BITS == 64</code> on a
32-bit machine this function is available under the name
<code>setrlimit</code> and so transparently replaces the old interface.
</p></dd></dl>

<dl>
<dt><u>Data Type:</u> <b>struct rlimit</b>
<a name="IDX2320"></a>
</dt>
<dd><p>This structure is used with <code>getrlimit</code> to receive limit values,
and with <code>setrlimit</code> to specify limit values for a particular process
and resource.  It has two fields:
</p>
<dl compact="compact">
<dt> <code>rlim_t rlim_cur</code></dt>
<dd><p>The current limit
</p>
</dd>
<dt> <code>rlim_t rlim_max</code></dt>
<dd><p>The maximum limit.
</p></dd>
</dl>

<p>For <code>getrlimit</code>, the structure is an output; it receives the current
values.  For <code>setrlimit</code>, it specifies the new values.
</p></dd></dl>

<p>For the LFS functions a similar type is defined in &lsquo;<tt>sys/resource.h</tt>&rsquo;.
</p>
<dl>
<dt><u>Data Type:</u> <b>struct rlimit64</b>
<a name="IDX2321"></a>
</dt>
<dd><p>This structure is analogous to the <code>rlimit</code> structure above, but
its components have wider ranges.  It has two fields:
</p>
<dl compact="compact">
<dt> <code>rlim64_t rlim_cur</code></dt>
<dd><p>This is analogous to <code>rlimit.rlim_cur</code>, but with a different type.
</p>
</dd>
<dt> <code>rlim64_t rlim_max</code></dt>
<dd><p>This is analogous to <code>rlimit.rlim_max</code>, but with a different type.
</p></dd>
</dl>

</dd></dl>

<p>Here is a list of resources for which you can specify a limit.  Memory
and file sizes are measured in bytes.
</p>
<dl compact="compact">
<dt> <code>RLIMIT_CPU</code></dt>
<dd><a name="IDX2322"></a>
<p>The maximum amount of CPU time the process can use.  If it runs for
longer than this, it gets a signal: <code>SIGXCPU</code>.  The value is
measured in seconds.  See section <a href="libc_24.html#SEC482">Operation Error Signals</a>.
</p>
</dd>
<dt> <code>RLIMIT_FSIZE</code></dt>
<dd><a name="IDX2323"></a>
<p>The maximum size of file the process can create.  Trying to write a
larger file causes a signal: <code>SIGXFSZ</code>.  See section <a href="libc_24.html#SEC482">Operation Error Signals</a>.
</p>
</dd>
<dt> <code>RLIMIT_DATA</code></dt>
<dd><a name="IDX2324"></a>
<p>The maximum size of data memory for the process.  If the process tries
to allocate data memory beyond this amount, the allocation function
fails.
</p>
</dd>
<dt> <code>RLIMIT_STACK</code></dt>
<dd><a name="IDX2325"></a>
<p>The maximum stack size for the process.  If the process tries to extend
its stack past this size, it gets a <code>SIGSEGV</code> signal.
See section <a href="libc_24.html#SEC477">Program Error Signals</a>.
</p>
</dd>
<dt> <code>RLIMIT_CORE</code></dt>
<dd><a name="IDX2326"></a>
<p>The maximum size core file that this process can create.  If the process
terminates and would dump a core file larger than this, then no core
file is created.  So setting this limit to zero prevents core files from
ever being created.
</p>
</dd>
<dt> <code>RLIMIT_RSS</code></dt>
<dd><a name="IDX2327"></a>
<p>The maximum amount of physical memory that this process should get.
This parameter is a guide for the system's scheduler and memory
allocator; the system may give the process more memory when there is a
surplus.
</p>
</dd>
<dt> <code>RLIMIT_MEMLOCK</code></dt>
<dd><p>The maximum amount of memory that can be locked into physical memory (so
it will never be paged out).
</p>
</dd>
<dt> <code>RLIMIT_NPROC</code></dt>
<dd><p>The maximum number of processes that can be created with the same user ID.
If you have reached the limit for your user ID, <code>fork</code> will fail
with <code>EAGAIN</code>.  See section <a href="libc_26.html#SEC572">Creating a Process</a>.
</p>
</dd>
<dt> <code>RLIMIT_NOFILE</code></dt>
<dd><a name="IDX2328"></a>
</dd>
<dt> <code>RLIMIT_OFILE</code></dt>
<dd><a name="IDX2329"></a>
<p>The maximum number of files that the process can open.  If it tries to
open more files than this, its open attempt fails with <code>errno</code>
<code>EMFILE</code>.  See section <a href="libc_2.html#SEC17">Error Codes</a>.  Not all systems support this limit;
GNU does, and 4.4 BSD does.
</p>
</dd>
<dt> <code>RLIMIT_AS</code></dt>
<dd><a name="IDX2330"></a>
<p>The maximum size of total memory that this process should get.  If the
process tries to allocate more memory beyond this amount with, for
example, <code>brk</code>, <code>malloc</code>, <code>mmap</code> or <code>sbrk</code>, the
allocation function fails.
</p>
</dd>
<dt> <code>RLIM_NLIMITS</code></dt>
<dd><a name="IDX2331"></a>
<p>The number of different resource limits.  Any valid <var>resource</var>
operand must be less than <code>RLIM_NLIMITS</code>.
</p></dd>
</dl>

<dl>
<dt><u>Constant:</u> int <b>RLIM_INFINITY</b>
<a name="IDX2332"></a>
</dt>
<dd><p>This constant stands for a value of &ldquo;infinity&rdquo; when supplied as
the limit value in <code>setrlimit</code>.
</p></dd></dl>


<p>The following are historical functions to do some of what the functions
above do.  The functions above are better choices.
</p>
<p><code>ulimit</code> and the command symbols are declared in &lsquo;<tt>ulimit.h</tt>&rsquo;.
<a name="IDX2333"></a>
</p>
<dl>
<dt><u>Function:</u> int <b>ulimit</b><i> (int <var>cmd</var>, ...)</i>
<a name="IDX2334"></a>
</dt>
<dd><p><code>ulimit</code> gets the current limit or sets the current and maximum
limit for a particular resource for the calling process according to the
command <var>cmd</var>.a
</p>
<p>If you are getting a limit, the command argument is the only argument.
If you are setting a limit, there is a second argument:
<code>long int</code> <var>limit</var> which is the value to which you are setting
the limit.
</p>
<p>The <var>cmd</var> values and the operations they specify are:
</p><dl compact="compact">
<dt> <code>GETFSIZE</code></dt>
<dd><p>Get the current limit on the size of a file, in units of 512 bytes.
</p>
</dd>
<dt> <code>SETFSIZE</code></dt>
<dd><p>Set the current and maximum limit on the size of a file to <var>limit</var> *
512 bytes.
</p>
</dd>
</dl>

<p>There are also some other <var>cmd</var> values that may do things on some
systems, but they are not supported.
</p>
<p>Only the superuser may increase a maximum limit.
</p>
<p>When you successfully get a limit, the return value of <code>ulimit</code> is
that limit, which is never negative.  When you successfully set a limit,
the return value is zero.  When the function fails, the return value is
<code>-1</code> and <code>errno</code> is set according to the reason:
</p>
<dl compact="compact">
<dt> <code>EPERM</code></dt>
<dd><p>A process tried to increase a maximum limit, but is not superuser.
</p></dd>
</dl>


</dd></dl>

<p><code>vlimit</code> and its resource symbols are declared in &lsquo;<tt>sys/vlimit.h</tt>&rsquo;.
<a name="IDX2335"></a>
</p>
<dl>
<dt><u>Function:</u> int <b>vlimit</b><i> (int <var>resource</var>, int <var>limit</var>)</i>
<a name="IDX2336"></a>
</dt>
<dd><p><code>vlimit</code> sets the current limit for a resource for a process.
</p>
<p><var>resource</var> identifies the resource:
</p>
<dl compact="compact">
<dt> <code>LIM_CPU</code></dt>
<dd><p>Maximum CPU time.  Same as <code>RLIMIT_CPU</code> for <code>setrlimit</code>.
</p></dd>
<dt> <code>LIM_FSIZE</code></dt>
<dd><p>Maximum file size.  Same as <code>RLIMIT_FSIZE</code> for <code>setrlimit</code>.
</p></dd>
<dt> <code>LIM_DATA</code></dt>
<dd><p>Maximum data memory.  Same as <code>RLIMIT_DATA</code> for <code>setrlimit</code>.
</p></dd>
<dt> <code>LIM_STACK</code></dt>
<dd><p>Maximum stack size.  Same as <code>RLIMIT_STACK</code> for <code>setrlimit</code>.
</p></dd>
<dt> <code>LIM_CORE</code></dt>
<dd><p>Maximum core file size.  Same as <code>RLIMIT_COR</code> for <code>setrlimit</code>.
</p></dd>
<dt> <code>LIM_MAXRSS</code></dt>
<dd><p>Maximum physical memory.  Same as <code>RLIMIT_RSS</code> for <code>setrlimit</code>.
</p></dd>
</dl>

<p>The return value is zero for success, and <code>-1</code> with <code>errno</code> set
accordingly for failure:
</p>
<dl compact="compact">
<dt> <code>EPERM</code></dt>
<dd><p>The process tried to set its current limit beyond its maximum limit.
</p></dd>
</dl>

</dd></dl>

<hr size="6">
<a name="Priority"></a>
<a name="SEC452"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC451" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC453" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC449" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC449" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="libc_23.html#SEC465" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="libc.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="libc_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="libc_42.html#SEC712" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="libc_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="section"> 22.3 Process CPU Priority And Scheduling </h2>

<p>When multiple processes simultaneously require CPU time, the system's
scheduling policy and process CPU priorities determine which processes
get it.  This section describes how that determination is made and
GNU C library functions to control it.
</p>
<p>It is common to refer to CPU scheduling simply as scheduling and a
process' CPU priority simply as the process' priority, with the CPU
resource being implied.  Bear in mind, though, that CPU time is not the
only resource a process uses or that processes contend for.  In some
cases, it is not even particularly important.  Giving a process a high
&ldquo;priority&rdquo; may have very little effect on how fast a process runs with
respect to other processes.  The priorities discussed in this section
apply only to CPU time.
</p>
<p>CPU scheduling is a complex issue and different systems do it in wildly
different ways.  New ideas continually develop and find their way into
the intricacies of the various systems' scheduling algorithms.  This
section discusses the general concepts, some specifics of systems
that commonly use the GNU C library, and some standards.
</p>
<p>For simplicity, we talk about CPU contention as if there is only one CPU
in the system.  But all the same principles apply when a processor has
multiple CPUs, and knowing that the number of processes that can run at
any one time is equal to the number of CPUs, you can easily extrapolate
the information.
</p>
<p>The functions described in this section are all defined by the POSIX.1
and POSIX.1b standards (the <code>sched&hellip;</code> functions are POSIX.1b).
However, POSIX does not define any semantics for the values that these
functions get and set.  In this chapter, the semantics are based on the
Linux kernel's implementation of the POSIX standard.  As you will see,
the Linux implementation is quite the inverse of what the authors of the
POSIX syntax had in mind.
</p>
<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top"><a href="#SEC453">22.3.1 Absolute Priority</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">               The first tier of priority.  Posix
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC455">22.3.2 Realtime Scheduling</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">             Scheduling among the process nobility
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC456">22.3.3 Basic Scheduling Functions</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">      Get/set scheduling policy, priority
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC457">22.3.4 Traditional Scheduling</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">          Scheduling among the vulgar masses
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC460">22.3.5 Limiting execution to certain CPUs</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top"></td></tr>
</table>



<hr size="6">
<a name="Absolute-Priority"></a>
<a name="SEC453"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC452" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC454" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC449" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC452" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="libc_23.html#SEC465" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="libc.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="libc_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="libc_42.html#SEC712" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="libc_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h3 class="subsection"> 22.3.1 Absolute Priority </h3>

<p>Every process has an absolute priority, and it is represented by a number.
The higher the number, the higher the absolute priority.
</p>
<a name="IDX2337"></a>
<p>On systems of the past, and most systems today, all processes have
absolute priority 0 and this section is irrelevant.  In that case,
See section <a href="#SEC457">Traditional Scheduling</a>.  Absolute priorities were invented to
accommodate realtime systems, in which it is vital that certain processes
be able to respond to external events happening in real time, which
means they cannot wait around while some other process that <em>wants
to</em>, but doesn't <em>need to</em> run occupies the CPU.
</p>
<a name="IDX2338"></a>
<a name="IDX2339"></a>
<p>When two processes are in contention to use the CPU at any instant, the
one with the higher absolute priority always gets it.  This is true even if the
process with the lower priority is already using the CPU (i.e., the
scheduling is preemptive).  Of course, we're only talking about
processes that are running or &ldquo;ready to run,&rdquo; which means they are
ready to execute instructions right now.  When a process blocks to wait
for something like I/O, its absolute priority is irrelevant.
</p>
<a name="IDX2340"></a>
<p><strong>NB:</strong>  The term &ldquo;runnable&rdquo; is a synonym for &ldquo;ready to run.&rdquo;
</p>
<p>When two processes are running or ready to run and both have the same
absolute priority, it's more interesting.  In that case, who gets the
CPU is determined by the scheduling policy.  If the processes have
absolute priority 0, the traditional scheduling policy described in
<a href="#SEC457">Traditional Scheduling</a> applies.  Otherwise, the policies described
in <a href="#SEC455">Realtime Scheduling</a> apply.
</p>
<p>You normally give an absolute priority above 0 only to a process that
can be trusted not to hog the CPU.  Such processes are designed to block
(or terminate) after relatively short CPU runs.
</p>
<p>A process begins life with the same absolute priority as its parent
process.  Functions described in <a href="#SEC456">Basic Scheduling Functions</a> can
change it.
</p>
<p>Only a privileged process can change a process' absolute priority to
something other than <code>0</code>.  Only a privileged process or the
target process' owner can change its absolute priority at all.
</p>
<p>POSIX requires absolute priority values used with the realtime
scheduling policies to be consecutive with a range of at least 32.  On
Linux, they are 1 through 99.  The functions
<code>sched_get_priority_max</code> and <code>sched_set_priority_min</code> portably
tell you what the range is on a particular system.
</p>

<hr size="6">
<a name="SEC454"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC453" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC455" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC449" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC453" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="libc_23.html#SEC465" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="libc.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="libc_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="libc_42.html#SEC712" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="libc_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h4 class="subsubsection"> 22.3.1.1 Using Absolute Priority </h4>

<p>One thing you must keep in mind when designing real time applications is
that having higher absolute priority than any other process doesn't
guarantee the process can run continuously.  Two things that can wreck a
good CPU run are interrupts and page faults.
</p>
<p>Interrupt handlers live in that limbo between processes.  The CPU is
executing instructions, but they aren't part of any process.  An
interrupt will stop even the highest priority process.  So you must
allow for slight delays and make sure that no device in the system has
an interrupt handler that could cause too long a delay between
instructions for your process.
</p>
<p>Similarly, a page fault causes what looks like a straightforward
sequence of instructions to take a long time.  The fact that other
processes get to run while the page faults in is of no consequence,
because as soon as the I/O is complete, the high priority process will
kick them out and run again, but the wait for the I/O itself could be a
problem.  To neutralize this threat, use <code>mlock</code> or
<code>mlockall</code>.
</p>
<p>There are a few ramifications of the absoluteness of this priority on a
single-CPU system that you need to keep in mind when you choose to set a
priority and also when you're working on a program that runs with high
absolute priority.  Consider a process that has higher absolute priority
than any other process in the system and due to a bug in its program, it
gets into an infinite loop.  It will never cede the CPU.  You can't run
a command to kill it because your command would need to get the CPU in
order to run.  The errant program is in complete control.  It controls
the vertical, it controls the horizontal.
</p>
<p>There are two ways to avoid this: 1) keep a shell running somewhere with
a higher absolute priority.  2) keep a controlling terminal attached to
the high priority process group.  All the priority in the world won't
stop an interrupt handler from running and delivering a signal to the
process if you hit Control-C.
</p>
<p>Some systems use absolute priority as a means of allocating a fixed
percentage of CPU time to a process.  To do this, a super high priority
privileged process constantly monitors the process' CPU usage and raises
its absolute priority when the process isn't getting its entitled share
and lowers it when the process is exceeding it.
</p>
<p><strong>NB:</strong>  The absolute priority is sometimes called the &ldquo;static
priority.&rdquo;  We don't use that term in this manual because it misses the
most important feature of the absolute priority:  its absoluteness.
</p>

<hr size="6">
<a name="Realtime-Scheduling"></a>
<a name="SEC455"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC454" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC456" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC449" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC452" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="libc_23.html#SEC465" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="libc.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="libc_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="libc_42.html#SEC712" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="libc_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h3 class="subsection"> 22.3.2 Realtime Scheduling </h3>

<p>Whenever two processes with the same absolute priority are ready to run,
the kernel has a decision to make, because only one can run at a time.
If the processes have absolute priority 0, the kernel makes this decision
as described in <a href="#SEC457">Traditional Scheduling</a>.  Otherwise, the decision
is as described in this section.
</p>
<p>If two processes are ready to run but have different absolute priorities,
the decision is much simpler, and is described in <a href="#SEC453">Absolute Priority</a>.
</p>
<p>Each process has a scheduling policy.  For processes with absolute
priority other than zero, there are two available:
</p>
<ol>
<li>
First Come First Served
</li><li>
Round Robin
</li></ol>

<p>The most sensible case is where all the processes with a certain
absolute priority have the same scheduling policy.  We'll discuss that
first.
</p>
<p>In Round Robin, processes share the CPU, each one running for a small
quantum of time (&ldquo;time slice&rdquo;) and then yielding to another in a
circular fashion.  Of course, only processes that are ready to run and
have the same absolute priority are in this circle.
</p>
<p>In First Come First Served, the process that has been waiting the
longest to run gets the CPU, and it keeps it until it voluntarily
relinquishes the CPU, runs out of things to do (blocks), or gets
preempted by a higher priority process.
</p>
<p>First Come First Served, along with maximal absolute priority and
careful control of interrupts and page faults, is the one to use when a
process absolutely, positively has to run at full CPU speed or not at
all.
</p>
<p>Judicious use of <code>sched_yield</code> function invocations by processes
with First Come First Served scheduling policy forms a good compromise
between Round Robin and First Come First Served.
</p>
<p>To understand how scheduling works when processes of different scheduling
policies occupy the same absolute priority, you have to know the nitty
gritty details of how processes enter and exit the ready to run list:
</p>
<p>In both cases, the ready to run list is organized as a true queue, where
a process gets pushed onto the tail when it becomes ready to run and is
popped off the head when the scheduler decides to run it.  Note that
ready to run and running are two mutually exclusive states.  When the
scheduler runs a process, that process is no longer ready to run and no
longer in the ready to run list.  When the process stops running, it
may go back to being ready to run again.
</p>
<p>The only difference between a process that is assigned the Round Robin
scheduling policy and a process that is assigned First Come First Serve
is that in the former case, the process is automatically booted off the
CPU after a certain amount of time.  When that happens, the process goes
back to being ready to run, which means it enters the queue at the tail.
The time quantum we're talking about is small.  Really small.  This is
not your father's timesharing.  For example, with the Linux kernel, the
round robin time slice is a thousand times shorter than its typical
time slice for traditional scheduling.
</p>
<p>A process begins life with the same scheduling policy as its parent process.
Functions described in <a href="#SEC456">Basic Scheduling Functions</a> can change it.
</p>
<p>Only a privileged process can set the scheduling policy of a process
that has absolute priority higher than 0.
</p>
<hr size="6">
<a name="Basic-Scheduling-Functions"></a>
<a name="SEC456"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC455" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC457" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC449" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC452" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="libc_23.html#SEC465" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="libc.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="libc_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="libc_42.html#SEC712" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="libc_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h3 class="subsection"> 22.3.3 Basic Scheduling Functions </h3>

<p>This section describes functions in the GNU C library for setting the
absolute priority and scheduling policy of a process.
</p>
<p><strong>Portability Note:</strong>  On systems that have the functions in this
section, the macro _POSIX_PRIORITY_SCHEDULING is defined in
&lsquo;<tt>&lt;unistd.h&gt;</tt>&rsquo;.
</p>
<p>For the case that the scheduling policy is traditional scheduling, more
functions to fine tune the scheduling are in <a href="#SEC457">Traditional Scheduling</a>.
</p>
<p>Don't try to make too much out of the naming and structure of these
functions.  They don't match the concepts described in this manual
because the functions are as defined by POSIX.1b, but the implementation
on systems that use the GNU C library is the inverse of what the POSIX
structure contemplates.  The POSIX scheme assumes that the primary
scheduling parameter is the scheduling policy and that the priority
value, if any, is a parameter of the scheduling policy.  In the
implementation, though, the priority value is king and the scheduling
policy, if anything, only fine tunes the effect of that priority.
</p>
<p>The symbols in this section are declared by including file &lsquo;<tt>sched.h</tt>&rsquo;.
</p>
<dl>
<dt><u>Data Type:</u> <b>struct sched_param</b>
<a name="IDX2341"></a>
</dt>
<dd><p>This structure describes an absolute priority.
</p><dl compact="compact">
<dt> <code>int sched_priority</code></dt>
<dd><p>absolute priority value
</p></dd>
</dl>
</dd></dl>

<dl>
<dt><u>Function:</u> int <b>sched_setscheduler</b><i> (pid_t <var>pid</var>, int <var>policy</var>, const struct sched_param *<var>param</var>)</i>
<a name="IDX2342"></a>
</dt>
<dd><p>This function sets both the absolute priority and the scheduling policy
for a process.
</p>
<p>It assigns the absolute priority value given by <var>param</var> and the
scheduling policy <var>policy</var> to the process with Process ID <var>pid</var>,
or the calling process if <var>pid</var> is zero.  If <var>policy</var> is
negative, <code>sched_setscheduler</code> keeps the existing scheduling policy.
</p>
<p>The following macros represent the valid values for <var>policy</var>:
</p>
<dl compact="compact">
<dt> <code>SCHED_OTHER</code></dt>
<dd><p>Traditional Scheduling
</p></dd>
<dt> <code>SCHED_FIFO</code></dt>
<dd><p>First In First Out
</p></dd>
<dt> <code>SCHED_RR</code></dt>
<dd><p>Round Robin
</p></dd>
</dl>


<p>On success, the return value is <code>0</code>.  Otherwise, it is <code>-1</code>
and <code>ERRNO</code> is set accordingly.  The <code>errno</code> values specific
to this function are:
</p>
<dl compact="compact">
<dt> <code>EPERM</code></dt>
<dd><ul>
<li>
The calling process does not have <code>CAP_SYS_NICE</code> permission and
<var>policy</var> is not <code>SCHED_OTHER</code> (or it's negative and the
existing policy is not <code>SCHED_OTHER</code>.

</li><li>
The calling process does not have <code>CAP_SYS_NICE</code> permission and its
owner is not the target process' owner.  I.e., the effective uid of the
calling process is neither the effective nor the real uid of process
<var>pid</var>.
</li></ul>

</dd>
<dt> <code>ESRCH</code></dt>
<dd><p>There is no process with pid <var>pid</var> and <var>pid</var> is not zero.
</p>
</dd>
<dt> <code>EINVAL</code></dt>
<dd><ul>
<li>
<var>policy</var> does not identify an existing scheduling policy.

</li><li>
The absolute priority value identified by *<var>param</var> is outside the
valid range for the scheduling policy <var>policy</var> (or the existing
scheduling policy if <var>policy</var> is negative) or <var>param</var> is
null.  <code>sched_get_priority_max</code> and <code>sched_get_priority_min</code>
tell you what the valid range is.

</li><li>
<var>pid</var> is negative.
</li></ul>
</dd>
</dl>

</dd></dl>


<dl>
<dt><u>Function:</u> int <b>sched_getscheduler</b><i> (pid_t <var>pid</var>)</i>
<a name="IDX2343"></a>
</dt>
<dd><p>This function returns the scheduling policy assigned to the process with
Process ID (pid) <var>pid</var>, or the calling process if <var>pid</var> is zero.
</p>
<p>The return value is the scheduling policy.  See
<code>sched_setscheduler</code> for the possible values.
</p>
<p>If the function fails, the return value is instead <code>-1</code> and
<code>errno</code> is set accordingly.
</p>
<p>The <code>errno</code> values specific to this function are:
</p>
<dl compact="compact">
<dt> <code>ESRCH</code></dt>
<dd><p>There is no process with pid <var>pid</var> and it is not zero.
</p>
</dd>
<dt> <code>EINVAL</code></dt>
<dd><p><var>pid</var> is negative.
</p>
</dd>
</dl>

<p>Note that this function is not an exact mate to <code>sched_setscheduler</code>
because while that function sets the scheduling policy and the absolute
priority, this function gets only the scheduling policy.  To get the
absolute priority, use <code>sched_getparam</code>.
</p>
</dd></dl>


<dl>
<dt><u>Function:</u> int <b>sched_setparam</b><i> (pid_t <var>pid</var>, const struct sched_param *<var>param</var>)</i>
<a name="IDX2344"></a>
</dt>
<dd><p>This function sets a process' absolute priority.
</p>
<p>It is functionally identical to <code>sched_setscheduler</code> with
<var>policy</var> = <code>-1</code>.
</p>

</dd></dl>

<dl>
<dt><u>Function:</u> int <b>sched_getparam</b><i> (pid_t <var>pid</var>, const struct sched_param *<var>param</var>)</i>
<a name="IDX2345"></a>
</dt>
<dd><p>This function returns a process' absolute priority.
</p>
<p><var>pid</var> is the Process ID (pid) of the process whose absolute priority
you want to know.
</p>
<p><var>param</var> is a pointer to a structure in which the function stores the
absolute priority of the process.
</p>
<p>On success, the return value is <code>0</code>.  Otherwise, it is <code>-1</code>
and <code>ERRNO</code> is set accordingly.  The <code>errno</code> values specific
to this function are:
</p>
<dl compact="compact">
<dt> <code>ESRCH</code></dt>
<dd><p>There is no process with pid <var>pid</var> and it is not zero.
</p>
</dd>
<dt> <code>EINVAL</code></dt>
<dd><p><var>pid</var> is negative.
</p>
</dd>
</dl>

</dd></dl>


<dl>
<dt><u>Function:</u> int <b>sched_get_priority_min</b><i> (int *<var>policy</var>);</i>
<a name="IDX2346"></a>
</dt>
<dd><p>This function returns the lowest absolute priority value that is
allowable for a process with scheduling policy <var>policy</var>.
</p>
<p>On Linux, it is 0 for SCHED_OTHER and 1 for everything else.
</p>
<p>On success, the return value is <code>0</code>.  Otherwise, it is <code>-1</code>
and <code>ERRNO</code> is set accordingly.  The <code>errno</code> values specific
to this function are:
</p>
<dl compact="compact">
<dt> <code>EINVAL</code></dt>
<dd><p><var>policy</var> does not identify an existing scheduling policy.
</p></dd>
</dl>

</dd></dl>

<dl>
<dt><u>Function:</u> int <b>sched_get_priority_max</b><i> (int *<var>policy</var>);</i>
<a name="IDX2347"></a>
</dt>
<dd><p>This function returns the highest absolute priority value that is
allowable for a process that with scheduling policy <var>policy</var>.
</p>
<p>On Linux, it is 0 for SCHED_OTHER and 99 for everything else.
</p>
<p>On success, the return value is <code>0</code>.  Otherwise, it is <code>-1</code>
and <code>ERRNO</code> is set accordingly.  The <code>errno</code> values specific
to this function are:
</p>
<dl compact="compact">
<dt> <code>EINVAL</code></dt>
<dd><p><var>policy</var> does not identify an existing scheduling policy.
</p></dd>
</dl>

</dd></dl>

<dl>
<dt><u>Function:</u> int <b>sched_rr_get_interval</b><i> (pid_t <var>pid</var>, struct timespec *<var>interval</var>)</i>
<a name="IDX2348"></a>
</dt>
<dd><p>This function returns the length of the quantum (time slice) used with
the Round Robin scheduling policy, if it is used, for the process with
Process ID <var>pid</var>.
</p>
<p>It returns the length of time as <var>interval</var>.
</p>
<p>With a Linux kernel, the round robin time slice is always 150
microseconds, and <var>pid</var> need not even be a real pid.
</p>
<p>The return value is <code>0</code> on success and in the pathological case
that it fails, the return value is <code>-1</code> and <code>errno</code> is set
accordingly.  There is nothing specific that can go wrong with this
function, so there are no specific <code>errno</code> values.
</p>
</dd></dl>

<dl>
<dt><u>Function:</u> int <b>sched_yield</b><i> (void)</i>
<a name="IDX2349"></a>
</dt>
<dd><p>This function voluntarily gives up the process' claim on the CPU.
</p>
<p>Technically, <code>sched_yield</code> causes the calling process to be made
immediately ready to run (as opposed to running, which is what it was
before).  This means that if it has absolute priority higher than 0, it
gets pushed onto the tail of the queue of processes that share its
absolute priority and are ready to run, and it will run again when its
turn next arrives.  If its absolute priority is 0, it is more
complicated, but still has the effect of yielding the CPU to other
processes.
</p>
<p>If there are no other processes that share the calling process' absolute
priority, this function doesn't have any effect.
</p>
<p>To the extent that the containing program is oblivious to what other
processes in the system are doing and how fast it executes, this
function appears as a no-op.
</p>
<p>The return value is <code>0</code> on success and in the pathological case
that it fails, the return value is <code>-1</code> and <code>errno</code> is set
accordingly.  There is nothing specific that can go wrong with this
function, so there are no specific <code>errno</code> values.
</p>
</dd></dl>

<hr size="6">
<a name="Traditional-Scheduling"></a>
<a name="SEC457"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC456" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC458" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC449" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC452" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="libc_23.html#SEC465" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="libc.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="libc_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="libc_42.html#SEC712" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="libc_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h3 class="subsection"> 22.3.4 Traditional Scheduling </h3>

<p>This section is about the scheduling among processes whose absolute
priority is 0.  When the system hands out the scraps of CPU time that
are left over after the processes with higher absolute priority have
taken all they want, the scheduling described herein determines who
among the great unwashed processes gets them.
</p>
<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top"><a href="#SEC458">22.3.4.1 Introduction To Traditional Scheduling</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC459">22.3.4.2 Functions For Traditional Scheduling</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
</table>

<hr size="6">
<a name="Traditional-Scheduling-Intro"></a>
<a name="SEC458"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC457" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC459" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC449" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC457" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="libc_23.html#SEC465" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="libc.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="libc_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="libc_42.html#SEC712" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="libc_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h4 class="subsubsection"> 22.3.4.1 Introduction To Traditional Scheduling </h4>

<p>Long before there was absolute priority (See <a href="#SEC453">Absolute Priority</a>),
Unix systems were scheduling the CPU using this system.  When Posix came
in like the Romans and imposed absolute priorities to accommodate the
needs of realtime processing, it left the indigenous Absolute Priority
Zero processes to govern themselves by their own familiar scheduling
policy.
</p>
<p>Indeed, absolute priorities higher than zero are not available on many
systems today and are not typically used when they are, being intended
mainly for computers that do realtime processing.  So this section
describes the only scheduling many programmers need to be concerned
about.
</p>
<p>But just to be clear about the scope of this scheduling: Any time a
process with a absolute priority of 0 and a process with an absolute
priority higher than 0 are ready to run at the same time, the one with
absolute priority 0 does not run.  If it's already running when the
higher priority ready-to-run process comes into existence, it stops
immediately.
</p>
<p>In addition to its absolute priority of zero, every process has another
priority, which we will refer to as &quot;dynamic priority&quot; because it changes
over time.  The dynamic priority is meaningless for processes with
an absolute priority higher than zero.
</p>
<p>The dynamic priority sometimes determines who gets the next turn on the
CPU.  Sometimes it determines how long turns last.  Sometimes it
determines whether a process can kick another off the CPU.
</p>
<p>In Linux, the value is a combination of these things, but mostly it is
just determines the length of the time slice.  The higher a process'
dynamic priority, the longer a shot it gets on the CPU when it gets one.
If it doesn't use up its time slice before giving up the CPU to do
something like wait for I/O, it is favored for getting the CPU back when
it's ready for it, to finish out its time slice.  Other than that,
selection of processes for new time slices is basically round robin.
But the scheduler does throw a bone to the low priority processes: A
process' dynamic priority rises every time it is snubbed in the
scheduling process.  In Linux, even the fat kid gets to play.
</p>
<p>The fluctuation of a process' dynamic priority is regulated by another
value: The &ldquo;nice&rdquo; value.  The nice value is an integer, usually in the
range -20 to 20, and represents an upper limit on a process' dynamic
priority.  The higher the nice number, the lower that limit.
</p>
<p>On a typical Linux system, for example, a process with a nice value of
20 can get only 10 milliseconds on the CPU at a time, whereas a process
with a nice value of -20 can achieve a high enough priority to get 400
milliseconds.
</p>
<p>The idea of the nice value is deferential courtesy.  In the beginning,
in the Unix garden of Eden, all processes shared equally in the bounty
of the computer system.  But not all processes really need the same
share of CPU time, so the nice value gave a courteous process the
ability to refuse its equal share of CPU time that others might prosper.
Hence, the higher a process' nice value, the nicer the process is.
(Then a snake came along and offered some process a negative nice value
and the system became the crass resource allocation system we know
today).
</p>
<p>Dynamic priorities tend upward and downward with an objective of
smoothing out allocation of CPU time and giving quick response time to
infrequent requests.  But they never exceed their nice limits, so on a
heavily loaded CPU, the nice value effectively determines how fast a
process runs.
</p>
<p>In keeping with the socialistic heritage of Unix process priority, a
process begins life with the same nice value as its parent process and
can raise it at will.  A process can also raise the nice value of any
other process owned by the same user (or effective user).  But only a
privileged process can lower its nice value.  A privileged process can
also raise or lower another process' nice value.
</p>
<p>GNU C Library functions for getting and setting nice values are described in
See section <a href="#SEC459">Functions For Traditional Scheduling</a>.
</p>
<hr size="6">
<a name="Traditional-Scheduling-Functions"></a>
<a name="SEC459"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC458" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC460" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC449" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC457" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="libc_23.html#SEC465" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="libc.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="libc_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="libc_42.html#SEC712" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="libc_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h4 class="subsubsection"> 22.3.4.2 Functions For Traditional Scheduling </h4>

<p>This section describes how you can read and set the nice value of a
process.  All these symbols are declared in &lsquo;<tt>sys/resource.h</tt>&rsquo;.
</p>
<p>The function and macro names are defined by POSIX, and refer to
&quot;priority,&quot; but the functions actually have to do with nice values, as
the terms are used both in the manual and POSIX.
</p>
<p>The range of valid nice values depends on the kernel, but typically it
runs from <code>-20</code> to <code>20</code>.  A lower nice value corresponds to
higher priority for the process.  These constants describe the range of
priority values:
</p>
<dl compact="compact">
<dt> <code>PRIO_MIN</code>
<a name="IDX2350"></a>
</dt>
<dd><p>The lowest valid nice value.
</p>
</dd>
<dt> <code>PRIO_MAX</code>
<a name="IDX2351"></a>
</dt>
<dd><p>The highest valid nice value.
</p></dd>
</dl>

<dl>
<dt><u>Function:</u> int <b>getpriority</b><i> (int <var>class</var>, int <var>id</var>)</i>
<a name="IDX2352"></a>
</dt>
<dd><p>Return the nice value of a set of processes; <var>class</var> and <var>id</var>
specify which ones (see below).  If the processes specified do not all
have the same nice value, this returns the lowest value that any of them
has.
</p>
<p>On success, the return value is <code>0</code>.  Otherwise, it is <code>-1</code>
and <code>ERRNO</code> is set accordingly.  The <code>errno</code> values specific
to this function are:
</p>
<dl compact="compact">
<dt> <code>ESRCH</code></dt>
<dd><p>The combination of <var>class</var> and <var>id</var> does not match any existing
process.
</p>
</dd>
<dt> <code>EINVAL</code></dt>
<dd><p>The value of <var>class</var> is not valid.
</p></dd>
</dl>

<p>If the return value is <code>-1</code>, it could indicate failure, or it could
be the nice value.  The only way to make certain is to set <code>errno =
0</code> before calling <code>getpriority</code>, then use <code>errno != 0</code>
afterward as the criterion for failure.
</p></dd></dl>

<dl>
<dt><u>Function:</u> int <b>setpriority</b><i> (int <var>class</var>, int <var>id</var>, int <var>niceval</var>)</i>
<a name="IDX2353"></a>
</dt>
<dd><p>Set the nice value of a set of processes to <var>niceval</var>; <var>class</var>
and <var>id</var> specify which ones (see below).
</p>
<p>The return value is <code>0</code> on success, and <code>-1</code> on
failure.  The following <code>errno</code> error condition are possible for
this function:
</p>
<dl compact="compact">
<dt> <code>ESRCH</code></dt>
<dd><p>The combination of <var>class</var> and <var>id</var> does not match any existing
process.
</p>
</dd>
<dt> <code>EINVAL</code></dt>
<dd><p>The value of <var>class</var> is not valid.
</p>
</dd>
<dt> <code>EPERM</code></dt>
<dd><p>The call would set the nice value of a process which is owned by a different
user than the calling process (i.e., the target process' real or effective
uid does not match the calling process' effective uid) and the calling
process does not have <code>CAP_SYS_NICE</code> permission.
</p>
</dd>
<dt> <code>EACCES</code></dt>
<dd><p>The call would lower the process' nice value and the process does not have
<code>CAP_SYS_NICE</code> permission.
</p></dd>
</dl>

</dd></dl>

<p>The arguments <var>class</var> and <var>id</var> together specify a set of
processes in which you are interested.  These are the possible values of
<var>class</var>:
</p>
<dl compact="compact">
<dt> <code>PRIO_PROCESS</code>
<a name="IDX2354"></a>
</dt>
<dd><p>One particular process.  The argument <var>id</var> is a process ID (pid).
</p>
</dd>
<dt> <code>PRIO_PGRP</code>
<a name="IDX2355"></a>
</dt>
<dd><p>All the processes in a particular process group.  The argument <var>id</var> is
a process group ID (pgid).
</p>
</dd>
<dt> <code>PRIO_USER</code>
<a name="IDX2356"></a>
</dt>
<dd><p>All the processes owned by a particular user (i.e., whose real uid
indicates the user).  The argument <var>id</var> is a user ID (uid).
</p></dd>
</dl>

<p>If the argument <var>id</var> is 0, it stands for the calling process, its
process group, or its owner (real uid), according to <var>class</var>.
</p>
<dl>
<dt><u>Function:</u> int <b>nice</b><i> (int <var>increment</var>)</i>
<a name="IDX2357"></a>
</dt>
<dd><p>Increment the nice value of the calling process by <var>increment</var>.
The return value is the new nice value on success, and <code>-1</code> on
failure.  In the case of failure, <code>errno</code> will be set to the
same values as for <code>setpriority</code>.
</p>

<p>Here is an equivalent definition of <code>nice</code>:
</p>
<table><tr><td>&nbsp;</td><td><pre class="smallexample">int
nice (int increment)
{
  int result, old = getpriority (PRIO_PROCESS, 0);
  result = setpriority (PRIO_PROCESS, 0, old + increment);
  if (result != -1)
      return old + increment;
  else
      return -1;
}
</pre></td></tr></table>
</dd></dl>


<hr size="6">
<a name="CPU-Affinity"></a>
<a name="SEC460"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC459" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC461" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC449" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC452" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="libc_23.html#SEC465" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="libc.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="libc_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="libc_42.html#SEC712" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="libc_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h3 class="subsection"> 22.3.5 Limiting execution to certain CPUs </h3>

<p>On a multi-processor system the operating system usually distributes
the different processes which are runnable on all available CPUs in a
way which allows the system to work most efficiently.  Which processes
and threads run can be to some extend be control with the scheduling
functionality described in the last sections.  But which CPU finally
executes which process or thread is not covered.
</p>
<p>There are a number of reasons why a program might want to have control
over this aspect of the system as well:
</p>
<ul>
<li>
One thread or process is responsible for absolutely critical work
which under no circumstances must be interrupted or hindered from
making process by other process or threads using CPU resources.  In
this case the special process would be confined to a CPU which no
other process or thread is allowed to use.

</li><li>
The access to certain resources (RAM, I/O ports) has different costs
from different CPUs.  This is the case in NUMA (Non-Uniform Memory
Architecture) machines.  Preferably memory should be accessed locally
but this requirement is usually not visible to the scheduler.
Therefore forcing a process or thread to the CPUs which have local
access to the mostly used memory helps to significantly boost the
performance.

</li><li>
In controlled runtimes resource allocation and book-keeping work (for
instance garbage collection) is performance local to processors.  This
can help to reduce locking costs if the resources do not have to be
protected from concurrent accesses from different processors.
</li></ul>

<p>The POSIX standard up to this date is of not much help to solve this
problem.  The Linux kernel provides a set of interfaces to allow
specifying <em>affinity sets</em> for a process.  The scheduler will
schedule the thread or process on on CPUs specified by the affinity
masks.  The interfaces which the GNU C library define follow to some
extend the Linux kernel interface.
</p>
<dl>
<dt><u>Data Type:</u> <b>cpu_set_t</b>
<a name="IDX2358"></a>
</dt>
<dd><p>This data set is a bitset where each bit represents a CPU.  How the
system's CPUs are mapped to bits in the bitset is system dependent.
The data type has a fixed size; in the unlikely case that the number
of bits are not sufficient to describe the CPUs of the system a
different interface has to be used.
</p>
<p>This type is a GNU extension and is defined in &lsquo;<tt>sched.h</tt>&rsquo;.
</p></dd></dl>

<p>To manipulate the bitset, to set and reset bits, a number of macros is
defined.  Some of the macros take a CPU number as a parameter.  Here
it is important to never exceed the size of the bitset.  The following
macro specifies the number of bits in the <code>cpu_set_t</code> bitset.
</p>
<dl>
<dt><u>Macro:</u> int <b>CPU_SETSIZE</b>
<a name="IDX2359"></a>
</dt>
<dd><p>The value of this macro is the maximum number of CPUs which can be
handled with a <code>cpu_set_t</code> object.
</p></dd></dl>

<p>The type <code>cpu_set_t</code> should be considered opaque; all
manipulation should happen via the next four macros.
</p>
<dl>
<dt><u>Macro:</u> void <b>CPU_ZERO</b><i> (cpu_set_t *<var>set</var>)</i>
<a name="IDX2360"></a>
</dt>
<dd><p>This macro initializes the CPU set <var>set</var> to be the empty set.
</p>
<p>This macro is a GNU extension and is defined in &lsquo;<tt>sched.h</tt>&rsquo;.
</p></dd></dl>

<dl>
<dt><u>Macro:</u> void <b>CPU_SET</b><i> (int <var>cpu</var>, cpu_set_t *<var>set</var>)</i>
<a name="IDX2361"></a>
</dt>
<dd><p>This macro adds <var>cpu</var> to the CPU set <var>set</var>.
</p>
<p>The <var>cpu</var> parameter must not have side effects since it is
evaluated more than once.
</p>
<p>This macro is a GNU extension and is defined in &lsquo;<tt>sched.h</tt>&rsquo;.
</p></dd></dl>

<dl>
<dt><u>Macro:</u> void <b>CPU_CLR</b><i> (int <var>cpu</var>, cpu_set_t *<var>set</var>)</i>
<a name="IDX2362"></a>
</dt>
<dd><p>This macro removes <var>cpu</var> from the CPU set <var>set</var>.
</p>
<p>The <var>cpu</var> parameter must not have side effects since it is
evaluated more than once.
</p>
<p>This macro is a GNU extension and is defined in &lsquo;<tt>sched.h</tt>&rsquo;.
</p></dd></dl>

<dl>
<dt><u>Macro:</u> int <b>CPU_ISSET</b><i> (int <var>cpu</var>, const cpu_set_t *<var>set</var>)</i>
<a name="IDX2363"></a>
</dt>
<dd><p>This macro returns a nonzero value (true) if <var>cpu</var> is a member
of the CPU set <var>set</var>, and zero (false) otherwise.
</p>
<p>The <var>cpu</var> parameter must not have side effects since it is
evaluated more than once.
</p>
<p>This macro is a GNU extension and is defined in &lsquo;<tt>sched.h</tt>&rsquo;.
</p></dd></dl>


<p>CPU bitsets can be constructed from scratch or the currently installed
affinity mask can be retrieved from the system.
</p>
<dl>
<dt><u>Function:</u> int <b>sched_getaffinity</b><i> (pid_t <var>pid</var>, size_t <var>cpusetsize</var>, cpu_set_t *<var>cpuset</var>)</i>
<a name="IDX2364"></a>
</dt>
<dd><p>This functions stores the CPU affinity mask for the process or thread
with the ID <var>pid</var> in the <var>cpusetsize</var> bytes long bitmap
pointed to by <var>cpuset</var>.  If successful, the function always
initializes all bits in the <code>cpu_set_t</code> object and returns zero.
</p>
<p>If <var>pid</var> does not correspond to a process or thread on the system
the or the function fails for some other reason, it returns <code>-1</code>
and <code>errno</code> is set to represent the error condition.
</p>
<dl compact="compact">
<dt> <code>ESRCH</code></dt>
<dd><p>No process or thread with the given ID found.
</p>
</dd>
<dt> <code>EFAULT</code></dt>
<dd><p>The pointer <var>cpuset</var> is does not point to a valid object.
</p></dd>
</dl>

<p>This function is a GNU extension and is declared in &lsquo;<tt>sched.h</tt>&rsquo;.
</p></dd></dl>

<p>Note that it is not portably possible to use this information to
retrieve the information for different POSIX threads.  A separate
interface must be provided for that.
</p>
<dl>
<dt><u>Function:</u> int <b>sched_setaffinity</b><i> (pid_t <var>pid</var>, size_t <var>cpusetsize</var>, const cpu_set_t *<var>cpuset</var>)</i>
<a name="IDX2365"></a>
</dt>
<dd><p>This function installs the <var>cpusetsize</var> bytes long affinity mask
pointed to by <var>cpuset</var> for the process or thread with the ID <var>pid</var>.
If successful the function returns zero and the scheduler will in future
take the affinity information into account.
</p>
<p>If the function fails it will return <code>-1</code> and <code>errno</code> is set
to the error code:
</p>
<dl compact="compact">
<dt> <code>ESRCH</code></dt>
<dd><p>No process or thread with the given ID found.
</p>
</dd>
<dt> <code>EFAULT</code></dt>
<dd><p>The pointer <var>cpuset</var> is does not point to a valid object.
</p>
</dd>
<dt> <code>EINVAL</code></dt>
<dd><p>The bitset is not valid.  This might mean that the affinity set might
not leave a processor for the process or thread to run on.
</p></dd>
</dl>

<p>This function is a GNU extension and is declared in &lsquo;<tt>sched.h</tt>&rsquo;.
</p></dd></dl>


<hr size="6">
<a name="Memory-Resources"></a>
<a name="SEC461"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC460" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC462" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC449" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC449" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="libc_23.html#SEC465" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="libc.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="libc_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="libc_42.html#SEC712" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="libc_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="section"> 22.4 Querying memory available resources </h2>

<p>The amount of memory available in the system and the way it is organized
determines oftentimes the way programs can and have to work.  For
functions like <code>mmap</code> it is necessary to know about the size of
individual memory pages and knowing how much memory is available enables
a program to select appropriate sizes for, say, caches.  Before we get
into these details a few words about memory subsystems in traditional
Unix systems will be given.
</p>
<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top"><a href="#SEC462">22.4.1 Overview about traditional Unix memory handling</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top"></td></tr>
<tr><td align="left" valign="top"><a href="#SEC463">22.4.2 How to get information about the memory subsystem?</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top"></td></tr>
</table>

<hr size="6">
<a name="Memory-Subsystem"></a>
<a name="SEC462"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC461" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC463" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC449" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC461" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="libc_23.html#SEC465" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="libc.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="libc_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="libc_42.html#SEC712" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="libc_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h3 class="subsection"> 22.4.1 Overview about traditional Unix memory handling </h3>

<p>Unix systems normally provide processes virtual address spaces.  This
means that the addresses of the memory regions do not have to correspond
directly to the addresses of the actual physical memory which stores the
data.  An extra level of indirection is introduced which translates
virtual addresses into physical addresses.  This is normally done by the
hardware of the processor.
</p>
<a name="IDX2366"></a>
<p>Using a virtual address space has several advantage.  The most important
is process isolation.  The different processes running on the system
cannot interfere directly with each other.  No process can write into
the address space of another process (except when shared memory is used
but then it is wanted and controlled).
</p>
<p>Another advantage of virtual memory is that the address space the
processes see can actually be larger than the physical memory available.
The physical memory can be extended by storage on an external media
where the content of currently unused memory regions is stored.  The
address translation can then intercept accesses to these memory regions
and make memory content available again by loading the data back into
memory.  This concept makes it necessary that programs which have to use
lots of memory know the difference between available virtual address
space and available physical memory.  If the working set of virtual
memory of all the processes is larger than the available physical memory
the system will slow down dramatically due to constant swapping of
memory content from the memory to the storage media and back.  This is
called &ldquo;thrashing&rdquo;.
<a name="IDX2367"></a>
</p>
<a name="IDX2368"></a>
<a name="IDX2369"></a>
<p>A final aspect of virtual memory which is important and follows from
what is said in the last paragraph is the granularity of the virtual
address space handling.  When we said that the virtual address handling
stores memory content externally it cannot do this on a byte-by-byte
basis.  The administrative overhead does not allow this (leaving alone
the processor hardware).  Instead several thousand bytes are handled
together and form a <em>page</em>.  The size of each page is always a power
of two byte.  The smallest page size in use today is 4096, with 8192,
16384, and 65536 being other popular sizes.
</p>
<hr size="6">
<a name="Query-Memory-Parameters"></a>
<a name="SEC463"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC462" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC464" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC449" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC461" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="libc_23.html#SEC465" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="libc.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="libc_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="libc_42.html#SEC712" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="libc_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h3 class="subsection"> 22.4.2 How to get information about the memory subsystem? </h3>

<p>The page size of the virtual memory the process sees is essential to
know in several situations.  Some programming interface (e.g.,
<code>mmap</code>, see section <a href="libc_13.html#SEC248">Memory-mapped I/O</a>) require the user to provide
information adjusted to the page size.  In the case of <code>mmap</code> is it
necessary to provide a length argument which is a multiple of the page
size.  Another place where the knowledge about the page size is useful
is in memory allocation.  If one allocates pieces of memory in larger
chunks which are then subdivided by the application code it is useful to
adjust the size of the larger blocks to the page size.  If the total
memory requirement for the block is close (but not larger) to a multiple
of the page size the kernel's memory handling can work more effectively
since it only has to allocate memory pages which are fully used.  (To do
this optimization it is necessary to know a bit about the memory
allocator which will require a bit of memory itself for each block and
this overhead must not push the total size over the page size multiple.
</p>
<p>The page size traditionally was a compile time constant.  But recent
development of processors changed this.  Processors now support
different page sizes and they can possibly even vary among different
processes on the same system.  Therefore the system should be queried at
runtime about the current page size and no assumptions (except about it
being a power of two) should be made.
</p>
<a name="IDX2370"></a>
<p>The correct interface to query about the page size is <code>sysconf</code>
(see section <a href="libc_31.html#SEC653">Definition of <code>sysconf</code></a>) with the parameter <code>_SC_PAGESIZE</code>.
There is a much older interface available, too.
</p>
<dl>
<dt><u>Function:</u> int <b>getpagesize</b><i> (void)</i>
<a name="IDX2371"></a>
</dt>
<dd><p>The <code>getpagesize</code> function returns the page size of the process.
This value is fixed for the runtime of the process but can vary in
different runs of the application.
</p>
<p>The function is declared in &lsquo;<tt>unistd.h</tt>&rsquo;.
</p></dd></dl>

<p>Widely available on System V derived systems is a method to get
information about the physical memory the system has.  The call
</p>
<a name="IDX2372"></a>
<a name="IDX2373"></a>
<table><tr><td>&nbsp;</td><td><pre class="smallexample">  sysconf (_SC_PHYS_PAGES)
</pre></td></tr></table>

<p>returns the total number of pages of physical the system has.
This does not mean all this memory is available.  This information can
be found using
</p>
<a name="IDX2374"></a>
<a name="IDX2375"></a>
<table><tr><td>&nbsp;</td><td><pre class="smallexample">  sysconf (_SC_AVPHYS_PAGES)
</pre></td></tr></table>

<p>These two values help to optimize applications.  The value returned for
<code>_SC_AVPHYS_PAGES</code> is the amount of memory the application can use
without hindering any other process (given that no other process
increases its memory usage).  The value returned for
<code>_SC_PHYS_PAGES</code> is more or less a hard limit for the working set.
If all applications together constantly use more than that amount of
memory the system is in trouble.
</p>
<p>The GNU C library provides in addition to these already described way to
get this information two functions.  They are declared in the file
&lsquo;<tt>sys/sysinfo.h</tt>&rsquo;.  Programmers should prefer to use the
<code>sysconf</code> method described above.
</p>
<dl>
<dt><u>Function:</u> long int <b>get_phys_pages</b><i> (void)</i>
<a name="IDX2376"></a>
</dt>
<dd><p>The <code>get_phys_pages</code> function returns the total number of pages of
physical the system has.  To get the amount of memory this number has to
be multiplied by the page size.
</p>
<p>This function is a GNU extension.
</p></dd></dl>

<dl>
<dt><u>Function:</u> long int <b>get_avphys_pages</b><i> (void)</i>
<a name="IDX2377"></a>
</dt>
<dd><p>The <code>get_phys_pages</code> function returns the number of available pages of
physical the system has.  To get the amount of memory this number has to
be multiplied by the page size.
</p>
<p>This function is a GNU extension.
</p></dd></dl>

<hr size="6">
<a name="Processor-Resources"></a>
<a name="SEC464"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC463" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="libc_23.html#SEC465" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC449" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC449" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="libc_23.html#SEC465" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="libc.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="libc_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="libc_42.html#SEC712" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="libc_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="section"> 22.5 Learn about the processors available </h2>

<p>The use of threads or processes with shared memory allows an application
to take advantage of all the processing power a system can provide.  If
the task can be parallelized the optimal way to write an application is
to have at any time as many processes running as there are processors.
To determine the number of processors available to the system one can
run
</p>
<a name="IDX2378"></a>
<a name="IDX2379"></a>
<table><tr><td>&nbsp;</td><td><pre class="smallexample">  sysconf (_SC_NPROCESSORS_CONF)
</pre></td></tr></table>

<p>which returns the number of processors the operating system configured.
But it might be possible for the operating system to disable individual
processors and so the call
</p>
<a name="IDX2380"></a>
<a name="IDX2381"></a>
<table><tr><td>&nbsp;</td><td><pre class="smallexample">  sysconf (_SC_NPROCESSORS_ONLN)
</pre></td></tr></table>

<p>returns the number of processors which are currently inline (i.e.,
available).
</p>
<p>For these two pieces of information the GNU C library also provides
functions to get the information directly.  The functions are declared
in &lsquo;<tt>sys/sysinfo.h</tt>&rsquo;.
</p>
<dl>
<dt><u>Function:</u> int <b>get_nprocs_conf</b><i> (void)</i>
<a name="IDX2382"></a>
</dt>
<dd><p>The <code>get_nprocs_conf</code> function returns the number of processors the
operating system configured.
</p>
<p>This function is a GNU extension.
</p></dd></dl>

<dl>
<dt><u>Function:</u> int <b>get_nprocs</b><i> (void)</i>
<a name="IDX2383"></a>
</dt>
<dd><p>The <code>get_nprocs</code> function returns the number of available processors.
</p>
<p>This function is a GNU extension.
</p></dd></dl>

<a name="IDX2384"></a>
<p>Before starting more threads it should be checked whether the processors
are not already overused.  Unix systems calculate something called the
<em>load average</em>.  This is a number indicating how many processes were
running.  This number is average over different periods of times
(normally 1, 5, and 15 minutes).
</p>
<dl>
<dt><u>Function:</u> int <b>getloadavg</b><i> (double <var>loadavg</var>[], int <var>nelem</var>)</i>
<a name="IDX2385"></a>
</dt>
<dd><p>This function gets the 1, 5 and 15 minute load averages of the
system. The values are placed in <var>loadavg</var>.  <code>getloadavg</code> will
place at most <var>nelem</var> elements into the array but never more than
three elements.  The return value is the number of elements written to
<var>loadavg</var>, or -1 on error.
</p>
<p>This function is declared in &lsquo;<tt>stdlib.h</tt>&rsquo;.
</p></dd></dl>
<hr size="6">
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC449" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="libc_23.html#SEC465" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="libc.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="libc_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="libc_42.html#SEC712" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="libc_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<p>
 <font size="-1">
  This document was generated by <em>root</em> on <em>February, 13 2009</em> using <a href="http://www.nongnu.org/texi2html/"><em>texi2html 1.78</em></a>.
 </font>
 <br>

</p>
</body>
</html>
