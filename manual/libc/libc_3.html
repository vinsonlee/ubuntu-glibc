<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html401/loose.dtd">
<html>
<!-- This file documents the GNU C library.

This is Edition 0.12, last updated 2007-10-27,
of The GNU C Library Reference Manual, for version 2.8.

Copyright (C) 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2001, 2002,
2003, 2007, 2008 Free Software Foundation, Inc.

Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.2 or
any later version published by the Free Software Foundation; with the
Invariant Sections being "Free Software Needs Free Documentation"
and "GNU Lesser General Public License", the Front-Cover texts being
"A GNU Manual", and with the Back-Cover Texts as in (a) below.  A
copy of the license is included in the section entitled "GNU Free
Documentation License".

(a) The FSF's Back-Cover Text is: "You have the freedom to
copy and modify this GNU manual.  Buying copies from the FSF
supports it in developing GNU and promoting software freedom."
 -->
<!-- Created on February, 26 2009 by texi2html 1.78 -->
<!--
Written by: Lionel Cons <Lionel.Cons@cern.ch> (original author)
            Karl Berry  <karl@freefriends.org>
            Olaf Bachmann <obachman@mathematik.uni-kl.de>
            and many others.
Maintained by: Many creative people.
Send bugs and suggestions to <texi2html-bug@nongnu.org>

-->
<head>
<title>The GNU C Library: 3. Virtual Memory Allocation And Paging</title>

<meta name="description" content="The GNU C Library: 3. Virtual Memory Allocation And Paging">
<meta name="keywords" content="The GNU C Library: 3. Virtual Memory Allocation And Paging">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="texi2html 1.78">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
<!--
a.summary-letter {text-decoration: none}
pre.display {font-family: serif}
pre.format {font-family: serif}
pre.menu-comment {font-family: serif}
pre.menu-preformatted {font-family: serif}
pre.smalldisplay {font-family: serif; font-size: smaller}
pre.smallexample {font-size: smaller}
pre.smallformat {font-family: serif; font-size: smaller}
pre.smalllisp {font-size: smaller}
span.roman {font-family:serif; font-weight:normal;}
span.sansserif {font-family:sans-serif; font-weight:normal;}
ul.toc {list-style: none}
-->
</style>


</head>

<body lang="en" bgcolor="#FFFFFF" text="#000000" link="#0000FF" vlink="#800080" alink="#FF0000">

<a name="Memory"></a>
<a name="SEC19"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="libc_2.html#SEC18" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC20" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="libc_2.html#SEC15" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="libc.html#SEC_Top" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="libc_4.html#SEC64" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="libc.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="libc_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="libc_42.html#SEC712" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="libc_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h1 class="chapter"> 3. Virtual Memory Allocation And Paging </h1>

<p>This chapter describes how processes manage and use memory in a system
that uses the GNU C library.
</p>
<p>The GNU C Library has several functions for dynamically allocating
virtual memory in various ways.  They vary in generality and in
efficiency.  The library also provides functions for controlling paging
and allocation of real memory.
</p>

<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top"><a href="#SEC20">3.1 Process Memory Concepts</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">             An introduction to concepts and terminology.
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC21">3.2 Allocating Storage For Program Data</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">           Allocating storage for your program data
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC60">3.4 Locking Pages</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">               Preventing page faults
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC59">3.3 Resizing the Data Segment</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">   <code>brk</code>, <code>sbrk</code>
</td></tr>
</table>

<p>Memory mapped I/O is not discussed in this chapter.  See section <a href="libc_13.html#SEC248">Memory-mapped I/O</a>.
</p>


<hr size="6">
<a name="Memory-Concepts"></a>
<a name="SEC20"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC19" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC21" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC19" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC19" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="libc_4.html#SEC64" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="libc.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="libc_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="libc_42.html#SEC712" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="libc_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="section"> 3.1 Process Memory Concepts </h2>

<p>One of the most basic resources a process has available to it is memory.
There are a lot of different ways systems organize memory, but in a
typical one, each process has one linear virtual address space, with
addresses running from zero to some huge maximum.  It need not be
contiguous; i.e., not all of these addresses actually can be used to
store data.
</p>
<p>The virtual memory is divided into pages (4 kilobytes is typical).
Backing each page of virtual memory is a page of real memory (called a
<em>frame</em>) or some secondary storage, usually disk space.  The disk
space might be swap space or just some ordinary disk file.  Actually, a
page of all zeroes sometimes has nothing at all backing it &ndash; there's
just a flag saying it is all zeroes.
<a name="IDX201"></a>
<a name="IDX202"></a>
<a name="IDX203"></a>
<a name="IDX204"></a>
</p>
<p>The same frame of real memory or backing store can back multiple virtual
pages belonging to multiple processes.  This is normally the case, for
example, with virtual memory occupied by GNU C library code.  The same
real memory frame containing the <code>printf</code> function backs a virtual
memory page in each of the existing processes that has a <code>printf</code>
call in its program.
</p>
<p>In order for a program to access any part of a virtual page, the page
must at that moment be backed by (&ldquo;connected to&rdquo;) a real frame.  But
because there is usually a lot more virtual memory than real memory, the
pages must move back and forth between real memory and backing store
regularly, coming into real memory when a process needs to access them
and then retreating to backing store when not needed anymore.  This
movement is called <em>paging</em>.
</p>
<p>When a program attempts to access a page which is not at that moment
backed by real memory, this is known as a <em>page fault</em>.  When a page
fault occurs, the kernel suspends the process, places the page into a
real page frame (this is called &ldquo;paging in&rdquo; or &ldquo;faulting in&rdquo;), then
resumes the process so that from the process' point of view, the page
was in real memory all along.  In fact, to the process, all pages always
seem to be in real memory.  Except for one thing: the elapsed execution
time of an instruction that would normally be a few nanoseconds is
suddenly much, much, longer (because the kernel normally has to do I/O
to complete the page-in).  For programs sensitive to that, the functions
described in <a href="#SEC60">Locking Pages</a> can control it.
<a name="IDX205"></a>
<a name="IDX206"></a>
</p>
<p>Within each virtual address space, a process has to keep track of what
is at which addresses, and that process is called memory allocation.
Allocation usually brings to mind meting out scarce resources, but in
the case of virtual memory, that's not a major goal, because there is
generally much more of it than anyone needs.  Memory allocation within a
process is mainly just a matter of making sure that the same byte of
memory isn't used to store two different things.
</p>
<p>Processes allocate memory in two major ways: by exec and
programmatically.  Actually, forking is a third way, but it's not very
interesting.  See section <a href="libc_26.html#SEC572">Creating a Process</a>.
</p>
<p>Exec is the operation of creating a virtual address space for a process,
loading its basic program into it, and executing the program.  It is
done by the &ldquo;exec&rdquo; family of functions (e.g. <code>execl</code>).  The
operation takes a program file (an executable), it allocates space to
load all the data in the executable, loads it, and transfers control to
it.  That data is most notably the instructions of the program (the
<em>text</em>), but also literals and constants in the program and even
some variables: C variables with the static storage class (see section <a href="#SEC22">Memory Allocation in C Programs</a>).
<a name="IDX207"></a>
<a name="IDX208"></a>
<a name="IDX209"></a>
</p>
<p>Once that program begins to execute, it uses programmatic allocation to
gain additional memory.  In a C program with the GNU C library, there
are two kinds of programmatic allocation: automatic and dynamic.
See section <a href="#SEC22">Memory Allocation in C Programs</a>.
</p>
<p>Memory-mapped I/O is another form of dynamic virtual memory allocation.
Mapping memory to a file means declaring that the contents of certain
range of a process' addresses shall be identical to the contents of a
specified regular file.  The system makes the virtual memory initially
contain the contents of the file, and if you modify the memory, the
system writes the same modification to the file.  Note that due to the
magic of virtual memory and page faults, there is no reason for the
system to do I/O to read the file, or allocate real memory for its
contents, until the program accesses the virtual memory.
See section <a href="libc_13.html#SEC248">Memory-mapped I/O</a>.
<a name="IDX210"></a>
<a name="IDX211"></a>
<a name="IDX212"></a>
</p>
<p>Just as it programmatically allocates memory, the program can
programmatically deallocate (<em>free</em>) it.  You can't free the memory
that was allocated by exec.  When the program exits or execs, you might
say that all its memory gets freed, but since in both cases the address
space ceases to exist, the point is really moot.  See section <a href="libc_25.html#SEC562">Program Termination</a>.
<a name="IDX213"></a>
<a name="IDX214"></a>
<a name="IDX215"></a>
</p>
<p>A process' virtual address space is divided into segments.  A segment is
a contiguous range of virtual addresses.  Three important segments are:
</p>
<ul>
<li>

The <em>text segment</em> contains a program's instructions and literals and
static constants.  It is allocated by exec and stays the same size for
the life of the virtual address space.

</li><li>
The <em>data segment</em> is working storage for the program.  It can be
preallocated and preloaded by exec and the process can extend or shrink
it by calling functions as described in See section <a href="#SEC59">Resizing the Data Segment</a>.  Its lower end is fixed.

</li><li>
The <em>stack segment</em> contains a program stack.  It grows as the stack
grows, but doesn't shrink when the stack shrinks.

</li></ul>



<hr size="6">
<a name="Memory-Allocation"></a>
<a name="SEC21"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC20" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC22" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC19" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC19" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="libc_4.html#SEC64" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="libc.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="libc_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="libc_42.html#SEC712" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="libc_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="section"> 3.2 Allocating Storage For Program Data </h2>

<p>This section covers how ordinary programs manage storage for their data,
including the famous <code>malloc</code> function and some fancier facilities
special the GNU C library and GNU Compiler.
</p>
<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top"><a href="#SEC22">3.2.1 Memory Allocation in C Programs</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">     How to get different kinds of allocation in C.
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC24">3.2.2 Unconstrained Allocation</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">    The <code>malloc</code> facility allows fully general
		 		 dynamic allocation.
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC37">3.2.3 Allocation Debugging</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">        Finding memory leaks and not freed memory.
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC42">3.2.4 Obstacks</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                    Obstacks are less general than malloc
				 but more efficient and convenient.
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC54">3.2.5 Automatic Storage with Variable Size</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">     Allocation of variable-sized blocks
				 of automatic storage that are freed when the
				 calling function returns.
</td></tr>
</table>


<hr size="6">
<a name="Memory-Allocation-and-C"></a>
<a name="SEC22"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC21" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC23" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC19" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC21" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="libc_4.html#SEC64" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="libc.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="libc_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="libc_42.html#SEC712" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="libc_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h3 class="subsection"> 3.2.1 Memory Allocation in C Programs </h3>

<p>The C language supports two kinds of memory allocation through the
variables in C programs:
</p>
<ul>
<li>
<em>Static allocation</em> is what happens when you declare a static or
global variable.  Each static or global variable defines one block of
space, of a fixed size.  The space is allocated once, when your program
is started (part of the exec operation), and is never freed.
<a name="IDX216"></a>
<a name="IDX217"></a>

</li><li>
<em>Automatic allocation</em> happens when you declare an automatic
variable, such as a function argument or a local variable.  The space
for an automatic variable is allocated when the compound statement
containing the declaration is entered, and is freed when that
compound statement is exited.
<a name="IDX218"></a>
<a name="IDX219"></a>

<p>In GNU C, the size of the automatic storage can be an expression
that varies.  In other C implementations, it must be a constant.
</p></li></ul>

<p>A third important kind of memory allocation, <em>dynamic allocation</em>,
is not supported by C variables but is available via GNU C library
functions.
<a name="IDX220"></a>
</p>
<hr size="6">
<a name="SEC23"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC22" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC24" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC19" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC22" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="libc_4.html#SEC64" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="libc.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="libc_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="libc_42.html#SEC712" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="libc_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h4 class="subsubsection"> 3.2.1.1 Dynamic Memory Allocation </h4>

<p><em>Dynamic memory allocation</em> is a technique in which programs
determine as they are running where to store some information.  You need
dynamic allocation when the amount of memory you need, or how long you
continue to need it, depends on factors that are not known before the
program runs.
</p>
<p>For example, you may need a block to store a line read from an input
file; since there is no limit to how long a line can be, you must
allocate the memory dynamically and make it dynamically larger as you
read more of the line.
</p>
<p>Or, you may need a block for each record or each definition in the input
data; since you can't know in advance how many there will be, you must
allocate a new block for each record or definition as you read it.
</p>
<p>When you use dynamic allocation, the allocation of a block of memory is
an action that the program requests explicitly.  You call a function or
macro when you want to allocate space, and specify the size with an
argument.  If you want to free the space, you do so by calling another
function or macro.  You can do these things whenever you want, as often
as you want.
</p>
<p>Dynamic allocation is not supported by C variables; there is no storage
class &ldquo;dynamic&rdquo;, and there can never be a C variable whose value is
stored in dynamically allocated space.  The only way to get dynamically
allocated memory is via a system call (which is generally via a GNU C
library function call), and the only way to refer to dynamically
allocated space is through a pointer.  Because it is less convenient,
and because the actual process of dynamic allocation requires more
computation time, programmers generally use dynamic allocation only when
neither static nor automatic allocation will serve.
</p>
<p>For example, if you want to allocate dynamically some space to hold a
<code>struct foobar</code>, you cannot declare a variable of type <code>struct
foobar</code> whose contents are the dynamically allocated space.  But you can
declare a variable of pointer type <code>struct foobar *</code> and assign it the
address of the space.  Then you can use the operators &lsquo;<samp>*</samp>&rsquo; and
&lsquo;<samp>-&gt;</samp>&rsquo; on this pointer variable to refer to the contents of the space:
</p>
<table><tr><td>&nbsp;</td><td><pre class="smallexample">{
  struct foobar *ptr
     = (struct foobar *) malloc (sizeof (struct foobar));
  ptr-&gt;name = x;
  ptr-&gt;next = current_foobar;
  current_foobar = ptr;
}
</pre></td></tr></table>

<hr size="6">
<a name="Unconstrained-Allocation"></a>
<a name="SEC24"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC23" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC25" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC19" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC21" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="libc_4.html#SEC64" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="libc.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="libc_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="libc_42.html#SEC712" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="libc_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h3 class="subsection"> 3.2.2 Unconstrained Allocation </h3>

<p>The most general dynamic allocation facility is <code>malloc</code>.  It
allows you to allocate blocks of memory of any size at any time, make
them bigger or smaller at any time, and free the blocks individually at
any time (or never).
</p>
<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top"><a href="#SEC25">3.2.2.1 Basic Memory Allocation</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">            Simple use of <code>malloc</code>.
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC26">3.2.2.2 Examples of <code>malloc</code></a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">             Examples of <code>malloc</code>.  <code>xmalloc</code>.
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC27">3.2.2.3 Freeing Memory Allocated with <code>malloc</code></a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">        Use <code>free</code> to free a block you
				 got with <code>malloc</code>.
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC28">3.2.2.4 Changing the Size of a Block</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">         Use <code>realloc</code> to make a block
				 bigger or smaller.
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC29">3.2.2.5 Allocating Cleared Space</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">    Use <code>calloc</code> to allocate a
				 block and clear it.
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC30">3.2.2.6 Efficiency Considerations for <code>malloc</code></a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">       Efficiency considerations in use of
				 these functions.
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC31">3.2.2.7 Allocating Aligned Memory Blocks</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">       Allocating specially aligned memory.
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC32">3.2.2.8 Malloc Tunable Parameters</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">   Use <code>mallopt</code> to adjust allocation
                                 parameters.
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC33">3.2.2.9 Heap Consistency Checking</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">   Automatic checking for errors.
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC34">3.2.2.10 Memory Allocation Hooks</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">            You can use these hooks for debugging
				 programs that use <code>malloc</code>.
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC35">3.2.2.11 Statistics for Memory Allocation with <code>malloc</code></a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">        Getting information about how much
				 memory your program is using.
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC36">3.2.2.12 Summary of <code>malloc</code>-Related Functions</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">           Summary of <code>malloc</code> and related functions.
</td></tr>
</table>

<hr size="6">
<a name="Basic-Allocation"></a>
<a name="SEC25"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC24" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC26" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC19" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC24" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="libc_4.html#SEC64" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="libc.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="libc_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="libc_42.html#SEC712" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="libc_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h4 class="subsubsection"> 3.2.2.1 Basic Memory Allocation </h4>

<p>To allocate a block of memory, call <code>malloc</code>.  The prototype for
this function is in &lsquo;<tt>stdlib.h</tt>&rsquo;.
<a name="IDX221"></a>
</p>
<dl>
<dt><u>Function:</u> void * <b>malloc</b><i> (size_t <var>size</var>)</i>
<a name="IDX222"></a>
</dt>
<dd><p>This function returns a pointer to a newly allocated block <var>size</var>
bytes long, or a null pointer if the block could not be allocated.
</p></dd></dl>

<p>The contents of the block are undefined; you must initialize it yourself
(or use <code>calloc</code> instead; see section <a href="#SEC29">Allocating Cleared Space</a>).
Normally you would cast the value as a pointer to the kind of object
that you want to store in the block.  Here we show an example of doing
so, and of initializing the space with zeros using the library function
<code>memset</code> (see section <a href="libc_5.html#SEC74">Copying and Concatenation</a>):
</p>
<table><tr><td>&nbsp;</td><td><pre class="smallexample">struct foo *ptr;
&hellip;
ptr = (struct foo *) malloc (sizeof (struct foo));
if (ptr == 0) abort ();
memset (ptr, 0, sizeof (struct foo));
</pre></td></tr></table>

<p>You can store the result of <code>malloc</code> into any pointer variable
without a cast, because ISO C automatically converts the type
<code>void *</code> to another type of pointer when necessary.  But the cast
is necessary in contexts other than assignment operators or if you might
want your code to run in traditional C.
</p>
<p>Remember that when allocating space for a string, the argument to
<code>malloc</code> must be one plus the length of the string.  This is
because a string is terminated with a null character that doesn't count
in the &ldquo;length&rdquo; of the string but does need space.  For example:
</p>
<table><tr><td>&nbsp;</td><td><pre class="smallexample">char *ptr;
&hellip;
ptr = (char *) malloc (length + 1);
</pre></td></tr></table>

<p>See section <a href="libc_5.html#SEC71">Representation of Strings</a>, for more information about this.
</p>
<hr size="6">
<a name="Malloc-Examples"></a>
<a name="SEC26"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC25" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC27" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC19" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC24" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="libc_4.html#SEC64" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="libc.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="libc_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="libc_42.html#SEC712" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="libc_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h4 class="subsubsection"> 3.2.2.2 Examples of <code>malloc</code> </h4>

<p>If no more space is available, <code>malloc</code> returns a null pointer.
You should check the value of <em>every</em> call to <code>malloc</code>.  It is
useful to write a subroutine that calls <code>malloc</code> and reports an
error if the value is a null pointer, returning only if the value is
nonzero.  This function is conventionally called <code>xmalloc</code>.  Here
it is:
</p>
<table><tr><td>&nbsp;</td><td><pre class="smallexample">void *
xmalloc (size_t size)
{
  register void *value = malloc (size);
  if (value == 0)
    fatal (&quot;virtual memory exhausted&quot;);
  return value;
}
</pre></td></tr></table>

<p>Here is a real example of using <code>malloc</code> (by way of <code>xmalloc</code>).
The function <code>savestring</code> will copy a sequence of characters into
a newly allocated null-terminated string:
</p>
<table><tr><td>&nbsp;</td><td><pre class="smallexample">char *
savestring (const char *ptr, size_t len)
{
  register char *value = (char *) xmalloc (len + 1);
  value[len] = '\0';
  return (char *) memcpy (value, ptr, len);
}
</pre></td></tr></table>

<p>The block that <code>malloc</code> gives you is guaranteed to be aligned so
that it can hold any type of data.  In the GNU system, the address is
always a multiple of eight on most systems, and a multiple of 16 on
64-bit systems.  Only rarely is any higher boundary (such as a page
boundary) necessary; for those cases, use <code>memalign</code>,
<code>posix_memalign</code> or <code>valloc</code> (see section <a href="#SEC31">Allocating Aligned Memory Blocks</a>).
</p>
<p>Note that the memory located after the end of the block is likely to be
in use for something else; perhaps a block already allocated by another
call to <code>malloc</code>.  If you attempt to treat the block as longer than
you asked for it to be, you are liable to destroy the data that
<code>malloc</code> uses to keep track of its blocks, or you may destroy the
contents of another block.  If you have already allocated a block and
discover you want it to be bigger, use <code>realloc</code> (see section <a href="#SEC28">Changing the Size of a Block</a>).
</p>
<hr size="6">
<a name="Freeing-after-Malloc"></a>
<a name="SEC27"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC26" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC28" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC19" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC24" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="libc_4.html#SEC64" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="libc.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="libc_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="libc_42.html#SEC712" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="libc_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h4 class="subsubsection"> 3.2.2.3 Freeing Memory Allocated with <code>malloc</code> </h4>

<p>When you no longer need a block that you got with <code>malloc</code>, use the
function <code>free</code> to make the block available to be allocated again.
The prototype for this function is in &lsquo;<tt>stdlib.h</tt>&rsquo;.
<a name="IDX223"></a>
</p>
<dl>
<dt><u>Function:</u> void <b>free</b><i> (void *<var>ptr</var>)</i>
<a name="IDX224"></a>
</dt>
<dd><p>The <code>free</code> function deallocates the block of memory pointed at
by <var>ptr</var>.
</p></dd></dl>

<dl>
<dt><u>Function:</u> void <b>cfree</b><i> (void *<var>ptr</var>)</i>
<a name="IDX225"></a>
</dt>
<dd><p>This function does the same thing as <code>free</code>.  It's provided for
backward compatibility with SunOS; you should use <code>free</code> instead.
</p></dd></dl>

<p>Freeing a block alters the contents of the block.  <strong>Do not expect to
find any data (such as a pointer to the next block in a chain of blocks) in
the block after freeing it.</strong>  Copy whatever you need out of the block before
freeing it!  Here is an example of the proper way to free all the blocks in
a chain, and the strings that they point to:
</p>
<table><tr><td>&nbsp;</td><td><pre class="smallexample">struct chain
  {
    struct chain *next;
    char *name;
  }

void
free_chain (struct chain *chain)
{
  while (chain != 0)
    {
      struct chain *next = chain-&gt;next;
      free (chain-&gt;name);
      free (chain);
      chain = next;
    }
}
</pre></td></tr></table>

<p>Occasionally, <code>free</code> can actually return memory to the operating
system and make the process smaller.  Usually, all it can do is allow a
later call to <code>malloc</code> to reuse the space.  In the meantime, the
space remains in your program as part of a free-list used internally by
<code>malloc</code>.
</p>
<p>There is no point in freeing blocks at the end of a program, because all
of the program's space is given back to the system when the process
terminates.
</p>
<hr size="6">
<a name="Changing-Block-Size"></a>
<a name="SEC28"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC27" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC29" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC19" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC24" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="libc_4.html#SEC64" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="libc.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="libc_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="libc_42.html#SEC712" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="libc_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h4 class="subsubsection"> 3.2.2.4 Changing the Size of a Block </h4>

<p>Often you do not know for certain how big a block you will ultimately need
at the time you must begin to use the block.  For example, the block might
be a buffer that you use to hold a line being read from a file; no matter
how long you make the buffer initially, you may encounter a line that is
longer.
</p>
<p>You can make the block longer by calling <code>realloc</code>.  This function
is declared in &lsquo;<tt>stdlib.h</tt>&rsquo;.
<a name="IDX226"></a>
</p>
<dl>
<dt><u>Function:</u> void * <b>realloc</b><i> (void *<var>ptr</var>, size_t <var>newsize</var>)</i>
<a name="IDX227"></a>
</dt>
<dd><p>The <code>realloc</code> function changes the size of the block whose address is
<var>ptr</var> to be <var>newsize</var>.
</p>
<p>Since the space after the end of the block may be in use, <code>realloc</code>
may find it necessary to copy the block to a new address where more free
space is available.  The value of <code>realloc</code> is the new address of the
block.  If the block needs to be moved, <code>realloc</code> copies the old
contents.
</p>
<p>If you pass a null pointer for <var>ptr</var>, <code>realloc</code> behaves just
like &lsquo;<samp>malloc (<var>newsize</var>)</samp>&rsquo;.  This can be convenient, but beware
that older implementations (before ISO C) may not support this
behavior, and will probably crash when <code>realloc</code> is passed a null
pointer.
</p></dd></dl>

<p>Like <code>malloc</code>, <code>realloc</code> may return a null pointer if no
memory space is available to make the block bigger.  When this happens,
the original block is untouched; it has not been modified or relocated.
</p>
<p>In most cases it makes no difference what happens to the original block
when <code>realloc</code> fails, because the application program cannot continue
when it is out of memory, and the only thing to do is to give a fatal error
message.  Often it is convenient to write and use a subroutine,
conventionally called <code>xrealloc</code>, that takes care of the error message
as <code>xmalloc</code> does for <code>malloc</code>:
</p>
<table><tr><td>&nbsp;</td><td><pre class="smallexample">void *
xrealloc (void *ptr, size_t size)
{
  register void *value = realloc (ptr, size);
  if (value == 0)
    fatal (&quot;Virtual memory exhausted&quot;);
  return value;
}
</pre></td></tr></table>

<p>You can also use <code>realloc</code> to make a block smaller.  The reason you
would do this is to avoid tying up a lot of memory space when only a little
is needed.
In several allocation implementations, making a block smaller sometimes
necessitates copying it, so it can fail if no other space is available.
</p>
<p>If the new size you specify is the same as the old size, <code>realloc</code>
is guaranteed to change nothing and return the same address that you gave.
</p>
<hr size="6">
<a name="Allocating-Cleared-Space"></a>
<a name="SEC29"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC28" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC30" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC19" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC24" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="libc_4.html#SEC64" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="libc.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="libc_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="libc_42.html#SEC712" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="libc_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h4 class="subsubsection"> 3.2.2.5 Allocating Cleared Space </h4>

<p>The function <code>calloc</code> allocates memory and clears it to zero.  It
is declared in &lsquo;<tt>stdlib.h</tt>&rsquo;.
<a name="IDX228"></a>
</p>
<dl>
<dt><u>Function:</u> void * <b>calloc</b><i> (size_t <var>count</var>, size_t <var>eltsize</var>)</i>
<a name="IDX229"></a>
</dt>
<dd><p>This function allocates a block long enough to contain a vector of
<var>count</var> elements, each of size <var>eltsize</var>.  Its contents are
cleared to zero before <code>calloc</code> returns.
</p></dd></dl>

<p>You could define <code>calloc</code> as follows:
</p>
<table><tr><td>&nbsp;</td><td><pre class="smallexample">void *
calloc (size_t count, size_t eltsize)
{
  size_t size = count * eltsize;
  void *value = malloc (size);
  if (value != 0)
    memset (value, 0, size);
  return value;
}
</pre></td></tr></table>

<p>But in general, it is not guaranteed that <code>calloc</code> calls
<code>malloc</code> internally.  Therefore, if an application provides its own
<code>malloc</code>/<code>realloc</code>/<code>free</code> outside the C library, it
should always define <code>calloc</code>, too.
</p>
<hr size="6">
<a name="Efficiency-and-Malloc"></a>
<a name="SEC30"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC29" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC31" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC19" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC24" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="libc_4.html#SEC64" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="libc.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="libc_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="libc_42.html#SEC712" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="libc_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h4 class="subsubsection"> 3.2.2.6 Efficiency Considerations for <code>malloc</code> </h4>





<p>As opposed to other versions, the <code>malloc</code> in the GNU C Library
does not round up block sizes to powers of two, neither for large nor
for small sizes.  Neighboring chunks can be coalesced on a <code>free</code>
no matter what their size is.  This makes the implementation suitable
for all kinds of allocation patterns without generally incurring high
memory waste through fragmentation.
</p>
<p>Very large blocks (much larger than a page) are allocated with
<code>mmap</code> (anonymous or via <code>/dev/zero</code>) by this implementation.
This has the great advantage that these chunks are returned to the
system immediately when they are freed.  Therefore, it cannot happen
that a large chunk becomes &ldquo;locked&rdquo; in between smaller ones and even
after calling <code>free</code> wastes memory.  The size threshold for
<code>mmap</code> to be used can be adjusted with <code>mallopt</code>.  The use of
<code>mmap</code> can also be disabled completely.
</p>
<hr size="6">
<a name="Aligned-Memory-Blocks"></a>
<a name="SEC31"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC30" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC32" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC19" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC24" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="libc_4.html#SEC64" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="libc.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="libc_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="libc_42.html#SEC712" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="libc_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h4 class="subsubsection"> 3.2.2.7 Allocating Aligned Memory Blocks </h4>

<p>The address of a block returned by <code>malloc</code> or <code>realloc</code> in
the GNU system is always a multiple of eight (or sixteen on 64-bit
systems).  If you need a block whose address is a multiple of a higher
power of two than that, use <code>memalign</code>, <code>posix_memalign</code>, or
<code>valloc</code>.  <code>memalign</code> is declared in &lsquo;<tt>malloc.h</tt>&rsquo; and
<code>posix_memalign</code> is declared in &lsquo;<tt>stdlib.h</tt>&rsquo;.
</p>
<p>With the GNU library, you can use <code>free</code> to free the blocks that
<code>memalign</code>, <code>posix_memalign</code>, and <code>valloc</code> return.  That
does not work in BSD, however&mdash;BSD does not provide any way to free
such blocks.
</p>
<dl>
<dt><u>Function:</u> void * <b>memalign</b><i> (size_t <var>boundary</var>, size_t <var>size</var>)</i>
<a name="IDX230"></a>
</dt>
<dd><p>The <code>memalign</code> function allocates a block of <var>size</var> bytes whose
address is a multiple of <var>boundary</var>.  The <var>boundary</var> must be a
power of two!  The function <code>memalign</code> works by allocating a
somewhat larger block, and then returning an address within the block
that is on the specified boundary.
</p></dd></dl>

<dl>
<dt><u>Function:</u> int <b>posix_memalign</b><i> (void **<var>memptr</var>, size_t <var>alignment</var>, size_t <var>size</var>)</i>
<a name="IDX231"></a>
</dt>
<dd><p>The <code>posix_memalign</code> function is similar to the <code>memalign</code>
function in that it returns a buffer of <var>size</var> bytes aligned to a
multiple of <var>alignment</var>.  But it adds one requirement to the
parameter <var>alignment</var>: the value must be a power of two multiple of
<code>sizeof (void *)</code>.
</p>
<p>If the function succeeds in allocation memory a pointer to the allocated
memory is returned in <code>*<var>memptr</var></code> and the return value is zero.
Otherwise the function returns an error value indicating the problem.
</p>
<p>This function was introduced in POSIX 1003.1d.
</p></dd></dl>

<dl>
<dt><u>Function:</u> void * <b>valloc</b><i> (size_t <var>size</var>)</i>
<a name="IDX232"></a>
</dt>
<dd><p>Using <code>valloc</code> is like using <code>memalign</code> and passing the page size
as the value of the second argument.  It is implemented like this:
</p>
<table><tr><td>&nbsp;</td><td><pre class="smallexample">void *
valloc (size_t size)
{
  return memalign (getpagesize (), size);
}
</pre></td></tr></table>

<p><a href="libc_22.html#SEC463">How to get information about the memory subsystem?</a> for more information about the memory
subsystem.
</p></dd></dl>

<hr size="6">
<a name="Malloc-Tunable-Parameters"></a>
<a name="SEC32"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC31" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC33" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC19" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC24" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="libc_4.html#SEC64" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="libc.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="libc_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="libc_42.html#SEC712" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="libc_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h4 class="subsubsection"> 3.2.2.8 Malloc Tunable Parameters </h4>

<p>You can adjust some parameters for dynamic memory allocation with the
<code>mallopt</code> function.  This function is the general SVID/XPG
interface, defined in &lsquo;<tt>malloc.h</tt>&rsquo;.
<a name="IDX233"></a>
</p>
<dl>
<dt><u>Function:</u> int <b>mallopt</b><i> (int <var>param</var>, int <var>value</var>)</i>
<a name="IDX234"></a>
</dt>
<dd><p>When calling <code>mallopt</code>, the <var>param</var> argument specifies the
parameter to be set, and <var>value</var> the new value to be set.  Possible
choices for <var>param</var>, as defined in &lsquo;<tt>malloc.h</tt>&rsquo;, are:
</p>
<dl compact="compact">
<dt> <code>M_TRIM_THRESHOLD</code></dt>
<dd><p>This is the minimum size (in bytes) of the top-most, releasable chunk
that will cause <code>sbrk</code> to be called with a negative argument in
order to return memory to the system.
</p></dd>
<dt> <code>M_TOP_PAD</code></dt>
<dd><p>This parameter determines the amount of extra memory to obtain from the
system when a call to <code>sbrk</code> is required.  It also specifies the
number of bytes to retain when shrinking the heap by calling <code>sbrk</code>
with a negative argument.  This provides the necessary hysteresis in
heap size such that excessive amounts of system calls can be avoided.
</p></dd>
<dt> <code>M_MMAP_THRESHOLD</code></dt>
<dd><p>All chunks larger than this value are allocated outside the normal
heap, using the <code>mmap</code> system call.  This way it is guaranteed
that the memory for these chunks can be returned to the system on
<code>free</code>.  Note that requests smaller than this threshold might still
be allocated via <code>mmap</code>.
</p></dd>
<dt> <code>M_MMAP_MAX</code></dt>
<dd><p>The maximum number of chunks to allocate with <code>mmap</code>.  Setting this
to zero disables all use of <code>mmap</code>.
</p></dd>
</dl>

</dd></dl>

<hr size="6">
<a name="Heap-Consistency-Checking"></a>
<a name="SEC33"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC32" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC34" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC19" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC24" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="libc_4.html#SEC64" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="libc.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="libc_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="libc_42.html#SEC712" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="libc_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h4 class="subsubsection"> 3.2.2.9 Heap Consistency Checking </h4>


<p>You can ask <code>malloc</code> to check the consistency of dynamic memory by
using the <code>mcheck</code> function.  This function is a GNU extension,
declared in &lsquo;<tt>mcheck.h</tt>&rsquo;.
<a name="IDX235"></a>
</p>
<dl>
<dt><u>Function:</u> int <b>mcheck</b><i> (void (*<var>abortfn</var>) (enum mcheck_status <var>status</var>))</i>
<a name="IDX236"></a>
</dt>
<dd><p>Calling <code>mcheck</code> tells <code>malloc</code> to perform occasional
consistency checks.  These will catch things such as writing
past the end of a block that was allocated with <code>malloc</code>.
</p>
<p>The <var>abortfn</var> argument is the function to call when an inconsistency
is found.  If you supply a null pointer, then <code>mcheck</code> uses a
default function which prints a message and calls <code>abort</code>
(see section <a href="libc_25.html#SEC566">Aborting a Program</a>).  The function you supply is called with
one argument, which says what sort of inconsistency was detected; its
type is described below.
</p>
<p>It is too late to begin allocation checking once you have allocated
anything with <code>malloc</code>.  So <code>mcheck</code> does nothing in that
case.  The function returns <code>-1</code> if you call it too late, and
<code>0</code> otherwise (when it is successful).
</p>
<p>The easiest way to arrange to call <code>mcheck</code> early enough is to use
the option &lsquo;<samp>-lmcheck</samp>&rsquo; when you link your program; then you don't
need to modify your program source at all.  Alternatively you might use
a debugger to insert a call to <code>mcheck</code> whenever the program is
started, for example these gdb commands will automatically call <code>mcheck</code>
whenever the program starts:
</p>
<table><tr><td>&nbsp;</td><td><pre class="smallexample">(gdb) break main
Breakpoint 1, main (argc=2, argv=0xbffff964) at whatever.c:10
(gdb) command 1
Type commands for when breakpoint 1 is hit, one per line.
End with a line saying just &quot;end&quot;.
&gt;call mcheck(0)
&gt;continue
&gt;end
(gdb) &hellip;
</pre></td></tr></table>

<p>This will however only work if no initialization function of any object
involved calls any of the <code>malloc</code> functions since <code>mcheck</code>
must be called before the first such function.
</p>
</dd></dl>

<dl>
<dt><u>Function:</u> enum mcheck_status <b>mprobe</b><i> (void *<var>pointer</var>)</i>
<a name="IDX237"></a>
</dt>
<dd><p>The <code>mprobe</code> function lets you explicitly check for inconsistencies
in a particular allocated block.  You must have already called
<code>mcheck</code> at the beginning of the program, to do its occasional
checks; calling <code>mprobe</code> requests an additional consistency check
to be done at the time of the call.
</p>
<p>The argument <var>pointer</var> must be a pointer returned by <code>malloc</code>
or <code>realloc</code>.  <code>mprobe</code> returns a value that says what
inconsistency, if any, was found.  The values are described below.
</p></dd></dl>

<dl>
<dt><u>Data Type:</u> <b>enum mcheck_status</b>
<a name="IDX238"></a>
</dt>
<dd><p>This enumerated type describes what kind of inconsistency was detected
in an allocated block, if any.  Here are the possible values:
</p>
<dl compact="compact">
<dt> <code>MCHECK_DISABLED</code></dt>
<dd><p><code>mcheck</code> was not called before the first allocation.
No consistency checking can be done.
</p></dd>
<dt> <code>MCHECK_OK</code></dt>
<dd><p>No inconsistency detected.
</p></dd>
<dt> <code>MCHECK_HEAD</code></dt>
<dd><p>The data immediately before the block was modified.
This commonly happens when an array index or pointer
is decremented too far.
</p></dd>
<dt> <code>MCHECK_TAIL</code></dt>
<dd><p>The data immediately after the block was modified.
This commonly happens when an array index or pointer
is incremented too far.
</p></dd>
<dt> <code>MCHECK_FREE</code></dt>
<dd><p>The block was already freed.
</p></dd>
</dl>
</dd></dl>

<p>Another possibility to check for and guard against bugs in the use of
<code>malloc</code>, <code>realloc</code> and <code>free</code> is to set the environment
variable <code>MALLOC_CHECK_</code>.  When <code>MALLOC_CHECK_</code> is set, a
special (less efficient) implementation is used which is designed to be
tolerant against simple errors, such as double calls of <code>free</code> with
the same argument, or overruns of a single byte (off-by-one bugs).  Not
all such errors can be protected against, however, and memory leaks can
result.  If <code>MALLOC_CHECK_</code> is set to <code>0</code>, any detected heap
corruption is silently ignored; if set to <code>1</code>, a diagnostic is
printed on <code>stderr</code>; if set to <code>2</code>, <code>abort</code> is called
immediately.  This can be useful because otherwise a crash may happen
much later, and the true cause for the problem is then very hard to
track down.
</p>
<p>There is one problem with <code>MALLOC_CHECK_</code>: in SUID or SGID binaries
it could possibly be exploited since diverging from the normal programs
behavior it now writes something to the standard error descriptor.
Therefore the use of <code>MALLOC_CHECK_</code> is disabled by default for
SUID and SGID binaries.  It can be enabled again by the system
administrator by adding a file &lsquo;<tt>/etc/suid-debug</tt>&rsquo; (the content is
not important it could be empty).
</p>
<p>So, what's the difference between using <code>MALLOC_CHECK_</code> and linking
with &lsquo;<samp>-lmcheck</samp>&rsquo;?  <code>MALLOC_CHECK_</code> is orthogonal with respect to
&lsquo;<samp>-lmcheck</samp>&rsquo;.  &lsquo;<samp>-lmcheck</samp>&rsquo; has been added for backward
compatibility.  Both <code>MALLOC_CHECK_</code> and &lsquo;<samp>-lmcheck</samp>&rsquo; should
uncover the same bugs - but using <code>MALLOC_CHECK_</code> you don't need to
recompile your application.
</p>
<hr size="6">
<a name="Hooks-for-Malloc"></a>
<a name="SEC34"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC33" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC35" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC19" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC24" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="libc_4.html#SEC64" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="libc.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="libc_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="libc_42.html#SEC712" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="libc_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h4 class="subsubsection"> 3.2.2.10 Memory Allocation Hooks </h4>

<p>The GNU C library lets you modify the behavior of <code>malloc</code>,
<code>realloc</code>, and <code>free</code> by specifying appropriate hook
functions.  You can use these hooks to help you debug programs that use
dynamic memory allocation, for example.
</p>
<p>The hook variables are declared in &lsquo;<tt>malloc.h</tt>&rsquo;.
<a name="IDX239"></a>
</p>
<dl>
<dt><u>Variable:</u> <b>__malloc_hook</b>
<a name="IDX240"></a>
</dt>
<dd><p>The value of this variable is a pointer to the function that
<code>malloc</code> uses whenever it is called.  You should define this
function to look like <code>malloc</code>; that is, like:
</p>
<table><tr><td>&nbsp;</td><td><pre class="smallexample">void *<var>function</var> (size_t <var>size</var>, const void *<var>caller</var>)
</pre></td></tr></table>

<p>The value of <var>caller</var> is the return address found on the stack when
the <code>malloc</code> function was called.  This value allows you to trace
the memory consumption of the program.
</p></dd></dl>

<dl>
<dt><u>Variable:</u> <b>__realloc_hook</b>
<a name="IDX241"></a>
</dt>
<dd><p>The value of this variable is a pointer to function that <code>realloc</code>
uses whenever it is called.  You should define this function to look
like <code>realloc</code>; that is, like:
</p>
<table><tr><td>&nbsp;</td><td><pre class="smallexample">void *<var>function</var> (void *<var>ptr</var>, size_t <var>size</var>, const void *<var>caller</var>)
</pre></td></tr></table>

<p>The value of <var>caller</var> is the return address found on the stack when
the <code>realloc</code> function was called.  This value allows you to trace the
memory consumption of the program.
</p></dd></dl>

<dl>
<dt><u>Variable:</u> <b>__free_hook</b>
<a name="IDX242"></a>
</dt>
<dd><p>The value of this variable is a pointer to function that <code>free</code>
uses whenever it is called.  You should define this function to look
like <code>free</code>; that is, like:
</p>
<table><tr><td>&nbsp;</td><td><pre class="smallexample">void <var>function</var> (void *<var>ptr</var>, const void *<var>caller</var>)
</pre></td></tr></table>

<p>The value of <var>caller</var> is the return address found on the stack when
the <code>free</code> function was called.  This value allows you to trace the
memory consumption of the program.
</p></dd></dl>

<dl>
<dt><u>Variable:</u> <b>__memalign_hook</b>
<a name="IDX243"></a>
</dt>
<dd><p>The value of this variable is a pointer to function that <code>memalign</code>
uses whenever it is called.  You should define this function to look
like <code>memalign</code>; that is, like:
</p>
<table><tr><td>&nbsp;</td><td><pre class="smallexample">void *<var>function</var> (size_t <var>alignment</var>, size_t <var>size</var>, const void *<var>caller</var>)
</pre></td></tr></table>

<p>The value of <var>caller</var> is the return address found on the stack when
the <code>memalign</code> function was called.  This value allows you to trace the
memory consumption of the program.
</p></dd></dl>

<p>You must make sure that the function you install as a hook for one of
these functions does not call that function recursively without restoring
the old value of the hook first!  Otherwise, your program will get stuck
in an infinite recursion.  Before calling the function recursively, one
should make sure to restore all the hooks to their previous value.  When
coming back from the recursive call, all the hooks should be resaved
since a hook might modify itself.
</p>
<dl>
<dt><u>Variable:</u> <b>__malloc_initialize_hook</b>
<a name="IDX244"></a>
</dt>
<dd><p>The value of this variable is a pointer to a function that is called
once when the malloc implementation is initialized.  This is a weak
variable, so it can be overridden in the application with a definition
like the following:
</p>
<table><tr><td>&nbsp;</td><td><pre class="smallexample">void (*<var>__malloc_initialize_hook</var>) (void) = my_init_hook;
</pre></td></tr></table>
</dd></dl>

<p>An issue to look out for is the time at which the malloc hook functions
can be safely installed.  If the hook functions call the malloc-related
functions recursively, it is necessary that malloc has already properly
initialized itself at the time when <code>__malloc_hook</code> etc. is
assigned to.  On the other hand, if the hook functions provide a
complete malloc implementation of their own, it is vital that the hooks
are assigned to <em>before</em> the very first <code>malloc</code> call has
completed, because otherwise a chunk obtained from the ordinary,
un-hooked malloc may later be handed to <code>__free_hook</code>, for example.
</p>
<p>In both cases, the problem can be solved by setting up the hooks from
within a user-defined function pointed to by
<code>__malloc_initialize_hook</code>&mdash;then the hooks will be set up safely
at the right time.
</p>
<p>Here is an example showing how to use <code>__malloc_hook</code> and
<code>__free_hook</code> properly.  It installs a function that prints out
information every time <code>malloc</code> or <code>free</code> is called.  We just
assume here that <code>realloc</code> and <code>memalign</code> are not used in our
program.
</p>
<table><tr><td>&nbsp;</td><td><pre class="smallexample">/* Prototypes for __malloc_hook, __free_hook */
#include &lt;malloc.h&gt;

/* Prototypes for our hooks.  */
static void my_init_hook (void);
static void *my_malloc_hook (size_t, const void *);
static void my_free_hook (void*, const void *);

/* Override initializing hook from the C library. */
void (*__malloc_initialize_hook) (void) = my_init_hook;

static void
my_init_hook (void)
{
  old_malloc_hook = __malloc_hook;
  old_free_hook = __free_hook;
  __malloc_hook = my_malloc_hook;
  __free_hook = my_free_hook;
}

static void *
my_malloc_hook (size_t size, const void *caller)
{
  void *result;
  /* Restore all old hooks */
  __malloc_hook = old_malloc_hook;
  __free_hook = old_free_hook;
  /* Call recursively */
  result = malloc (size);
  /* Save underlying hooks */
  old_malloc_hook = __malloc_hook;
  old_free_hook = __free_hook;
  /* <span class="roman"><code>printf</code> might call <code>malloc</code>, so protect it too.</span> */
  printf (&quot;malloc (%u) returns %p\n&quot;, (unsigned int) size, result);
  /* Restore our own hooks */
  __malloc_hook = my_malloc_hook;
  __free_hook = my_free_hook;
  return result;
}

static void
my_free_hook (void *ptr, const void *caller)
{
  /* Restore all old hooks */
  __malloc_hook = old_malloc_hook;
  __free_hook = old_free_hook;
  /* Call recursively */
  free (ptr);
  /* Save underlying hooks */
  old_malloc_hook = __malloc_hook;
  old_free_hook = __free_hook;
  /* <span class="roman"><code>printf</code> might call <code>free</code>, so protect it too.</span> */
  printf (&quot;freed pointer %p\n&quot;, ptr);
  /* Restore our own hooks */
  __malloc_hook = my_malloc_hook;
  __free_hook = my_free_hook;
}

main ()
{
  &hellip;
}
</pre></td></tr></table>

<p>The <code>mcheck</code> function (see section <a href="#SEC33">Heap Consistency Checking</a>) works by
installing such hooks.
</p>

<hr size="6">
<a name="Statistics-of-Malloc"></a>
<a name="SEC35"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC34" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC36" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC19" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC24" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="libc_4.html#SEC64" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="libc.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="libc_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="libc_42.html#SEC712" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="libc_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h4 class="subsubsection"> 3.2.2.11 Statistics for Memory Allocation with <code>malloc</code> </h4>

<p>You can get information about dynamic memory allocation by calling the
<code>mallinfo</code> function.  This function and its associated data type
are declared in &lsquo;<tt>malloc.h</tt>&rsquo;; they are an extension of the standard
SVID/XPG version.
<a name="IDX245"></a>
</p>
<dl>
<dt><u>Data Type:</u> <b>struct mallinfo</b>
<a name="IDX246"></a>
</dt>
<dd><p>This structure type is used to return information about the dynamic
memory allocator.  It contains the following members:
</p>
<dl compact="compact">
<dt> <code>int arena</code></dt>
<dd><p>This is the total size of memory allocated with <code>sbrk</code> by
<code>malloc</code>, in bytes.
</p>
</dd>
<dt> <code>int ordblks</code></dt>
<dd><p>This is the number of chunks not in use.  (The memory allocator
internally gets chunks of memory from the operating system, and then
carves them up to satisfy individual <code>malloc</code> requests; see
<a href="#SEC30">Efficiency Considerations for <code>malloc</code></a>.)
</p>
</dd>
<dt> <code>int smblks</code></dt>
<dd><p>This field is unused.
</p>
</dd>
<dt> <code>int hblks</code></dt>
<dd><p>This is the total number of chunks allocated with <code>mmap</code>.
</p>
</dd>
<dt> <code>int hblkhd</code></dt>
<dd><p>This is the total size of memory allocated with <code>mmap</code>, in bytes.
</p>
</dd>
<dt> <code>int usmblks</code></dt>
<dd><p>This field is unused.
</p>
</dd>
<dt> <code>int fsmblks</code></dt>
<dd><p>This field is unused.
</p>
</dd>
<dt> <code>int uordblks</code></dt>
<dd><p>This is the total size of memory occupied by chunks handed out by
<code>malloc</code>.
</p>
</dd>
<dt> <code>int fordblks</code></dt>
<dd><p>This is the total size of memory occupied by free (not in use) chunks.
</p>
</dd>
<dt> <code>int keepcost</code></dt>
<dd><p>This is the size of the top-most releasable chunk that normally
borders the end of the heap (i.e., the high end of the virtual address
space's data segment).
</p>
</dd>
</dl>
</dd></dl>

<dl>
<dt><u>Function:</u> struct mallinfo <b>mallinfo</b><i> (void)</i>
<a name="IDX247"></a>
</dt>
<dd><p>This function returns information about the current dynamic memory usage
in a structure of type <code>struct mallinfo</code>.
</p></dd></dl>

<hr size="6">
<a name="Summary-of-Malloc"></a>
<a name="SEC36"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC35" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC37" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC19" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC24" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="libc_4.html#SEC64" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="libc.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="libc_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="libc_42.html#SEC712" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="libc_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h4 class="subsubsection"> 3.2.2.12 Summary of <code>malloc</code>-Related Functions </h4>

<p>Here is a summary of the functions that work with <code>malloc</code>:
</p>
<dl compact="compact">
<dt> <code>void *malloc (size_t <var>size</var>)</code></dt>
<dd><p>Allocate a block of <var>size</var> bytes.  See section <a href="#SEC25">Basic Memory Allocation</a>.
</p>
</dd>
<dt> <code>void free (void *<var>addr</var>)</code></dt>
<dd><p>Free a block previously allocated by <code>malloc</code>.  See section <a href="#SEC27">Freeing Memory Allocated with <code>malloc</code></a>.
</p>
</dd>
<dt> <code>void *realloc (void *<var>addr</var>, size_t <var>size</var>)</code></dt>
<dd><p>Make a block previously allocated by <code>malloc</code> larger or smaller,
possibly by copying it to a new location.  See section <a href="#SEC28">Changing the Size of a Block</a>.
</p>
</dd>
<dt> <code>void *calloc (size_t <var>count</var>, size_t <var>eltsize</var>)</code></dt>
<dd><p>Allocate a block of <var>count</var> * <var>eltsize</var> bytes using
<code>malloc</code>, and set its contents to zero.  See section <a href="#SEC29">Allocating Cleared Space</a>.
</p>
</dd>
<dt> <code>void *valloc (size_t <var>size</var>)</code></dt>
<dd><p>Allocate a block of <var>size</var> bytes, starting on a page boundary.
See section <a href="#SEC31">Allocating Aligned Memory Blocks</a>.
</p>
</dd>
<dt> <code>void *memalign (size_t <var>size</var>, size_t <var>boundary</var>)</code></dt>
<dd><p>Allocate a block of <var>size</var> bytes, starting on an address that is a
multiple of <var>boundary</var>.  See section <a href="#SEC31">Allocating Aligned Memory Blocks</a>.
</p>
</dd>
<dt> <code>int mallopt (int <var>param</var>, int <var>value</var>)</code></dt>
<dd><p>Adjust a tunable parameter.  See section <a href="#SEC32">Malloc Tunable Parameters</a>.
</p>
</dd>
<dt> <code>int mcheck (void (*<var>abortfn</var>) (void))</code></dt>
<dd><p>Tell <code>malloc</code> to perform occasional consistency checks on
dynamically allocated memory, and to call <var>abortfn</var> when an
inconsistency is found.  See section <a href="#SEC33">Heap Consistency Checking</a>.
</p>
</dd>
<dt> <code>void *(*__malloc_hook) (size_t <var>size</var>, const void *<var>caller</var>)</code></dt>
<dd><p>A pointer to a function that <code>malloc</code> uses whenever it is called.
</p>
</dd>
<dt> <code>void *(*__realloc_hook) (void *<var>ptr</var>, size_t <var>size</var>, const void *<var>caller</var>)</code></dt>
<dd><p>A pointer to a function that <code>realloc</code> uses whenever it is called.
</p>
</dd>
<dt> <code>void (*__free_hook) (void *<var>ptr</var>, const void *<var>caller</var>)</code></dt>
<dd><p>A pointer to a function that <code>free</code> uses whenever it is called.
</p>
</dd>
<dt> <code>void (*__memalign_hook) (size_t <var>size</var>, size_t <var>alignment</var>, const void *<var>caller</var>)</code></dt>
<dd><p>A pointer to a function that <code>memalign</code> uses whenever it is called.
</p>
</dd>
<dt> <code>struct mallinfo mallinfo (void)</code></dt>
<dd><p>Return information about the current dynamic memory usage.
See section <a href="#SEC35">Statistics for Memory Allocation with <code>malloc</code></a>.
</p></dd>
</dl>

<hr size="6">
<a name="Allocation-Debugging"></a>
<a name="SEC37"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC36" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC38" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC19" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC21" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="libc_4.html#SEC64" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="libc.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="libc_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="libc_42.html#SEC712" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="libc_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h3 class="subsection"> 3.2.3 Allocation Debugging </h3>

<p>A complicated task when programming with languages which do not use
garbage collected dynamic memory allocation is to find memory leaks.
Long running programs must assure that dynamically allocated objects are
freed at the end of their lifetime.  If this does not happen the system
runs out of memory, sooner or later.
</p>
<p>The <code>malloc</code> implementation in the GNU C library provides some
simple means to detect such leaks and obtain some information to find
the location.  To do this the application must be started in a special
mode which is enabled by an environment variable.  There are no speed
penalties for the program if the debugging mode is not enabled.
</p>
<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top"><a href="#SEC38">3.2.3.1 How to install the tracing functionality</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top"></td></tr>
<tr><td align="left" valign="top"><a href="#SEC39">3.2.3.2 Example program excerpts</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">    Example programs excerpts.
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC40">3.2.3.3 Some more or less clever ideas</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top"></td></tr>
<tr><td align="left" valign="top"><a href="#SEC41">3.2.3.4 Interpreting the traces</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">      What do all these lines mean?
</td></tr>
</table>

<hr size="6">
<a name="Tracing-malloc"></a>
<a name="SEC38"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC37" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC39" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC19" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC37" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="libc_4.html#SEC64" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="libc.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="libc_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="libc_42.html#SEC712" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="libc_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h4 class="subsubsection"> 3.2.3.1 How to install the tracing functionality </h4>

<dl>
<dt><u>Function:</u> void <b>mtrace</b><i> (void)</i>
<a name="IDX248"></a>
</dt>
<dd><p>When the <code>mtrace</code> function is called it looks for an environment
variable named <code>MALLOC_TRACE</code>.  This variable is supposed to
contain a valid file name.  The user must have write access.  If the
file already exists it is truncated.  If the environment variable is not
set or it does not name a valid file which can be opened for writing
nothing is done.  The behavior of <code>malloc</code> etc. is not changed.
For obvious reasons this also happens if the application is installed
with the SUID or SGID bit set.
</p>
<p>If the named file is successfully opened, <code>mtrace</code> installs special
handlers for the functions <code>malloc</code>, <code>realloc</code>, and
<code>free</code> (see section <a href="#SEC34">Memory Allocation Hooks</a>).  From then on, all uses of these
functions are traced and protocolled into the file.  There is now of
course a speed penalty for all calls to the traced functions so tracing
should not be enabled during normal use.
</p>
<p>This function is a GNU extension and generally not available on other
systems.  The prototype can be found in &lsquo;<tt>mcheck.h</tt>&rsquo;.
</p></dd></dl>

<dl>
<dt><u>Function:</u> void <b>muntrace</b><i> (void)</i>
<a name="IDX249"></a>
</dt>
<dd><p>The <code>muntrace</code> function can be called after <code>mtrace</code> was used
to enable tracing the <code>malloc</code> calls.  If no (successful) call of
<code>mtrace</code> was made <code>muntrace</code> does nothing.
</p>
<p>Otherwise it deinstalls the handlers for <code>malloc</code>, <code>realloc</code>,
and <code>free</code> and then closes the protocol file.  No calls are
protocolled anymore and the program runs again at full speed.
</p>
<p>This function is a GNU extension and generally not available on other
systems.  The prototype can be found in &lsquo;<tt>mcheck.h</tt>&rsquo;.
</p></dd></dl>

<hr size="6">
<a name="Using-the-Memory-Debugger"></a>
<a name="SEC39"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC38" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC40" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC19" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC37" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="libc_4.html#SEC64" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="libc.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="libc_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="libc_42.html#SEC712" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="libc_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h4 class="subsubsection"> 3.2.3.2 Example program excerpts </h4>

<p>Even though the tracing functionality does not influence the runtime
behavior of the program it is not a good idea to call <code>mtrace</code> in
all programs.  Just imagine that you debug a program using <code>mtrace</code>
and all other programs used in the debugging session also trace their
<code>malloc</code> calls.  The output file would be the same for all programs
and thus is unusable.  Therefore one should call <code>mtrace</code> only if
compiled for debugging.  A program could therefore start like this:
</p>
<table><tr><td>&nbsp;</td><td><pre class="example">#include &lt;mcheck.h&gt;

int
main (int argc, char *argv[])
{
#ifdef DEBUGGING
  mtrace ();
#endif
  &hellip;
}
</pre></td></tr></table>

<p>This is all what is needed if you want to trace the calls during the
whole runtime of the program.  Alternatively you can stop the tracing at
any time with a call to <code>muntrace</code>.  It is even possible to restart
the tracing again with a new call to <code>mtrace</code>.  But this can cause
unreliable results since there may be calls of the functions which are
not called.  Please note that not only the application uses the traced
functions, also libraries (including the C library itself) use these
functions.
</p>
<p>This last point is also why it is no good idea to call <code>muntrace</code>
before the program terminated.  The libraries are informed about the
termination of the program only after the program returns from
<code>main</code> or calls <code>exit</code> and so cannot free the memory they use
before this time.
</p>
<p>So the best thing one can do is to call <code>mtrace</code> as the very first
function in the program and never call <code>muntrace</code>.  So the program
traces almost all uses of the <code>malloc</code> functions (except those
calls which are executed by constructors of the program or used
libraries).
</p>
<hr size="6">
<a name="Tips-for-the-Memory-Debugger"></a>
<a name="SEC40"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC39" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC41" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC19" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC37" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="libc_4.html#SEC64" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="libc.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="libc_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="libc_42.html#SEC712" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="libc_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h4 class="subsubsection"> 3.2.3.3 Some more or less clever ideas </h4>

<p>You know the situation.  The program is prepared for debugging and in
all debugging sessions it runs well.  But once it is started without
debugging the error shows up.  A typical example is a memory leak that
becomes visible only when we turn off the debugging.  If you foresee
such situations you can still win.  Simply use something equivalent to
the following little program:
</p>
<table><tr><td>&nbsp;</td><td><pre class="example">#include &lt;mcheck.h&gt;
#include &lt;signal.h&gt;

static void
enable (int sig)
{
  mtrace ();
  signal (SIGUSR1, enable);
}

static void
disable (int sig)
{
  muntrace ();
  signal (SIGUSR2, disable);
}

int
main (int argc, char *argv[])
{
  &hellip;

  signal (SIGUSR1, enable);
  signal (SIGUSR2, disable);

  &hellip;
}
</pre></td></tr></table>

<p>I.e., the user can start the memory debugger any time s/he wants if the
program was started with <code>MALLOC_TRACE</code> set in the environment.
The output will of course not show the allocations which happened before
the first signal but if there is a memory leak this will show up
nevertheless.
</p>
<hr size="6">
<a name="Interpreting-the-traces"></a>
<a name="SEC41"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC40" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC42" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC19" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC37" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="libc_4.html#SEC64" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="libc.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="libc_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="libc_42.html#SEC712" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="libc_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h4 class="subsubsection"> 3.2.3.4 Interpreting the traces </h4>

<p>If you take a look at the output it will look similar to this:
</p>
<table><tr><td>&nbsp;</td><td><pre class="example">= Start
&nbsp;[0x8048209] - 0x8064cc8
&nbsp;[0x8048209] - 0x8064ce0
&nbsp;[0x8048209] - 0x8064cf8
&nbsp;[0x80481eb] + 0x8064c48 0x14
&nbsp;[0x80481eb] + 0x8064c60 0x14
&nbsp;[0x80481eb] + 0x8064c78 0x14
&nbsp;[0x80481eb] + 0x8064c90 0x14
= End
</pre></td></tr></table>

<p>What this all means is not really important since the trace file is not
meant to be read by a human.  Therefore no attention is given to
readability.  Instead there is a program which comes with the GNU C
library which interprets the traces and outputs a summary in an
user-friendly way.  The program is called <code>mtrace</code> (it is in fact a
Perl script) and it takes one or two arguments.  In any case the name of
the file with the trace output must be specified.  If an optional
argument precedes the name of the trace file this must be the name of
the program which generated the trace.
</p>
<table><tr><td>&nbsp;</td><td><pre class="example">drepper$ mtrace tst-mtrace log
No memory leaks.
</pre></td></tr></table>

<p>In this case the program <code>tst-mtrace</code> was run and it produced a
trace file &lsquo;<tt>log</tt>&rsquo;.  The message printed by <code>mtrace</code> shows there
are no problems with the code, all allocated memory was freed
afterwards.
</p>
<p>If we call <code>mtrace</code> on the example trace given above we would get a
different outout:
</p>
<table><tr><td>&nbsp;</td><td><pre class="example">drepper$ mtrace errlog
- 0x08064cc8 Free 2 was never alloc'd 0x8048209
- 0x08064ce0 Free 3 was never alloc'd 0x8048209
- 0x08064cf8 Free 4 was never alloc'd 0x8048209

Memory not freed:
-----------------
   Address     Size     Caller
0x08064c48     0x14  at 0x80481eb
0x08064c60     0x14  at 0x80481eb
0x08064c78     0x14  at 0x80481eb
0x08064c90     0x14  at 0x80481eb
</pre></td></tr></table>

<p>We have called <code>mtrace</code> with only one argument and so the script
has no chance to find out what is meant with the addresses given in the
trace.  We can do better:
</p>
<table><tr><td>&nbsp;</td><td><pre class="example">drepper$ mtrace tst errlog
- 0x08064cc8 Free 2 was never alloc'd /home/drepper/tst.c:39
- 0x08064ce0 Free 3 was never alloc'd /home/drepper/tst.c:39
- 0x08064cf8 Free 4 was never alloc'd /home/drepper/tst.c:39

Memory not freed:
-----------------
   Address     Size     Caller
0x08064c48     0x14  at /home/drepper/tst.c:33
0x08064c60     0x14  at /home/drepper/tst.c:33
0x08064c78     0x14  at /home/drepper/tst.c:33
0x08064c90     0x14  at /home/drepper/tst.c:33
</pre></td></tr></table>

<p>Suddenly the output makes much more sense and the user can see
immediately where the function calls causing the trouble can be found.
</p>
<p>Interpreting this output is not complicated.  There are at most two
different situations being detected.  First, <code>free</code> was called for
pointers which were never returned by one of the allocation functions.
This is usually a very bad problem and what this looks like is shown in
the first three lines of the output.  Situations like this are quite
rare and if they appear they show up very drastically: the program
normally crashes.
</p>
<p>The other situation which is much harder to detect are memory leaks.  As
you can see in the output the <code>mtrace</code> function collects all this
information and so can say that the program calls an allocation function
from line 33 in the source file &lsquo;<tt>/home/drepper/tst-mtrace.c</tt>&rsquo; four
times without freeing this memory before the program terminates.
Whether this is a real problem remains to be investigated.
</p>
<hr size="6">
<a name="Obstacks"></a>
<a name="SEC42"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC41" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC43" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC19" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC21" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="libc_4.html#SEC64" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="libc.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="libc_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="libc_42.html#SEC712" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="libc_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h3 class="subsection"> 3.2.4 Obstacks </h3>

<p>An <em>obstack</em> is a pool of memory containing a stack of objects.  You
can create any number of separate obstacks, and then allocate objects in
specified obstacks.  Within each obstack, the last object allocated must
always be the first one freed, but distinct obstacks are independent of
each other.
</p>
<p>Aside from this one constraint of order of freeing, obstacks are totally
general: an obstack can contain any number of objects of any size.  They
are implemented with macros, so allocation is usually very fast as long as
the objects are usually small.  And the only space overhead per object is
the padding needed to start each object on a suitable boundary.
</p>
<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top"><a href="#SEC43">3.2.4.1 Creating Obstacks</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">		How to declare an obstack in your program.
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC44">3.2.4.2 Preparing for Using Obstacks</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">	Preparations needed before you can
				 use obstacks.
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC45">3.2.4.3 Allocation in an Obstack</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">    Allocating objects in an obstack.
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC46">3.2.4.4 Freeing Objects in an Obstack</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">     Freeing objects in an obstack.
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC47">3.2.4.5 Obstack Functions and Macros</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">		The obstack functions are both
				 functions and macros.
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC48">3.2.4.6 Growing Objects</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">             Making an object bigger by stages.
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC49">3.2.4.7 Extra Fast Growing Objects</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">		Extra-high-efficiency (though more
				 complicated) growing objects.
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC50">3.2.4.8 Status of an Obstack</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">        Inquiries about the status of an obstack.
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC51">3.2.4.9 Alignment of Data in Obstacks</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">     Controlling alignment of objects in obstacks.
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC52">3.2.4.10 Obstack Chunks</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">              How obstacks obtain and release chunks;
				 efficiency considerations.
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC53">3.2.4.11 Summary of Obstack Functions</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
</table>

<hr size="6">
<a name="Creating-Obstacks"></a>
<a name="SEC43"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC42" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC44" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC19" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC42" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="libc_4.html#SEC64" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="libc.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="libc_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="libc_42.html#SEC712" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="libc_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h4 class="subsubsection"> 3.2.4.1 Creating Obstacks </h4>

<p>The utilities for manipulating obstacks are declared in the header
file &lsquo;<tt>obstack.h</tt>&rsquo;.
<a name="IDX250"></a>
</p>
<dl>
<dt><u>Data Type:</u> <b>struct obstack</b>
<a name="IDX251"></a>
</dt>
<dd><p>An obstack is represented by a data structure of type <code>struct
obstack</code>.  This structure has a small fixed size; it records the status
of the obstack and how to find the space in which objects are allocated.
It does not contain any of the objects themselves.  You should not try
to access the contents of the structure directly; use only the functions
described in this chapter.
</p></dd></dl>

<p>You can declare variables of type <code>struct obstack</code> and use them as
obstacks, or you can allocate obstacks dynamically like any other kind
of object.  Dynamic allocation of obstacks allows your program to have a
variable number of different stacks.  (You can even allocate an
obstack structure in another obstack, but this is rarely useful.)
</p>
<p>All the functions that work with obstacks require you to specify which
obstack to use.  You do this with a pointer of type <code>struct obstack
*</code>.  In the following, we often say &ldquo;an obstack&rdquo; when strictly
speaking the object at hand is such a pointer.
</p>
<p>The objects in the obstack are packed into large blocks called
<em>chunks</em>.  The <code>struct obstack</code> structure points to a chain of
the chunks currently in use.
</p>
<p>The obstack library obtains a new chunk whenever you allocate an object
that won't fit in the previous chunk.  Since the obstack library manages
chunks automatically, you don't need to pay much attention to them, but
you do need to supply a function which the obstack library should use to
get a chunk.  Usually you supply a function which uses <code>malloc</code>
directly or indirectly.  You must also supply a function to free a chunk.
These matters are described in the following section.
</p>
<hr size="6">
<a name="Preparing-for-Obstacks"></a>
<a name="SEC44"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC43" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC45" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC19" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC42" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="libc_4.html#SEC64" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="libc.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="libc_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="libc_42.html#SEC712" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="libc_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h4 class="subsubsection"> 3.2.4.2 Preparing for Using Obstacks </h4>

<p>Each source file in which you plan to use the obstack functions
must include the header file &lsquo;<tt>obstack.h</tt>&rsquo;, like this:
</p>
<table><tr><td>&nbsp;</td><td><pre class="smallexample">#include &lt;obstack.h&gt;
</pre></td></tr></table>

<a name="IDX252"></a>
<a name="IDX253"></a>
<p>Also, if the source file uses the macro <code>obstack_init</code>, it must
declare or define two functions or macros that will be called by the
obstack library.  One, <code>obstack_chunk_alloc</code>, is used to allocate
the chunks of memory into which objects are packed.  The other,
<code>obstack_chunk_free</code>, is used to return chunks when the objects in
them are freed.  These macros should appear before any use of obstacks
in the source file.
</p>
<p>Usually these are defined to use <code>malloc</code> via the intermediary
<code>xmalloc</code> (see section <a href="#SEC24">Unconstrained Allocation</a>).  This is done with
the following pair of macro definitions:
</p>
<table><tr><td>&nbsp;</td><td><pre class="smallexample">#define obstack_chunk_alloc xmalloc
#define obstack_chunk_free free
</pre></td></tr></table>

<p>Though the memory you get using obstacks really comes from <code>malloc</code>,
using obstacks is faster because <code>malloc</code> is called less often, for
larger blocks of memory.  See section <a href="#SEC52">Obstack Chunks</a>, for full details.
</p>
<p>At run time, before the program can use a <code>struct obstack</code> object
as an obstack, it must initialize the obstack by calling
<code>obstack_init</code>.
</p>
<dl>
<dt><u>Function:</u> int <b>obstack_init</b><i> (struct obstack *<var>obstack-ptr</var>)</i>
<a name="IDX254"></a>
</dt>
<dd><p>Initialize obstack <var>obstack-ptr</var> for allocation of objects.  This
function calls the obstack's <code>obstack_chunk_alloc</code> function.  If
allocation of memory fails, the function pointed to by
<code>obstack_alloc_failed_handler</code> is called.  The <code>obstack_init</code>
function always returns 1 (Compatibility notice: Former versions of
obstack returned 0 if allocation failed).
</p></dd></dl>

<p>Here are two examples of how to allocate the space for an obstack and
initialize it.  First, an obstack that is a static variable:
</p>
<table><tr><td>&nbsp;</td><td><pre class="smallexample">static struct obstack myobstack;
&hellip;
obstack_init (&amp;myobstack);
</pre></td></tr></table>

<p>Second, an obstack that is itself dynamically allocated:
</p>
<table><tr><td>&nbsp;</td><td><pre class="smallexample">struct obstack *myobstack_ptr
  = (struct obstack *) xmalloc (sizeof (struct obstack));

obstack_init (myobstack_ptr);
</pre></td></tr></table>

<dl>
<dt><u>Variable:</u> <b>obstack_alloc_failed_handler</b>
<a name="IDX255"></a>
</dt>
<dd><p>The value of this variable is a pointer to a function that
<code>obstack</code> uses when <code>obstack_chunk_alloc</code> fails to allocate
memory.  The default action is to print a message and abort.
You should supply a function that either calls <code>exit</code>
(see section <a href="libc_25.html#SEC562">Program Termination</a>) or <code>longjmp</code> (see section <a href="libc_23.html#SEC465">Non-Local Exits</a>) and doesn't return.
</p>
<table><tr><td>&nbsp;</td><td><pre class="smallexample">void my_obstack_alloc_failed (void)
&hellip;
obstack_alloc_failed_handler = &amp;my_obstack_alloc_failed;
</pre></td></tr></table>

</dd></dl>

<hr size="6">
<a name="Allocation-in-an-Obstack"></a>
<a name="SEC45"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC44" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC46" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC19" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC42" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="libc_4.html#SEC64" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="libc.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="libc_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="libc_42.html#SEC712" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="libc_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h4 class="subsubsection"> 3.2.4.3 Allocation in an Obstack </h4>

<p>The most direct way to allocate an object in an obstack is with
<code>obstack_alloc</code>, which is invoked almost like <code>malloc</code>.
</p>
<dl>
<dt><u>Function:</u> void * <b>obstack_alloc</b><i> (struct obstack *<var>obstack-ptr</var>, int <var>size</var>)</i>
<a name="IDX256"></a>
</dt>
<dd><p>This allocates an uninitialized block of <var>size</var> bytes in an obstack
and returns its address.  Here <var>obstack-ptr</var> specifies which obstack
to allocate the block in; it is the address of the <code>struct obstack</code>
object which represents the obstack.  Each obstack function or macro
requires you to specify an <var>obstack-ptr</var> as the first argument.
</p>
<p>This function calls the obstack's <code>obstack_chunk_alloc</code> function if
it needs to allocate a new chunk of memory; it calls
<code>obstack_alloc_failed_handler</code> if allocation of memory by
<code>obstack_chunk_alloc</code> failed.
</p></dd></dl>

<p>For example, here is a function that allocates a copy of a string <var>str</var>
in a specific obstack, which is in the variable <code>string_obstack</code>:
</p>
<table><tr><td>&nbsp;</td><td><pre class="smallexample">struct obstack string_obstack;

char *
copystring (char *string)
{
  size_t len = strlen (string) + 1;
  char *s = (char *) obstack_alloc (&amp;string_obstack, len);
  memcpy (s, string, len);
  return s;
}
</pre></td></tr></table>

<p>To allocate a block with specified contents, use the function
<code>obstack_copy</code>, declared like this:
</p>
<dl>
<dt><u>Function:</u> void * <b>obstack_copy</b><i> (struct obstack *<var>obstack-ptr</var>, void *<var>address</var>, int <var>size</var>)</i>
<a name="IDX257"></a>
</dt>
<dd><p>This allocates a block and initializes it by copying <var>size</var>
bytes of data starting at <var>address</var>.  It calls
<code>obstack_alloc_failed_handler</code> if allocation of memory by
<code>obstack_chunk_alloc</code> failed.
</p></dd></dl>

<dl>
<dt><u>Function:</u> void * <b>obstack_copy0</b><i> (struct obstack *<var>obstack-ptr</var>, void *<var>address</var>, int <var>size</var>)</i>
<a name="IDX258"></a>
</dt>
<dd><p>Like <code>obstack_copy</code>, but appends an extra byte containing a null
character.  This extra byte is not counted in the argument <var>size</var>.
</p></dd></dl>

<p>The <code>obstack_copy0</code> function is convenient for copying a sequence
of characters into an obstack as a null-terminated string.  Here is an
example of its use:
</p>
<table><tr><td>&nbsp;</td><td><pre class="smallexample">char *
obstack_savestring (char *addr, int size)
{
  return obstack_copy0 (&amp;myobstack, addr, size);
}
</pre></td></tr></table>

<p>Contrast this with the previous example of <code>savestring</code> using
<code>malloc</code> (see section <a href="#SEC25">Basic Memory Allocation</a>).
</p>
<hr size="6">
<a name="Freeing-Obstack-Objects"></a>
<a name="SEC46"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC45" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC47" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC19" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC42" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="libc_4.html#SEC64" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="libc.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="libc_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="libc_42.html#SEC712" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="libc_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h4 class="subsubsection"> 3.2.4.4 Freeing Objects in an Obstack </h4>

<p>To free an object allocated in an obstack, use the function
<code>obstack_free</code>.  Since the obstack is a stack of objects, freeing
one object automatically frees all other objects allocated more recently
in the same obstack.
</p>
<dl>
<dt><u>Function:</u> void <b>obstack_free</b><i> (struct obstack *<var>obstack-ptr</var>, void *<var>object</var>)</i>
<a name="IDX259"></a>
</dt>
<dd><p>If <var>object</var> is a null pointer, everything allocated in the obstack
is freed.  Otherwise, <var>object</var> must be the address of an object
allocated in the obstack.  Then <var>object</var> is freed, along with
everything allocated in <var>obstack</var> since <var>object</var>.
</p></dd></dl>

<p>Note that if <var>object</var> is a null pointer, the result is an
uninitialized obstack.  To free all memory in an obstack but leave it
valid for further allocation, call <code>obstack_free</code> with the address
of the first object allocated on the obstack:
</p>
<table><tr><td>&nbsp;</td><td><pre class="smallexample">obstack_free (obstack_ptr, first_object_allocated_ptr);
</pre></td></tr></table>

<p>Recall that the objects in an obstack are grouped into chunks.  When all
the objects in a chunk become free, the obstack library automatically
frees the chunk (see section <a href="#SEC44">Preparing for Using Obstacks</a>).  Then other
obstacks, or non-obstack allocation, can reuse the space of the chunk.
</p>
<hr size="6">
<a name="Obstack-Functions"></a>
<a name="SEC47"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC46" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC48" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC19" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC42" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="libc_4.html#SEC64" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="libc.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="libc_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="libc_42.html#SEC712" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="libc_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h4 class="subsubsection"> 3.2.4.5 Obstack Functions and Macros </h4>

<p>The interfaces for using obstacks may be defined either as functions or
as macros, depending on the compiler.  The obstack facility works with
all C compilers, including both ISO C and traditional C, but there are
precautions you must take if you plan to use compilers other than GNU C.
</p>
<p>If you are using an old-fashioned non-ISO C compiler, all the obstack
&ldquo;functions&rdquo; are actually defined only as macros.  You can call these
macros like functions, but you cannot use them in any other way (for
example, you cannot take their address).
</p>
<p>Calling the macros requires a special precaution: namely, the first
operand (the obstack pointer) may not contain any side effects, because
it may be computed more than once.  For example, if you write this:
</p>
<table><tr><td>&nbsp;</td><td><pre class="smallexample">obstack_alloc (get_obstack (), 4);
</pre></td></tr></table>

<p>you will find that <code>get_obstack</code> may be called several times.
If you use <code>*obstack_list_ptr++</code> as the obstack pointer argument,
you will get very strange results since the incrementation may occur
several times.
</p>
<p>In ISO C, each function has both a macro definition and a function
definition.  The function definition is used if you take the address of the
function without calling it.  An ordinary call uses the macro definition by
default, but you can request the function definition instead by writing the
function name in parentheses, as shown here:
</p>
<table><tr><td>&nbsp;</td><td><pre class="smallexample">char *x;
void *(*funcp) ();
/* <span class="roman">Use the macro</span>.  */
x = (char *) obstack_alloc (obptr, size);
/* <span class="roman">Call the function</span>.  */
x = (char *) (obstack_alloc) (obptr, size);
/* <span class="roman">Take the address of the function</span>.  */
funcp = obstack_alloc;
</pre></td></tr></table>

<p>This is the same situation that exists in ISO C for the standard library
functions.  See section <a href="libc_1.html#SEC11">Macro Definitions of Functions</a>.
</p>
<p><strong>Warning:</strong> When you do use the macros, you must observe the
precaution of avoiding side effects in the first operand, even in ISO C.
</p>
<p>If you use the GNU C compiler, this precaution is not necessary, because
various language extensions in GNU C permit defining the macros so as to
compute each argument only once.
</p>
<hr size="6">
<a name="Growing-Objects"></a>
<a name="SEC48"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC47" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC49" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC19" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC42" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="libc_4.html#SEC64" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="libc.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="libc_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="libc_42.html#SEC712" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="libc_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h4 class="subsubsection"> 3.2.4.6 Growing Objects </h4>

<p>Because memory in obstack chunks is used sequentially, it is possible to
build up an object step by step, adding one or more bytes at a time to the
end of the object.  With this technique, you do not need to know how much
data you will put in the object until you come to the end of it.  We call
this the technique of <em>growing objects</em>.  The special functions
for adding data to the growing object are described in this section.
</p>
<p>You don't need to do anything special when you start to grow an object.
Using one of the functions to add data to the object automatically
starts it.  However, it is necessary to say explicitly when the object is
finished.  This is done with the function <code>obstack_finish</code>.
</p>
<p>The actual address of the object thus built up is not known until the
object is finished.  Until then, it always remains possible that you will
add so much data that the object must be copied into a new chunk.
</p>
<p>While the obstack is in use for a growing object, you cannot use it for
ordinary allocation of another object.  If you try to do so, the space
already added to the growing object will become part of the other object.
</p>
<dl>
<dt><u>Function:</u> void <b>obstack_blank</b><i> (struct obstack *<var>obstack-ptr</var>, int <var>size</var>)</i>
<a name="IDX260"></a>
</dt>
<dd><p>The most basic function for adding to a growing object is
<code>obstack_blank</code>, which adds space without initializing it.
</p></dd></dl>

<dl>
<dt><u>Function:</u> void <b>obstack_grow</b><i> (struct obstack *<var>obstack-ptr</var>, void *<var>data</var>, int <var>size</var>)</i>
<a name="IDX261"></a>
</dt>
<dd><p>To add a block of initialized space, use <code>obstack_grow</code>, which is
the growing-object analogue of <code>obstack_copy</code>.  It adds <var>size</var>
bytes of data to the growing object, copying the contents from
<var>data</var>.
</p></dd></dl>

<dl>
<dt><u>Function:</u> void <b>obstack_grow0</b><i> (struct obstack *<var>obstack-ptr</var>, void *<var>data</var>, int <var>size</var>)</i>
<a name="IDX262"></a>
</dt>
<dd><p>This is the growing-object analogue of <code>obstack_copy0</code>.  It adds
<var>size</var> bytes copied from <var>data</var>, followed by an additional null
character.
</p></dd></dl>

<dl>
<dt><u>Function:</u> void <b>obstack_1grow</b><i> (struct obstack *<var>obstack-ptr</var>, char <var>c</var>)</i>
<a name="IDX263"></a>
</dt>
<dd><p>To add one character at a time, use the function <code>obstack_1grow</code>.
It adds a single byte containing <var>c</var> to the growing object.
</p></dd></dl>

<dl>
<dt><u>Function:</u> void <b>obstack_ptr_grow</b><i> (struct obstack *<var>obstack-ptr</var>, void *<var>data</var>)</i>
<a name="IDX264"></a>
</dt>
<dd><p>Adding the value of a pointer one can use the function
<code>obstack_ptr_grow</code>.  It adds <code>sizeof (void *)</code> bytes
containing the value of <var>data</var>.
</p></dd></dl>

<dl>
<dt><u>Function:</u> void <b>obstack_int_grow</b><i> (struct obstack *<var>obstack-ptr</var>, int <var>data</var>)</i>
<a name="IDX265"></a>
</dt>
<dd><p>A single value of type <code>int</code> can be added by using the
<code>obstack_int_grow</code> function.  It adds <code>sizeof (int)</code> bytes to
the growing object and initializes them with the value of <var>data</var>.
</p></dd></dl>

<dl>
<dt><u>Function:</u> void * <b>obstack_finish</b><i> (struct obstack *<var>obstack-ptr</var>)</i>
<a name="IDX266"></a>
</dt>
<dd><p>When you are finished growing the object, use the function
<code>obstack_finish</code> to close it off and return its final address.
</p>
<p>Once you have finished the object, the obstack is available for ordinary
allocation or for growing another object.
</p>
<p>This function can return a null pointer under the same conditions as
<code>obstack_alloc</code> (see section <a href="#SEC45">Allocation in an Obstack</a>).
</p></dd></dl>

<p>When you build an object by growing it, you will probably need to know
afterward how long it became.  You need not keep track of this as you grow
the object, because you can find out the length from the obstack just
before finishing the object with the function <code>obstack_object_size</code>,
declared as follows:
</p>
<dl>
<dt><u>Function:</u> int <b>obstack_object_size</b><i> (struct obstack *<var>obstack-ptr</var>)</i>
<a name="IDX267"></a>
</dt>
<dd><p>This function returns the current size of the growing object, in bytes.
Remember to call this function <em>before</em> finishing the object.
After it is finished, <code>obstack_object_size</code> will return zero.
</p></dd></dl>

<p>If you have started growing an object and wish to cancel it, you should
finish it and then free it, like this:
</p>
<table><tr><td>&nbsp;</td><td><pre class="smallexample">obstack_free (obstack_ptr, obstack_finish (obstack_ptr));
</pre></td></tr></table>

<p>This has no effect if no object was growing.
</p>
<a name="IDX268"></a>
<p>You can use <code>obstack_blank</code> with a negative size argument to make
the current object smaller.  Just don't try to shrink it beyond zero
length&mdash;there's no telling what will happen if you do that.
</p>
<hr size="6">
<a name="Extra-Fast-Growing"></a>
<a name="SEC49"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC48" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC50" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC19" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC42" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="libc_4.html#SEC64" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="libc.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="libc_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="libc_42.html#SEC712" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="libc_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h4 class="subsubsection"> 3.2.4.7 Extra Fast Growing Objects </h4>

<p>The usual functions for growing objects incur overhead for checking
whether there is room for the new growth in the current chunk.  If you
are frequently constructing objects in small steps of growth, this
overhead can be significant.
</p>
<p>You can reduce the overhead by using special &ldquo;fast growth&rdquo;
functions that grow the object without checking.  In order to have a
robust program, you must do the checking yourself.  If you do this checking
in the simplest way each time you are about to add data to the object, you
have not saved anything, because that is what the ordinary growth
functions do.  But if you can arrange to check less often, or check
more efficiently, then you make the program faster.
</p>
<p>The function <code>obstack_room</code> returns the amount of room available
in the current chunk.  It is declared as follows:
</p>
<dl>
<dt><u>Function:</u> int <b>obstack_room</b><i> (struct obstack *<var>obstack-ptr</var>)</i>
<a name="IDX269"></a>
</dt>
<dd><p>This returns the number of bytes that can be added safely to the current
growing object (or to an object about to be started) in obstack
<var>obstack</var> using the fast growth functions.
</p></dd></dl>

<p>While you know there is room, you can use these fast growth functions
for adding data to a growing object:
</p>
<dl>
<dt><u>Function:</u> void <b>obstack_1grow_fast</b><i> (struct obstack *<var>obstack-ptr</var>, char <var>c</var>)</i>
<a name="IDX270"></a>
</dt>
<dd><p>The function <code>obstack_1grow_fast</code> adds one byte containing the
character <var>c</var> to the growing object in obstack <var>obstack-ptr</var>.
</p></dd></dl>

<dl>
<dt><u>Function:</u> void <b>obstack_ptr_grow_fast</b><i> (struct obstack *<var>obstack-ptr</var>, void *<var>data</var>)</i>
<a name="IDX271"></a>
</dt>
<dd><p>The function <code>obstack_ptr_grow_fast</code> adds <code>sizeof (void *)</code>
bytes containing the value of <var>data</var> to the growing object in
obstack <var>obstack-ptr</var>.
</p></dd></dl>

<dl>
<dt><u>Function:</u> void <b>obstack_int_grow_fast</b><i> (struct obstack *<var>obstack-ptr</var>, int <var>data</var>)</i>
<a name="IDX272"></a>
</dt>
<dd><p>The function <code>obstack_int_grow_fast</code> adds <code>sizeof (int)</code> bytes
containing the value of <var>data</var> to the growing object in obstack
<var>obstack-ptr</var>.
</p></dd></dl>

<dl>
<dt><u>Function:</u> void <b>obstack_blank_fast</b><i> (struct obstack *<var>obstack-ptr</var>, int <var>size</var>)</i>
<a name="IDX273"></a>
</dt>
<dd><p>The function <code>obstack_blank_fast</code> adds <var>size</var> bytes to the
growing object in obstack <var>obstack-ptr</var> without initializing them.
</p></dd></dl>

<p>When you check for space using <code>obstack_room</code> and there is not
enough room for what you want to add, the fast growth functions
are not safe.  In this case, simply use the corresponding ordinary
growth function instead.  Very soon this will copy the object to a
new chunk; then there will be lots of room available again.
</p>
<p>So, each time you use an ordinary growth function, check afterward for
sufficient space using <code>obstack_room</code>.  Once the object is copied
to a new chunk, there will be plenty of space again, so the program will
start using the fast growth functions again.
</p>
<p>Here is an example:
</p>
<table><tr><td>&nbsp;</td><td><pre class="smallexample">void
add_string (struct obstack *obstack, const char *ptr, int len)
{
  while (len &gt; 0)
    {
      int room = obstack_room (obstack);
      if (room == 0)
        {
          /* <span class="roman">Not enough room. Add one character slowly,</span>
             <span class="roman">which may copy to a new chunk and make room.</span>  */
          obstack_1grow (obstack, *ptr++);
          len--;
        }
      else
        {
          if (room &gt; len)
            room = len;
          /* <span class="roman">Add fast as much as we have room for.</span> */
          len -= room;
          while (room-- &gt; 0)
            obstack_1grow_fast (obstack, *ptr++);
        }
    }
}
</pre></td></tr></table>

<hr size="6">
<a name="Status-of-an-Obstack"></a>
<a name="SEC50"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC49" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC51" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC19" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC42" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="libc_4.html#SEC64" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="libc.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="libc_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="libc_42.html#SEC712" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="libc_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h4 class="subsubsection"> 3.2.4.8 Status of an Obstack </h4>

<p>Here are functions that provide information on the current status of
allocation in an obstack.  You can use them to learn about an object while
still growing it.
</p>
<dl>
<dt><u>Function:</u> void * <b>obstack_base</b><i> (struct obstack *<var>obstack-ptr</var>)</i>
<a name="IDX274"></a>
</dt>
<dd><p>This function returns the tentative address of the beginning of the
currently growing object in <var>obstack-ptr</var>.  If you finish the object
immediately, it will have that address.  If you make it larger first, it
may outgrow the current chunk&mdash;then its address will change!
</p>
<p>If no object is growing, this value says where the next object you
allocate will start (once again assuming it fits in the current
chunk).
</p></dd></dl>

<dl>
<dt><u>Function:</u> void * <b>obstack_next_free</b><i> (struct obstack *<var>obstack-ptr</var>)</i>
<a name="IDX275"></a>
</dt>
<dd><p>This function returns the address of the first free byte in the current
chunk of obstack <var>obstack-ptr</var>.  This is the end of the currently
growing object.  If no object is growing, <code>obstack_next_free</code>
returns the same value as <code>obstack_base</code>.
</p></dd></dl>

<dl>
<dt><u>Function:</u> int <b>obstack_object_size</b><i> (struct obstack *<var>obstack-ptr</var>)</i>
<a name="IDX276"></a>
</dt>
<dd><p>This function returns the size in bytes of the currently growing object.
This is equivalent to
</p>
<table><tr><td>&nbsp;</td><td><pre class="smallexample">obstack_next_free (<var>obstack-ptr</var>) - obstack_base (<var>obstack-ptr</var>)
</pre></td></tr></table>
</dd></dl>

<hr size="6">
<a name="Obstacks-Data-Alignment"></a>
<a name="SEC51"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC50" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC52" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC19" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC42" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="libc_4.html#SEC64" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="libc.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="libc_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="libc_42.html#SEC712" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="libc_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h4 class="subsubsection"> 3.2.4.9 Alignment of Data in Obstacks </h4>

<p>Each obstack has an <em>alignment boundary</em>; each object allocated in
the obstack automatically starts on an address that is a multiple of the
specified boundary.  By default, this boundary is aligned so that
the object can hold any type of data.
</p>
<p>To access an obstack's alignment boundary, use the macro
<code>obstack_alignment_mask</code>, whose function prototype looks like
this:
</p>
<dl>
<dt><u>Macro:</u> int <b>obstack_alignment_mask</b><i> (struct obstack *<var>obstack-ptr</var>)</i>
<a name="IDX277"></a>
</dt>
<dd><p>The value is a bit mask; a bit that is 1 indicates that the corresponding
bit in the address of an object should be 0.  The mask value should be one
less than a power of 2; the effect is that all object addresses are
multiples of that power of 2.  The default value of the mask is a value
that allows aligned objects to hold any type of data: for example, if
its value is 3, any type of data can be stored at locations whose
addresses are multiples of 4.  A mask value of 0 means an object can start
on any multiple of 1 (that is, no alignment is required).
</p>
<p>The expansion of the macro <code>obstack_alignment_mask</code> is an lvalue,
so you can alter the mask by assignment.  For example, this statement:
</p>
<table><tr><td>&nbsp;</td><td><pre class="smallexample">obstack_alignment_mask (obstack_ptr) = 0;
</pre></td></tr></table>

<p>has the effect of turning off alignment processing in the specified obstack.
</p></dd></dl>

<p>Note that a change in alignment mask does not take effect until
<em>after</em> the next time an object is allocated or finished in the
obstack.  If you are not growing an object, you can make the new
alignment mask take effect immediately by calling <code>obstack_finish</code>.
This will finish a zero-length object and then do proper alignment for
the next object.
</p>
<hr size="6">
<a name="Obstack-Chunks"></a>
<a name="SEC52"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC51" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC53" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC19" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC42" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="libc_4.html#SEC64" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="libc.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="libc_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="libc_42.html#SEC712" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="libc_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h4 class="subsubsection"> 3.2.4.10 Obstack Chunks </h4>

<p>Obstacks work by allocating space for themselves in large chunks, and
then parceling out space in the chunks to satisfy your requests.  Chunks
are normally 4096 bytes long unless you specify a different chunk size.
The chunk size includes 8 bytes of overhead that are not actually used
for storing objects.  Regardless of the specified size, longer chunks
will be allocated when necessary for long objects.
</p>
<p>The obstack library allocates chunks by calling the function
<code>obstack_chunk_alloc</code>, which you must define.  When a chunk is no
longer needed because you have freed all the objects in it, the obstack
library frees the chunk by calling <code>obstack_chunk_free</code>, which you
must also define.
</p>
<p>These two must be defined (as macros) or declared (as functions) in each
source file that uses <code>obstack_init</code> (see section <a href="#SEC43">Creating Obstacks</a>).
Most often they are defined as macros like this:
</p>
<table><tr><td>&nbsp;</td><td><pre class="smallexample">#define obstack_chunk_alloc malloc
#define obstack_chunk_free free
</pre></td></tr></table>

<p>Note that these are simple macros (no arguments).  Macro definitions with
arguments will not work!  It is necessary that <code>obstack_chunk_alloc</code>
or <code>obstack_chunk_free</code>, alone, expand into a function name if it is
not itself a function name.
</p>
<p>If you allocate chunks with <code>malloc</code>, the chunk size should be a
power of 2.  The default chunk size, 4096, was chosen because it is long
enough to satisfy many typical requests on the obstack yet short enough
not to waste too much memory in the portion of the last chunk not yet used.
</p>
<dl>
<dt><u>Macro:</u> int <b>obstack_chunk_size</b><i> (struct obstack *<var>obstack-ptr</var>)</i>
<a name="IDX278"></a>
</dt>
<dd><p>This returns the chunk size of the given obstack.
</p></dd></dl>

<p>Since this macro expands to an lvalue, you can specify a new chunk size by
assigning it a new value.  Doing so does not affect the chunks already
allocated, but will change the size of chunks allocated for that particular
obstack in the future.  It is unlikely to be useful to make the chunk size
smaller, but making it larger might improve efficiency if you are
allocating many objects whose size is comparable to the chunk size.  Here
is how to do so cleanly:
</p>
<table><tr><td>&nbsp;</td><td><pre class="smallexample">if (obstack_chunk_size (obstack_ptr) &lt; <var>new-chunk-size</var>)
  obstack_chunk_size (obstack_ptr) = <var>new-chunk-size</var>;
</pre></td></tr></table>

<hr size="6">
<a name="Summary-of-Obstacks"></a>
<a name="SEC53"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC52" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC54" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC19" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC42" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="libc_4.html#SEC64" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="libc.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="libc_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="libc_42.html#SEC712" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="libc_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h4 class="subsubsection"> 3.2.4.11 Summary of Obstack Functions </h4>

<p>Here is a summary of all the functions associated with obstacks.  Each
takes the address of an obstack (<code>struct obstack *</code>) as its first
argument.
</p>
<dl compact="compact">
<dt> <code>void obstack_init (struct obstack *<var>obstack-ptr</var>)</code></dt>
<dd><p>Initialize use of an obstack.  See section <a href="#SEC43">Creating Obstacks</a>.
</p>
</dd>
<dt> <code>void *obstack_alloc (struct obstack *<var>obstack-ptr</var>, int <var>size</var>)</code></dt>
<dd><p>Allocate an object of <var>size</var> uninitialized bytes.
See section <a href="#SEC45">Allocation in an Obstack</a>.
</p>
</dd>
<dt> <code>void *obstack_copy (struct obstack *<var>obstack-ptr</var>, void *<var>address</var>, int <var>size</var>)</code></dt>
<dd><p>Allocate an object of <var>size</var> bytes, with contents copied from
<var>address</var>.  See section <a href="#SEC45">Allocation in an Obstack</a>.
</p>
</dd>
<dt> <code>void *obstack_copy0 (struct obstack *<var>obstack-ptr</var>, void *<var>address</var>, int <var>size</var>)</code></dt>
<dd><p>Allocate an object of <var>size</var>+1 bytes, with <var>size</var> of them copied
from <var>address</var>, followed by a null character at the end.
See section <a href="#SEC45">Allocation in an Obstack</a>.
</p>
</dd>
<dt> <code>void obstack_free (struct obstack *<var>obstack-ptr</var>, void *<var>object</var>)</code></dt>
<dd><p>Free <var>object</var> (and everything allocated in the specified obstack
more recently than <var>object</var>).  See section <a href="#SEC46">Freeing Objects in an Obstack</a>.
</p>
</dd>
<dt> <code>void obstack_blank (struct obstack *<var>obstack-ptr</var>, int <var>size</var>)</code></dt>
<dd><p>Add <var>size</var> uninitialized bytes to a growing object.
See section <a href="#SEC48">Growing Objects</a>.
</p>
</dd>
<dt> <code>void obstack_grow (struct obstack *<var>obstack-ptr</var>, void *<var>address</var>, int <var>size</var>)</code></dt>
<dd><p>Add <var>size</var> bytes, copied from <var>address</var>, to a growing object.
See section <a href="#SEC48">Growing Objects</a>.
</p>
</dd>
<dt> <code>void obstack_grow0 (struct obstack *<var>obstack-ptr</var>, void *<var>address</var>, int <var>size</var>)</code></dt>
<dd><p>Add <var>size</var> bytes, copied from <var>address</var>, to a growing object,
and then add another byte containing a null character.  See section <a href="#SEC48">Growing Objects</a>.
</p>
</dd>
<dt> <code>void obstack_1grow (struct obstack *<var>obstack-ptr</var>, char <var>data-char</var>)</code></dt>
<dd><p>Add one byte containing <var>data-char</var> to a growing object.
See section <a href="#SEC48">Growing Objects</a>.
</p>
</dd>
<dt> <code>void *obstack_finish (struct obstack *<var>obstack-ptr</var>)</code></dt>
<dd><p>Finalize the object that is growing and return its permanent address.
See section <a href="#SEC48">Growing Objects</a>.
</p>
</dd>
<dt> <code>int obstack_object_size (struct obstack *<var>obstack-ptr</var>)</code></dt>
<dd><p>Get the current size of the currently growing object.  See section <a href="#SEC48">Growing Objects</a>.
</p>
</dd>
<dt> <code>void obstack_blank_fast (struct obstack *<var>obstack-ptr</var>, int <var>size</var>)</code></dt>
<dd><p>Add <var>size</var> uninitialized bytes to a growing object without checking
that there is enough room.  See section <a href="#SEC49">Extra Fast Growing Objects</a>.
</p>
</dd>
<dt> <code>void obstack_1grow_fast (struct obstack *<var>obstack-ptr</var>, char <var>data-char</var>)</code></dt>
<dd><p>Add one byte containing <var>data-char</var> to a growing object without
checking that there is enough room.  See section <a href="#SEC49">Extra Fast Growing Objects</a>.
</p>
</dd>
<dt> <code>int obstack_room (struct obstack *<var>obstack-ptr</var>)</code></dt>
<dd><p>Get the amount of room now available for growing the current object.
See section <a href="#SEC49">Extra Fast Growing Objects</a>.
</p>
</dd>
<dt> <code>int obstack_alignment_mask (struct obstack *<var>obstack-ptr</var>)</code></dt>
<dd><p>The mask used for aligning the beginning of an object.  This is an
lvalue.  See section <a href="#SEC51">Alignment of Data in Obstacks</a>.
</p>
</dd>
<dt> <code>int obstack_chunk_size (struct obstack *<var>obstack-ptr</var>)</code></dt>
<dd><p>The size for allocating chunks.  This is an lvalue.  See section <a href="#SEC52">Obstack Chunks</a>.
</p>
</dd>
<dt> <code>void *obstack_base (struct obstack *<var>obstack-ptr</var>)</code></dt>
<dd><p>Tentative starting address of the currently growing object.
See section <a href="#SEC50">Status of an Obstack</a>.
</p>
</dd>
<dt> <code>void *obstack_next_free (struct obstack *<var>obstack-ptr</var>)</code></dt>
<dd><p>Address just after the end of the currently growing object.
See section <a href="#SEC50">Status of an Obstack</a>.
</p></dd>
</dl>

<hr size="6">
<a name="Variable-Size-Automatic"></a>
<a name="SEC54"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC53" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC55" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC19" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC21" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="libc_4.html#SEC64" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="libc.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="libc_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="libc_42.html#SEC712" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="libc_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h3 class="subsection"> 3.2.5 Automatic Storage with Variable Size </h3>

<p>The function <code>alloca</code> supports a kind of half-dynamic allocation in
which blocks are allocated dynamically but freed automatically.
</p>
<p>Allocating a block with <code>alloca</code> is an explicit action; you can
allocate as many blocks as you wish, and compute the size at run time.  But
all the blocks are freed when you exit the function that <code>alloca</code> was
called from, just as if they were automatic variables declared in that
function.  There is no way to free the space explicitly.
</p>
<p>The prototype for <code>alloca</code> is in &lsquo;<tt>stdlib.h</tt>&rsquo;.  This function is
a BSD extension.
<a name="IDX279"></a>
</p>
<dl>
<dt><u>Function:</u> void * <b>alloca</b><i> (size_t <var>size</var>);</i>
<a name="IDX280"></a>
</dt>
<dd><p>The return value of <code>alloca</code> is the address of a block of <var>size</var>
bytes of memory, allocated in the stack frame of the calling function.
</p></dd></dl>

<p>Do not use <code>alloca</code> inside the arguments of a function call&mdash;you
will get unpredictable results, because the stack space for the
<code>alloca</code> would appear on the stack in the middle of the space for
the function arguments.  An example of what to avoid is <code>foo (x,
alloca (4), y)</code>.
</p>
<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top"><a href="#SEC55">3.2.5.1 <code>alloca</code> Example</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">              Example of using <code>alloca</code>.
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC56">3.2.5.2 Advantages of <code>alloca</code></a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">        Reasons to use <code>alloca</code>.
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC57">3.2.5.3 Disadvantages of <code>alloca</code></a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">     Reasons to avoid <code>alloca</code>.
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC58">3.2.5.4 GNU C Variable-Size Arrays</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">  Only in GNU C, here is an alternative
				 method of allocating dynamically and
				 freeing automatically.
</td></tr>
</table>

<hr size="6">
<a name="Alloca-Example"></a>
<a name="SEC55"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC54" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC56" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC19" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC54" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="libc_4.html#SEC64" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="libc.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="libc_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="libc_42.html#SEC712" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="libc_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h4 class="subsubsection"> 3.2.5.1 <code>alloca</code> Example </h4>

<p>As an example of the use of <code>alloca</code>, here is a function that opens
a file name made from concatenating two argument strings, and returns a
file descriptor or minus one signifying failure:
</p>
<table><tr><td>&nbsp;</td><td><pre class="smallexample">int
open2 (char *str1, char *str2, int flags, int mode)
{
  char *name = (char *) alloca (strlen (str1) + strlen (str2) + 1);
  stpcpy (stpcpy (name, str1), str2);
  return open (name, flags, mode);
}
</pre></td></tr></table>

<p>Here is how you would get the same results with <code>malloc</code> and
<code>free</code>:
</p>
<table><tr><td>&nbsp;</td><td><pre class="smallexample">int
open2 (char *str1, char *str2, int flags, int mode)
{
  char *name = (char *) malloc (strlen (str1) + strlen (str2) + 1);
  int desc;
  if (name == 0)
    fatal (&quot;virtual memory exceeded&quot;);
  stpcpy (stpcpy (name, str1), str2);
  desc = open (name, flags, mode);
  free (name);
  return desc;
}
</pre></td></tr></table>

<p>As you can see, it is simpler with <code>alloca</code>.  But <code>alloca</code> has
other, more important advantages, and some disadvantages.
</p>
<hr size="6">
<a name="Advantages-of-Alloca"></a>
<a name="SEC56"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC55" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC57" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC19" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC54" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="libc_4.html#SEC64" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="libc.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="libc_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="libc_42.html#SEC712" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="libc_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h4 class="subsubsection"> 3.2.5.2 Advantages of <code>alloca</code> </h4>

<p>Here are the reasons why <code>alloca</code> may be preferable to <code>malloc</code>:
</p>
<ul>
<li>
Using <code>alloca</code> wastes very little space and is very fast.  (It is
open-coded by the GNU C compiler.)

</li><li>
Since <code>alloca</code> does not have separate pools for different sizes of
block, space used for any size block can be reused for any other size.
<code>alloca</code> does not cause memory fragmentation.

</li><li>
<a name="IDX281"></a>
Nonlocal exits done with <code>longjmp</code> (see section <a href="libc_23.html#SEC465">Non-Local Exits</a>)
automatically free the space allocated with <code>alloca</code> when they exit
through the function that called <code>alloca</code>.  This is the most
important reason to use <code>alloca</code>.

<p>To illustrate this, suppose you have a function
<code>open_or_report_error</code> which returns a descriptor, like
<code>open</code>, if it succeeds, but does not return to its caller if it
fails.  If the file cannot be opened, it prints an error message and
jumps out to the command level of your program using <code>longjmp</code>.
Let's change <code>open2</code> (see section <a href="#SEC55"><code>alloca</code> Example</a>) to use this
subroutine:
</p>
<table><tr><td>&nbsp;</td><td><pre class="smallexample">int
open2 (char *str1, char *str2, int flags, int mode)
{
  char *name = (char *) alloca (strlen (str1) + strlen (str2) + 1);
  stpcpy (stpcpy (name, str1), str2);
  return open_or_report_error (name, flags, mode);
}
</pre></td></tr></table>

<p>Because of the way <code>alloca</code> works, the memory it allocates is
freed even when an error occurs, with no special effort required.
</p>
<p>By contrast, the previous definition of <code>open2</code> (which uses
<code>malloc</code> and <code>free</code>) would develop a memory leak if it were
changed in this way.  Even if you are willing to make more changes to
fix it, there is no easy way to do so.
</p></li></ul>

<hr size="6">
<a name="Disadvantages-of-Alloca"></a>
<a name="SEC57"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC56" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC58" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC19" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC54" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="libc_4.html#SEC64" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="libc.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="libc_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="libc_42.html#SEC712" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="libc_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h4 class="subsubsection"> 3.2.5.3 Disadvantages of <code>alloca</code> </h4>

<p>These are the disadvantages of <code>alloca</code> in comparison with
<code>malloc</code>:
</p>
<ul>
<li>
If you try to allocate more memory than the machine can provide, you
don't get a clean error message.  Instead you get a fatal signal like
the one you would get from an infinite recursion; probably a
segmentation violation (see section <a href="libc_24.html#SEC477">Program Error Signals</a>).

</li><li>
Some non-GNU systems fail to support <code>alloca</code>, so it is less
portable.  However, a slower emulation of <code>alloca</code> written in C
is available for use on systems with this deficiency.
</li></ul>

<hr size="6">
<a name="GNU-C-Variable_002dSize-Arrays"></a>
<a name="SEC58"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC57" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC59" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC19" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC54" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="libc_4.html#SEC64" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="libc.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="libc_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="libc_42.html#SEC712" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="libc_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h4 class="subsubsection"> 3.2.5.4 GNU C Variable-Size Arrays </h4>

<p>In GNU C, you can replace most uses of <code>alloca</code> with an array of
variable size.  Here is how <code>open2</code> would look then:
</p>
<table><tr><td>&nbsp;</td><td><pre class="smallexample">int open2 (char *str1, char *str2, int flags, int mode)
{
  char name[strlen (str1) + strlen (str2) + 1];
  stpcpy (stpcpy (name, str1), str2);
  return open (name, flags, mode);
}
</pre></td></tr></table>

<p>But <code>alloca</code> is not always equivalent to a variable-sized array, for
several reasons:
</p>
<ul>
<li>
A variable size array's space is freed at the end of the scope of the
name of the array.  The space allocated with <code>alloca</code>
remains until the end of the function.

</li><li>
It is possible to use <code>alloca</code> within a loop, allocating an
additional block on each iteration.  This is impossible with
variable-sized arrays.
</li></ul>

<p><strong>NB:</strong> If you mix use of <code>alloca</code> and variable-sized arrays
within one function, exiting a scope in which a variable-sized array was
declared frees all blocks allocated with <code>alloca</code> during the
execution of that scope.
</p>

<hr size="6">
<a name="Resizing-the-Data-Segment"></a>
<a name="SEC59"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC58" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC60" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC19" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC19" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="libc_4.html#SEC64" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="libc.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="libc_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="libc_42.html#SEC712" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="libc_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="section"> 3.3 Resizing the Data Segment </h2>

<p>The symbols in this section are declared in &lsquo;<tt>unistd.h</tt>&rsquo;.
</p>
<p>You will not normally use the functions in this section, because the
functions described in <a href="#SEC21">Allocating Storage For Program Data</a> are easier to use.  Those
are interfaces to a GNU C Library memory allocator that uses the
functions below itself.  The functions below are simple interfaces to
system calls.
</p>
<dl>
<dt><u>Function:</u> int <b>brk</b><i> (void *<var>addr</var>)</i>
<a name="IDX282"></a>
</dt>
<dd><p><code>brk</code> sets the high end of the calling process' data segment to
<var>addr</var>.
</p>
<p>The address of the end of a segment is defined to be the address of the
last byte in the segment plus 1.
</p>
<p>The function has no effect if <var>addr</var> is lower than the low end of
the data segment.  (This is considered success, by the way).
</p>
<p>The function fails if it would cause the data segment to overlap another
segment or exceed the process' data storage limit (see section <a href="libc_22.html#SEC451">Limiting Resource Usage</a>).
</p>
<p>The function is named for a common historical case where data storage
and the stack are in the same segment.  Data storage allocation grows
upward from the bottom of the segment while the stack grows downward
toward it from the top of the segment and the curtain between them is
called the <em>break</em>.
</p>
<p>The return value is zero on success.  On failure, the return value is
<code>-1</code> and <code>errno</code> is set accordingly.  The following <code>errno</code>
values are specific to this function:
</p>
<dl compact="compact">
<dt> <code>ENOMEM</code></dt>
<dd><p>The request would cause the data segment to overlap another segment or
exceed the process' data storage limit.
</p></dd>
</dl>


</dd></dl>


<dl>
<dt><u>Function:</u> void <b>*sbrk</b><i> (ptrdiff_t <var>delta</var>)</i>
<a name="IDX283"></a>
</dt>
<dd><p>This function is the same as <code>brk</code> except that you specify the new
end of the data segment as an offset <var>delta</var> from the current end
and on success the return value is the address of the resulting end of
the data segment instead of zero.
</p>
<p>This means you can use &lsquo;<samp>sbrk(0)</samp>&rsquo; to find out what the current end
of the data segment is.
</p>
</dd></dl>



<hr size="6">
<a name="Locking-Pages"></a>
<a name="SEC60"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC59" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC61" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC19" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC19" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="libc_4.html#SEC64" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="libc.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="libc_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="libc_42.html#SEC712" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="libc_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="section"> 3.4 Locking Pages </h2>

<p>You can tell the system to associate a particular virtual memory page
with a real page frame and keep it that way &mdash; i.e., cause the page to
be paged in if it isn't already and mark it so it will never be paged
out and consequently will never cause a page fault.  This is called
<em>locking</em> a page.
</p>
<p>The functions in this chapter lock and unlock the calling process'
pages.
</p>
<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top"><a href="#SEC61">3.4.1 Why Lock Pages</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                Reasons to read this section.
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC62">3.4.2 Locked Memory Details</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">         Everything you need to know locked
                                    memory
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC63">3.4.3 Functions To Lock And Unlock Pages</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">           Here's how to do it.
</td></tr>
</table>

<hr size="6">
<a name="Why-Lock-Pages"></a>
<a name="SEC61"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC60" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC62" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC19" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC60" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="libc_4.html#SEC64" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="libc.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="libc_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="libc_42.html#SEC712" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="libc_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h3 class="subsection"> 3.4.1 Why Lock Pages </h3>

<p>Because page faults cause paged out pages to be paged in transparently,
a process rarely needs to be concerned about locking pages.  However,
there are two reasons people sometimes are:
</p>
<ul>
<li>
Speed.  A page fault is transparent only insofar as the process is not
sensitive to how long it takes to do a simple memory access.  Time-critical
processes, especially realtime processes, may not be able to wait or
may not be able to tolerate variance in execution speed.
<a name="IDX284"></a>
<a name="IDX285"></a>

<p>A process that needs to lock pages for this reason probably also needs
priority among other processes for use of the CPU.  See section <a href="libc_22.html#SEC452">Process CPU Priority And Scheduling</a>.
</p>
<p>In some cases, the programmer knows better than the system's demand
paging allocator which pages should remain in real memory to optimize
system performance.  In this case, locking pages can help.
</p>
</li><li>
Privacy.  If you keep secrets in virtual memory and that virtual memory
gets paged out, that increases the chance that the secrets will get out.
If a password gets written out to disk swap space, for example, it might
still be there long after virtual and real memory have been wiped clean.

</li></ul>

<p>Be aware that when you lock a page, that's one fewer page frame that can
be used to back other virtual memory (by the same or other processes),
which can mean more page faults, which means the system runs more
slowly.  In fact, if you lock enough memory, some programs may not be
able to run at all for lack of real memory.
</p>
<hr size="6">
<a name="Locked-Memory-Details"></a>
<a name="SEC62"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC61" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC63" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC19" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC60" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="libc_4.html#SEC64" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="libc.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="libc_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="libc_42.html#SEC712" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="libc_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h3 class="subsection"> 3.4.2 Locked Memory Details </h3>

<p>A memory lock is associated with a virtual page, not a real frame.  The
paging rule is: If a frame backs at least one locked page, don't page it
out.
</p>
<p>Memory locks do not stack.  I.e., you can't lock a particular page twice
so that it has to be unlocked twice before it is truly unlocked.  It is
either locked or it isn't.
</p>
<p>A memory lock persists until the process that owns the memory explicitly
unlocks it.  (But process termination and exec cause the virtual memory
to cease to exist, which you might say means it isn't locked any more).
</p>
<p>Memory locks are not inherited by child processes.  (But note that on a
modern Unix system, immediately after a fork, the parent's and the
child's virtual address space are backed by the same real page frames,
so the child enjoys the parent's locks).  See section <a href="libc_26.html#SEC572">Creating a Process</a>.
</p>
<p>Because of its ability to impact other processes, only the superuser can
lock a page.  Any process can unlock its own page.
</p>
<p>The system sets limits on the amount of memory a process can have locked
and the amount of real memory it can have dedicated to it.  See section <a href="libc_22.html#SEC451">Limiting Resource Usage</a>.
</p>
<p>In Linux, locked pages aren't as locked as you might think.
Two virtual pages that are not shared memory can nonetheless be backed
by the same real frame.  The kernel does this in the name of efficiency
when it knows both virtual pages contain identical data, and does it
even if one or both of the virtual pages are locked.
</p>
<p>But when a process modifies one of those pages, the kernel must get it a
separate frame and fill it with the page's data.  This is known as a
<em>copy-on-write page fault</em>.  It takes a small amount of time and in
a pathological case, getting that frame may require I/O.
<a name="IDX286"></a>
<a name="IDX287"></a>
</p>
<p>To make sure this doesn't happen to your program, don't just lock the
pages.  Write to them as well, unless you know you won't write to them
ever.  And to make sure you have pre-allocated frames for your stack,
enter a scope that declares a C automatic variable larger than the
maximum stack size you will need, set it to something, then return from
its scope.
</p>
<hr size="6">
<a name="Page-Lock-Functions"></a>
<a name="SEC63"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC62" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="libc_4.html#SEC64" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC19" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC60" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="libc_4.html#SEC64" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="libc.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="libc_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="libc_42.html#SEC712" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="libc_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h3 class="subsection"> 3.4.3 Functions To Lock And Unlock Pages </h3>

<p>The symbols in this section are declared in &lsquo;<tt>sys/mman.h</tt>&rsquo;.  These
functions are defined by POSIX.1b, but their availability depends on
your kernel.  If your kernel doesn't allow these functions, they exist
but always fail.  They <em>are</em> available with a Linux kernel.
</p>
<p><strong>Portability Note:</strong> POSIX.1b requires that when the <code>mlock</code>
and <code>munlock</code> functions are available, the file &lsquo;<tt>unistd.h</tt>&rsquo;
define the macro <code>_POSIX_MEMLOCK_RANGE</code> and the file
<code>limits.h</code> define the macro <code>PAGESIZE</code> to be the size of a
memory page in bytes.  It requires that when the <code>mlockall</code> and
<code>munlockall</code> functions are available, the &lsquo;<tt>unistd.h</tt>&rsquo; file
define the macro <code>_POSIX_MEMLOCK</code>.  The GNU C library conforms to
this requirement.
</p>
<dl>
<dt><u>Function:</u> int <b>mlock</b><i> (const void *<var>addr</var>, size_t <var>len</var>)</i>
<a name="IDX288"></a>
</dt>
<dd><p><code>mlock</code> locks a range of the calling process' virtual pages.
</p>
<p>The range of memory starts at address <var>addr</var> and is <var>len</var> bytes
long.  Actually, since you must lock whole pages, it is the range of
pages that include any part of the specified range.
</p>
<p>When the function returns successfully, each of those pages is backed by
(connected to) a real frame (is resident) and is marked to stay that
way.  This means the function may cause page-ins and have to wait for
them.
</p>
<p>When the function fails, it does not affect the lock status of any
pages.
</p>
<p>The return value is zero if the function succeeds.  Otherwise, it is
<code>-1</code> and <code>errno</code> is set accordingly.  <code>errno</code> values
specific to this function are:
</p>
<dl compact="compact">
<dt> <code>ENOMEM</code></dt>
<dd><ul>
<li>
At least some of the specified address range does not exist in the
calling process' virtual address space.
</li><li>
The locking would cause the process to exceed its locked page limit.
</li></ul>

</dd>
<dt> <code>EPERM</code></dt>
<dd><p>The calling process is not superuser.
</p>
</dd>
<dt> <code>EINVAL</code></dt>
<dd><p><var>len</var> is not positive.
</p>
</dd>
<dt> <code>ENOSYS</code></dt>
<dd><p>The kernel does not provide <code>mlock</code> capability.
</p>
</dd>
</dl>

<p>You can lock <em>all</em> a process' memory with <code>mlockall</code>.  You
unlock memory with <code>munlock</code> or <code>munlockall</code>.
</p>
<p>To avoid all page faults in a C program, you have to use
<code>mlockall</code>, because some of the memory a program uses is hidden
from the C code, e.g. the stack and automatic variables, and you
wouldn't know what address to tell <code>mlock</code>.
</p>
</dd></dl>

<dl>
<dt><u>Function:</u> int <b>munlock</b><i> (const void *<var>addr</var>, size_t <var>len</var>)</i>
<a name="IDX289"></a>
</dt>
<dd><p><code>munlock</code> unlocks a range of the calling process' virtual pages.
</p>
<p><code>munlock</code> is the inverse of <code>mlock</code> and functions completely
analogously to <code>mlock</code>, except that there is no <code>EPERM</code>
failure.
</p>
</dd></dl>

<dl>
<dt><u>Function:</u> int <b>mlockall</b><i> (int <var>flags</var>)</i>
<a name="IDX290"></a>
</dt>
<dd><p><code>mlockall</code> locks all the pages in a process' virtual memory address
space, and/or any that are added to it in the future.  This includes the
pages of the code, data and stack segment, as well as shared libraries,
user space kernel data, shared memory, and memory mapped files.
</p>
<p><var>flags</var> is a string of single bit flags represented by the following
macros.  They tell <code>mlockall</code> which of its functions you want.  All
other bits must be zero.
</p>
<dl compact="compact">
<dt> <code>MCL_CURRENT</code></dt>
<dd><p>Lock all pages which currently exist in the calling process' virtual
address space.
</p>
</dd>
<dt> <code>MCL_FUTURE</code></dt>
<dd><p>Set a mode such that any pages added to the process' virtual address
space in the future will be locked from birth.  This mode does not
affect future address spaces owned by the same process so exec, which
replaces a process' address space, wipes out <code>MCL_FUTURE</code>.
See section <a href="libc_26.html#SEC573">Executing a File</a>.
</p>
</dd>
</dl>

<p>When the function returns successfully, and you specified
<code>MCL_CURRENT</code>, all of the process' pages are backed by (connected
to) real frames (they are resident) and are marked to stay that way.
This means the function may cause page-ins and have to wait for them.
</p>
<p>When the process is in <code>MCL_FUTURE</code> mode because it successfully
executed this function and specified <code>MCL_CURRENT</code>, any system call
by the process that requires space be added to its virtual address space
fails with <code>errno</code> = <code>ENOMEM</code> if locking the additional space
would cause the process to exceed its locked page limit.  In the case
that the address space addition that can't be accommodated is stack
expansion, the stack expansion fails and the kernel sends a
<code>SIGSEGV</code> signal to the process.
</p>
<p>When the function fails, it does not affect the lock status of any pages
or the future locking mode.
</p>
<p>The return value is zero if the function succeeds.  Otherwise, it is
<code>-1</code> and <code>errno</code> is set accordingly.  <code>errno</code> values
specific to this function are:
</p>
<dl compact="compact">
<dt> <code>ENOMEM</code></dt>
<dd><ul>
<li>
At least some of the specified address range does not exist in the
calling process' virtual address space.
</li><li>
The locking would cause the process to exceed its locked page limit.
</li></ul>

</dd>
<dt> <code>EPERM</code></dt>
<dd><p>The calling process is not superuser.
</p>
</dd>
<dt> <code>EINVAL</code></dt>
<dd><p>Undefined bits in <var>flags</var> are not zero.
</p>
</dd>
<dt> <code>ENOSYS</code></dt>
<dd><p>The kernel does not provide <code>mlockall</code> capability.
</p>
</dd>
</dl>

<p>You can lock just specific pages with <code>mlock</code>.  You unlock pages
with <code>munlockall</code> and <code>munlock</code>.
</p>
</dd></dl>


<dl>
<dt><u>Function:</u> int <b>munlockall</b><i> (void)</i>
<a name="IDX291"></a>
</dt>
<dd><p><code>munlockall</code> unlocks every page in the calling process' virtual
address space and turn off <code>MCL_FUTURE</code> future locking mode.
</p>
<p>The return value is zero if the function succeeds.  Otherwise, it is
<code>-1</code> and <code>errno</code> is set accordingly.  The only way this
function can fail is for generic reasons that all functions and system
calls can fail, so there are no specific <code>errno</code> values.
</p>
</dd></dl>








<hr size="6">
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC19" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="libc_4.html#SEC64" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="libc.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="libc_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="libc_42.html#SEC712" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="libc_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<p>
 <font size="-1">
  This document was generated by <em>root</em> on <em>February, 26 2009</em> using <a href="http://www.nongnu.org/texi2html/"><em>texi2html 1.78</em></a>.
 </font>
 <br>

</p>
</body>
</html>
