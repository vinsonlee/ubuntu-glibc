<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html401/loose.dtd">
<html>
<!-- This file documents the GNU C library.

This is Edition 0.12, last updated 2007-10-27,
of The GNU C Library Reference Manual, for version 2.8.

Copyright (C) 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2001, 2002,
2003, 2007, 2008 Free Software Foundation, Inc.

Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.2 or
any later version published by the Free Software Foundation; with the
Invariant Sections being "Free Software Needs Free Documentation"
and "GNU Lesser General Public License", the Front-Cover texts being
"A GNU Manual", and with the Back-Cover Texts as in (a) below.  A
copy of the license is included in the section entitled "GNU Free
Documentation License".

(a) The FSF's Back-Cover Text is: "You have the freedom to
copy and modify this GNU manual.  Buying copies from the FSF
supports it in developing GNU and promoting software freedom."
 -->
<!-- Created on February, 13 2009 by texi2html 1.78 -->
<!--
Written by: Lionel Cons <Lionel.Cons@cern.ch> (original author)
            Karl Berry  <karl@freefriends.org>
            Olaf Bachmann <obachman@mathematik.uni-kl.de>
            and many others.
Maintained by: Many creative people.
Send bugs and suggestions to <texi2html-bug@nongnu.org>

-->
<head>
<title>The GNU C Library: 29. Users and Groups</title>

<meta name="description" content="The GNU C Library: 29. Users and Groups">
<meta name="keywords" content="The GNU C Library: 29. Users and Groups">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="texi2html 1.78">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
<!--
a.summary-letter {text-decoration: none}
pre.display {font-family: serif}
pre.format {font-family: serif}
pre.menu-comment {font-family: serif}
pre.menu-preformatted {font-family: serif}
pre.smalldisplay {font-family: serif; font-size: smaller}
pre.smallexample {font-size: smaller}
pre.smallformat {font-family: serif; font-size: smaller}
pre.smalllisp {font-size: smaller}
span.roman {font-family:serif; font-weight:normal;}
span.sansserif {font-family:sans-serif; font-weight:normal;}
ul.toc {list-style: none}
-->
</style>


</head>

<body lang="en" bgcolor="#FFFFFF" text="#000000" link="#0000FF" vlink="#800080" alink="#FF0000">

<a name="Users-and-Groups"></a>
<a name="SEC608"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="libc_28.html#SEC607" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC609" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="libc_28.html#SEC596" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="libc.html#SEC_Top" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="libc_30.html#SEC638" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="libc.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="libc_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="libc_42.html#SEC712" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="libc_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h1 class="chapter"> 29. Users and Groups </h1>

<p>Every user who can log in on the system is identified by a unique number
called the <em>user ID</em>.  Each process has an effective user ID which
says which user's access permissions it has.
</p>
<p>Users are classified into <em>groups</em> for access control purposes.  Each
process has one or more <em>group ID values</em> which say which groups the
process can use for access to files.
</p>
<p>The effective user and group IDs of a process collectively form its
<em>persona</em>.  This determines which files the process can access.
Normally, a process inherits its persona from the parent process, but
under special circumstances a process can change its persona and thus
change its access permissions.
</p>
<p>Each file in the system also has a user ID and a group ID.  Access
control works by comparing the user and group IDs of the file with those
of the running process.
</p>
<p>The system keeps a database of all the registered users, and another
database of all the defined groups.  There are library functions you
can use to examine these databases.
</p>
<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top"><a href="#SEC609">29.1 User and Group IDs</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">          Each user has a unique numeric ID;
				 likewise for groups.
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC610">29.2 The Persona of a Process</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">             The user IDs and group IDs of a process.
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC611">29.3 Why Change the Persona of a Process?</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">          Why a program might need to change
				 its user and/or group IDs.
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC612">29.4 How an Application Can Change Persona</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">          Changing the user and group IDs.
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC613">29.5 Reading the Persona of a Process</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">             How to examine the user and group IDs.
</td></tr>
<tr><th colspan="3" align="left" valign="top"><pre class="menu-comment">
</pre></th></tr><tr><td align="left" valign="top"><a href="#SEC614">29.6 Setting the User ID</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">             Functions for setting the user ID.
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC615">29.7 Setting the Group IDs</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">              Functions for setting the group IDs.
</td></tr>
<tr><th colspan="3" align="left" valign="top"><pre class="menu-comment">
</pre></th></tr><tr><td align="left" valign="top"><a href="#SEC616">29.8 Enabling and Disabling Setuid Access</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">       Turning setuid access on and off.
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC617">29.9 Setuid Program Example</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">      The pertinent parts of one sample program.
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC618">29.10 Tips for Writing Setuid Programs</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">             How to avoid granting unlimited access.
</td></tr>
<tr><th colspan="3" align="left" valign="top"><pre class="menu-comment">
</pre></th></tr><tr><td align="left" valign="top"><a href="#SEC619">29.11 Identifying Who Logged In</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">               Getting the name of the user who logged in,
				 or of the real user ID of the current process.
</td></tr>
<tr><th colspan="3" align="left" valign="top"><pre class="menu-comment">
</pre></th></tr><tr><td align="left" valign="top"><a href="#SEC620">29.12 The User Accounting Database</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">    Keeping information about users and various
                                 actions in databases.
</td></tr>
<tr><th colspan="3" align="left" valign="top"><pre class="menu-comment">
</pre></th></tr><tr><td align="left" valign="top"><a href="#SEC624">29.13 User Database</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">               Functions and data structures for
                        	 accessing the user database.
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC629">29.14 Group Database</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">              Functions and data structures for
                        	 accessing the group database.
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC633">29.15 User and Group Database Example</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">            Example program showing the use of database
				 inquiry functions.
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC634">29.16 Netgroup Database</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">           Functions for accessing the netgroup database.
</td></tr>
</table>

<hr size="6">
<a name="User-and-Group-IDs"></a>
<a name="SEC609"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC608" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC610" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC608" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC608" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="libc_30.html#SEC638" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="libc.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="libc_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="libc_42.html#SEC712" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="libc_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="section"> 29.1 User and Group IDs </h2>

<p>Each user account on a computer system is identified by a <em>user
name</em> (or <em>login name</em>) and <em>user ID</em>.  Normally, each user name
has a unique user ID, but it is possible for several login names to have
the same user ID.  The user names and corresponding user IDs are stored
in a data base which you can access as described in <a href="#SEC624">User Database</a>.
</p>
<a name="IDX2776"></a>
<a name="IDX2777"></a>
<p>Users are classified in <em>groups</em>.  Each user name belongs to one
<em>default group</em> and may also belong to any number of
<em>supplementary groups</em>. Users who are members of the same group can
share resources (such as files) that are not accessible to users who are
not a member of that group.  Each group has a <em>group name</em> and
<em>group ID</em>.  See section <a href="#SEC629">Group Database</a>, for how to find information
about a group ID or group name.
</p>
<hr size="6">
<a name="Process-Persona"></a>
<a name="SEC610"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC609" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC611" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC608" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC608" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="libc_30.html#SEC638" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="libc.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="libc_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="libc_42.html#SEC712" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="libc_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="section"> 29.2 The Persona of a Process </h2>

<p>At any time, each process has an <em>effective user ID</em>, a <em>effective
group ID</em>, and a set of <em>supplementary group IDs</em>.  These IDs
determine the privileges of the process.  They are collectively
called the <em>persona</em> of the process, because they determine &ldquo;who it
is&rdquo; for purposes of access control.
</p>
<p>Your login shell starts out with a persona which consists of your user
ID, your default group ID, and your supplementary group IDs (if you are
in more than one group).  In normal circumstances, all your other processes
inherit these values.
</p>
<a name="IDX2778"></a>
<a name="IDX2779"></a>
<p>A process also has a <em>real user ID</em> which identifies the user who
created the process, and a <em>real group ID</em> which identifies that
user's default group.  These values do not play a role in access
control, so we do not consider them part of the persona.  But they are
also important.
</p>
<p>Both the real and effective user ID can be changed during the lifetime
of a process.  See section <a href="#SEC611">Why Change the Persona of a Process?</a>.
</p>
<p>For details on how a process's effective user ID and group IDs affect
its permission to access files, see <a href="libc_14.html#SEC290">How Your Access to a File is Decided</a>.
</p>
<p>The effective user ID of a process also controls permissions for sending
signals using the <code>kill</code> function.  See section <a href="libc_24.html#SEC506">Signaling Another Process</a>.
</p>
<p>Finally, there are many operations which can only be performed by a
process whose effective user ID is zero.  A process with this user ID is
a <em>privileged process</em>.  Commonly the user name <code>root</code> is
associated with user ID 0, but there may be other user names with this
ID.
</p>
<hr size="6">
<a name="Why-Change-Persona"></a>
<a name="SEC611"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC610" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC612" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC608" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC608" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="libc_30.html#SEC638" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="libc.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="libc_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="libc_42.html#SEC712" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="libc_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="section"> 29.3 Why Change the Persona of a Process? </h2>

<p>The most obvious situation where it is necessary for a process to change
its user and/or group IDs is the <code>login</code> program.  When
<code>login</code> starts running, its user ID is <code>root</code>.  Its job is to
start a shell whose user and group IDs are those of the user who is
logging in.  (To accomplish this fully, <code>login</code> must set the real
user and group IDs as well as its persona.  But this is a special case.)
</p>
<p>The more common case of changing persona is when an ordinary user
program needs access to a resource that wouldn't ordinarily be
accessible to the user actually running it.
</p>
<p>For example, you may have a file that is controlled by your program but
that shouldn't be read or modified directly by other users, either
because it implements some kind of locking protocol, or because you want
to preserve the integrity or privacy of the information it contains.
This kind of restricted access can be implemented by having the program
change its effective user or group ID to match that of the resource.
</p>
<p>Thus, imagine a game program that saves scores in a file.  The game
program itself needs to be able to update this file no matter who is
running it, but if users can write the file without going through the
game, they can give themselves any scores they like.  Some people
consider this undesirable, or even reprehensible.  It can be prevented
by creating a new user ID and login name (say, <code>games</code>) to own the
scores file, and make the file writable only by this user.  Then, when
the game program wants to update this file, it can change its effective
user ID to be that for <code>games</code>.  In effect, the program must
adopt the persona of <code>games</code> so it can write the scores file.
</p>
<hr size="6">
<a name="How-Change-Persona"></a>
<a name="SEC612"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC611" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC613" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC608" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC608" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="libc_30.html#SEC638" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="libc.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="libc_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="libc_42.html#SEC712" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="libc_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="section"> 29.4 How an Application Can Change Persona </h2>

<p>The ability to change the persona of a process can be a source of
unintentional privacy violations, or even intentional abuse.  Because of
the potential for problems, changing persona is restricted to special
circumstances.
</p>
<p>You can't arbitrarily set your user ID or group ID to anything you want;
only privileged processes can do that.  Instead, the normal way for a
program to change its persona is that it has been set up in advance to
change to a particular user or group.  This is the function of the setuid
and setgid bits of a file's access mode.  See section <a href="libc_14.html#SEC289">The Mode Bits for Access Permission</a>.
</p>
<p>When the setuid bit of an executable file is on, executing that file
gives the process a third user ID: the <em>file user ID</em>.  This ID is
set to the owner ID of the file.  The system then changes the effective
user ID to the file user ID.  The real user ID remains as it was.
Likewise, if the setgid bit is on, the process is given a <em>file
group ID</em> equal to the group ID of the file, and its effective group ID
is changed to the file group ID.
</p>
<p>If a process has a file ID (user or group), then it can at any time
change its effective ID to its real ID and back to its file ID.
Programs use this feature to relinquish their special privileges except
when they actually need them.  This makes it less likely that they can
be tricked into doing something inappropriate with their privileges.
</p>
<p><strong>Portability Note:</strong> Older systems do not have file IDs.
To determine if a system has this feature, you can test the compiler
define <code>_POSIX_SAVED_IDS</code>.  (In the POSIX standard, file IDs are
known as saved IDs.)
</p>
<p>See section <a href="libc_14.html#SEC284">File Attributes</a>, for a more general discussion of file modes and
accessibility.
</p>
<hr size="6">
<a name="Reading-Persona"></a>
<a name="SEC613"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC612" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC614" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC608" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC608" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="libc_30.html#SEC638" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="libc.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="libc_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="libc_42.html#SEC712" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="libc_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="section"> 29.5 Reading the Persona of a Process </h2>

<p>Here are detailed descriptions of the functions for reading the user and
group IDs of a process, both real and effective.  To use these
facilities, you must include the header files &lsquo;<tt>sys/types.h</tt>&rsquo; and
&lsquo;<tt>unistd.h</tt>&rsquo;.
<a name="IDX2780"></a>
<a name="IDX2781"></a>
</p>
<dl>
<dt><u>Data Type:</u> <b>uid_t</b>
<a name="IDX2782"></a>
</dt>
<dd><p>This is an integer data type used to represent user IDs.  In the GNU
library, this is an alias for <code>unsigned int</code>.
</p></dd></dl>

<dl>
<dt><u>Data Type:</u> <b>gid_t</b>
<a name="IDX2783"></a>
</dt>
<dd><p>This is an integer data type used to represent group IDs.  In the GNU
library, this is an alias for <code>unsigned int</code>.
</p></dd></dl>

<dl>
<dt><u>Function:</u> uid_t <b>getuid</b><i> (void)</i>
<a name="IDX2784"></a>
</dt>
<dd><p>The <code>getuid</code> function returns the real user ID of the process.
</p></dd></dl>

<dl>
<dt><u>Function:</u> gid_t <b>getgid</b><i> (void)</i>
<a name="IDX2785"></a>
</dt>
<dd><p>The <code>getgid</code> function returns the real group ID of the process.
</p></dd></dl>

<dl>
<dt><u>Function:</u> uid_t <b>geteuid</b><i> (void)</i>
<a name="IDX2786"></a>
</dt>
<dd><p>The <code>geteuid</code> function returns the effective user ID of the process.
</p></dd></dl>

<dl>
<dt><u>Function:</u> gid_t <b>getegid</b><i> (void)</i>
<a name="IDX2787"></a>
</dt>
<dd><p>The <code>getegid</code> function returns the effective group ID of the process.
</p></dd></dl>

<dl>
<dt><u>Function:</u> int <b>getgroups</b><i> (int <var>count</var>, gid_t *<var>groups</var>)</i>
<a name="IDX2788"></a>
</dt>
<dd><p>The <code>getgroups</code> function is used to inquire about the supplementary
group IDs of the process.  Up to <var>count</var> of these group IDs are
stored in the array <var>groups</var>; the return value from the function is
the number of group IDs actually stored.  If <var>count</var> is smaller than
the total number of supplementary group IDs, then <code>getgroups</code>
returns a value of <code>-1</code> and <code>errno</code> is set to <code>EINVAL</code>.
</p>
<p>If <var>count</var> is zero, then <code>getgroups</code> just returns the total
number of supplementary group IDs.  On systems that do not support
supplementary groups, this will always be zero.
</p>
<p>Here's how to use <code>getgroups</code> to read all the supplementary group
IDs:
</p>
<table><tr><td>&nbsp;</td><td><pre class="smallexample">gid_t *
read_all_groups (void)
{
  int ngroups = getgroups (0, NULL);
  gid_t *groups
    = (gid_t *) xmalloc (ngroups * sizeof (gid_t));
  int val = getgroups (ngroups, groups);
  if (val &lt; 0)
    {
      free (groups);
      return NULL;
    }
  return groups;
}
</pre></td></tr></table>
</dd></dl>

<hr size="6">
<a name="Setting-User-ID"></a>
<a name="SEC614"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC613" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC615" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC608" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC608" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="libc_30.html#SEC638" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="libc.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="libc_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="libc_42.html#SEC712" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="libc_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="section"> 29.6 Setting the User ID </h2>

<p>This section describes the functions for altering the user ID (real
and/or effective) of a process.  To use these facilities, you must
include the header files &lsquo;<tt>sys/types.h</tt>&rsquo; and &lsquo;<tt>unistd.h</tt>&rsquo;.
<a name="IDX2789"></a>
<a name="IDX2790"></a>
</p>
<dl>
<dt><u>Function:</u> int <b>seteuid</b><i> (uid_t <var>neweuid</var>)</i>
<a name="IDX2791"></a>
</dt>
<dd><p>This function sets the effective user ID of a process to <var>newuid</var>,
provided that the process is allowed to change its effective user ID.  A
privileged process (effective user ID zero) can change its effective
user ID to any legal value.  An unprivileged process with a file user ID
can change its effective user ID to its real user ID or to its file user
ID.  Otherwise, a process may not change its effective user ID at all.
</p>
<p>The <code>seteuid</code> function returns a value of <code>0</code> to indicate
successful completion, and a value of <code>-1</code> to indicate an error.
The following <code>errno</code> error conditions are defined for this
function:
</p>
<dl compact="compact">
<dt> <code>EINVAL</code></dt>
<dd><p>The value of the <var>newuid</var> argument is invalid.
</p>
</dd>
<dt> <code>EPERM</code></dt>
<dd><p>The process may not change to the specified ID.
</p></dd>
</dl>

<p>Older systems (those without the <code>_POSIX_SAVED_IDS</code> feature) do not
have this function.
</p></dd></dl>

<dl>
<dt><u>Function:</u> int <b>setuid</b><i> (uid_t <var>newuid</var>)</i>
<a name="IDX2792"></a>
</dt>
<dd><p>If the calling process is privileged, this function sets both the real
and effective user ID of the process to <var>newuid</var>.  It also deletes
the file user ID of the process, if any.  <var>newuid</var> may be any
legal value.  (Once this has been done, there is no way to recover the
old effective user ID.)
</p>
<p>If the process is not privileged, and the system supports the
<code>_POSIX_SAVED_IDS</code> feature, then this function behaves like
<code>seteuid</code>.
</p>
<p>The return values and error conditions are the same as for <code>seteuid</code>.
</p></dd></dl>

<dl>
<dt><u>Function:</u> int <b>setreuid</b><i> (uid_t <var>ruid</var>, uid_t <var>euid</var>)</i>
<a name="IDX2793"></a>
</dt>
<dd><p>This function sets the real user ID of the process to <var>ruid</var> and the
effective user ID to <var>euid</var>.  If <var>ruid</var> is <code>-1</code>, it means
not to change the real user ID; likewise if <var>euid</var> is <code>-1</code>, it
means not to change the effective user ID.
</p>
<p>The <code>setreuid</code> function exists for compatibility with 4.3 BSD Unix,
which does not support file IDs.  You can use this function to swap the
effective and real user IDs of the process.  (Privileged processes are
not limited to this particular usage.)  If file IDs are supported, you
should use that feature instead of this function.  See section <a href="#SEC616">Enabling and Disabling Setuid Access</a>.
</p>
<p>The return value is <code>0</code> on success and <code>-1</code> on failure.
The following <code>errno</code> error conditions are defined for this
function:
</p>
<dl compact="compact">
<dt> <code>EPERM</code></dt>
<dd><p>The process does not have the appropriate privileges; you do not
have permission to change to the specified ID.
</p></dd>
</dl>
</dd></dl>

<hr size="6">
<a name="Setting-Groups"></a>
<a name="SEC615"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC614" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC616" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC608" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC608" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="libc_30.html#SEC638" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="libc.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="libc_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="libc_42.html#SEC712" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="libc_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="section"> 29.7 Setting the Group IDs </h2>

<p>This section describes the functions for altering the group IDs (real
and effective) of a process.  To use these facilities, you must include
the header files &lsquo;<tt>sys/types.h</tt>&rsquo; and &lsquo;<tt>unistd.h</tt>&rsquo;.
<a name="IDX2794"></a>
<a name="IDX2795"></a>
</p>
<dl>
<dt><u>Function:</u> int <b>setegid</b><i> (gid_t <var>newgid</var>)</i>
<a name="IDX2796"></a>
</dt>
<dd><p>This function sets the effective group ID of the process to
<var>newgid</var>, provided that the process is allowed to change its group
ID.  Just as with <code>seteuid</code>, if the process is privileged it may
change its effective group ID to any value; if it isn't, but it has a
file group ID, then it may change to its real group ID or file group ID;
otherwise it may not change its effective group ID.
</p>
<p>Note that a process is only privileged if its effective <em>user</em> ID
is zero.  The effective group ID only affects access permissions.
</p>
<p>The return values and error conditions for <code>setegid</code> are the same
as those for <code>seteuid</code>.
</p>
<p>This function is only present if <code>_POSIX_SAVED_IDS</code> is defined.
</p></dd></dl>

<dl>
<dt><u>Function:</u> int <b>setgid</b><i> (gid_t <var>newgid</var>)</i>
<a name="IDX2797"></a>
</dt>
<dd><p>This function sets both the real and effective group ID of the process
to <var>newgid</var>, provided that the process is privileged.  It also
deletes the file group ID, if any.
</p>
<p>If the process is not privileged, then <code>setgid</code> behaves like
<code>setegid</code>.
</p>
<p>The return values and error conditions for <code>setgid</code> are the same
as those for <code>seteuid</code>.
</p></dd></dl>

<dl>
<dt><u>Function:</u> int <b>setregid</b><i> (gid_t <var>rgid</var>, gid_t <var>egid</var>)</i>
<a name="IDX2798"></a>
</dt>
<dd><p>This function sets the real group ID of the process to <var>rgid</var> and
the effective group ID to <var>egid</var>.  If <var>rgid</var> is <code>-1</code>, it
means not to change the real group ID; likewise if <var>egid</var> is
<code>-1</code>, it means not to change the effective group ID.
</p>
<p>The <code>setregid</code> function is provided for compatibility with 4.3 BSD
Unix, which does not support file IDs.  You can use this function to
swap the effective and real group IDs of the process.  (Privileged
processes are not limited to this usage.)  If file IDs are supported,
you should use that feature instead of using this function.
See section <a href="#SEC616">Enabling and Disabling Setuid Access</a>.
</p>
<p>The return values and error conditions for <code>setregid</code> are the same
as those for <code>setreuid</code>.
</p></dd></dl>

<p><code>setuid</code> and <code>setgid</code> behave differently depending on whether
the effective user ID at the time is zero.  If it is not zero, they
behave like <code>seteuid</code> and <code>setegid</code>.  If it is, they change
both effective and real IDs and delete the file ID.  To avoid confusion,
we recommend you always use <code>seteuid</code> and <code>setegid</code> except
when you know the effective user ID is zero and your intent is to change
the persona permanently.  This case is rare&mdash;most of the programs that
need it, such as <code>login</code> and <code>su</code>, have already been written.
</p>
<p>Note that if your program is setuid to some user other than <code>root</code>,
there is no way to drop privileges permanently.
</p>
<p>The system also lets privileged processes change their supplementary
group IDs.  To use <code>setgroups</code> or <code>initgroups</code>, your programs
should include the header file &lsquo;<tt>grp.h</tt>&rsquo;.
<a name="IDX2799"></a>
</p>
<dl>
<dt><u>Function:</u> int <b>setgroups</b><i> (size_t <var>count</var>, gid_t *<var>groups</var>)</i>
<a name="IDX2800"></a>
</dt>
<dd><p>This function sets the process's supplementary group IDs.  It can only
be called from privileged processes.  The <var>count</var> argument specifies
the number of group IDs in the array <var>groups</var>.
</p>
<p>This function returns <code>0</code> if successful and <code>-1</code> on error.
The following <code>errno</code> error conditions are defined for this
function:
</p>
<dl compact="compact">
<dt> <code>EPERM</code></dt>
<dd><p>The calling process is not privileged.
</p></dd>
</dl>
</dd></dl>

<dl>
<dt><u>Function:</u> int <b>initgroups</b><i> (const char *<var>user</var>, gid_t <var>group</var>)</i>
<a name="IDX2801"></a>
</dt>
<dd><p>The <code>initgroups</code> function sets the process's supplementary group
IDs to be the normal default for the user name <var>user</var>.  The group
<var>group</var> is automatically included.
</p>
<p>This function works by scanning the group database for all the groups
<var>user</var> belongs to.  It then calls <code>setgroups</code> with the list it
has constructed.
</p>
<p>The return values and error conditions are the same as for
<code>setgroups</code>.
</p></dd></dl>

<p>If you are interested in the groups a particular user belongs to, but do
not want to change the process's supplementary group IDs, you can use
<code>getgrouplist</code>.  To use <code>getgrouplist</code>, your programs should
include the header file &lsquo;<tt>grp.h</tt>&rsquo;.
<a name="IDX2802"></a>
</p>
<dl>
<dt><u>Function:</u> int <b>getgrouplist</b><i> (const char *<var>user</var>, gid_t <var>group</var>, gid_t *<var>groups</var>, int *<var>ngroups</var>)</i>
<a name="IDX2803"></a>
</dt>
<dd><p>The <code>getgrouplist</code> function scans the group database for all the
groups <var>user</var> belongs to.  Up to *<var>ngroups</var> group IDs
corresponding to these groups are stored in the array <var>groups</var>; the
return value from the function is the number of group IDs actually
stored.  If *<var>ngroups</var> is smaller than the total number of groups
found, then <code>getgrouplist</code> returns a value of <code>-1</code> and stores
the actual number of groups in *<var>ngroups</var>.  The group <var>group</var> is
automatically included in the list of groups returned by
<code>getgrouplist</code>.
</p>
<p>Here's how to use <code>getgrouplist</code> to read all supplementary groups
for <var>user</var>:
</p>
<table><tr><td>&nbsp;</td><td><pre class="smallexample">gid_t *
supplementary_groups (char *user)
{
  int ngroups = 16;
  gid_t *groups
    = (gid_t *) xmalloc (ngroups * sizeof (gid_t));
  struct passwd *pw = getpwnam (user);

  if (pw == NULL)
    return NULL;

  if (getgrouplist (pw-&gt;pw_name, pw-&gt;pw_gid, groups, &amp;ngroups) &lt; 0)
    {
      groups = xrealloc (ngroups * sizeof (gid_t));
      getgrouplist (pw-&gt;pw_name, pw-&gt;pw_gid, groups, &amp;ngroups);
    }
  return groups;
}
</pre></td></tr></table>
</dd></dl>

<hr size="6">
<a name="Enable_002fDisable-Setuid"></a>
<a name="SEC616"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC615" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC617" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC608" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC608" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="libc_30.html#SEC638" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="libc.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="libc_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="libc_42.html#SEC712" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="libc_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="section"> 29.8 Enabling and Disabling Setuid Access </h2>

<p>A typical setuid program does not need its special access all of the
time.  It's a good idea to turn off this access when it isn't needed,
so it can't possibly give unintended access.
</p>
<p>If the system supports the <code>_POSIX_SAVED_IDS</code> feature, you can
accomplish this with <code>seteuid</code>.  When the game program starts, its
real user ID is <code>jdoe</code>, its effective user ID is <code>games</code>, and
its saved user ID is also <code>games</code>.  The program should record both
user ID values once at the beginning, like this:
</p>
<table><tr><td>&nbsp;</td><td><pre class="smallexample">user_user_id = getuid ();
game_user_id = geteuid ();
</pre></td></tr></table>

<p>Then it can turn off game file access with
</p>
<table><tr><td>&nbsp;</td><td><pre class="smallexample">seteuid (user_user_id);
</pre></td></tr></table>

<p>and turn it on with
</p>
<table><tr><td>&nbsp;</td><td><pre class="smallexample">seteuid (game_user_id);
</pre></td></tr></table>

<p>Throughout this process, the real user ID remains <code>jdoe</code> and the
file user ID remains <code>games</code>, so the program can always set its
effective user ID to either one.
</p>
<p>On other systems that don't support file user IDs, you can
turn setuid access on and off by using <code>setreuid</code> to swap the real
and effective user IDs of the process, as follows:
</p>
<table><tr><td>&nbsp;</td><td><pre class="smallexample">setreuid (geteuid (), getuid ());
</pre></td></tr></table>

<p>This special case is always allowed&mdash;it cannot fail.
</p>
<p>Why does this have the effect of toggling the setuid access?  Suppose a
game program has just started, and its real user ID is <code>jdoe</code> while
its effective user ID is <code>games</code>.  In this state, the game can
write the scores file.  If it swaps the two uids, the real becomes
<code>games</code> and the effective becomes <code>jdoe</code>; now the program has
only <code>jdoe</code> access.  Another swap brings <code>games</code> back to
the effective user ID and restores access to the scores file.
</p>
<p>In order to handle both kinds of systems, test for the saved user ID
feature with a preprocessor conditional, like this:
</p>
<table><tr><td>&nbsp;</td><td><pre class="smallexample">#ifdef _POSIX_SAVED_IDS
  seteuid (user_user_id);
#else
  setreuid (geteuid (), getuid ());
#endif
</pre></td></tr></table>

<hr size="6">
<a name="Setuid-Program-Example"></a>
<a name="SEC617"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC616" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC618" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC608" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC608" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="libc_30.html#SEC638" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="libc.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="libc_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="libc_42.html#SEC712" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="libc_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="section"> 29.9 Setuid Program Example </h2>

<p>Here's an example showing how to set up a program that changes its
effective user ID.
</p>
<p>This is part of a game program called <code>caber-toss</code> that manipulates
a file &lsquo;<tt>scores</tt>&rsquo; that should be writable only by the game program
itself.  The program assumes that its executable file will be installed
with the setuid bit set and owned by the same user as the &lsquo;<tt>scores</tt>&rsquo;
file.  Typically, a system administrator will set up an account like
<code>games</code> for this purpose.
</p>
<p>The executable file is given mode <code>4755</code>, so that doing an
&lsquo;<samp>ls -l</samp>&rsquo; on it produces output like:
</p>
<table><tr><td>&nbsp;</td><td><pre class="smallexample">-rwsr-xr-x   1 games    184422 Jul 30 15:17 caber-toss
</pre></td></tr></table>

<p>The setuid bit shows up in the file modes as the &lsquo;<samp>s</samp>&rsquo;.
</p>
<p>The scores file is given mode <code>644</code>, and doing an &lsquo;<samp>ls -l</samp>&rsquo; on
it shows:
</p>
<table><tr><td>&nbsp;</td><td><pre class="smallexample">-rw-r--r--  1 games           0 Jul 31 15:33 scores
</pre></td></tr></table>

<p>Here are the parts of the program that show how to set up the changed
user ID.  This program is conditionalized so that it makes use of the
file IDs feature if it is supported, and otherwise uses <code>setreuid</code>
to swap the effective and real user IDs.
</p>
<table><tr><td>&nbsp;</td><td><pre class="smallexample">#include &lt;stdio.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;unistd.h&gt;
#include &lt;stdlib.h&gt;


/* <span class="roman">Remember the effective and real UIDs.</span> */

static uid_t euid, ruid;


/* <span class="roman">Restore the effective UID to its original value.</span> */

void
do_setuid (void)
{
  int status;

#ifdef _POSIX_SAVED_IDS
  status = seteuid (euid);
#else
  status = setreuid (ruid, euid);
#endif
  if (status &lt; 0) {
    fprintf (stderr, &quot;Couldn't set uid.\n&quot;);
    exit (status);
    }
}


/* <span class="roman">Set the effective UID to the real UID.</span> */

void
undo_setuid (void)
{
  int status;

#ifdef _POSIX_SAVED_IDS
  status = seteuid (ruid);
#else
  status = setreuid (euid, ruid);
#endif
  if (status &lt; 0) {
    fprintf (stderr, &quot;Couldn't set uid.\n&quot;);
    exit (status);
    }
}

/* <span class="roman">Main program.</span> */

int
main (void)
{
  /* <span class="roman">Remember the real and effective user IDs.</span>  */
  ruid = getuid ();
  euid = geteuid ();
  undo_setuid ();

  /* <span class="roman">Do the game and record the score.</span>  */
  &hellip;
}
</pre></td></tr></table>

<p>Notice how the first thing the <code>main</code> function does is to set the
effective user ID back to the real user ID.  This is so that any other
file accesses that are performed while the user is playing the game use
the real user ID for determining permissions.  Only when the program
needs to open the scores file does it switch back to the file user ID,
like this:
</p>
<table><tr><td>&nbsp;</td><td><pre class="smallexample">/* <span class="roman">Record the score.</span> */

int
record_score (int score)
{
  FILE *stream;
  char *myname;

  /* <span class="roman">Open the scores file.</span> */
  do_setuid ();
  stream = fopen (SCORES_FILE, &quot;a&quot;);
  undo_setuid ();

  /* <span class="roman">Write the score to the file.</span> */
  if (stream)
    {
      myname = cuserid (NULL);
      if (score &lt; 0)
        fprintf (stream, &quot;%10s: Couldn't lift the caber.\n&quot;, myname);
      else
        fprintf (stream, &quot;%10s: %d feet.\n&quot;, myname, score);
      fclose (stream);
      return 0;
    }
  else
    return -1;
}
</pre></td></tr></table>

<hr size="6">
<a name="Tips-for-Setuid"></a>
<a name="SEC618"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC617" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC619" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC608" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC608" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="libc_30.html#SEC638" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="libc.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="libc_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="libc_42.html#SEC712" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="libc_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="section"> 29.10 Tips for Writing Setuid Programs </h2>

<p>It is easy for setuid programs to give the user access that isn't
intended&mdash;in fact, if you want to avoid this, you need to be careful.
Here are some guidelines for preventing unintended access and
minimizing its consequences when it does occur:
</p>
<ul>
<li>
Don't have <code>setuid</code> programs with privileged user IDs such as
<code>root</code> unless it is absolutely necessary.  If the resource is
specific to your particular program, it's better to define a new,
nonprivileged user ID or group ID just to manage that resource.
It's better if you can write your program to use a special group than a
special user.

</li><li>
Be cautious about using the <code>exec</code> functions in combination with
changing the effective user ID.  Don't let users of your program execute
arbitrary programs under a changed user ID.  Executing a shell is
especially bad news. Less obviously, the <code>execlp</code> and <code>execvp</code>
functions are a potential risk (since the program they execute depends
on the user's <code>PATH</code> environment variable).

<p>If you must <code>exec</code> another program under a changed ID, specify an
absolute file name (see section <a href="libc_11.html#SEC174">File Name Resolution</a>) for the executable,
and make sure that the protections on that executable and <em>all</em>
containing directories are such that ordinary users cannot replace it
with some other program.
</p>
<p>You should also check the arguments passed to the program to make sure
they do not have unexpected effects.  Likewise, you should examine the
environment variables.  Decide which arguments and variables are safe,
and reject all others.
</p>
<p>You should never use <code>system</code> in a privileged program, because it
invokes a shell.
</p>
</li><li>
Only use the user ID controlling the resource in the part of the program
that actually uses that resource.  When you're finished with it, restore
the effective user ID back to the actual user's user ID.
See section <a href="#SEC616">Enabling and Disabling Setuid Access</a>.

</li><li>
If the <code>setuid</code> part of your program needs to access other files
besides the controlled resource, it should verify that the real user
would ordinarily have permission to access those files.  You can use the
<code>access</code> function (see section <a href="libc_14.html#SEC290">How Your Access to a File is Decided</a>) to check this; it
uses the real user and group IDs, rather than the effective IDs.
</li></ul>

<hr size="6">
<a name="Who-Logged-In"></a>
<a name="SEC619"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC618" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC620" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC608" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC608" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="libc_30.html#SEC638" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="libc.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="libc_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="libc_42.html#SEC712" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="libc_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="section"> 29.11 Identifying Who Logged In </h2>

<p>You can use the functions listed in this section to determine the login
name of the user who is running a process, and the name of the user who
logged in the current session.  See also the function <code>getuid</code> and
friends (see section <a href="#SEC613">Reading the Persona of a Process</a>).  How this information is collected by
the system and how to control/add/remove information from the background
storage is described in <a href="#SEC620">The User Accounting Database</a>.
</p>
<p>The <code>getlogin</code> function is declared in &lsquo;<tt>unistd.h</tt>&rsquo;, while
<code>cuserid</code> and <code>L_cuserid</code> are declared in &lsquo;<tt>stdio.h</tt>&rsquo;.
<a name="IDX2804"></a>
<a name="IDX2805"></a>
</p>
<dl>
<dt><u>Function:</u> char * <b>getlogin</b><i> (void)</i>
<a name="IDX2806"></a>
</dt>
<dd><p>The <code>getlogin</code> function returns a pointer to a string containing the
name of the user logged in on the controlling terminal of the process,
or a null pointer if this information cannot be determined.  The string
is statically allocated and might be overwritten on subsequent calls to
this function or to <code>cuserid</code>.
</p></dd></dl>

<dl>
<dt><u>Function:</u> char * <b>cuserid</b><i> (char *<var>string</var>)</i>
<a name="IDX2807"></a>
</dt>
<dd><p>The <code>cuserid</code> function returns a pointer to a string containing a
user name associated with the effective ID of the process.  If
<var>string</var> is not a null pointer, it should be an array that can hold
at least <code>L_cuserid</code> characters; the string is returned in this
array.  Otherwise, a pointer to a string in a static area is returned.
This string is statically allocated and might be overwritten on
subsequent calls to this function or to <code>getlogin</code>.
</p>
<p>The use of this function is deprecated since it is marked to be
withdrawn in XPG4.2 and has already been removed from newer revisions of
POSIX.1.
</p></dd></dl>

<dl>
<dt><u>Macro:</u> int <b>L_cuserid</b>
<a name="IDX2808"></a>
</dt>
<dd><p>An integer constant that indicates how long an array you might need to
store a user name.
</p></dd></dl>

<p>These functions let your program identify positively the user who is
running or the user who logged in this session.  (These can differ when
setuid programs are involved; see <a href="#SEC610">The Persona of a Process</a>.)  The user cannot
do anything to fool these functions.
</p>
<p>For most purposes, it is more useful to use the environment variable
<code>LOGNAME</code> to find out who the user is.  This is more flexible
precisely because the user can set <code>LOGNAME</code> arbitrarily.
See section <a href="libc_25.html#SEC560">Standard Environment Variables</a>.
</p>

<hr size="6">
<a name="User-Accounting-Database"></a>
<a name="SEC620"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC619" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC621" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC608" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC608" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="libc_30.html#SEC638" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="libc.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="libc_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="libc_42.html#SEC712" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="libc_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="section"> 29.12 The User Accounting Database </h2>

<p>Most Unix-like operating systems keep track of logged in users by
maintaining a user accounting database.  This user accounting database
stores for each terminal, who has logged on, at what time, the process
ID of the user's login shell, etc., etc., but also stores information
about the run level of the system, the time of the last system reboot,
and possibly more.
</p>
<p>The user accounting database typically lives in &lsquo;<tt>/etc/utmp</tt>&rsquo;,
&lsquo;<tt>/var/adm/utmp</tt>&rsquo; or &lsquo;<tt>/var/run/utmp</tt>&rsquo;.  However, these files
should <strong>never</strong> be accessed directly.  For reading information
from and writing information to the user accounting database, the
functions described in this section should be used.
</p>

<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top"><a href="#SEC621">29.12.1 Manipulating the User Accounting Database</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">   Scanning and modifying the user
                                 accounting database.
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC622">29.12.2 XPG User Accounting Database Functions</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">               A standardized way for doing the same thing.
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC623">29.12.3 Logging In and Out</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">          Functions from BSD that modify the user
                                 accounting database.
</td></tr>
</table>

<hr size="6">
<a name="Manipulating-the-Database"></a>
<a name="SEC621"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC620" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC622" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC608" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC620" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="libc_30.html#SEC638" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="libc.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="libc_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="libc_42.html#SEC712" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="libc_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h3 class="subsection"> 29.12.1 Manipulating the User Accounting Database </h3>

<p>These functions and the corresponding data structures are declared in
the header file &lsquo;<tt>utmp.h</tt>&rsquo;.
<a name="IDX2809"></a>
</p>
<dl>
<dt><u>Data Type:</u> <b>struct exit_status</b>
<a name="IDX2810"></a>
</dt>
<dd><p>The <code>exit_status</code> data structure is used to hold information about
the exit status of processes marked as <code>DEAD_PROCESS</code> in the user
accounting database.
</p>
<dl compact="compact">
<dt> <code>short int e_termination</code></dt>
<dd><p>The exit status of the process.
</p>
</dd>
<dt> <code>short int e_exit</code></dt>
<dd><p>The exit status of the process.
</p></dd>
</dl>
</dd></dl>

<dl>
<dt><u>Data Type:</u> <b>struct utmp</b>
<a name="IDX2811"></a>
</dt>
<dd><p>The <code>utmp</code> data structure is used to hold information about entries
in the user accounting database.  On the GNU system it has the following
members:
</p>
<dl compact="compact">
<dt> <code>short int ut_type</code></dt>
<dd><p>Specifies the type of login; one of <code>EMPTY</code>, <code>RUN_LVL</code>,
<code>BOOT_TIME</code>, <code>OLD_TIME</code>, <code>NEW_TIME</code>, <code>INIT_PROCESS</code>,
<code>LOGIN_PROCESS</code>, <code>USER_PROCESS</code>, <code>DEAD_PROCESS</code> or
<code>ACCOUNTING</code>.
</p>
</dd>
<dt> <code>pid_t ut_pid</code></dt>
<dd><p>The process ID number of the login process.
</p>
</dd>
<dt> <code>char ut_line[]</code></dt>
<dd><p>The device name of the tty (without &lsquo;<tt>/dev/</tt>&rsquo;).
</p>
</dd>
<dt> <code>char ut_id[]</code></dt>
<dd><p>The inittab ID of the process.
</p>
</dd>
<dt> <code>char ut_user[]</code></dt>
<dd><p>The user's login name.
</p>
</dd>
<dt> <code>char ut_host[]</code></dt>
<dd><p>The name of the host from which the user logged in.
</p>
</dd>
<dt> <code>struct exit_status ut_exit</code></dt>
<dd><p>The exit status of a process marked as <code>DEAD_PROCESS</code>.
</p>
</dd>
<dt> <code>long ut_session</code></dt>
<dd><p>The Session ID, used for windowing.
</p>
</dd>
<dt> <code>struct timeval ut_tv</code></dt>
<dd><p>Time the entry was made.  For entries of type <code>OLD_TIME</code> this is
the time when the system clock changed, and for entries of type
<code>NEW_TIME</code> this is the time the system clock was set to.
</p>
</dd>
<dt> <code>int32_t ut_addr_v6[4]</code></dt>
<dd><p>The Internet address of a remote host.
</p></dd>
</dl>
</dd></dl>

<p>The <code>ut_type</code>, <code>ut_pid</code>, <code>ut_id</code>, <code>ut_tv</code>, and
<code>ut_host</code> fields are not available on all systems.  Portable
applications therefore should be prepared for these situations.  To help
doing this the &lsquo;<tt>utmp.h</tt>&rsquo; header provides macros
<code>_HAVE_UT_TYPE</code>, <code>_HAVE_UT_PID</code>, <code>_HAVE_UT_ID</code>,
<code>_HAVE_UT_TV</code>, and <code>_HAVE_UT_HOST</code> if the respective field is
available.  The programmer can handle the situations by using
<code>#ifdef</code> in the program code.
</p>
<p>The following macros are defined for use as values for the
<code>ut_type</code> member of the <code>utmp</code> structure.  The values are
integer constants.
</p>
<dl compact="compact">
<dd><a name="IDX2812"></a>
</dd>
<dt> <code>EMPTY</code></dt>
<dd><p>This macro is used to indicate that the entry contains no valid user
accounting information.
</p>
<a name="IDX2813"></a>
</dd>
<dt> <code>RUN_LVL</code></dt>
<dd><p>This macro is used to identify the systems runlevel.
</p>
<a name="IDX2814"></a>
</dd>
<dt> <code>BOOT_TIME</code></dt>
<dd><p>This macro is used to identify the time of system boot.
</p>
<a name="IDX2815"></a>
</dd>
<dt> <code>OLD_TIME</code></dt>
<dd><p>This macro is used to identify the time when the system clock changed.
</p>
<a name="IDX2816"></a>
</dd>
<dt> <code>NEW_TIME</code></dt>
<dd><p>This macro is used to identify the time after the system changed.
</p>
<a name="IDX2817"></a>
</dd>
<dt> <code>INIT_PROCESS</code></dt>
<dd><p>This macro is used to identify a process spawned by the init process.
</p>
<a name="IDX2818"></a>
</dd>
<dt> <code>LOGIN_PROCESS</code></dt>
<dd><p>This macro is used to identify the session leader of a logged in user.
</p>
<a name="IDX2819"></a>
</dd>
<dt> <code>USER_PROCESS</code></dt>
<dd><p>This macro is used to identify a user process.
</p>
<a name="IDX2820"></a>
</dd>
<dt> <code>DEAD_PROCESS</code></dt>
<dd><p>This macro is used to identify a terminated process.
</p>
<a name="IDX2821"></a>
</dd>
<dt> <code>ACCOUNTING</code></dt>
<dd><p>???
</p></dd>
</dl>

<p>The size of the <code>ut_line</code>, <code>ut_id</code>, <code>ut_user</code> and
<code>ut_host</code> arrays can be found using the <code>sizeof</code> operator.
</p>
<p>Many older systems have, instead of an <code>ut_tv</code> member, an
<code>ut_time</code> member, usually of type <code>time_t</code>, for representing
the time associated with the entry.  Therefore, for backwards
compatibility only, &lsquo;<tt>utmp.h</tt>&rsquo; defines <code>ut_time</code> as an alias for
<code>ut_tv.tv_sec</code>.
</p>
<dl>
<dt><u>Function:</u> void <b>setutent</b><i> (void)</i>
<a name="IDX2822"></a>
</dt>
<dd><p>This function opens the user accounting database to begin scanning it.
You can then call <code>getutent</code>, <code>getutid</code> or <code>getutline</code> to
read entries and <code>pututline</code> to write entries.
</p>
<p>If the database is already open, it resets the input to the beginning of
the database.
</p></dd></dl>

<dl>
<dt><u>Function:</u> struct utmp * <b>getutent</b><i> (void)</i>
<a name="IDX2823"></a>
</dt>
<dd><p>The <code>getutent</code> function reads the next entry from the user
accounting database.  It returns a pointer to the entry, which is
statically allocated and may be overwritten by subsequent calls to
<code>getutent</code>.  You must copy the contents of the structure if you
wish to save the information or you can use the <code>getutent_r</code>
function which stores the data in a user-provided buffer.
</p>
<p>A null pointer is returned in case no further entry is available.
</p></dd></dl>

<dl>
<dt><u>Function:</u> void <b>endutent</b><i> (void)</i>
<a name="IDX2824"></a>
</dt>
<dd><p>This function closes the user accounting database.
</p></dd></dl>

<dl>
<dt><u>Function:</u> struct utmp * <b>getutid</b><i> (const struct utmp *<var>id</var>)</i>
<a name="IDX2825"></a>
</dt>
<dd><p>This function searches forward from the current point in the database
for an entry that matches <var>id</var>.  If the <code>ut_type</code> member of the
<var>id</var> structure is one of <code>RUN_LVL</code>, <code>BOOT_TIME</code>,
<code>OLD_TIME</code> or <code>NEW_TIME</code> the entries match if the
<code>ut_type</code> members are identical.  If the <code>ut_type</code> member of
the <var>id</var> structure is <code>INIT_PROCESS</code>, <code>LOGIN_PROCESS</code>,
<code>USER_PROCESS</code> or <code>DEAD_PROCESS</code>, the entries match if the
<code>ut_type</code> member of the entry read from the database is one of
these four, and the <code>ut_id</code> members match.  However if the
<code>ut_id</code> member of either the <var>id</var> structure or the entry read
from the database is empty it checks if the <code>ut_line</code> members match
instead.  If a matching entry is found, <code>getutid</code> returns a pointer
to the entry, which is statically allocated, and may be overwritten by a
subsequent call to <code>getutent</code>, <code>getutid</code> or <code>getutline</code>.
You must copy the contents of the structure if you wish to save the
information.
</p>
<p>A null pointer is returned in case the end of the database is reached
without a match.
</p>
<p>The <code>getutid</code> function may cache the last read entry.  Therefore,
if you are using <code>getutid</code> to search for multiple occurrences, it
is necessary to zero out the static data after each call.  Otherwise
<code>getutid</code> could just return a pointer to the same entry over and
over again.
</p></dd></dl>

<dl>
<dt><u>Function:</u> struct utmp * <b>getutline</b><i> (const struct utmp *<var>line</var>)</i>
<a name="IDX2826"></a>
</dt>
<dd><p>This function searches forward from the current point in the database
until it finds an entry whose <code>ut_type</code> value is
<code>LOGIN_PROCESS</code> or <code>USER_PROCESS</code>, and whose <code>ut_line</code>
member matches the <code>ut_line</code> member of the <var>line</var> structure.
If it finds such an entry, it returns a pointer to the entry which is
statically allocated, and may be overwritten by a subsequent call to
<code>getutent</code>, <code>getutid</code> or <code>getutline</code>.  You must copy the
contents of the structure if you wish to save the information.
</p>
<p>A null pointer is returned in case the end of the database is reached
without a match.
</p>
<p>The <code>getutline</code> function may cache the last read entry.  Therefore
if you are using <code>getutline</code> to search for multiple occurrences, it
is necessary to zero out the static data after each call.  Otherwise
<code>getutline</code> could just return a pointer to the same entry over and
over again.
</p></dd></dl>

<dl>
<dt><u>Function:</u> struct utmp * <b>pututline</b><i> (const struct utmp *<var>utmp</var>)</i>
<a name="IDX2827"></a>
</dt>
<dd><p>The <code>pututline</code> function inserts the entry <code>*<var>utmp</var></code> at
the appropriate place in the user accounting database.  If it finds that
it is not already at the correct place in the database, it uses
<code>getutid</code> to search for the position to insert the entry, however
this will not modify the static structure returned by <code>getutent</code>,
<code>getutid</code> and <code>getutline</code>.  If this search fails, the entry
is appended to the database.
</p>
<p>The <code>pututline</code> function returns a pointer to a copy of the entry
inserted in the user accounting database, or a null pointer if the entry
could not be added.  The following <code>errno</code> error conditions are
defined for this function:
</p>
<dl compact="compact">
<dt> <code>EPERM</code></dt>
<dd><p>The process does not have the appropriate privileges; you cannot modify
the user accounting database.
</p></dd>
</dl>
</dd></dl>

<p>All the <code>get*</code> functions mentioned before store the information
they return in a static buffer.  This can be a problem in multi-threaded
programs since the data returned for the request is overwritten by the
return value data in another thread.  Therefore the GNU C Library
provides as extensions three more functions which return the data in a
user-provided buffer.
</p>
<dl>
<dt><u>Function:</u> int <b>getutent_r</b><i> (struct utmp *<var>buffer</var>, struct utmp **<var>result</var>)</i>
<a name="IDX2828"></a>
</dt>
<dd><p>The <code>getutent_r</code> is equivalent to the <code>getutent</code> function.  It
returns the next entry from the database.  But instead of storing the
information in a static buffer it stores it in the buffer pointed to by
the parameter <var>buffer</var>.
</p>
<p>If the call was successful, the function returns <code>0</code> and the
pointer variable pointed to by the parameter <var>result</var> contains a
pointer to the buffer which contains the result (this is most probably
the same value as <var>buffer</var>).  If something went wrong during the
execution of <code>getutent_r</code> the function returns <code>-1</code>.
</p>
<p>This function is a GNU extension.
</p></dd></dl>

<dl>
<dt><u>Function:</u> int <b>getutid_r</b><i> (const struct utmp *<var>id</var>, struct utmp *<var>buffer</var>, struct utmp **<var>result</var>)</i>
<a name="IDX2829"></a>
</dt>
<dd><p>This function retrieves just like <code>getutid</code> the next entry matching
the information stored in <var>id</var>.  But the result is stored in the
buffer pointed to by the parameter <var>buffer</var>.
</p>
<p>If successful the function returns <code>0</code> and the pointer variable
pointed to by the parameter <var>result</var> contains a pointer to the
buffer with the result (probably the same as <var>result</var>.  If not
successful the function return <code>-1</code>.
</p>
<p>This function is a GNU extension.
</p></dd></dl>

<dl>
<dt><u>Function:</u> int <b>getutline_r</b><i> (const struct utmp *<var>line</var>, struct utmp *<var>buffer</var>, struct utmp **<var>result</var>)</i>
<a name="IDX2830"></a>
</dt>
<dd><p>This function retrieves just like <code>getutline</code> the next entry
matching the information stored in <var>line</var>.  But the result is stored
in the buffer pointed to by the parameter <var>buffer</var>.
</p>
<p>If successful the function returns <code>0</code> and the pointer variable
pointed to by the parameter <var>result</var> contains a pointer to the
buffer with the result (probably the same as <var>result</var>.  If not
successful the function return <code>-1</code>.
</p>
<p>This function is a GNU extension.
</p></dd></dl>


<p>In addition to the user accounting database, most systems keep a number
of similar databases.  For example most systems keep a log file with all
previous logins (usually in &lsquo;<tt>/etc/wtmp</tt>&rsquo; or &lsquo;<tt>/var/log/wtmp</tt>&rsquo;).
</p>
<p>For specifying which database to examine, the following function should
be used.
</p>
<dl>
<dt><u>Function:</u> int <b>utmpname</b><i> (const char *<var>file</var>)</i>
<a name="IDX2831"></a>
</dt>
<dd><p>The <code>utmpname</code> function changes the name of the database to be
examined to <var>file</var>, and closes any previously opened database.  By
default <code>getutent</code>, <code>getutid</code>, <code>getutline</code> and
<code>pututline</code> read from and write to the user accounting database.
</p>
<p>The following macros are defined for use as the <var>file</var> argument:
</p>
<dl>
<dt><u>Macro:</u> char * <b>_PATH_UTMP</b>
<a name="IDX2832"></a>
</dt>
<dd><p>This macro is used to specify the user accounting database.
</p></dd></dl>

<dl>
<dt><u>Macro:</u> char * <b>_PATH_WTMP</b>
<a name="IDX2833"></a>
</dt>
<dd><p>This macro is used to specify the user accounting log file.
</p></dd></dl>

<p>The <code>utmpname</code> function returns a value of <code>0</code> if the new name
was successfully stored, and a value of <code>-1</code> to indicate an error.
Note that <code>utmpname</code> does not try to open the database, and that
therefore the return value does not say anything about whether the
database can be successfully opened.
</p></dd></dl>

<p>Specially for maintaining log-like databases the GNU C Library provides
the following function:
</p>
<dl>
<dt><u>Function:</u> void <b>updwtmp</b><i> (const char *<var>wtmp_file</var>, const struct utmp *<var>utmp</var>)</i>
<a name="IDX2834"></a>
</dt>
<dd><p>The <code>updwtmp</code> function appends the entry *<var>utmp</var> to the
database specified by <var>wtmp_file</var>.  For possible values for the
<var>wtmp_file</var> argument see the <code>utmpname</code> function.
</p></dd></dl>

<p><strong>Portability Note:</strong> Although many operating systems provide a
subset of these functions, they are not standardized.  There are often
subtle differences in the return types, and there are considerable
differences between the various definitions of <code>struct utmp</code>.  When
programming for the GNU system, it is probably best to stick
with the functions described in this section.  If however, you want your
program to be portable, consider using the XPG functions described in
<a href="#SEC622">XPG User Accounting Database Functions</a>, or take a look at the BSD compatible functions in
<a href="#SEC623">Logging In and Out</a>.
</p>

<hr size="6">
<a name="XPG-Functions"></a>
<a name="SEC622"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC621" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC623" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC608" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC620" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="libc_30.html#SEC638" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="libc.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="libc_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="libc_42.html#SEC712" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="libc_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h3 class="subsection"> 29.12.2 XPG User Accounting Database Functions </h3>

<p>These functions, described in the X/Open Portability Guide, are declared
in the header file &lsquo;<tt>utmpx.h</tt>&rsquo;.
<a name="IDX2835"></a>
</p>
<dl>
<dt><u>Data Type:</u> <b>struct utmpx</b>
<a name="IDX2836"></a>
</dt>
<dd><p>The <code>utmpx</code> data structure contains at least the following members:
</p>
<dl compact="compact">
<dt> <code>short int ut_type</code></dt>
<dd><p>Specifies the type of login; one of <code>EMPTY</code>, <code>RUN_LVL</code>,
<code>BOOT_TIME</code>, <code>OLD_TIME</code>, <code>NEW_TIME</code>, <code>INIT_PROCESS</code>,
<code>LOGIN_PROCESS</code>, <code>USER_PROCESS</code> or <code>DEAD_PROCESS</code>.
</p>
</dd>
<dt> <code>pid_t ut_pid</code></dt>
<dd><p>The process ID number of the login process.
</p>
</dd>
<dt> <code>char ut_line[]</code></dt>
<dd><p>The device name of the tty (without &lsquo;<tt>/dev/</tt>&rsquo;).
</p>
</dd>
<dt> <code>char ut_id[]</code></dt>
<dd><p>The inittab ID of the process.
</p>
</dd>
<dt> <code>char ut_user[]</code></dt>
<dd><p>The user's login name.
</p>
</dd>
<dt> <code>struct timeval ut_tv</code></dt>
<dd><p>Time the entry was made.  For entries of type <code>OLD_TIME</code> this is
the time when the system clock changed, and for entries of type
<code>NEW_TIME</code> this is the time the system clock was set to.
</p></dd>
</dl>
<p>On the GNU system, <code>struct utmpx</code> is identical to <code>struct
utmp</code> except for the fact that including &lsquo;<tt>utmpx.h</tt>&rsquo; does not make
visible the declaration of <code>struct exit_status</code>.
</p></dd></dl>

<p>The following macros are defined for use as values for the
<code>ut_type</code> member of the <code>utmpx</code> structure.  The values are
integer constants and are, on the GNU system, identical to the
definitions in &lsquo;<tt>utmp.h</tt>&rsquo;.
</p>
<dl compact="compact">
<dd><a name="IDX2837"></a>
</dd>
<dt> <code>EMPTY</code></dt>
<dd><p>This macro is used to indicate that the entry contains no valid user
accounting information.
</p>
<a name="IDX2838"></a>
</dd>
<dt> <code>RUN_LVL</code></dt>
<dd><p>This macro is used to identify the systems runlevel.
</p>
<a name="IDX2839"></a>
</dd>
<dt> <code>BOOT_TIME</code></dt>
<dd><p>This macro is used to identify the time of system boot.
</p>
<a name="IDX2840"></a>
</dd>
<dt> <code>OLD_TIME</code></dt>
<dd><p>This macro is used to identify the time when the system clock changed.
</p>
<a name="IDX2841"></a>
</dd>
<dt> <code>NEW_TIME</code></dt>
<dd><p>This macro is used to identify the time after the system changed.
</p>
<a name="IDX2842"></a>
</dd>
<dt> <code>INIT_PROCESS</code></dt>
<dd><p>This macro is used to identify a process spawned by the init process.
</p>
<a name="IDX2843"></a>
</dd>
<dt> <code>LOGIN_PROCESS</code></dt>
<dd><p>This macro is used to identify the session leader of a logged in user.
</p>
<a name="IDX2844"></a>
</dd>
<dt> <code>USER_PROCESS</code></dt>
<dd><p>This macro is used to identify a user process.
</p>
<a name="IDX2845"></a>
</dd>
<dt> <code>DEAD_PROCESS</code></dt>
<dd><p>This macro is used to identify a terminated process.
</p></dd>
</dl>

<p>The size of the <code>ut_line</code>, <code>ut_id</code> and <code>ut_user</code> arrays
can be found using the <code>sizeof</code> operator.
</p>
<dl>
<dt><u>Function:</u> void <b>setutxent</b><i> (void)</i>
<a name="IDX2846"></a>
</dt>
<dd><p>This function is similar to <code>setutent</code>.  On the GNU system it is
simply an alias for <code>setutent</code>.
</p></dd></dl>

<dl>
<dt><u>Function:</u> struct utmpx * <b>getutxent</b><i> (void)</i>
<a name="IDX2847"></a>
</dt>
<dd><p>The <code>getutxent</code> function is similar to <code>getutent</code>, but returns
a pointer to a <code>struct utmpx</code> instead of <code>struct utmp</code>.  On
the GNU system it simply is an alias for <code>getutent</code>.
</p></dd></dl>

<dl>
<dt><u>Function:</u> void <b>endutxent</b><i> (void)</i>
<a name="IDX2848"></a>
</dt>
<dd><p>This function is similar to <code>endutent</code>.  On the GNU system it is
simply an alias for <code>endutent</code>.
</p></dd></dl>

<dl>
<dt><u>Function:</u> struct utmpx * <b>getutxid</b><i> (const struct utmpx *<var>id</var>)</i>
<a name="IDX2849"></a>
</dt>
<dd><p>This function is similar to <code>getutid</code>, but uses <code>struct utmpx</code>
instead of <code>struct utmp</code>.  On the GNU system it is simply an alias
for <code>getutid</code>.
</p></dd></dl>

<dl>
<dt><u>Function:</u> struct utmpx * <b>getutxline</b><i> (const struct utmpx *<var>line</var>)</i>
<a name="IDX2850"></a>
</dt>
<dd><p>This function is similar to <code>getutid</code>, but uses <code>struct utmpx</code>
instead of <code>struct utmp</code>.  On the GNU system it is simply an alias
for <code>getutline</code>.
</p></dd></dl>

<dl>
<dt><u>Function:</u> struct utmpx * <b>pututxline</b><i> (const struct utmpx *<var>utmp</var>)</i>
<a name="IDX2851"></a>
</dt>
<dd><p>The <code>pututxline</code> function is functionally identical to
<code>pututline</code>, but uses <code>struct utmpx</code> instead of <code>struct
utmp</code>.  On the GNU system, <code>pututxline</code> is simply an alias for
<code>pututline</code>.
</p></dd></dl>

<dl>
<dt><u>Function:</u> int <b>utmpxname</b><i> (const char *<var>file</var>)</i>
<a name="IDX2852"></a>
</dt>
<dd><p>The <code>utmpxname</code> function is functionally identical to
<code>utmpname</code>.  On the GNU system, <code>utmpxname</code> is simply an
alias for <code>utmpname</code>.
</p></dd></dl>

<p>You can translate between a traditional <code>struct utmp</code> and an XPG
<code>struct utmpx</code> with the following functions.  On the GNU system,
these functions are merely copies, since the two structures are
identical.
</p>
<dl>
<dt><u>Function:</u> int <b>getutmp</b><i> (const struct utmpx *utmpx, struct utmp *utmp)</i>
<a name="IDX2853"></a>
</dt>
<dd><p><code>getutmp</code> copies the information, insofar as the structures are
compatible, from <var>utmpx</var> to <var>utmp</var>.
</p></dd></dl>

<dl>
<dt><u>Function:</u> int <b>getutmpx</b><i> (const struct utmp *utmp, struct utmpx *utmpx)</i>
<a name="IDX2854"></a>
</dt>
<dd><p><code>getutmpx</code> copies the information, insofar as the structures are
compatible, from <var>utmp</var> to <var>utmpx</var>.
</p></dd></dl>


<hr size="6">
<a name="Logging-In-and-Out"></a>
<a name="SEC623"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC622" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC624" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC608" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC620" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="libc_30.html#SEC638" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="libc.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="libc_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="libc_42.html#SEC712" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="libc_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h3 class="subsection"> 29.12.3 Logging In and Out </h3>

<p>These functions, derived from BSD, are available in the separate
&lsquo;<tt>libutil</tt>&rsquo; library, and declared in &lsquo;<tt>utmp.h</tt>&rsquo;.
<a name="IDX2855"></a>
</p>
<p>Note that the <code>ut_user</code> member of <code>struct utmp</code> is called
<code>ut_name</code> in BSD.  Therefore, <code>ut_name</code> is defined as an alias
for <code>ut_user</code> in &lsquo;<tt>utmp.h</tt>&rsquo;.
</p>
<dl>
<dt><u>Function:</u> int <b>login_tty</b><i> (int <var>filedes</var>)</i>
<a name="IDX2856"></a>
</dt>
<dd><p>This function makes <var>filedes</var> the controlling terminal of the
current process, redirects standard input, standard output and
standard error output to this terminal, and closes <var>filedes</var>.
</p>
<p>This function returns <code>0</code> on successful completion, and <code>-1</code>
on error.
</p></dd></dl>

<dl>
<dt><u>Function:</u> void <b>login</b><i> (const struct utmp *<var>entry</var>)</i>
<a name="IDX2857"></a>
</dt>
<dd><p>The <code>login</code> functions inserts an entry into the user accounting
database.  The <code>ut_line</code> member is set to the name of the terminal
on standard input.  If standard input is not a terminal <code>login</code>
uses standard output or standard error output to determine the name of
the terminal.  If <code>struct utmp</code> has a <code>ut_type</code> member,
<code>login</code> sets it to <code>USER_PROCESS</code>, and if there is an
<code>ut_pid</code> member, it will be set to the process ID of the current
process.  The remaining entries are copied from <var>entry</var>.
</p>
<p>A copy of the entry is written to the user accounting log file.
</p></dd></dl>

<dl>
<dt><u>Function:</u> int <b>logout</b><i> (const char *<var>ut_line</var>)</i>
<a name="IDX2858"></a>
</dt>
<dd><p>This function modifies the user accounting database to indicate that the
user on <var>ut_line</var> has logged out.
</p>
<p>The <code>logout</code> function returns <code>1</code> if the entry was successfully
written to the database, or <code>0</code> on error.
</p></dd></dl>

<dl>
<dt><u>Function:</u> void <b>logwtmp</b><i> (const char *<var>ut_line</var>, const char *<var>ut_name</var>, const char *<var>ut_host</var>)</i>
<a name="IDX2859"></a>
</dt>
<dd><p>The <code>logwtmp</code> function appends an entry to the user accounting log
file, for the current time and the information provided in the
<var>ut_line</var>, <var>ut_name</var> and <var>ut_host</var> arguments.
</p></dd></dl>

<p><strong>Portability Note:</strong> The BSD <code>struct utmp</code> only has the
<code>ut_line</code>, <code>ut_name</code>, <code>ut_host</code> and <code>ut_time</code>
members.  Older systems do not even have the <code>ut_host</code> member.
</p>

<hr size="6">
<a name="User-Database"></a>
<a name="SEC624"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC623" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC625" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC608" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC608" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="libc_30.html#SEC638" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="libc.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="libc_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="libc_42.html#SEC712" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="libc_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="section"> 29.13 User Database </h2>

<p>This section describes how to search and scan the database of registered
users.  The database itself is kept in the file &lsquo;<tt>/etc/passwd</tt>&rsquo; on
most systems, but on some systems a special network server gives access
to it.
</p>
<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top"><a href="#SEC625">29.13.1 The Data Structure that Describes a User</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">         What each user record contains.
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC626">29.13.2 Looking Up One User</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                 How to look for a particular user.
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC627">29.13.3 Scanning the List of All Users</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">          Scanning the list of all users, one by one.
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC628">29.13.4 Writing a User Entry</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">        How a program can rewrite a user's record.
</td></tr>
</table>

<hr size="6">
<a name="User-Data-Structure"></a>
<a name="SEC625"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC624" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC626" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC608" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC624" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="libc_30.html#SEC638" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="libc.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="libc_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="libc_42.html#SEC712" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="libc_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h3 class="subsection"> 29.13.1 The Data Structure that Describes a User </h3>

<p>The functions and data structures for accessing the system user database
are declared in the header file &lsquo;<tt>pwd.h</tt>&rsquo;.
<a name="IDX2860"></a>
</p>
<dl>
<dt><u>Data Type:</u> <b>struct passwd</b>
<a name="IDX2861"></a>
</dt>
<dd><p>The <code>passwd</code> data structure is used to hold information about
entries in the system user data base.  It has at least the following members:
</p>
<dl compact="compact">
<dt> <code>char *pw_name</code></dt>
<dd><p>The user's login name.
</p>
</dd>
<dt> <code>char *pw_passwd.</code></dt>
<dd><p>The encrypted password string.
</p>
</dd>
<dt> <code>uid_t pw_uid</code></dt>
<dd><p>The user ID number.
</p>
</dd>
<dt> <code>gid_t pw_gid</code></dt>
<dd><p>The user's default group ID number.
</p>
</dd>
<dt> <code>char *pw_gecos</code></dt>
<dd><p>A string typically containing the user's real name, and possibly other
information such as a phone number.
</p>
</dd>
<dt> <code>char *pw_dir</code></dt>
<dd><p>The user's home directory, or initial working directory.  This might be
a null pointer, in which case the interpretation is system-dependent.
</p>
</dd>
<dt> <code>char *pw_shell</code></dt>
<dd><p>The user's default shell, or the initial program run when the user logs in.
This might be a null pointer, indicating that the system default should
be used.
</p></dd>
</dl>
</dd></dl>

<hr size="6">
<a name="Lookup-User"></a>
<a name="SEC626"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC625" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC627" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC608" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC624" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="libc_30.html#SEC638" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="libc.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="libc_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="libc_42.html#SEC712" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="libc_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h3 class="subsection"> 29.13.2 Looking Up One User </h3>

<p>You can search the system user database for information about a
specific user using <code>getpwuid</code> or <code>getpwnam</code>.  These
functions are declared in &lsquo;<tt>pwd.h</tt>&rsquo;.
</p>
<dl>
<dt><u>Function:</u> struct passwd * <b>getpwuid</b><i> (uid_t <var>uid</var>)</i>
<a name="IDX2862"></a>
</dt>
<dd><p>This function returns a pointer to a statically-allocated structure
containing information about the user whose user ID is <var>uid</var>.  This
structure may be overwritten on subsequent calls to <code>getpwuid</code>.
</p>
<p>A null pointer value indicates there is no user in the data base with
user ID <var>uid</var>.
</p></dd></dl>

<dl>
<dt><u>Function:</u> int <b>getpwuid_r</b><i> (uid_t <var>uid</var>, struct passwd *<var>result_buf</var>, char *<var>buffer</var>, size_t <var>buflen</var>, struct passwd **<var>result</var>)</i>
<a name="IDX2863"></a>
</dt>
<dd><p>This function is similar to <code>getpwuid</code> in that it returns
information about the user whose user ID is <var>uid</var>.  However, it
fills the user supplied structure pointed to by <var>result_buf</var> with
the information instead of using a static buffer.  The first
<var>buflen</var> bytes of the additional buffer pointed to by <var>buffer</var>
are used to contain additional information, normally strings which are
pointed to by the elements of the result structure.
</p>
<p>If a user with ID <var>uid</var> is found, the pointer returned in
<var>result</var> points to the record which contains the wanted data (i.e.,
<var>result</var> contains the value <var>result_buf</var>).  If no user is found
or if an error occurred, the pointer returned in <var>result</var> is a null
pointer.  The function returns zero or an error code.  If the buffer
<var>buffer</var> is too small to contain all the needed information, the
error code <code>ERANGE</code> is returned and <var>errno</var> is set to
<code>ERANGE</code>.
</p></dd></dl>


<dl>
<dt><u>Function:</u> struct passwd * <b>getpwnam</b><i> (const char *<var>name</var>)</i>
<a name="IDX2864"></a>
</dt>
<dd><p>This function returns a pointer to a statically-allocated structure
containing information about the user whose user name is <var>name</var>.
This structure may be overwritten on subsequent calls to
<code>getpwnam</code>.
</p>
<p>A null pointer return indicates there is no user named <var>name</var>.
</p></dd></dl>

<dl>
<dt><u>Function:</u> int <b>getpwnam_r</b><i> (const char *<var>name</var>, struct passwd *<var>result_buf</var>, char *<var>buffer</var>, size_t <var>buflen</var>, struct passwd **<var>result</var>)</i>
<a name="IDX2865"></a>
</dt>
<dd><p>This function is similar to <code>getpwnam</code> in that is returns
information about the user whose user name is <var>name</var>.  However, like
<code>getpwuid_r</code>, it fills the user supplied buffers in
<var>result_buf</var> and <var>buffer</var> with the information instead of using
a static buffer.
</p>
<p>The return values are the same as for <code>getpwuid_r</code>.
</p></dd></dl>


<hr size="6">
<a name="Scanning-All-Users"></a>
<a name="SEC627"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC626" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC628" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC608" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC624" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="libc_30.html#SEC638" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="libc.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="libc_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="libc_42.html#SEC712" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="libc_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h3 class="subsection"> 29.13.3 Scanning the List of All Users </h3>

<p>This section explains how a program can read the list of all users in
the system, one user at a time.  The functions described here are
declared in &lsquo;<tt>pwd.h</tt>&rsquo;.
</p>
<p>You can use the <code>fgetpwent</code> function to read user entries from a
particular file.
</p>
<dl>
<dt><u>Function:</u> struct passwd * <b>fgetpwent</b><i> (FILE *<var>stream</var>)</i>
<a name="IDX2866"></a>
</dt>
<dd><p>This function reads the next user entry from <var>stream</var> and returns a
pointer to the entry.  The structure is statically allocated and is
rewritten on subsequent calls to <code>fgetpwent</code>.  You must copy the
contents of the structure if you wish to save the information.
</p>
<p>The stream must correspond to a file in the same format as the standard
password database file.
</p></dd></dl>

<dl>
<dt><u>Function:</u> int <b>fgetpwent_r</b><i> (FILE *<var>stream</var>, struct passwd *<var>result_buf</var>, char *<var>buffer</var>, size_t <var>buflen</var>, struct passwd **<var>result</var>)</i>
<a name="IDX2867"></a>
</dt>
<dd><p>This function is similar to <code>fgetpwent</code> in that it reads the next
user entry from <var>stream</var>.  But the result is returned in the
structure pointed to by <var>result_buf</var>.  The
first <var>buflen</var> bytes of the additional buffer pointed to by
<var>buffer</var> are used to contain additional information, normally
strings which are pointed to by the elements of the result structure.
</p>
<p>The stream must correspond to a file in the same format as the standard
password database file.
</p>
<p>If the function returns zero <var>result</var> points to the structure with
the wanted data (normally this is in <var>result_buf</var>).  If errors
occurred the return value is nonzero and <var>result</var> contains a null
pointer.
</p></dd></dl>

<p>The way to scan all the entries in the user database is with
<code>setpwent</code>, <code>getpwent</code>, and <code>endpwent</code>.
</p>
<dl>
<dt><u>Function:</u> void <b>setpwent</b><i> (void)</i>
<a name="IDX2868"></a>
</dt>
<dd><p>This function initializes a stream which <code>getpwent</code> and
<code>getpwent_r</code> use to read the user database.
</p></dd></dl>

<dl>
<dt><u>Function:</u> struct passwd * <b>getpwent</b><i> (void)</i>
<a name="IDX2869"></a>
</dt>
<dd><p>The <code>getpwent</code> function reads the next entry from the stream
initialized by <code>setpwent</code>.  It returns a pointer to the entry.  The
structure is statically allocated and is rewritten on subsequent calls
to <code>getpwent</code>.  You must copy the contents of the structure if you
wish to save the information.
</p>
<p>A null pointer is returned when no more entries are available.
</p></dd></dl>

<dl>
<dt><u>Function:</u> int <b>getpwent_r</b><i> (struct passwd *<var>result_buf</var>, char *<var>buffer</var>, int <var>buflen</var>, struct passwd **<var>result</var>)</i>
<a name="IDX2870"></a>
</dt>
<dd><p>This function is similar to <code>getpwent</code> in that it returns the next
entry from the stream initialized by <code>setpwent</code>.  Like
<code>fgetpwent_r</code>, it uses the user-supplied buffers in
<var>result_buf</var> and <var>buffer</var> to return the information requested.
</p>
<p>The return values are the same as for <code>fgetpwent_r</code>.
</p>
</dd></dl>

<dl>
<dt><u>Function:</u> void <b>endpwent</b><i> (void)</i>
<a name="IDX2871"></a>
</dt>
<dd><p>This function closes the internal stream used by <code>getpwent</code> or
<code>getpwent_r</code>.
</p></dd></dl>

<hr size="6">
<a name="Writing-a-User-Entry"></a>
<a name="SEC628"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC627" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC629" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC608" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC624" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="libc_30.html#SEC638" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="libc.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="libc_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="libc_42.html#SEC712" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="libc_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h3 class="subsection"> 29.13.4 Writing a User Entry </h3>

<dl>
<dt><u>Function:</u> int <b>putpwent</b><i> (const struct passwd *<var>p</var>, FILE *<var>stream</var>)</i>
<a name="IDX2872"></a>
</dt>
<dd><p>This function writes the user entry <code>*<var>p</var></code> to the stream
<var>stream</var>, in the format used for the standard user database
file.  The return value is zero on success and nonzero on failure.
</p>
<p>This function exists for compatibility with SVID.  We recommend that you
avoid using it, because it makes sense only on the assumption that the
<code>struct passwd</code> structure has no members except the standard ones;
on a system which merges the traditional Unix data base with other
extended information about users, adding an entry using this function
would inevitably leave out much of the important information.
</p>
<p>The group and user ID fields are left empty if the group or user name
starts with a - or +.
</p>
<p>The function <code>putpwent</code> is declared in &lsquo;<tt>pwd.h</tt>&rsquo;.
</p></dd></dl>

<hr size="6">
<a name="Group-Database"></a>
<a name="SEC629"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC628" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC630" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC608" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC608" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="libc_30.html#SEC638" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="libc.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="libc_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="libc_42.html#SEC712" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="libc_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="section"> 29.14 Group Database </h2>

<p>This section describes how to search and scan the database of
registered groups.  The database itself is kept in the file
&lsquo;<tt>/etc/group</tt>&rsquo; on most systems, but on some systems a special network
service provides access to it.
</p>
<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top"><a href="#SEC630">29.14.1 The Data Structure for a Group</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">        What each group record contains.
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC631">29.14.2 Looking Up One Group</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                How to look for a particular group.
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC632">29.14.3 Scanning the List of All Groups</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">         Scanning the list of all groups.
</td></tr>
</table>

<hr size="6">
<a name="Group-Data-Structure"></a>
<a name="SEC630"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC629" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC631" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC608" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC629" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="libc_30.html#SEC638" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="libc.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="libc_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="libc_42.html#SEC712" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="libc_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h3 class="subsection"> 29.14.1 The Data Structure for a Group </h3>

<p>The functions and data structures for accessing the system group
database are declared in the header file &lsquo;<tt>grp.h</tt>&rsquo;.
<a name="IDX2873"></a>
</p>
<dl>
<dt><u>Data Type:</u> <b>struct group</b>
<a name="IDX2874"></a>
</dt>
<dd><p>The <code>group</code> structure is used to hold information about an entry in
the system group database.  It has at least the following members:
</p>
<dl compact="compact">
<dt> <code>char *gr_name</code></dt>
<dd><p>The name of the group.
</p>
</dd>
<dt> <code>gid_t gr_gid</code></dt>
<dd><p>The group ID of the group.
</p>
</dd>
<dt> <code>char **gr_mem</code></dt>
<dd><p>A vector of pointers to the names of users in the group.  Each user name
is a null-terminated string, and the vector itself is terminated by a
null pointer.
</p></dd>
</dl>
</dd></dl>

<hr size="6">
<a name="Lookup-Group"></a>
<a name="SEC631"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC630" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC632" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC608" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC629" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="libc_30.html#SEC638" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="libc.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="libc_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="libc_42.html#SEC712" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="libc_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h3 class="subsection"> 29.14.2 Looking Up One Group </h3>

<p>You can search the group database for information about a specific
group using <code>getgrgid</code> or <code>getgrnam</code>.  These functions are
declared in &lsquo;<tt>grp.h</tt>&rsquo;.
</p>
<dl>
<dt><u>Function:</u> struct group * <b>getgrgid</b><i> (gid_t <var>gid</var>)</i>
<a name="IDX2875"></a>
</dt>
<dd><p>This function returns a pointer to a statically-allocated structure
containing information about the group whose group ID is <var>gid</var>.
This structure may be overwritten by subsequent calls to
<code>getgrgid</code>.
</p>
<p>A null pointer indicates there is no group with ID <var>gid</var>.
</p></dd></dl>

<dl>
<dt><u>Function:</u> int <b>getgrgid_r</b><i> (gid_t <var>gid</var>, struct group *<var>result_buf</var>, char *<var>buffer</var>, size_t <var>buflen</var>, struct group **<var>result</var>)</i>
<a name="IDX2876"></a>
</dt>
<dd><p>This function is similar to <code>getgrgid</code> in that it returns
information about the group whose group ID is <var>gid</var>.  However, it
fills the user supplied structure pointed to by <var>result_buf</var> with
the information instead of using a static buffer.  The first
<var>buflen</var> bytes of the additional buffer pointed to by <var>buffer</var>
are used to contain additional information, normally strings which are
pointed to by the elements of the result structure.
</p>
<p>If a group with ID <var>gid</var> is found, the pointer returned in
<var>result</var> points to the record which contains the wanted data (i.e.,
<var>result</var> contains the value <var>result_buf</var>).  If no group is found
or if an error occurred, the pointer returned in <var>result</var> is a null
pointer.  The function returns zero or an error code.  If the buffer
<var>buffer</var> is too small to contain all the needed information, the
error code <code>ERANGE</code> is returned and <var>errno</var> is set to
<code>ERANGE</code>.
</p></dd></dl>

<dl>
<dt><u>Function:</u> struct group * <b>getgrnam</b><i> (const char *<var>name</var>)</i>
<a name="IDX2877"></a>
</dt>
<dd><p>This function returns a pointer to a statically-allocated structure
containing information about the group whose group name is <var>name</var>.
This structure may be overwritten by subsequent calls to
<code>getgrnam</code>.
</p>
<p>A null pointer indicates there is no group named <var>name</var>.
</p></dd></dl>

<dl>
<dt><u>Function:</u> int <b>getgrnam_r</b><i> (const char *<var>name</var>, struct group *<var>result_buf</var>, char *<var>buffer</var>, size_t <var>buflen</var>, struct group **<var>result</var>)</i>
<a name="IDX2878"></a>
</dt>
<dd><p>This function is similar to <code>getgrnam</code> in that is returns
information about the group whose group name is <var>name</var>.  Like
<code>getgrgid_r</code>, it uses the user supplied buffers in
<var>result_buf</var> and <var>buffer</var>, not a static buffer.
</p>
<p>The return values are the same as for <code>getgrgid_r</code>
<code>ERANGE</code>.
</p></dd></dl>

<hr size="6">
<a name="Scanning-All-Groups"></a>
<a name="SEC632"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC631" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC633" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC608" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC629" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="libc_30.html#SEC638" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="libc.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="libc_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="libc_42.html#SEC712" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="libc_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h3 class="subsection"> 29.14.3 Scanning the List of All Groups </h3>

<p>This section explains how a program can read the list of all groups in
the system, one group at a time.  The functions described here are
declared in &lsquo;<tt>grp.h</tt>&rsquo;.
</p>
<p>You can use the <code>fgetgrent</code> function to read group entries from a
particular file.
</p>
<dl>
<dt><u>Function:</u> struct group * <b>fgetgrent</b><i> (FILE *<var>stream</var>)</i>
<a name="IDX2879"></a>
</dt>
<dd><p>The <code>fgetgrent</code> function reads the next entry from <var>stream</var>.
It returns a pointer to the entry.  The structure is statically
allocated and is overwritten on subsequent calls to <code>fgetgrent</code>.  You
must copy the contents of the structure if you wish to save the
information.
</p>
<p>The stream must correspond to a file in the same format as the standard
group database file.
</p></dd></dl>

<dl>
<dt><u>Function:</u> int <b>fgetgrent_r</b><i> (FILE *<var>stream</var>, struct group *<var>result_buf</var>, char *<var>buffer</var>, size_t <var>buflen</var>, struct group **<var>result</var>)</i>
<a name="IDX2880"></a>
</dt>
<dd><p>This function is similar to <code>fgetgrent</code> in that it reads the next
user entry from <var>stream</var>.  But the result is returned in the
structure pointed to by <var>result_buf</var>.  The first <var>buflen</var> bytes
of the additional buffer pointed to by <var>buffer</var> are used to contain
additional information, normally strings which are pointed to by the
elements of the result structure.
</p>
<p>This stream must correspond to a file in the same format as the standard
group database file.
</p>
<p>If the function returns zero <var>result</var> points to the structure with
the wanted data (normally this is in <var>result_buf</var>).  If errors
occurred the return value is non-zero and <var>result</var> contains a null
pointer.
</p></dd></dl>

<p>The way to scan all the entries in the group database is with
<code>setgrent</code>, <code>getgrent</code>, and <code>endgrent</code>.
</p>
<dl>
<dt><u>Function:</u> void <b>setgrent</b><i> (void)</i>
<a name="IDX2881"></a>
</dt>
<dd><p>This function initializes a stream for reading from the group data base.
You use this stream by calling <code>getgrent</code> or <code>getgrent_r</code>.
</p></dd></dl>

<dl>
<dt><u>Function:</u> struct group * <b>getgrent</b><i> (void)</i>
<a name="IDX2882"></a>
</dt>
<dd><p>The <code>getgrent</code> function reads the next entry from the stream
initialized by <code>setgrent</code>.  It returns a pointer to the entry.  The
structure is statically allocated and is overwritten on subsequent calls
to <code>getgrent</code>.  You must copy the contents of the structure if you
wish to save the information.
</p></dd></dl>

<dl>
<dt><u>Function:</u> int <b>getgrent_r</b><i> (struct group *<var>result_buf</var>, char *<var>buffer</var>, size_t <var>buflen</var>, struct group **<var>result</var>)</i>
<a name="IDX2883"></a>
</dt>
<dd><p>This function is similar to <code>getgrent</code> in that it returns the next
entry from the stream initialized by <code>setgrent</code>.  Like
<code>fgetgrent_r</code>, it places the result in user-supplied buffers
pointed to <var>result_buf</var> and <var>buffer</var>.
</p>
<p>If the function returns zero <var>result</var> contains a pointer to the data
(normally equal to <var>result_buf</var>).  If errors occurred the return
value is non-zero and <var>result</var> contains a null pointer.
</p></dd></dl>

<dl>
<dt><u>Function:</u> void <b>endgrent</b><i> (void)</i>
<a name="IDX2884"></a>
</dt>
<dd><p>This function closes the internal stream used by <code>getgrent</code> or
<code>getgrent_r</code>.
</p></dd></dl>

<hr size="6">
<a name="Database-Example"></a>
<a name="SEC633"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC632" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC634" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC608" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC608" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="libc_30.html#SEC638" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="libc.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="libc_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="libc_42.html#SEC712" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="libc_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="section"> 29.15 User and Group Database Example </h2>

<p>Here is an example program showing the use of the system database inquiry
functions.  The program prints some information about the user running
the program.
</p>
<table><tr><td>&nbsp;</td><td><pre class="smallexample">#include &lt;grp.h&gt;
#include &lt;pwd.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;unistd.h&gt;
#include &lt;stdlib.h&gt;

int
main (void)
{
  uid_t me;
  struct passwd *my_passwd;
  struct group *my_group;
  char **members;

  /* <span class="roman">Get information about the user ID.</span> */
  me = getuid ();
  my_passwd = getpwuid (me);
  if (!my_passwd)
    {
      printf (&quot;Couldn't find out about user %d.\n&quot;, (int) me);
      exit (EXIT_FAILURE);
    }

  /* <span class="roman">Print the information.</span> */
  printf (&quot;I am %s.\n&quot;, my_passwd-&gt;pw_gecos);
  printf (&quot;My login name is %s.\n&quot;, my_passwd-&gt;pw_name);
  printf (&quot;My uid is %d.\n&quot;, (int) (my_passwd-&gt;pw_uid));
  printf (&quot;My home directory is %s.\n&quot;, my_passwd-&gt;pw_dir);
  printf (&quot;My default shell is %s.\n&quot;, my_passwd-&gt;pw_shell);

  /* <span class="roman">Get information about the default group ID.</span> */
  my_group = getgrgid (my_passwd-&gt;pw_gid);
  if (!my_group)
    {
      printf (&quot;Couldn't find out about group %d.\n&quot;,
              (int) my_passwd-&gt;pw_gid);
      exit (EXIT_FAILURE);
    }

  /* <span class="roman">Print the information.</span> */
  printf (&quot;My default group is %s (%d).\n&quot;,
          my_group-&gt;gr_name, (int) (my_passwd-&gt;pw_gid));
  printf (&quot;The members of this group are:\n&quot;);
  members = my_group-&gt;gr_mem;
  while (*members)
    {
      printf (&quot;  %s\n&quot;, *(members));
      members++;
    }

  return EXIT_SUCCESS;
}
</pre></td></tr></table>

<p>Here is some output from this program:
</p>
<table><tr><td>&nbsp;</td><td><pre class="smallexample">I am Throckmorton Snurd.
My login name is snurd.
My uid is 31093.
My home directory is /home/fsg/snurd.
My default shell is /bin/sh.
My default group is guest (12).
The members of this group are:
  friedman
  tami
</pre></td></tr></table>

<hr size="6">
<a name="Netgroup-Database"></a>
<a name="SEC634"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC633" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC635" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC608" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC608" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="libc_30.html#SEC638" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="libc.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="libc_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="libc_42.html#SEC712" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="libc_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="section"> 29.16 Netgroup Database </h2>

<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top"><a href="#SEC635">29.16.1 Netgroup Data</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                  Data in the Netgroup database and where
                                   it comes from.
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC636">29.16.2 Looking up one Netgroup</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                How to look for a particular netgroup.
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC637">29.16.3 Testing for Netgroup Membership</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">            How to test for netgroup membership.
</td></tr>
</table>

<hr size="6">
<a name="Netgroup-Data"></a>
<a name="SEC635"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC634" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC636" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC608" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC634" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="libc_30.html#SEC638" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="libc.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="libc_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="libc_42.html#SEC712" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="libc_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h3 class="subsection"> 29.16.1 Netgroup Data </h3>

<p>Sometimes it is useful to group users according to other criteria
(see section <a href="#SEC629">Group Database</a>).  E.g., it is useful to associate a certain
group of users with a certain machine.  On the other hand grouping of
host names is not supported so far.
</p>
<p>In Sun Microsystems SunOS appeared a new kind of database, the netgroup
database.  It allows grouping hosts, users, and domains freely, giving
them individual names.  To be more concrete, a netgroup is a list of triples
consisting of a host name, a user name, and a domain name where any of
the entries can be a wildcard entry matching all inputs.  A last
possibility is that names of other netgroups can also be given in the
list specifying a netgroup.  So one can construct arbitrary hierarchies
without loops.
</p>
<p>Sun's implementation allows netgroups only for the <code>nis</code> or
<code>nisplus</code> service, see section <a href="libc_28.html#SEC599">Services in the NSS configuration File</a>.  The
implementation in the GNU C library has no such restriction.  An entry
in either of the input services must have the following form:
</p>
<table><tr><td>&nbsp;</td><td><pre class="smallexample"><var>groupname</var> ( <var>groupname</var> | <code>(</code><var>hostname</var><code>,</code><var>username</var><code>,</code><code>domainname</code><code>)</code> )+
</pre></td></tr></table>

<p>Any of the fields in the triple can be empty which means anything
matches.  While describing the functions we will see that the opposite
case is useful as well.  I.e., there may be entries which will not
match any input.  For entries like this, a name consisting of the single
character <code>-</code> shall be used.
</p>
<hr size="6">
<a name="Lookup-Netgroup"></a>
<a name="SEC636"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC635" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC637" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC608" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC634" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="libc_30.html#SEC638" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="libc.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="libc_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="libc_42.html#SEC712" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="libc_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h3 class="subsection"> 29.16.2 Looking up one Netgroup </h3>

<p>The lookup functions for netgroups are a bit different to all other
system database handling functions.  Since a single netgroup can contain
many entries a two-step process is needed.  First a single netgroup is
selected and then one can iterate over all entries in this netgroup.
These functions are declared in &lsquo;<tt>netdb.h</tt>&rsquo;.
</p>
<dl>
<dt><u>Function:</u> int <b>setnetgrent</b><i> (const char *<var>netgroup</var>)</i>
<a name="IDX2885"></a>
</dt>
<dd><p>A call to this function initializes the internal state of the library to
allow following calls of the <code>getnetgrent</code> to iterate over all entries
in the netgroup with name <var>netgroup</var>.
</p>
<p>When the call is successful (i.e., when a netgroup with this name exists)
the return value is <code>1</code>.  When the return value is <code>0</code> no
netgroup of this name is known or some other error occurred.
</p></dd></dl>

<p>It is important to remember that there is only one single state for
iterating the netgroups.  Even if the programmer uses the
<code>getnetgrent_r</code> function the result is not really reentrant since
always only one single netgroup at a time can be processed.  If the
program needs to process more than one netgroup simultaneously she
must protect this by using external locking.  This problem was
introduced in the original netgroups implementation in SunOS and since
we must stay compatible it is not possible to change this.
</p>
<p>Some other functions also use the netgroups state.  Currently these are
the <code>innetgr</code> function and parts of the implementation of the
<code>compat</code> service part of the NSS implementation.
</p>
<dl>
<dt><u>Function:</u> int <b>getnetgrent</b><i> (char **<var>hostp</var>, char **<var>userp</var>, char **<var>domainp</var>)</i>
<a name="IDX2886"></a>
</dt>
<dd><p>This function returns the next unprocessed entry of the currently
selected netgroup.  The string pointers, in which addresses are passed in
the arguments <var>hostp</var>, <var>userp</var>, and <var>domainp</var>, will contain
after a successful call pointers to appropriate strings.  If the string
in the next entry is empty the pointer has the value <code>NULL</code>.
The returned string pointers are only valid if none of the netgroup
related functions are called.
</p>
<p>The return value is <code>1</code> if the next entry was successfully read.  A
value of <code>0</code> means no further entries exist or internal errors occurred.
</p></dd></dl>

<dl>
<dt><u>Function:</u> int <b>getnetgrent_r</b><i> (char **<var>hostp</var>, char **<var>userp</var>, char **<var>domainp</var>, char *<var>buffer</var>, int <var>buflen</var>)</i>
<a name="IDX2887"></a>
</dt>
<dd><p>This function is similar to <code>getnetgrent</code> with only one exception:
the strings the three string pointers <var>hostp</var>, <var>userp</var>, and
<var>domainp</var> point to, are placed in the buffer of <var>buflen</var> bytes
starting at <var>buffer</var>.  This means the returned values are valid
even after other netgroup related functions are called.
</p>
<p>The return value is <code>1</code> if the next entry was successfully read and
the buffer contains enough room to place the strings in it.  <code>0</code> is
returned in case no more entries are found, the buffer is too small, or
internal errors occurred.
</p>
<p>This function is a GNU extension.  The original implementation in the
SunOS libc does not provide this function.
</p></dd></dl>

<dl>
<dt><u>Function:</u> void <b>endnetgrent</b><i> (void)</i>
<a name="IDX2888"></a>
</dt>
<dd><p>This function frees all buffers which were allocated to process the last
selected netgroup.  As a result all string pointers returned by calls
to <code>getnetgrent</code> are invalid afterwards.
</p></dd></dl>

<hr size="6">
<a name="Netgroup-Membership"></a>
<a name="SEC637"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC636" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="libc_30.html#SEC638" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC608" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC634" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="libc_30.html#SEC638" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="libc.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="libc_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="libc_42.html#SEC712" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="libc_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h3 class="subsection"> 29.16.3 Testing for Netgroup Membership </h3>

<p>It is often not necessary to scan the whole netgroup since often the
only interesting question is whether a given entry is part of the
selected netgroup.
</p>
<dl>
<dt><u>Function:</u> int <b>innetgr</b><i> (const char *<var>netgroup</var>, const char *<var>host</var>, const char *<var>user</var>, const char *<var>domain</var>)</i>
<a name="IDX2889"></a>
</dt>
<dd><p>This function tests whether the triple specified by the parameters
<var>hostp</var>, <var>userp</var>, and <var>domainp</var> is part of the netgroup
<var>netgroup</var>.  Using this function has the advantage that
</p>
<ol>
<li>
no other netgroup function can use the global netgroup state since
internal locking is used and
</li><li>
the function is implemented more efficiently than successive calls
to the other <code>set</code>/<code>get</code>/<code>endnetgrent</code> functions.
</li></ol>

<p>Any of the pointers <var>hostp</var>, <var>userp</var>, and <var>domainp</var> can be
<code>NULL</code> which means any value is accepted in this position.  This is
also true for the name <code>-</code> which should not match any other string
otherwise.
</p>
<p>The return value is <code>1</code> if an entry matching the given triple is
found in the netgroup.  The return value is <code>0</code> if the netgroup
itself is not found, the netgroup does not contain the triple or
internal errors occurred.
</p></dd></dl>
<hr size="6">
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC608" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="libc_30.html#SEC638" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="libc.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="libc_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="libc_42.html#SEC712" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="libc_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<p>
 <font size="-1">
  This document was generated by <em>root</em> on <em>February, 13 2009</em> using <a href="http://www.nongnu.org/texi2html/"><em>texi2html 1.78</em></a>.
 </font>
 <br>

</p>
</body>
</html>
