2009-04-01  Carlos O'Donell  <carlos@codesourcery.com>

	* sysdeps/hppa/nptl/Makefile: Add compat routines
	when building nptl.

	sysdeps/unix/sysv/linux/hppa/nptl/
	* Versions: New file.
	* forward.c: New file.
	* init.c: New file.
	* old_hppa_pthread_cond_broadcast.c: New file.
	* old_hppa_pthread_cond_destroy.c: New file.
	* old_hppa_pthread_cond_init.c: New file.
	* old_hppa_pthread_cond_signal.c: New file.
	* old_hppa_pthread_cond_timedwait.c: New file.
	* old_hppa_pthread_cond_wait.c: New file.
	* old_hppa_pthread_mutex_destroy.c: New file.
	* old_hppa_pthread_mutex_init.c: New file.
	* old_hppa_pthread_mutex_lock.c: New file.
	* old_hppa_pthread_mutex_timedlock.c: New file.
	* old_hppa_pthread_mutex_trylock.c: New file.
	* old_hppa_pthread_mutex_unlock.c: New file.
	* old_hppa_pthread_rwlock_destroy.c: New file.
	* old_hppa_pthread_rwlock_init.c: New file.
	* old_hppa_pthread_rwlock_rdlock.c: New file.
	* old_hppa_pthread_rwlock_timedrdlock.c: New file.
	* old_hppa_pthread_rwlock_timedwrlock.c: New file.
	* old_hppa_pthread_rwlock_tryrdlock.c: New file.
	* old_hppa_pthread_rwlock_trywrlock.c: New file.
	* old_hppa_pthread_rwlock_unlock.c: New file.
	* old_hppa_pthread_rwlock_wrlock.c: New file.
	* pthread-functions.h: New file.
	* pthreadP.h: New file.
	* pthread_cond_broadcast.c: New file.
	* pthread_cond_destroy.c: New file.
	* pthread_cond_init.c: New file.
	* pthread_cond_signal.c: New file.
	* pthread_cond_timedwait.c: New file.
	* pthread_cond_wait.c: New file.
	* pthread_mutex_cond_lock.c: New file.
	* pthread_mutex_destroy.c: New file.
	* pthread_mutex_init.c: New file.
	* pthread_mutex_lock.c: New file.
	* pthread_mutex_timedlock.c: New file.
	* pthread_mutex_trylock.c: New file.
	* pthread_mutex_unlock.c: New file.
	* pthread_rwlock_destroy.c: New file.
	* pthread_rwlock_init.c: New file.
	* pthread_rwlock_rdlock.c: New file.
	* pthread_rwlock_timedrdlock.c: New file.
	* pthread_rwlock_timedwrlock.c: New file.
	* pthread_rwlock_tryrdlock.c: New file.
	* pthread_rwlock_trywrlock.c: New file.
	* pthread_rwlock_unlock.c: New file.
	* pthread_rwlock_wrlock.c: New file.

Index: sysdeps/hppa/nptl/Makefile
===================================================================
RCS file: /cvs/glibc/ports/sysdeps/hppa/nptl/Makefile,v
retrieving revision 1.2
diff -u -p -r1.2 Makefile
--- a/ports/sysdeps/hppa/nptl/Makefile	23 Feb 2008 01:18:17 -0000	1.2
+++ b/ports/sysdeps/hppa/nptl/Makefile	2 Apr 2009 02:34:02 -0000
@@ -25,3 +25,28 @@ endif
 # this because the default is too small to run with. 
 tst-oddstacklimit-ENV = ; ulimit -s 8193;
 
+ifeq ($(subdir),nptl)
+# Add compat routines for all versioned functions.
+libpthread-routines += \
+	old_hppa_pthread_cond_broadcast \
+	old_hppa_pthread_cond_destroy \
+	old_hppa_pthread_cond_init \
+	old_hppa_pthread_cond_signal \
+	old_hppa_pthread_cond_timedwait \
+	old_hppa_pthread_cond_wait \
+	old_hppa_pthread_mutex_destroy \
+	old_hppa_pthread_mutex_init \
+	old_hppa_pthread_mutex_lock \
+	old_hppa_pthread_mutex_timedlock \
+	old_hppa_pthread_mutex_trylock \
+	old_hppa_pthread_mutex_unlock \
+	old_hppa_pthread_rwlock_destroy \
+	old_hppa_pthread_rwlock_init \
+	old_hppa_pthread_rwlock_rdlock \
+	old_hppa_pthread_rwlock_timedrdlock \
+	old_hppa_pthread_rwlock_timedwrlock \
+	old_hppa_pthread_rwlock_tryrdlock \
+	old_hppa_pthread_rwlock_trywrlock \
+	old_hppa_pthread_rwlock_unlock \
+	old_hppa_pthread_rwlock_wrlock
+endif
Index: sysdeps/unix/sysv/linux/hppa/internaltypes.h
===================================================================
RCS file: sysdeps/unix/sysv/linux/hppa/internaltypes.h
diff -N sysdeps/unix/sysv/linux/hppa/internaltypes.h
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ b/ports/sysdeps/unix/sysv/linux/hppa/internaltypes.h	2 Apr 2009 02:34:03 -0000
@@ -0,0 +1,184 @@
+#include_next <internaltypes.h>
+#ifndef _INTERNAL_TYPES_H_HPPA_ 
+#define _INTERNAL_TYPES_H_HPPA_ 1
+
+/* Compatibility __atomic_lock_t 
+   and _pthread_fastlock.  */
+typedef volatile struct {
+	int lock[4];
+} __attribute__ ((aligned(16))) compat_atomic_lock_t;
+
+struct compat_pthread_fastlock
+{
+  compat_atomic_lock_t compat_spinlock;
+  long int compat_status;
+};
+
+/* The hppa only has one atomic read and modify memory operation,
+   load and clear, so hppa spinlocks must use zero to signify that
+   someone is holding the lock.  The address used for the ldcw
+   semaphore must be 16-byte aligned.  */
+#define __ldcw(a) \
+({ 									\
+  unsigned int __ret;							\
+  __asm__ __volatile__("ldcw 0(%1),%0"					\
+		       : "=r" (__ret) : "r" (a) : "memory");		\
+  __ret;								\
+})
+
+/* Strongly ordered lock reset */
+#define __lock_reset(lock_addr, tmp) \
+({									\
+  __asm__ __volatile__ ("stw,ma %1,0(%0)"				\
+			: : "r" (lock_addr), "r" (tmp) : "memory"); 	\
+})
+
+/* Because malloc only guarantees 8-byte alignment for malloc'd data,
+   and GCC only guarantees 8-byte alignment for stack locals, we can't
+   be assured of 16-byte alignment for atomic lock data even if we
+   specify "__attribute ((aligned(16)))" in the type declaration.  So,
+   we use a struct containing an array of four ints for the atomic lock
+   type and dynamically select the 16-byte aligned int from the array
+   for the semaphore.  */
+#define __PA_LDCW_ALIGNMENT 16
+#define __ldcw_align(a) ({ \
+  volatile unsigned int __ret = (unsigned int) a;			\
+  if ((__ret & ~(__PA_LDCW_ALIGNMENT - 1)) < (unsigned int) a)		\
+    __ret = (__ret & ~(__PA_LDCW_ALIGNMENT - 1)) + __PA_LDCW_ALIGNMENT; \
+  (unsigned int *) __ret;						\
+})
+
+/* If the compat funciton might be called by two or more threads
+   then the compat lock must be taken before modifying the 
+   compat structure. This avoids a race condition in the allocation
+   of the new structure.  */
+#define compat_lock(var) \
+({								\
+  volatile unsigned int *a = __ldcw_align (&var->compat_lock);	\
+  volatile unsigned int tmp;					\
+  /* Atomically lock the initialized lock.  */			\
+  /* printf ("%s:%d\n", __FILE__, __LINE__); */			\
+  while ((tmp = __ldcw(a)) == 0)				\
+    sched_yield();
+
+/* Allocate the new structure.
+   Notes: Must be called with lock held.  */
+#define compat_malloc(var) \
+  /* Allocate the new compat variable.  */			\
+  if (var->compat == NULL)					\
+    {								\
+      var->compat = (__typeof(var->compat)) 			\
+		    calloc(1, sizeof(__typeof(*var->compat)));	\
+      if (var->compat == NULL)					\
+	{							\
+	  __lock_reset(a, tmp = 1);				\
+	  return ENOMEM;					\
+	}							\
+    }								\
+
+/* Allocate the new structure.
+   Notes: Does not unlock any lock on error.  */
+#define compat_malloc_nolock(var) \
+  /* Allocate the new compat variable.  */			\
+  if (var->compat == NULL)					\
+    {								\
+      var->compat = (__typeof(var->compat)) 			\
+		    calloc(1, sizeof(__typeof(*var->compat)));	\
+      if (var->compat == NULL)					\
+	{							\
+	  return ENOMEM;					\
+	}							\
+    }								\
+
+/* Copy initialization data from the compat mutex.  
+   Notes: Must be called with lock held.  */
+#define compat_mutex_copy(var) \
+  /* Copy the mutex kind initializer.  */	\
+  var->compat->__data.__kind = var->__kind;
+
+/* Copy initialization data from the compat rwlock.  
+   Notes: Must be called with lock held.  */
+#define compat_rwlock_copy(var) \
+  /* Copy the rwlock flags initializers.  */	\
+  var->compat->__data.__flags = var->__flags;
+
+/* Release the lock.  */
+#define compat_unlock(var) \
+  __lock_reset(a, tmp = 1);			\
+})
+
+
+/* Was the compat variable initialized?  A read or write of a
+   pointer sized quantity is atomic, therefore we should see
+   either an initalized or uninitialized compat pointer and
+   act accordingly.  This is currently used by the destroy
+   functions to check if any work needs to be done. If a user
+   is in the middle of initialization, and calls destroy, 
+   the destroy function should see a consistent 
+   view of var->compat and do nothing if initialization
+   is not complete.  */
+#define compat_present(var) \
+ (var->compat != NULL)
+
+/* Free the compat variable. Must only be called from 
+   pthread_mutex_destory, pthread_cond_destroy, and
+   pthread_rwlock_destroy. Assumes only one thread is calling the
+   destroy function.  POSIX says that calling destroy twice is
+   undefined, therefore we can safely assume only one thread calls
+   this function.  If two threads call this function then malloc
+   double-free checking should allow users to correct their code.  */
+#define compat_free(var) \
+({			\
+  free (var->compat);	\
+  var->compat = NULL;	\
+})
+
+/* Inintialize the compat lock for use with ldcw. This function
+   must only be called from pthread_mutex_init, pthread_cond_init
+   or pthread_rwlock_init. POSIX says that "Attempting to initialise 
+   an already initialised mutex results in undefined behaviour."
+   therefore we assume only one thread is calling the initialization
+   function at any given point, and therefore initialization need
+   not be guarded by locking the compat lock.  */
+#define compat_init(var) \
+({												\
+  var->compat_lock = ((struct compat_pthread_fastlock) { { {1, 1, 1, 1 } }, 0xDEADBEEF });	\
+})
+
+/* The following are the compat interpretations of the
+   the old pthread structures.  */
+
+typedef struct {
+  struct compat_pthread_fastlock compat_lock;
+  /* Overwrites _pthread_descr __c_waiting.  */
+  pthread_cond_t *compat;
+} pthread_cond_hppa_2_3_2_t;
+
+typedef struct {
+  int pad1;
+  int pad2;
+  /* Overwrites _pthread_descr __m_owner.  */
+  pthread_mutex_t *compat;
+  /* KIND must stay at this position to maintain binary 
+     compatibility with Linuxthreads.  */
+  int __kind;
+  struct compat_pthread_fastlock compat_lock; 
+} pthread_mutex_hppa_2_0_t;
+
+typedef struct {
+  struct compat_pthread_fastlock compat_lock; 
+  /* Overwrites int __rw_readers.  */
+  pthread_rwlock_t *compat;
+  int pad1;
+  int pad2;
+  int pad3;
+  /* FLAGS and PSHARED stay at this position to 
+     maintain binary compatibility with Linuxthreads.  */
+  unsigned char __flags;
+  unsigned char __shared;
+  unsigned char __pad1;
+  unsigned char __pad2;
+} pthread_rwlock_hppa_2_0_t;
+
+#endif
+
Index: sysdeps/unix/sysv/linux/hppa/nptl/Versions
===================================================================
RCS file: sysdeps/unix/sysv/linux/hppa/nptl/Versions
diff -N sysdeps/unix/sysv/linux/hppa/nptl/Versions
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ b/ports/sysdeps/unix/sysv/linux/hppa/nptl/Versions	2 Apr 2009 02:34:03 -0000
@@ -0,0 +1,65 @@
+libc {
+  GLIBC_2.9 {
+    # Changed lock implemenation, breaking the ABI for
+    # all structures that can contain statically initialized
+    # locks. Added compat functions and structures for the
+    # following functions:
+    pthread_cond_broadcast;
+    pthread_cond_destroy;
+    pthread_cond_init;
+    pthread_cond_signal;
+    pthread_cond_timedwait;
+    pthread_cond_wait;
+    pthread_mutex_destroy;
+    pthread_mutex_init;
+    pthread_mutex_lock;
+    pthread_mutex_timedlock;
+    pthread_mutex_trylock;
+    pthread_mutex_unlock;
+    pthread_rwlock_destroy;
+    pthread_rwlock_init;
+    pthread_rwlock_rdlock;
+    pthread_rwlock_timedrdlock;
+    pthread_rwlock_timedwrlock;
+    pthread_rwlock_tryrdlock;
+    pthread_rwlock_trywrlock;
+    pthread_rwlock_unlock;
+    pthread_rwlock_wrlock;
+  }
+}
+
+libpthread {
+  GLIBC_2.9 {
+    # Changed lock implemenation, breaking the ABI for
+    # all structures that can contain statically initialized
+    # locks. Added compat functions and structures for the
+    # following functions:
+    pthread_cond_broadcast;
+    pthread_cond_destroy;
+    pthread_cond_init;
+    pthread_cond_signal;
+    pthread_cond_timedwait;
+    pthread_cond_wait;
+    pthread_mutex_destroy;
+    pthread_mutex_init;
+    pthread_mutex_lock;
+    pthread_mutex_timedlock;
+    pthread_mutex_trylock;
+    pthread_mutex_unlock;
+    pthread_rwlock_destroy;
+    pthread_rwlock_init;
+    pthread_rwlock_rdlock;
+    pthread_rwlock_timedrdlock;
+    pthread_rwlock_timedwrlock;
+    pthread_rwlock_tryrdlock;
+    pthread_rwlock_trywrlock;
+    pthread_rwlock_unlock;
+    pthread_rwlock_wrlock;
+    # Protected names for functions used in other shared objects.
+    __pthread_mutex_init;
+    __pthread_mutex_destroy;
+    __pthread_mutex_lock; 
+    __pthread_mutex_trylock; 
+    __pthread_mutex_unlock;
+  }
+}
Index: sysdeps/unix/sysv/linux/hppa/nptl/forward.c
===================================================================
RCS file: sysdeps/unix/sysv/linux/hppa/nptl/forward.c
diff -N sysdeps/unix/sysv/linux/hppa/nptl/forward.c
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ b/ports/sysdeps/unix/sysv/linux/hppa/nptl/forward.c	2 Apr 2009 02:34:03 -0000
@@ -0,0 +1,275 @@
+/* Copyright (C) 2002, 2003, 2004, 2007, 2009 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Ulrich Drepper <drepper@redhat.com>, 2002.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <dlfcn.h>
+#include <pthreadP.h>
+#include <signal.h>
+#include <stdlib.h>
+
+#include <shlib-compat.h>
+#include <atomic.h>
+#include <sysdep.h>
+
+
+/* Pointers to the libc functions.  */
+struct pthread_functions __libc_pthread_functions attribute_hidden;
+int __libc_pthread_functions_init attribute_hidden;
+
+
+#define FORWARD2(name, rettype, decl, params, defaction) \
+rettype									      \
+name decl								      \
+{									      \
+  if (!__libc_pthread_functions_init)					      \
+    defaction;								      \
+									      \
+  return PTHFCT_CALL (ptr_##name, params);				      \
+}
+
+#define FORWARD(name, decl, params, defretval) \
+  FORWARD2 (name, int, decl, params, return defretval)
+
+
+FORWARD (pthread_attr_destroy, (pthread_attr_t *attr), (attr), 0)
+
+#if SHLIB_COMPAT(libc, GLIBC_2_0, GLIBC_2_1)
+FORWARD (__pthread_attr_init_2_0, (pthread_attr_t *attr), (attr), 0)
+compat_symbol (libc, __pthread_attr_init_2_0, pthread_attr_init, GLIBC_2_0);
+#endif
+
+FORWARD (__pthread_attr_init_2_1, (pthread_attr_t *attr), (attr), 0)
+versioned_symbol (libc, __pthread_attr_init_2_1, pthread_attr_init, GLIBC_2_1);
+
+FORWARD (pthread_attr_getdetachstate,
+	 (const pthread_attr_t *attr, int *detachstate), (attr, detachstate),
+	 0)
+FORWARD (pthread_attr_setdetachstate, (pthread_attr_t *attr, int detachstate),
+	 (attr, detachstate), 0)
+
+FORWARD (pthread_attr_getinheritsched,
+	 (const pthread_attr_t *attr, int *inherit), (attr, inherit), 0)
+FORWARD (pthread_attr_setinheritsched, (pthread_attr_t *attr, int inherit),
+	 (attr, inherit), 0)
+
+FORWARD (pthread_attr_getschedparam,
+	 (const pthread_attr_t *attr, struct sched_param *param),
+	 (attr, param), 0)
+FORWARD (pthread_attr_setschedparam,
+	 (pthread_attr_t *attr, const struct sched_param *param),
+	 (attr, param), 0)
+
+FORWARD (pthread_attr_getschedpolicy,
+	 (const pthread_attr_t *attr, int *policy), (attr, policy), 0)
+FORWARD (pthread_attr_setschedpolicy, (pthread_attr_t *attr, int policy),
+	 (attr, policy), 0)
+
+FORWARD (pthread_attr_getscope,
+	 (const pthread_attr_t *attr, int *scope), (attr, scope), 0)
+FORWARD (pthread_attr_setscope, (pthread_attr_t *attr, int scope),
+	 (attr, scope), 0)
+
+
+FORWARD (pthread_condattr_destroy, (pthread_condattr_t *attr), (attr), 0)
+FORWARD (pthread_condattr_init, (pthread_condattr_t *attr), (attr), 0)
+
+#if SHLIB_COMPAT(libc, GLIBC_2_0, GLIBC_2_3_2)
+FORWARD2 (__pthread_cond_broadcast_2_0, int attribute_compat_text_section,
+	  (pthread_cond_2_0_t *cond), (cond), return 0)
+compat_symbol (libc, __pthread_cond_broadcast_2_0, pthread_cond_broadcast,
+	       GLIBC_2_0);
+#endif
+#if SHLIB_COMPAT(libc, GLIBC_2_3_2, GLIBC_2_9)
+FORWARD2 (__pthread_cond_broadcast_hppa_2_3_2, int attribute_compat_text_section,
+	  (pthread_cond_hppa_2_3_2_t *cond), (cond), return 0)
+compat_symbol (libc, __pthread_cond_broadcast_hppa_2_3_2, pthread_cond_broadcast, 
+	       GLIBC_2_3_2);
+#endif
+FORWARD (__pthread_cond_broadcast, (pthread_cond_t *cond), (cond), 0)
+versioned_symbol (libc, __pthread_cond_broadcast, pthread_cond_broadcast,
+		  GLIBC_2_9);
+
+#if SHLIB_COMPAT(libc, GLIBC_2_0, GLIBC_2_3_2)
+FORWARD2 (__pthread_cond_destroy_2_0, int attribute_compat_text_section,
+	  (pthread_cond_2_0_t *cond), (cond), return 0)
+compat_symbol (libc, __pthread_cond_destroy_2_0, pthread_cond_destroy,
+	       GLIBC_2_0);
+#endif
+#if SHLIB_COMPAT(libc, GLIBC_2_3_2, GLIBC_2_9)
+FORWARD2 (__pthread_cond_destroy_hppa_2_3_2, int attribute_compat_text_section,
+	  (pthread_cond_hppa_2_3_2_t *cond), (cond), return 0)
+compat_symbol (libc, __pthread_cond_destroy_hppa_2_3_2, pthread_cond_destroy,
+	       GLIBC_2_3_2);
+#endif
+FORWARD (__pthread_cond_destroy, (pthread_cond_t *cond), (cond), 0)
+versioned_symbol (libc, __pthread_cond_destroy, pthread_cond_destroy,
+		  GLIBC_2_9);
+
+#if SHLIB_COMPAT(libc, GLIBC_2_0, GLIBC_2_3_2)
+FORWARD2 (__pthread_cond_init_2_0, int attribute_compat_text_section,
+	  (pthread_cond_2_0_t *cond, const pthread_condattr_t *cond_attr),
+	  (cond, cond_attr), return 0)
+compat_symbol (libc, __pthread_cond_init_2_0, pthread_cond_init, GLIBC_2_0);
+#endif
+#if SHLIB_COMPAT(libc, GLIBC_2_3_2, GLIBC_2_9)
+FORWARD2 (__pthread_cond_init_hppa_2_3_2, int attribute_compat_text_section,
+	  (pthread_cond_hppa_2_3_2_t *cond, const pthread_condattr_t *cond_attr),
+	  (cond, cond_attr), return 0)
+compat_symbol (libc, __pthread_cond_init_hppa_2_3_2, pthread_cond_init, GLIBC_2_3_2);
+#endif
+FORWARD (__pthread_cond_init,
+	 (pthread_cond_t *cond, const pthread_condattr_t *cond_attr),
+	 (cond, cond_attr), 0)
+versioned_symbol (libc, __pthread_cond_init, pthread_cond_init, GLIBC_2_9);
+
+#if SHLIB_COMPAT(libc, GLIBC_2_0, GLIBC_2_3_2)
+FORWARD2 (__pthread_cond_signal_2_0, int attribute_compat_text_section,
+	  (pthread_cond_2_0_t *cond), (cond), return 0)
+compat_symbol (libc, __pthread_cond_signal_2_0, pthread_cond_signal,
+	       GLIBC_2_0);
+#endif
+#if SHLIB_COMPAT(libc, GLIBC_2_3_2, GLIBC_2_9)
+FORWARD2 (__pthread_cond_signal_hppa_2_3_2, int attribute_compat_text_section,
+	  (pthread_cond_hppa_2_3_2_t *cond), (cond), return 0)
+compat_symbol (libc, __pthread_cond_signal_hppa_2_3_2, pthread_cond_signal,
+	       GLIBC_2_3_2);
+#endif
+FORWARD (__pthread_cond_signal, (pthread_cond_t *cond), (cond), 0)
+versioned_symbol (libc, __pthread_cond_signal, pthread_cond_signal,
+		  GLIBC_2_9);
+
+#if SHLIB_COMPAT(libc, GLIBC_2_0, GLIBC_2_3_2)
+FORWARD2 (__pthread_cond_wait_2_0, int attribute_compat_text_section,
+	  (pthread_cond_2_0_t *cond, pthread_mutex_t *mutex), (cond, mutex),
+	  return 0)
+compat_symbol (libc, __pthread_cond_wait_2_0, pthread_cond_wait,
+	       GLIBC_2_0);
+#endif
+#if SHLIB_COMPAT(libc, GLIBC_2_3_2, GLIBC_2_9)
+FORWARD2 (__pthread_cond_wait_hppa_2_3_2, int attribute_compat_text_section,
+	  (pthread_cond_hppa_2_3_2_t *cond, pthread_mutex_hppa_2_0_t *mutex), (cond, mutex),
+	  return 0)
+compat_symbol (libc, __pthread_cond_wait_hppa_2_3_2, pthread_cond_wait,
+	       GLIBC_2_3_2);
+#endif
+FORWARD (__pthread_cond_wait, (pthread_cond_t *cond, pthread_mutex_t *mutex),
+	 (cond, mutex), 0)
+versioned_symbol (libc, __pthread_cond_wait, pthread_cond_wait,
+		  GLIBC_2_9);
+
+#if SHLIB_COMPAT(libc, GLIBC_2_0, GLIBC_2_3_2)
+FORWARD2 (__pthread_cond_timedwait_2_0, int attribute_compat_text_section,
+	  (pthread_cond_2_0_t *cond, pthread_mutex_t *mutex,
+	   const struct timespec *abstime), (cond, mutex, abstime),
+	  return 0)
+compat_symbol (libc, __pthread_cond_timedwait_2_0, pthread_cond_timedwait,
+	       GLIBC_2_0);
+#endif
+#if SHLIB_COMPAT(libc, GLIBC_2_3_2, GLIBC_2_9)
+FORWARD2 (__pthread_cond_timedwait_hppa_2_3_2, int attribute_compat_text_section,
+	  (pthread_cond_hppa_2_3_2_t *cond, pthread_mutex_hppa_2_0_t *mutex,
+	   const struct timespec *abstime), (cond, mutex, abstime),
+	  return 0)
+compat_symbol (libc, __pthread_cond_timedwait_hppa_2_3_2, pthread_cond_timedwait,
+	       GLIBC_2_3_2);
+#endif
+FORWARD (__pthread_cond_timedwait,
+	 (pthread_cond_t *cond, pthread_mutex_t *mutex,
+	  const struct timespec *abstime), (cond, mutex, abstime), 0)
+versioned_symbol (libc, __pthread_cond_timedwait, pthread_cond_timedwait,
+		  GLIBC_2_9);
+
+
+FORWARD (pthread_equal, (pthread_t thread1, pthread_t thread2),
+	 (thread1, thread2), 1)
+
+
+/* Use an alias to avoid warning, as pthread_exit is declared noreturn.  */
+FORWARD2 (__pthread_exit, void, (void *retval), (retval), exit (EXIT_SUCCESS))
+strong_alias (__pthread_exit, pthread_exit);
+
+
+FORWARD (pthread_getschedparam,
+	 (pthread_t target_thread, int *policy, struct sched_param *param),
+	 (target_thread, policy, param), 0)
+FORWARD (pthread_setschedparam,
+	 (pthread_t target_thread, int policy,
+	  const struct sched_param *param), (target_thread, policy, param), 0)
+
+
+#if SHLIB_COMPAT(libc, GLIBC_2_0, GLIBC_2_9)
+FORWARD2 (__pthread_mutex_destroy_hppa_2_0, int attribute_compat_text_section,
+	 (pthread_mutex_hppa_2_0_t *mutex), (mutex), return 0)
+compat_symbol (libc, __pthread_mutex_destroy_hppa_2_0, pthread_mutex_destroy,
+	       GLIBC_2_0);
+#endif
+FORWARD (pthread_mutex_destroy, (pthread_mutex_t *mutex), (mutex), 0)
+versioned_symbol (libc, __pthread_mutex_destroy, pthread_mutex_destroy,
+		  GLIBC_2_9);
+
+#if SHLIB_COMPAT(libc, GLIBC_2_0, GLIBC_2_9)
+FORWARD2 (__pthread_mutex_init_hppa_2_0, int attribute_compat_text_section,
+	 (pthread_mutex_hppa_2_0_t *mutex, const pthread_mutexattr_t *mutexattr),
+	 (mutex, mutexattr), return 0)
+compat_symbol (libc, __pthread_mutex_init_hppa_2_0, pthread_mutex_init,
+	       GLIBC_2_0);
+#endif
+FORWARD (pthread_mutex_init,
+	 (pthread_mutex_t *mutex, const pthread_mutexattr_t *mutexattr),
+	 (mutex, mutexattr), 0)
+versioned_symbol (libc, __pthread_mutex_init, pthread_mutex_init,
+		  GLIBC_2_9);
+
+#if SHLIB_COMPAT(libc, GLIBC_2_0, GLIBC_2_9)
+FORWARD2 (__pthread_mutex_lock_hppa_2_0, int attribute_compat_text_section,
+	 (pthread_mutex_hppa_2_0_t *mutex), (mutex), return 0)
+compat_symbol (libc, __pthread_mutex_lock_hppa_2_0, pthread_mutex_lock,
+	       GLIBC_2_0);
+#endif
+FORWARD (pthread_mutex_lock, (pthread_mutex_t *mutex), (mutex), 0)
+versioned_symbol (libc, __pthread_mutex_lock, pthread_mutex_lock,
+		  GLIBC_2_9);
+
+#if SHLIB_COMPAT(libc, GLIBC_2_0, GLIBC_2_9)
+FORWARD2 (__pthread_mutex_unlock_hppa_2_0, int attribute_compat_text_section,
+	 (pthread_mutex_hppa_2_0_t *mutex), (mutex), return 0)
+compat_symbol (libc, __pthread_mutex_unlock_hppa_2_0, pthread_mutex_unlock,
+	       GLIBC_2_0);
+#endif
+FORWARD (pthread_mutex_unlock, (pthread_mutex_t *mutex), (mutex), 0)
+versioned_symbol (libc, __pthread_mutex_init, pthread_mutex_init,
+		  GLIBC_2_9);
+
+FORWARD2 (pthread_self, pthread_t, (void), (), return 0)
+
+
+FORWARD (pthread_setcancelstate, (int state, int *oldstate), (state, oldstate),
+	 0)
+
+FORWARD (pthread_setcanceltype, (int type, int *oldtype), (type, oldtype), 0)
+
+#define return /* value is void */
+FORWARD2(__pthread_unwind,
+	 void attribute_hidden __attribute ((noreturn)) __cleanup_fct_attribute
+	 attribute_compat_text_section,
+	 (__pthread_unwind_buf_t *buf), (buf), {
+		       /* We cannot call abort() here.  */
+		       INTERNAL_SYSCALL_DECL (err);
+		       INTERNAL_SYSCALL (kill, err, 1, SIGKILL);
+		     })
+#undef return
Index: sysdeps/unix/sysv/linux/hppa/nptl/init.c
===================================================================
RCS file: sysdeps/unix/sysv/linux/hppa/nptl/init.c
diff -N sysdeps/unix/sysv/linux/hppa/nptl/init.c
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ b/ports/sysdeps/unix/sysv/linux/hppa/nptl/init.c	2 Apr 2009 02:34:03 -0000
@@ -0,0 +1,460 @@
+/* Copyright (C) 2002-2007, 2008, 2009 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Ulrich Drepper <drepper@redhat.com>, 2002.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <assert.h>
+#include <errno.h>
+#include <limits.h>
+#include <signal.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <sys/param.h>
+#include <sys/resource.h>
+#include <pthreadP.h>
+#include <atomic.h>
+#include <ldsodefs.h>
+#include <tls.h>
+#include <fork.h>
+#include <version.h>
+#include <shlib-compat.h>
+#include <smp.h>
+#include <lowlevellock.h>
+#include <kernel-features.h>
+
+
+/* Size and alignment of static TLS block.  */
+size_t __static_tls_size;
+size_t __static_tls_align_m1;
+
+#ifndef __ASSUME_SET_ROBUST_LIST
+/* Negative if we do not have the system call and we can use it.  */
+int __set_robust_list_avail;
+# define set_robust_list_not_avail() \
+  __set_robust_list_avail = -1
+#else
+# define set_robust_list_not_avail() do { } while (0)
+#endif
+
+#ifndef __ASSUME_FUTEX_CLOCK_REALTIME
+/* Nonzero if we do not have FUTEX_CLOCK_REALTIME.  */
+int __have_futex_clock_realtime;
+# define __set_futex_clock_realtime() \
+  __have_futex_clock_realtime = 1
+#else
+#define __set_futex_clock_realtime() do { } while (0)
+#endif
+
+/* Version of the library, used in libthread_db to detect mismatches.  */
+static const char nptl_version[] __attribute_used__ = VERSION;
+
+
+#ifndef SHARED
+extern void __libc_setup_tls (size_t tcbsize, size_t tcbalign);
+#endif
+
+static void nptl_freeres (void);
+
+
+#ifdef SHARED
+static const struct pthread_functions pthread_functions =
+  {
+    .ptr_pthread_attr_destroy = __pthread_attr_destroy,
+# if SHLIB_COMPAT(libpthread, GLIBC_2_0, GLIBC_2_1)
+    .ptr___pthread_attr_init_2_0 = __pthread_attr_init_2_0,
+# endif
+    .ptr___pthread_attr_init_2_1 = __pthread_attr_init_2_1,
+    .ptr_pthread_attr_getdetachstate = __pthread_attr_getdetachstate,
+    .ptr_pthread_attr_setdetachstate = __pthread_attr_setdetachstate,
+    .ptr_pthread_attr_getinheritsched = __pthread_attr_getinheritsched,
+    .ptr_pthread_attr_setinheritsched = __pthread_attr_setinheritsched,
+    .ptr_pthread_attr_getschedparam = __pthread_attr_getschedparam,
+    .ptr_pthread_attr_setschedparam = __pthread_attr_setschedparam,
+    .ptr_pthread_attr_getschedpolicy = __pthread_attr_getschedpolicy,
+    .ptr_pthread_attr_setschedpolicy = __pthread_attr_setschedpolicy,
+    .ptr_pthread_attr_getscope = __pthread_attr_getscope,
+    .ptr_pthread_attr_setscope = __pthread_attr_setscope,
+    .ptr_pthread_condattr_destroy = __pthread_condattr_destroy,
+    .ptr_pthread_condattr_init = __pthread_condattr_init,
+    .ptr___pthread_cond_broadcast = __pthread_cond_broadcast,
+    .ptr___pthread_cond_destroy = __pthread_cond_destroy,
+    .ptr___pthread_cond_init = __pthread_cond_init,
+    .ptr___pthread_cond_signal = __pthread_cond_signal,
+    .ptr___pthread_cond_wait = __pthread_cond_wait,
+    .ptr___pthread_cond_timedwait = __pthread_cond_timedwait,
+# if SHLIB_COMPAT(libpthread, GLIBC_2_0, GLIBC_2_3_2)
+    .ptr___pthread_cond_broadcast_2_0 = __pthread_cond_broadcast_2_0,
+    .ptr___pthread_cond_destroy_2_0 = __pthread_cond_destroy_2_0,
+    .ptr___pthread_cond_init_2_0 = __pthread_cond_init_2_0,
+    .ptr___pthread_cond_signal_2_0 = __pthread_cond_signal_2_0,
+    .ptr___pthread_cond_wait_2_0 = __pthread_cond_wait_2_0,
+    .ptr___pthread_cond_timedwait_2_0 = __pthread_cond_timedwait_2_0,
+# endif
+# if SHLIB_COMPAT(libpthread, GLIBC_2_3_2, GLIBC_2_9)
+    .ptr___pthread_cond_broadcast_hppa_2_3_2 = __pthread_cond_broadcast_hppa_2_3_2,
+    .ptr___pthread_cond_destroy_hppa_2_3_2 = __pthread_cond_destroy_hppa_2_3_2,
+    .ptr___pthread_cond_init_hppa_2_3_2 = __pthread_cond_init_hppa_2_3_2,
+    .ptr___pthread_cond_signal_hppa_2_3_2 = __pthread_cond_signal_hppa_2_3_2,
+    .ptr___pthread_cond_wait_hppa_2_3_2 = __pthread_cond_wait_hppa_2_3_2,
+    .ptr___pthread_cond_timedwait_hppa_2_3_2 = __pthread_cond_timedwait_hppa_2_3_2,
+# endif
+    .ptr_pthread_equal = __pthread_equal,
+    .ptr___pthread_exit = __pthread_exit,
+    .ptr_pthread_getschedparam = __pthread_getschedparam,
+    .ptr_pthread_setschedparam = __pthread_setschedparam,
+    .ptr_pthread_mutex_destroy = INTUSE(__pthread_mutex_destroy),
+    .ptr_pthread_mutex_init = INTUSE(__pthread_mutex_init),
+    .ptr_pthread_mutex_lock = INTUSE(__pthread_mutex_lock),
+    .ptr_pthread_mutex_unlock = INTUSE(__pthread_mutex_unlock),
+# if SHLIB_COMPAT(libpthread, GLIBC_2_0, GLIBC_2_9)
+    .ptr___pthread_mutex_destroy_hppa_2_0 = __pthread_mutex_destroy_hppa_2_0,
+    .ptr___pthread_mutex_init_hppa_2_0 = __pthread_mutex_init_hppa_2_0,
+    .ptr___pthread_mutex_lock_hppa_2_0 = __pthread_mutex_lock_hppa_2_0,
+    .ptr___pthread_mutex_unlock_hppa_2_0 = __pthread_mutex_unlock_hppa_2_0,
+# endif
+    .ptr_pthread_self = __pthread_self,
+    .ptr_pthread_setcancelstate = __pthread_setcancelstate,
+    .ptr_pthread_setcanceltype = __pthread_setcanceltype,
+    .ptr___pthread_cleanup_upto = __pthread_cleanup_upto,
+    .ptr___pthread_once = __pthread_once_internal,
+    .ptr___pthread_rwlock_rdlock = __pthread_rwlock_rdlock_internal,
+    .ptr___pthread_rwlock_wrlock = __pthread_rwlock_wrlock_internal,
+    .ptr___pthread_rwlock_unlock = __pthread_rwlock_unlock_internal,
+    .ptr___pthread_key_create = __pthread_key_create_internal,
+    .ptr___pthread_getspecific = __pthread_getspecific_internal,
+    .ptr___pthread_setspecific = __pthread_setspecific_internal,
+    .ptr__pthread_cleanup_push_defer = __pthread_cleanup_push_defer,
+    .ptr__pthread_cleanup_pop_restore = __pthread_cleanup_pop_restore,
+    .ptr_nthreads = &__nptl_nthreads,
+    .ptr___pthread_unwind = &__pthread_unwind,
+    .ptr__nptl_deallocate_tsd = __nptl_deallocate_tsd,
+    .ptr__nptl_setxid = __nptl_setxid,
+    /* For now only the stack cache needs to be freed.  */
+    .ptr_freeres = nptl_freeres
+  };
+# define ptr_pthread_functions &pthread_functions
+#else
+# define ptr_pthread_functions NULL
+#endif
+
+
+/* This function is called indirectly from the freeres code in libc.  */
+static void
+__libc_freeres_fn_section
+nptl_freeres (void)
+{
+#ifdef SHARED
+  __unwind_freeres ();
+#endif
+  __free_stacks (0);
+}
+
+
+/* For asynchronous cancellation we use a signal.  This is the handler.  */
+static void
+sigcancel_handler (int sig, siginfo_t *si, void *ctx)
+{
+#ifdef __ASSUME_CORRECT_SI_PID
+  /* Determine the process ID.  It might be negative if the thread is
+     in the middle of a fork() call.  */
+  pid_t pid = THREAD_GETMEM (THREAD_SELF, pid);
+  if (__builtin_expect (pid < 0, 0))
+    pid = -pid;
+#endif
+
+  /* Safety check.  It would be possible to call this function for
+     other signals and send a signal from another process.  This is not
+     correct and might even be a security problem.  Try to catch as
+     many incorrect invocations as possible.  */
+  if (sig != SIGCANCEL
+#ifdef __ASSUME_CORRECT_SI_PID
+      /* Kernels before 2.5.75 stored the thread ID and not the process
+	 ID in si_pid so we skip this test.  */
+      || si->si_pid != pid
+#endif
+      || si->si_code != SI_TKILL)
+    return;
+
+  struct pthread *self = THREAD_SELF;
+
+  int oldval = THREAD_GETMEM (self, cancelhandling);
+  while (1)
+    {
+      /* We are canceled now.  When canceled by another thread this flag
+	 is already set but if the signal is directly send (internally or
+	 from another process) is has to be done here.  */
+      int newval = oldval | CANCELING_BITMASK | CANCELED_BITMASK;
+
+      if (oldval == newval || (oldval & EXITING_BITMASK) != 0)
+	/* Already canceled or exiting.  */
+	break;
+
+      int curval = THREAD_ATOMIC_CMPXCHG_VAL (self, cancelhandling, newval,
+					      oldval);
+      if (curval == oldval)
+	{
+	  /* Set the return value.  */
+	  THREAD_SETMEM (self, result, PTHREAD_CANCELED);
+
+	  /* Make sure asynchronous cancellation is still enabled.  */
+	  if ((newval & CANCELTYPE_BITMASK) != 0)
+	    /* Run the registered destructors and terminate the thread.  */
+	    __do_cancel ();
+
+	  break;
+	}
+
+      oldval = curval;
+    }
+}
+
+
+struct xid_command *__xidcmd attribute_hidden;
+
+/* For asynchronous cancellation we use a signal.  This is the handler.  */
+static void
+sighandler_setxid (int sig, siginfo_t *si, void *ctx)
+{
+#ifdef __ASSUME_CORRECT_SI_PID
+  /* Determine the process ID.  It might be negative if the thread is
+     in the middle of a fork() call.  */
+  pid_t pid = THREAD_GETMEM (THREAD_SELF, pid);
+  if (__builtin_expect (pid < 0, 0))
+    pid = -pid;
+#endif
+
+  /* Safety check.  It would be possible to call this function for
+     other signals and send a signal from another process.  This is not
+     correct and might even be a security problem.  Try to catch as
+     many incorrect invocations as possible.  */
+  if (sig != SIGSETXID
+#ifdef __ASSUME_CORRECT_SI_PID
+      /* Kernels before 2.5.75 stored the thread ID and not the process
+	 ID in si_pid so we skip this test.  */
+      || si->si_pid != pid
+#endif
+      || si->si_code != SI_TKILL)
+    return;
+
+  INTERNAL_SYSCALL_DECL (err);
+  INTERNAL_SYSCALL_NCS (__xidcmd->syscall_no, err, 3, __xidcmd->id[0],
+			__xidcmd->id[1], __xidcmd->id[2]);
+
+  if (atomic_decrement_val (&__xidcmd->cntr) == 0)
+    lll_futex_wake (&__xidcmd->cntr, 1, LLL_PRIVATE);
+
+  /* Reset the SETXID flag.  */
+  struct pthread *self = THREAD_SELF;
+  int flags = THREAD_GETMEM (self, cancelhandling);
+  THREAD_SETMEM (self, cancelhandling, flags & ~SETXID_BITMASK);
+
+  /* And release the futex.  */
+  self->setxid_futex = 1;
+  lll_futex_wake (&self->setxid_futex, 1, LLL_PRIVATE);
+}
+
+
+/* When using __thread for this, we do it in libc so as not
+   to give libpthread its own TLS segment just for this.  */
+extern void **__libc_dl_error_tsd (void) __attribute__ ((const));
+
+
+/* This can be set by the debugger before initialization is complete.  */
+static bool __nptl_initial_report_events;
+
+void
+__pthread_initialize_minimal_internal (void)
+{
+#ifndef SHARED
+  /* Unlike in the dynamically linked case the dynamic linker has not
+     taken care of initializing the TLS data structures.  */
+  __libc_setup_tls (TLS_TCB_SIZE, TLS_TCB_ALIGN);
+
+  /* We must prevent gcc from being clever and move any of the
+     following code ahead of the __libc_setup_tls call.  This function
+     will initialize the thread register which is subsequently
+     used.  */
+  __asm __volatile ("");
+#endif
+
+  /* Minimal initialization of the thread descriptor.  */
+  struct pthread *pd = THREAD_SELF;
+  INTERNAL_SYSCALL_DECL (err);
+  pd->pid = pd->tid = INTERNAL_SYSCALL (set_tid_address, err, 1, &pd->tid);
+  THREAD_SETMEM (pd, specific[0], &pd->specific_1stblock[0]);
+  THREAD_SETMEM (pd, user_stack, true);
+  if (LLL_LOCK_INITIALIZER != 0)
+    THREAD_SETMEM (pd, lock, LLL_LOCK_INITIALIZER);
+#if HP_TIMING_AVAIL
+  THREAD_SETMEM (pd, cpuclock_offset, GL(dl_cpuclock_offset));
+#endif
+
+  /* Initialize the robust mutex data.  */
+#ifdef __PTHREAD_MUTEX_HAVE_PREV
+  pd->robust_prev = &pd->robust_head;
+#endif
+  pd->robust_head.list = &pd->robust_head;
+#ifdef __NR_set_robust_list
+  pd->robust_head.futex_offset = (offsetof (pthread_mutex_t, __data.__lock)
+				  - offsetof (pthread_mutex_t,
+					      __data.__list.__next));
+  int res = INTERNAL_SYSCALL (set_robust_list, err, 2, &pd->robust_head,
+			      sizeof (struct robust_list_head));
+  if (INTERNAL_SYSCALL_ERROR_P (res, err))
+#endif
+    set_robust_list_not_avail ();
+
+#ifndef __ASSUME_PRIVATE_FUTEX
+  /* Private futexes are always used (at least internally) so that
+     doing the test once this early is beneficial.  */
+  {
+    int word = 0;
+    word = INTERNAL_SYSCALL (futex, err, 3, &word,
+			    FUTEX_WAKE | FUTEX_PRIVATE_FLAG, 1);
+    if (!INTERNAL_SYSCALL_ERROR_P (word, err))
+      THREAD_SETMEM (pd, header.private_futex, FUTEX_PRIVATE_FLAG);
+  }
+
+  /* Private futexes have been introduced earlier than the
+     FUTEX_CLOCK_REALTIME flag.  We don't have to run the test if we
+     know the former are not supported.  This also means we know the
+     kernel will return ENOSYS for unknown operations.  */
+  if (THREAD_GETMEM (pd, header.private_futex) != 0)
+#endif
+#ifndef __ASSUME_FUTEX_CLOCK_REALTIME
+    {
+      int word = 0;
+      /* NB: the syscall actually takes six parameters.  The last is the
+	 bit mask.  But since we will not actually wait at all the value
+	 is irrelevant.  Given that passing six parameters is difficult
+	 on some architectures we just pass whatever random value the
+	 calling convention calls for to the kernel.  It causes no harm.  */
+      word = INTERNAL_SYSCALL (futex, err, 5, &word,
+			       FUTEX_WAIT_BITSET | FUTEX_CLOCK_REALTIME
+			       | FUTEX_PRIVATE_FLAG, 1, NULL, 0);
+      assert (INTERNAL_SYSCALL_ERROR_P (word, err));
+      if (INTERNAL_SYSCALL_ERRNO (word, err) != ENOSYS)
+	__set_futex_clock_realtime ();
+    }
+#endif
+
+  /* Set initial thread's stack block from 0 up to __libc_stack_end.
+     It will be bigger than it actually is, but for unwind.c/pt-longjmp.c
+     purposes this is good enough.  */
+  THREAD_SETMEM (pd, stackblock_size, (size_t) __libc_stack_end);
+
+  /* Initialize the list of all running threads with the main thread.  */
+  INIT_LIST_HEAD (&__stack_user);
+  list_add (&pd->list, &__stack_user);
+
+  /* Before initializing __stack_user, the debugger could not find us and
+     had to set __nptl_initial_report_events.  Propagate its setting.  */
+  THREAD_SETMEM (pd, report_events, __nptl_initial_report_events);
+
+  /* Install the cancellation signal handler.  If for some reason we
+     cannot install the handler we do not abort.  Maybe we should, but
+     it is only asynchronous cancellation which is affected.  */
+  struct sigaction sa;
+  sa.sa_sigaction = sigcancel_handler;
+  sa.sa_flags = SA_SIGINFO;
+  __sigemptyset (&sa.sa_mask);
+
+  (void) __libc_sigaction (SIGCANCEL, &sa, NULL);
+
+  /* Install the handle to change the threads' uid/gid.  */
+  sa.sa_sigaction = sighandler_setxid;
+  sa.sa_flags = SA_SIGINFO | SA_RESTART;
+
+  (void) __libc_sigaction (SIGSETXID, &sa, NULL);
+
+  /* The parent process might have left the signals blocked.  Just in
+     case, unblock it.  We reuse the signal mask in the sigaction
+     structure.  It is already cleared.  */
+  __sigaddset (&sa.sa_mask, SIGCANCEL);
+  __sigaddset (&sa.sa_mask, SIGSETXID);
+  (void) INTERNAL_SYSCALL (rt_sigprocmask, err, 4, SIG_UNBLOCK, &sa.sa_mask,
+			   NULL, _NSIG / 8);
+
+  /* Get the size of the static and alignment requirements for the TLS
+     block.  */
+  size_t static_tls_align;
+  _dl_get_tls_static_info (&__static_tls_size, &static_tls_align);
+
+  /* Make sure the size takes all the alignments into account.  */
+  if (STACK_ALIGN > static_tls_align)
+    static_tls_align = STACK_ALIGN;
+  __static_tls_align_m1 = static_tls_align - 1;
+
+  __static_tls_size = roundup (__static_tls_size, static_tls_align);
+
+  /* Determine the default allowed stack size.  This is the size used
+     in case the user does not specify one.  */
+  struct rlimit limit;
+  if (getrlimit (RLIMIT_STACK, &limit) != 0
+      || limit.rlim_cur == RLIM_INFINITY)
+    /* The system limit is not usable.  Use an architecture-specific
+       default.  */
+    limit.rlim_cur = ARCH_STACK_DEFAULT_SIZE;
+  else if (limit.rlim_cur < PTHREAD_STACK_MIN)
+    /* The system limit is unusably small.
+       Use the minimal size acceptable.  */
+    limit.rlim_cur = PTHREAD_STACK_MIN;
+
+  /* Make sure it meets the minimum size that allocate_stack
+     (allocatestack.c) will demand, which depends on the page size.  */
+  const uintptr_t pagesz = __sysconf (_SC_PAGESIZE);
+  const size_t minstack = pagesz + __static_tls_size + MINIMAL_REST_STACK;
+  if (limit.rlim_cur < minstack)
+    limit.rlim_cur = minstack;
+
+  /* Round the resource limit up to page size.  */
+  limit.rlim_cur = (limit.rlim_cur + pagesz - 1) & -pagesz;
+  __default_stacksize = limit.rlim_cur;
+
+#ifdef SHARED
+  /* Transfer the old value from the dynamic linker's internal location.  */
+  *__libc_dl_error_tsd () = *(*GL(dl_error_catch_tsd)) ();
+  GL(dl_error_catch_tsd) = &__libc_dl_error_tsd;
+
+  /* Make __rtld_lock_{,un}lock_recursive use pthread_mutex_{,un}lock,
+     keep the lock count from the ld.so implementation.  */
+  GL(dl_rtld_lock_recursive) = (void *) INTUSE (__pthread_mutex_lock);
+  GL(dl_rtld_unlock_recursive) = (void *) INTUSE (__pthread_mutex_unlock);
+  unsigned int rtld_lock_count = GL(dl_load_lock).mutex.__data.__count;
+  GL(dl_load_lock).mutex.__data.__count = 0;
+  while (rtld_lock_count-- > 0)
+    INTUSE (__pthread_mutex_lock) (&GL(dl_load_lock).mutex);
+
+  GL(dl_make_stack_executable_hook) = &__make_stacks_executable;
+#endif
+
+  GL(dl_init_static_tls) = &__pthread_init_static_tls;
+
+  GL(dl_wait_lookup_done) = &__wait_lookup_done;
+
+  /* Register the fork generation counter with the libc.  */
+#ifndef TLS_MULTIPLE_THREADS_IN_TCB
+  __libc_multiple_threads_ptr =
+#endif
+    __libc_pthread_init (&__fork_generation, __reclaim_stacks,
+			 ptr_pthread_functions);
+
+  /* Determine whether the machine is SMP or not.  */
+  __is_smp = is_smp_system ();
+}
+strong_alias (__pthread_initialize_minimal_internal,
+	      __pthread_initialize_minimal)
Index: sysdeps/unix/sysv/linux/hppa/nptl/old_hppa_pthread_cond_broadcast.c
===================================================================
RCS file: sysdeps/unix/sysv/linux/hppa/nptl/old_hppa_pthread_cond_broadcast.c
diff -N sysdeps/unix/sysv/linux/hppa/nptl/old_hppa_pthread_cond_broadcast.c
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ b/ports/sysdeps/unix/sysv/linux/hppa/nptl/old_hppa_pthread_cond_broadcast.c	2 Apr 2009 02:34:03 -0000
@@ -0,0 +1,36 @@
+/* Copyright (C) 2009 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Carlos O'Donell <carlos@codesourcery.com>, 2009.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <errno.h>
+#include "pthreadP.h"
+#include <shlib-compat.h>
+
+#if SHLIB_COMPAT(libpthread, GLIBC_2_3_2, GLIBC_2_9)
+int
+__pthread_cond_broadcast_hppa_2_3_2 (pthread_cond_hppa_2_3_2_t *var)
+{
+  compat_lock (var);
+  compat_malloc (var);
+  compat_unlock (var);
+  return __pthread_cond_broadcast(var->compat);
+}
+compat_symbol (libpthread, __pthread_cond_broadcast_hppa_2_3_2, 
+	       pthread_cond_broadcast, GLIBC_2_3_2);
+#endif
+
Index: sysdeps/unix/sysv/linux/hppa/nptl/old_hppa_pthread_cond_destroy.c
===================================================================
RCS file: sysdeps/unix/sysv/linux/hppa/nptl/old_hppa_pthread_cond_destroy.c
diff -N sysdeps/unix/sysv/linux/hppa/nptl/old_hppa_pthread_cond_destroy.c
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ b/ports/sysdeps/unix/sysv/linux/hppa/nptl/old_hppa_pthread_cond_destroy.c	2 Apr 2009 02:34:03 -0000
@@ -0,0 +1,40 @@
+/* Copyright (C) 2009 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Carlos O'Donell <carlos@codesourcery.com>, 2009.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <errno.h>
+#include "pthreadP.h"
+#include <shlib-compat.h>
+
+#if SHLIB_COMPAT(libpthread, GLIBC_2_3_2, GLIBC_2_9)
+int
+__pthread_cond_destroy_hppa_2_3_2 (pthread_cond_hppa_2_3_2_t *var)
+{
+  int ret;
+  if (compat_present (var))
+    {
+      ret = __pthread_cond_destroy(var->compat);
+      compat_free (var);
+      return ret;
+    }
+  return 0;
+}
+compat_symbol (libpthread, __pthread_cond_destroy_hppa_2_3_2, 
+	       pthread_cond_destroy, GLIBC_2_3_2);
+#endif
+
Index: sysdeps/unix/sysv/linux/hppa/nptl/old_hppa_pthread_cond_init.c
===================================================================
RCS file: sysdeps/unix/sysv/linux/hppa/nptl/old_hppa_pthread_cond_init.c
diff -N sysdeps/unix/sysv/linux/hppa/nptl/old_hppa_pthread_cond_init.c
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ b/ports/sysdeps/unix/sysv/linux/hppa/nptl/old_hppa_pthread_cond_init.c	2 Apr 2009 02:34:03 -0000
@@ -0,0 +1,37 @@
+/* Copyright (C) 2009 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Carlos O'Donell <carlos@codesourcery.com>, 2009.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <errno.h>
+#include "pthreadP.h"
+#include <shlib-compat.h>
+
+#if SHLIB_COMPAT(libpthread, GLIBC_2_3_2, GLIBC_2_9)
+int
+__pthread_cond_init_hppa_2_3_2 (pthread_cond_hppa_2_3_2_t *var,
+			      const pthread_condattr_t *attr)
+{
+  /* All other compat functions expect an initialized lock.  */
+  compat_init (var);
+  compat_malloc_nolock (var);
+  return __pthread_cond_init (var->compat, attr);
+}
+compat_symbol (libpthread, __pthread_cond_init_hppa_2_3_2, pthread_cond_init,
+	       GLIBC_2_3_2);
+#endif
+
Index: sysdeps/unix/sysv/linux/hppa/nptl/old_hppa_pthread_cond_signal.c
===================================================================
RCS file: sysdeps/unix/sysv/linux/hppa/nptl/old_hppa_pthread_cond_signal.c
diff -N sysdeps/unix/sysv/linux/hppa/nptl/old_hppa_pthread_cond_signal.c
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ b/ports/sysdeps/unix/sysv/linux/hppa/nptl/old_hppa_pthread_cond_signal.c	2 Apr 2009 02:34:03 -0000
@@ -0,0 +1,36 @@
+/* Copyright (C) 2009 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Carlos O'Donell <carlos@codesourcery.com>, 2009.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <errno.h>
+#include "pthreadP.h"
+#include <shlib-compat.h>
+
+#if SHLIB_COMPAT(libpthread, GLIBC_2_3_2, GLIBC_2_9)
+int
+__pthread_cond_signal_hppa_2_3_2 (pthread_cond_hppa_2_3_2_t *var)
+{
+  compat_lock (var);
+  compat_malloc (var);
+  compat_unlock (var);
+  return __pthread_cond_signal(var->compat);
+}
+compat_symbol (libpthread, __pthread_cond_signal_hppa_2_3_2, 
+	       pthread_cond_signal, GLIBC_2_3_2);
+#endif
+
Index: sysdeps/unix/sysv/linux/hppa/nptl/old_hppa_pthread_cond_timedwait.c
===================================================================
RCS file: sysdeps/unix/sysv/linux/hppa/nptl/old_hppa_pthread_cond_timedwait.c
diff -N sysdeps/unix/sysv/linux/hppa/nptl/old_hppa_pthread_cond_timedwait.c
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ b/ports/sysdeps/unix/sysv/linux/hppa/nptl/old_hppa_pthread_cond_timedwait.c	2 Apr 2009 02:34:03 -0000
@@ -0,0 +1,44 @@
+/* Copyright (C) 2009 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Carlos O'Donell <carlos@codesourcery.com>, 2009.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <errno.h>
+#include <time.h>
+#include "pthreadP.h"
+
+#include <shlib-compat.h>
+
+#if SHLIB_COMPAT(libpthread, GLIBC_2_3_2, GLIBC_2_9)
+int
+__pthread_cond_timedwait_hppa_2_3_2 (pthread_cond_hppa_2_3_2_t *var,
+				     pthread_mutex_hppa_2_0_t *mutex,
+				     const struct timespec *abstime)
+{
+  compat_lock (var);
+  compat_lock (mutex);
+  compat_malloc (var);
+  compat_malloc (mutex);
+  compat_mutex_copy (mutex);
+  compat_unlock (mutex);
+  compat_unlock (var);
+  return __pthread_cond_timedwait (var->compat, mutex->compat, abstime);
+}
+compat_symbol (libpthread, __pthread_cond_timedwait_hppa_2_3_2, 
+	       pthread_cond_timedwait, GLIBC_2_3_2);
+#endif
+
Index: sysdeps/unix/sysv/linux/hppa/nptl/old_hppa_pthread_cond_wait.c
===================================================================
RCS file: sysdeps/unix/sysv/linux/hppa/nptl/old_hppa_pthread_cond_wait.c
diff -N sysdeps/unix/sysv/linux/hppa/nptl/old_hppa_pthread_cond_wait.c
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ b/ports/sysdeps/unix/sysv/linux/hppa/nptl/old_hppa_pthread_cond_wait.c	2 Apr 2009 02:34:03 -0000
@@ -0,0 +1,41 @@
+/* Copyright (C) 2009 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Carlos O'Donell <carlos@codesourcery.com>, 2009.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <errno.h>
+#include "pthreadP.h"
+#include <shlib-compat.h>
+
+#if SHLIB_COMPAT(libpthread, GLIBC_2_3_2, GLIBC_2_9)
+int
+__pthread_cond_wait_hppa_2_3_2 (pthread_cond_hppa_2_3_2_t *var,
+				pthread_mutex_hppa_2_0_t *mutex)
+{
+  compat_lock (var);
+  compat_lock (mutex);
+  compat_malloc (var);
+  compat_malloc (mutex);
+  compat_mutex_copy (mutex);
+  compat_unlock (mutex);
+  compat_unlock (var);
+  return __pthread_cond_wait (var->compat, mutex->compat);
+}
+compat_symbol (libpthread, __pthread_cond_wait_hppa_2_3_2, 
+	       pthread_cond_wait, GLIBC_2_3_2);
+#endif
+
Index: sysdeps/unix/sysv/linux/hppa/nptl/old_hppa_pthread_mutex_destroy.c
===================================================================
RCS file: sysdeps/unix/sysv/linux/hppa/nptl/old_hppa_pthread_mutex_destroy.c
diff -N sysdeps/unix/sysv/linux/hppa/nptl/old_hppa_pthread_mutex_destroy.c
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ b/ports/sysdeps/unix/sysv/linux/hppa/nptl/old_hppa_pthread_mutex_destroy.c	2 Apr 2009 02:34:03 -0000
@@ -0,0 +1,40 @@
+/* Copyright (C) 2009 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Carlos O'Donell <carlos@codesourcery.com>, 2009.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <errno.h>
+#include "pthreadP.h"
+#include <shlib-compat.h>
+
+#if SHLIB_COMPAT(libpthread, GLIBC_2_0, GLIBC_2_9)
+int
+__pthread_mutex_destroy_hppa_2_0 (pthread_mutex_hppa_2_0_t *var)
+{
+  int ret;
+  if (compat_present (var))
+    {
+      ret = __pthread_mutex_destroy(var->compat);
+      compat_free (var);
+      return ret;
+    }
+  return 0;
+}
+compat_symbol (libpthread, __pthread_mutex_destroy_hppa_2_0, 
+	       pthread_mutex_destroy, GLIBC_2_0);
+#endif
+
Index: sysdeps/unix/sysv/linux/hppa/nptl/old_hppa_pthread_mutex_init.c
===================================================================
RCS file: sysdeps/unix/sysv/linux/hppa/nptl/old_hppa_pthread_mutex_init.c
diff -N sysdeps/unix/sysv/linux/hppa/nptl/old_hppa_pthread_mutex_init.c
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ b/ports/sysdeps/unix/sysv/linux/hppa/nptl/old_hppa_pthread_mutex_init.c	2 Apr 2009 02:34:03 -0000
@@ -0,0 +1,37 @@
+/* Copyright (C) 2009 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Carlos O'Donell <carlos@codesourcery.com>, 2009.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <errno.h>
+#include "pthreadP.h"
+#include <shlib-compat.h>
+
+#if SHLIB_COMPAT(libpthread, GLIBC_2_0, GLIBC_2_9)
+int
+__pthread_mutex_init_hppa_2_0 (pthread_mutex_hppa_2_0_t *var,
+			       const pthread_mutexattr_t *attr)
+{
+  /* All other compat functions expect an initialized lock.  */
+  compat_init (var);
+  compat_malloc_nolock (var);
+  return __pthread_mutex_init (var->compat, attr);
+}
+compat_symbol (libpthread, __pthread_mutex_init_hppa_2_0, pthread_mutex_init,
+	       GLIBC_2_0);
+#endif
+
Index: sysdeps/unix/sysv/linux/hppa/nptl/old_hppa_pthread_mutex_lock.c
===================================================================
RCS file: sysdeps/unix/sysv/linux/hppa/nptl/old_hppa_pthread_mutex_lock.c
diff -N sysdeps/unix/sysv/linux/hppa/nptl/old_hppa_pthread_mutex_lock.c
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ b/ports/sysdeps/unix/sysv/linux/hppa/nptl/old_hppa_pthread_mutex_lock.c	2 Apr 2009 02:34:03 -0000
@@ -0,0 +1,37 @@
+/* Copyright (C) 2009 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Carlos O'Donell <carlos@codesourcery.com>, 2009.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <errno.h>
+#include "pthreadP.h"
+#include <shlib-compat.h>
+
+#if SHLIB_COMPAT(libpthread, GLIBC_2_0, GLIBC_2_9)
+int
+__pthread_mutex_lock_hppa_2_0 (pthread_mutex_hppa_2_0_t *var)
+{
+  compat_lock (var);
+  compat_malloc (var);
+  compat_mutex_copy (var);
+  compat_unlock (var);
+  return __pthread_mutex_lock (var->compat);
+}
+compat_symbol (libpthread, __pthread_mutex_lock_hppa_2_0, pthread_mutex_lock,
+	       GLIBC_2_0);
+#endif
+
Index: sysdeps/unix/sysv/linux/hppa/nptl/old_hppa_pthread_mutex_timedlock.c
===================================================================
RCS file: sysdeps/unix/sysv/linux/hppa/nptl/old_hppa_pthread_mutex_timedlock.c
diff -N sysdeps/unix/sysv/linux/hppa/nptl/old_hppa_pthread_mutex_timedlock.c
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ b/ports/sysdeps/unix/sysv/linux/hppa/nptl/old_hppa_pthread_mutex_timedlock.c	2 Apr 2009 02:34:03 -0000
@@ -0,0 +1,40 @@
+/* Copyright (C) 2009 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Carlos O'Donell <carlos@codesourcery.com>, 2009.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <errno.h>
+#include <time.h>
+#include "pthreadP.h"
+
+#include <shlib-compat.h>
+
+#if SHLIB_COMPAT(libpthread, GLIBC_2_0, GLIBC_2_9)
+int
+__pthread_mutex_timedlock_hppa_2_0 (pthread_mutex_hppa_2_0_t *var,
+				    const struct timespec abs_timeout)
+{
+  compat_lock (var);
+  compat_malloc (var);
+  compat_mutex_copy (var);
+  compat_unlock (var);
+  return __pthread_mutex_timedlock (var->compat, abs_timeout);
+}
+compat_symbol (libpthread, __pthread_mutex_timedlock_hppa_2_0, pthread_mutex_timedlock,
+	       GLIBC_2_0);
+#endif
+
Index: sysdeps/unix/sysv/linux/hppa/nptl/old_hppa_pthread_mutex_trylock.c
===================================================================
RCS file: sysdeps/unix/sysv/linux/hppa/nptl/old_hppa_pthread_mutex_trylock.c
diff -N sysdeps/unix/sysv/linux/hppa/nptl/old_hppa_pthread_mutex_trylock.c
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ b/ports/sysdeps/unix/sysv/linux/hppa/nptl/old_hppa_pthread_mutex_trylock.c	2 Apr 2009 02:34:03 -0000
@@ -0,0 +1,37 @@
+/* Copyright (C) 2009 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Carlos O'Donell <carlos@codesourcery.com>, 2009.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <errno.h>
+#include "pthreadP.h"
+#include <shlib-compat.h>
+
+#if SHLIB_COMPAT(libpthread, GLIBC_2_0, GLIBC_2_9)
+int
+__pthread_mutex_trylock_hppa_2_0 (pthread_mutex_hppa_2_0_t *var)
+{
+  compat_lock (var);
+  compat_malloc (var);
+  compat_mutex_copy (var);
+  compat_unlock (var);
+  return __pthread_mutex_trylock (var->compat);
+}
+compat_symbol (libpthread, __pthread_mutex_trylock_hppa_2_0, pthread_mutex_trylock,
+	       GLIBC_2_0);
+#endif
+
Index: sysdeps/unix/sysv/linux/hppa/nptl/old_hppa_pthread_mutex_unlock.c
===================================================================
RCS file: sysdeps/unix/sysv/linux/hppa/nptl/old_hppa_pthread_mutex_unlock.c
diff -N sysdeps/unix/sysv/linux/hppa/nptl/old_hppa_pthread_mutex_unlock.c
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ b/ports/sysdeps/unix/sysv/linux/hppa/nptl/old_hppa_pthread_mutex_unlock.c	2 Apr 2009 02:34:03 -0000
@@ -0,0 +1,37 @@
+/* Copyright (C) 2009 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Carlos O'Donell <carlos@codesourcery.com>, 2009.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <errno.h>
+#include "pthreadP.h"
+#include <shlib-compat.h>
+
+#if SHLIB_COMPAT(libpthread, GLIBC_2_0, GLIBC_2_9)
+int
+__pthread_mutex_unlock_hppa_2_0 (pthread_mutex_hppa_2_0_t *var)
+{
+  compat_lock (var);
+  compat_malloc (var);
+  compat_mutex_copy (var);
+  compat_unlock (var);
+  return __pthread_mutex_unlock(var->compat);
+}
+compat_symbol (libpthread, __pthread_mutex_unlock_hppa_2_0, pthread_mutex_unlock,
+	       GLIBC_2_0);
+#endif
+
Index: sysdeps/unix/sysv/linux/hppa/nptl/old_hppa_pthread_rwlock_destroy.c
===================================================================
RCS file: sysdeps/unix/sysv/linux/hppa/nptl/old_hppa_pthread_rwlock_destroy.c
diff -N sysdeps/unix/sysv/linux/hppa/nptl/old_hppa_pthread_rwlock_destroy.c
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ b/ports/sysdeps/unix/sysv/linux/hppa/nptl/old_hppa_pthread_rwlock_destroy.c	2 Apr 2009 02:34:03 -0000
@@ -0,0 +1,40 @@
+/* Copyright (C) 2009 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Carlos O'Donell <carlos@codesourcery.com>, 2009.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <errno.h>
+#include "pthreadP.h"
+#include <shlib-compat.h>
+
+#if SHLIB_COMPAT(libpthread, GLIBC_2_0, GLIBC_2_9)
+int
+__pthread_rwlock_destroy_hppa_2_0 (pthread_rwlock_hppa_2_0_t *var)
+{
+  int ret;
+  if (compat_present (var))
+    {
+      ret = __pthread_rwlock_destroy(var->compat);
+      compat_free (var);
+      return ret;
+    }
+  return 0;
+}
+compat_symbol (libpthread, __pthread_rwlock_destroy_hppa_2_0, 
+	       pthread_rwlock_destroy, GLIBC_2_0);
+#endif
+
Index: sysdeps/unix/sysv/linux/hppa/nptl/old_hppa_pthread_rwlock_init.c
===================================================================
RCS file: sysdeps/unix/sysv/linux/hppa/nptl/old_hppa_pthread_rwlock_init.c
diff -N sysdeps/unix/sysv/linux/hppa/nptl/old_hppa_pthread_rwlock_init.c
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ b/ports/sysdeps/unix/sysv/linux/hppa/nptl/old_hppa_pthread_rwlock_init.c	2 Apr 2009 02:34:03 -0000
@@ -0,0 +1,37 @@
+/* Copyright (C) 2009 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Carlos O'Donell <carlos@codesourcery.com>, 2009.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <errno.h>
+#include "pthreadP.h"
+#include <shlib-compat.h>
+
+#if SHLIB_COMPAT(libpthread, GLIBC_2_0, GLIBC_2_9)
+int
+__pthread_rwlock_init_hppa_2_0 (pthread_rwlock_hppa_2_0_t *var,
+			       const pthread_rwlockattr_t *attr)
+{
+  /* All other compat functions expect an initialized lock.  */
+  compat_init (var);
+  compat_malloc_nolock (var);
+  return __pthread_rwlock_init (var->compat, attr);
+}
+compat_symbol (libpthread, __pthread_rwlock_init_hppa_2_0, pthread_rwlock_init,
+	       GLIBC_2_0);
+#endif
+
Index: sysdeps/unix/sysv/linux/hppa/nptl/old_hppa_pthread_rwlock_rdlock.c
===================================================================
RCS file: sysdeps/unix/sysv/linux/hppa/nptl/old_hppa_pthread_rwlock_rdlock.c
diff -N sysdeps/unix/sysv/linux/hppa/nptl/old_hppa_pthread_rwlock_rdlock.c
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ b/ports/sysdeps/unix/sysv/linux/hppa/nptl/old_hppa_pthread_rwlock_rdlock.c	2 Apr 2009 02:34:03 -0000
@@ -0,0 +1,37 @@
+/* Copyright (C) 2009 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Carlos O'Donell <carlos@codesourcery.com>, 2009.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <errno.h>
+#include "pthreadP.h"
+#include <shlib-compat.h>
+
+#if SHLIB_COMPAT(libpthread, GLIBC_2_0, GLIBC_2_9)
+int
+__pthread_rwlock_rdlock_hppa_2_0 (pthread_rwlock_hppa_2_0_t *var)
+{
+  compat_lock (var);
+  compat_malloc (var);
+  compat_rwlock_copy (var);
+  compat_unlock (var);
+  return __pthread_rwlock_rdlock (var->compat);
+}
+compat_symbol (libpthread, __pthread_rwlock_rdlock_hppa_2_0, pthread_rwlock_rdlock,
+	       GLIBC_2_0);
+#endif
+
Index: sysdeps/unix/sysv/linux/hppa/nptl/old_hppa_pthread_rwlock_timedrdlock.c
===================================================================
RCS file: sysdeps/unix/sysv/linux/hppa/nptl/old_hppa_pthread_rwlock_timedrdlock.c
diff -N sysdeps/unix/sysv/linux/hppa/nptl/old_hppa_pthread_rwlock_timedrdlock.c
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ b/ports/sysdeps/unix/sysv/linux/hppa/nptl/old_hppa_pthread_rwlock_timedrdlock.c	2 Apr 2009 02:34:03 -0000
@@ -0,0 +1,40 @@
+/* Copyright (C) 2009 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Carlos O'Donell <carlos@codesourcery.com>, 2009.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <errno.h>
+#include <time.h>
+#include "pthreadP.h"
+
+#include <shlib-compat.h>
+
+#if SHLIB_COMPAT(libpthread, GLIBC_2_0, GLIBC_2_9)
+int
+__pthread_rwlock_timedrdlock_hppa_2_0 (pthread_rwlock_hppa_2_0_t *var,
+				       const struct timespec *abs_timeout)
+{
+  compat_lock (var);
+  compat_malloc (var);
+  compat_rwlock_copy (var);
+  compat_unlock (var);
+  return __pthread_rwlock_timedrdlock (var->compat, abs_timeout);
+}
+compat_symbol (libpthread, __pthread_rwlock_timedrdlock_hppa_2_0, pthread_rwlock_timedrdlock,
+	       GLIBC_2_0);
+#endif
+
Index: sysdeps/unix/sysv/linux/hppa/nptl/old_hppa_pthread_rwlock_timedwrlock.c
===================================================================
RCS file: sysdeps/unix/sysv/linux/hppa/nptl/old_hppa_pthread_rwlock_timedwrlock.c
diff -N sysdeps/unix/sysv/linux/hppa/nptl/old_hppa_pthread_rwlock_timedwrlock.c
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ b/ports/sysdeps/unix/sysv/linux/hppa/nptl/old_hppa_pthread_rwlock_timedwrlock.c	2 Apr 2009 02:34:03 -0000
@@ -0,0 +1,40 @@
+/* Copyright (C) 2009 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Carlos O'Donell <carlos@codesourcery.com>, 2009.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <errno.h>
+#include <time.h>
+#include "pthreadP.h"
+
+#include <shlib-compat.h>
+
+#if SHLIB_COMPAT(libpthread, GLIBC_2_0, GLIBC_2_9)
+int
+__pthread_rwlock_timedwrlock_hppa_2_0 (pthread_rwlock_hppa_2_0_t *var,
+				       const struct timespec *abs_timeout)
+{
+  compat_lock (var);
+  compat_malloc (var);
+  compat_rwlock_copy (var);
+  compat_unlock (var);
+  return __pthread_rwlock_timedwrlock (var->compat, abs_timeout);
+}
+compat_symbol (libpthread, __pthread_rwlock_timedwrlock_hppa_2_0, pthread_rwlock_timedwrlock,
+	       GLIBC_2_0);
+#endif
+
Index: sysdeps/unix/sysv/linux/hppa/nptl/old_hppa_pthread_rwlock_tryrdlock.c
===================================================================
RCS file: sysdeps/unix/sysv/linux/hppa/nptl/old_hppa_pthread_rwlock_tryrdlock.c
diff -N sysdeps/unix/sysv/linux/hppa/nptl/old_hppa_pthread_rwlock_tryrdlock.c
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ b/ports/sysdeps/unix/sysv/linux/hppa/nptl/old_hppa_pthread_rwlock_tryrdlock.c	2 Apr 2009 02:34:03 -0000
@@ -0,0 +1,37 @@
+/* Copyright (C) 2009 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Carlos O'Donell <carlos@codesourcery.com>, 2009.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <errno.h>
+#include "pthreadP.h"
+#include <shlib-compat.h>
+
+#if SHLIB_COMPAT(libpthread, GLIBC_2_0, GLIBC_2_9)
+int
+__pthread_rwlock_tryrdlock_hppa_2_0 (pthread_rwlock_hppa_2_0_t *var)
+{
+  compat_lock (var);
+  compat_malloc (var);
+  compat_rwlock_copy (var);
+  compat_unlock (var);
+  return __pthread_rwlock_tryrdlock (var->compat);
+}
+compat_symbol (libpthread, __pthread_rwlock_tryrdlock_hppa_2_0, pthread_rwlock_tryrdlock,
+	       GLIBC_2_0);
+#endif
+
Index: sysdeps/unix/sysv/linux/hppa/nptl/old_hppa_pthread_rwlock_trywrlock.c
===================================================================
RCS file: sysdeps/unix/sysv/linux/hppa/nptl/old_hppa_pthread_rwlock_trywrlock.c
diff -N sysdeps/unix/sysv/linux/hppa/nptl/old_hppa_pthread_rwlock_trywrlock.c
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ b/ports/sysdeps/unix/sysv/linux/hppa/nptl/old_hppa_pthread_rwlock_trywrlock.c	2 Apr 2009 02:34:03 -0000
@@ -0,0 +1,37 @@
+/* Copyright (C) 2009 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Carlos O'Donell <carlos@codesourcery.com>, 2009.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <errno.h>
+#include "pthreadP.h"
+#include <shlib-compat.h>
+
+#if SHLIB_COMPAT(libpthread, GLIBC_2_0, GLIBC_2_9)
+int
+__pthread_rwlock_trywrlock_hppa_2_0 (pthread_rwlock_hppa_2_0_t *var)
+{
+  compat_lock (var);
+  compat_malloc (var);
+  compat_rwlock_copy (var);
+  compat_unlock (var);
+  return __pthread_rwlock_trywrlock (var->compat);
+}
+compat_symbol (libpthread, __pthread_rwlock_trywrlock_hppa_2_0, pthread_rwlock_trywrlock,
+	       GLIBC_2_0);
+#endif
+
Index: sysdeps/unix/sysv/linux/hppa/nptl/old_hppa_pthread_rwlock_unlock.c
===================================================================
RCS file: sysdeps/unix/sysv/linux/hppa/nptl/old_hppa_pthread_rwlock_unlock.c
diff -N sysdeps/unix/sysv/linux/hppa/nptl/old_hppa_pthread_rwlock_unlock.c
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ b/ports/sysdeps/unix/sysv/linux/hppa/nptl/old_hppa_pthread_rwlock_unlock.c	2 Apr 2009 02:34:03 -0000
@@ -0,0 +1,37 @@
+/* Copyright (C) 2009 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Carlos O'Donell <carlos@codesourcery.com>, 2009.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <errno.h>
+#include "pthreadP.h"
+#include <shlib-compat.h>
+
+#if SHLIB_COMPAT(libpthread, GLIBC_2_0, GLIBC_2_9)
+int
+__pthread_rwlock_unlock_hppa_2_0 (pthread_rwlock_hppa_2_0_t *var)
+{
+  compat_lock (var);
+  compat_malloc (var);
+  compat_rwlock_copy (var);
+  compat_unlock (var);
+  return __pthread_rwlock_unlock (var->compat);
+}
+compat_symbol (libpthread, __pthread_rwlock_unlock_hppa_2_0, pthread_rwlock_unlock,
+	       GLIBC_2_0);
+#endif
+
Index: sysdeps/unix/sysv/linux/hppa/nptl/old_hppa_pthread_rwlock_wrlock.c
===================================================================
RCS file: sysdeps/unix/sysv/linux/hppa/nptl/old_hppa_pthread_rwlock_wrlock.c
diff -N sysdeps/unix/sysv/linux/hppa/nptl/old_hppa_pthread_rwlock_wrlock.c
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ b/ports/sysdeps/unix/sysv/linux/hppa/nptl/old_hppa_pthread_rwlock_wrlock.c	2 Apr 2009 02:34:03 -0000
@@ -0,0 +1,37 @@
+/* Copyright (C) 2009 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Carlos O'Donell <carlos@codesourcery.com>, 2009.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <errno.h>
+#include "pthreadP.h"
+#include <shlib-compat.h>
+
+#if SHLIB_COMPAT(libpthread, GLIBC_2_0, GLIBC_2_9)
+int
+__pthread_rwlock_wrlock_hppa_2_0 (pthread_rwlock_hppa_2_0_t *var)
+{
+  compat_lock (var);
+  compat_malloc (var);
+  compat_rwlock_copy (var);
+  compat_unlock (var);
+  return __pthread_rwlock_wrlock (var->compat);
+}
+compat_symbol (libpthread, __pthread_rwlock_wrlock_hppa_2_0, pthread_rwlock_wrlock,
+	       GLIBC_2_0);
+#endif
+
Index: sysdeps/unix/sysv/linux/hppa/nptl/pthread-functions.h
===================================================================
RCS file: sysdeps/unix/sysv/linux/hppa/nptl/pthread-functions.h
diff -N sysdeps/unix/sysv/linux/hppa/nptl/pthread-functions.h
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ b/ports/sysdeps/unix/sysv/linux/hppa/nptl/pthread-functions.h	2 Apr 2009 02:34:03 -0000
@@ -0,0 +1,133 @@
+/* Copyright (C) 2003, 2004, 2005, 2006, 2007, 2009 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Ulrich Drepper <drepper@redhat.com>, 2003.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _PTHREAD_FUNCTIONS_H
+#define _PTHREAD_FUNCTIONS_H	1
+
+#include <pthread.h>
+#include <setjmp.h>
+#include <internaltypes.h>
+#include <sysdep.h>
+
+struct xid_command;
+
+/* Data type shared with libc.  The libc uses it to pass on calls to
+   the thread functions.  */
+struct pthread_functions
+{
+  int (*ptr_pthread_attr_destroy) (pthread_attr_t *);
+  int (*ptr___pthread_attr_init_2_0) (pthread_attr_t *);
+  int (*ptr___pthread_attr_init_2_1) (pthread_attr_t *);
+  int (*ptr_pthread_attr_getdetachstate) (const pthread_attr_t *, int *);
+  int (*ptr_pthread_attr_setdetachstate) (pthread_attr_t *, int);
+  int (*ptr_pthread_attr_getinheritsched) (const pthread_attr_t *, int *);
+  int (*ptr_pthread_attr_setinheritsched) (pthread_attr_t *, int);
+  int (*ptr_pthread_attr_getschedparam) (const pthread_attr_t *,
+					 struct sched_param *);
+  int (*ptr_pthread_attr_setschedparam) (pthread_attr_t *,
+					 const struct sched_param *);
+  int (*ptr_pthread_attr_getschedpolicy) (const pthread_attr_t *, int *);
+  int (*ptr_pthread_attr_setschedpolicy) (pthread_attr_t *, int);
+  int (*ptr_pthread_attr_getscope) (const pthread_attr_t *, int *);
+  int (*ptr_pthread_attr_setscope) (pthread_attr_t *, int);
+  int (*ptr_pthread_condattr_destroy) (pthread_condattr_t *);
+  int (*ptr_pthread_condattr_init) (pthread_condattr_t *);
+  int (*ptr___pthread_cond_broadcast) (pthread_cond_t *);
+  int (*ptr___pthread_cond_destroy) (pthread_cond_t *);
+  int (*ptr___pthread_cond_init) (pthread_cond_t *,
+				  const pthread_condattr_t *);
+  int (*ptr___pthread_cond_signal) (pthread_cond_t *);
+  int (*ptr___pthread_cond_wait) (pthread_cond_t *, pthread_mutex_t *);
+  int (*ptr___pthread_cond_timedwait) (pthread_cond_t *, pthread_mutex_t *,
+				       const struct timespec *);
+  int (*ptr___pthread_cond_broadcast_2_0) (pthread_cond_2_0_t *);
+  int (*ptr___pthread_cond_destroy_2_0) (pthread_cond_2_0_t *);
+  int (*ptr___pthread_cond_init_2_0) (pthread_cond_2_0_t *,
+				      const pthread_condattr_t *);
+  int (*ptr___pthread_cond_signal_2_0) (pthread_cond_2_0_t *);
+  int (*ptr___pthread_cond_wait_2_0) (pthread_cond_2_0_t *, pthread_mutex_t *);
+  int (*ptr___pthread_cond_timedwait_2_0) (pthread_cond_2_0_t *,
+					   pthread_mutex_t *,
+					   const struct timespec *);
+  int (*ptr___pthread_cond_broadcast_hppa_2_3_2) (pthread_cond_hppa_2_3_2_t *);
+  int (*ptr___pthread_cond_destroy_hppa_2_3_2) (pthread_cond_hppa_2_3_2_t *);
+  int (*ptr___pthread_cond_init_hppa_2_3_2) (pthread_cond_hppa_2_3_2_t *,
+				      const pthread_condattr_t *);
+  int (*ptr___pthread_cond_signal_hppa_2_3_2) (pthread_cond_hppa_2_3_2_t *);
+  int (*ptr___pthread_cond_wait_hppa_2_3_2) (pthread_cond_hppa_2_3_2_t *, pthread_mutex_hppa_2_0_t *);
+  int (*ptr___pthread_cond_timedwait_hppa_2_3_2) (pthread_cond_hppa_2_3_2_t *,
+					   pthread_mutex_t *,
+					   const struct timespec *);
+  int (*ptr_pthread_equal) (pthread_t, pthread_t);
+  void (*ptr___pthread_exit) (void *);
+  int (*ptr_pthread_getschedparam) (pthread_t, int *, struct sched_param *);
+  int (*ptr_pthread_setschedparam) (pthread_t, int,
+				    const struct sched_param *);
+  int (*ptr_pthread_mutex_destroy) (pthread_mutex_t *);
+  int (*ptr_pthread_mutex_init) (pthread_mutex_t *,
+				 const pthread_mutexattr_t *);
+  int (*ptr_pthread_mutex_lock) (pthread_mutex_t *);
+  int (*ptr_pthread_mutex_unlock) (pthread_mutex_t *);
+
+  int (*ptr___pthread_mutex_destroy_hppa_2_0) (pthread_mutex_hppa_2_0_t *);
+  int (*ptr___pthread_mutex_init_hppa_2_0) (pthread_mutex_hppa_2_0_t *,
+				 const pthread_mutexattr_t *);
+  int (*ptr___pthread_mutex_lock_hppa_2_0) (pthread_mutex_hppa_2_0_t *);
+  int (*ptr___pthread_mutex_unlock_hppa_2_0) (pthread_mutex_hppa_2_0_t *);
+
+  pthread_t (*ptr_pthread_self) (void);
+  int (*ptr_pthread_setcancelstate) (int, int *);
+  int (*ptr_pthread_setcanceltype) (int, int *);
+  void (*ptr___pthread_cleanup_upto) (__jmp_buf, char *);
+  int (*ptr___pthread_once) (pthread_once_t *, void (*) (void));
+  int (*ptr___pthread_rwlock_rdlock) (pthread_rwlock_t *);
+  int (*ptr___pthread_rwlock_wrlock) (pthread_rwlock_t *);
+  int (*ptr___pthread_rwlock_unlock) (pthread_rwlock_t *);
+  int (*ptr___pthread_key_create) (pthread_key_t *, void (*) (void *));
+  void *(*ptr___pthread_getspecific) (pthread_key_t);
+  int (*ptr___pthread_setspecific) (pthread_key_t, const void *);
+  void (*ptr__pthread_cleanup_push_defer) (struct _pthread_cleanup_buffer *,
+					   void (*) (void *), void *);
+  void (*ptr__pthread_cleanup_pop_restore) (struct _pthread_cleanup_buffer *,
+					    int);
+#define HAVE_PTR_NTHREADS
+  unsigned int *ptr_nthreads;
+  void (*ptr___pthread_unwind) (__pthread_unwind_buf_t *)
+       __attribute ((noreturn)) __cleanup_fct_attribute;
+  void (*ptr__nptl_deallocate_tsd) (void);
+  int (*ptr__nptl_setxid) (struct xid_command *);
+  void (*ptr_freeres) (void);
+};
+
+/* Variable in libc.so.  */
+extern struct pthread_functions __libc_pthread_functions attribute_hidden;
+extern int __libc_pthread_functions_init attribute_hidden;
+
+#ifdef PTR_DEMANGLE
+# define PTHFCT_CALL(fct, params) \
+  ({ __typeof (__libc_pthread_functions.fct) __p;			      \
+     __p = __libc_pthread_functions.fct;				      \
+     PTR_DEMANGLE (__p);						      \
+     __p params; })
+#else
+# define PTHFCT_CALL(fct, params) \
+  __libc_pthread_functions.fct params
+#endif
+
+#endif	/* pthread-functions.h */
Index: sysdeps/unix/sysv/linux/hppa/nptl/pthreadP.h
===================================================================
RCS file: sysdeps/unix/sysv/linux/hppa/nptl/pthreadP.h
diff -N sysdeps/unix/sysv/linux/hppa/nptl/pthreadP.h
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ b/ports/sysdeps/unix/sysv/linux/hppa/nptl/pthreadP.h	2 Apr 2009 02:34:03 -0000
@@ -0,0 +1,621 @@
+/* Copyright (C) 2002-2007, 2009 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Ulrich Drepper <drepper@redhat.com>, 2002.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _PTHREADP_H
+#define _PTHREADP_H	1
+
+#include <pthread.h>
+#include <setjmp.h>
+#include <stdbool.h>
+#include <sys/syscall.h>
+#include "descr.h"
+#include <tls.h>
+#include <lowlevellock.h>
+#include <stackinfo.h>
+#include <internaltypes.h>
+#include <pthread-functions.h>
+#include <atomic.h>
+#include <kernel-features.h>
+
+
+/* Atomic operations on TLS memory.  */
+#ifndef THREAD_ATOMIC_CMPXCHG_VAL
+# define THREAD_ATOMIC_CMPXCHG_VAL(descr, member, new, old) \
+  atomic_compare_and_exchange_val_acq (&(descr)->member, new, old)
+#endif
+
+#ifndef THREAD_ATOMIC_BIT_SET
+# define THREAD_ATOMIC_BIT_SET(descr, member, bit) \
+  atomic_bit_set (&(descr)->member, bit)
+#endif
+
+
+/* Adaptive mutex definitions.  */
+#ifndef MAX_ADAPTIVE_COUNT
+# define MAX_ADAPTIVE_COUNT 100
+#endif
+
+
+/* Magic cookie representing robust mutex with dead owner.  */
+#define PTHREAD_MUTEX_INCONSISTENT	INT_MAX
+/* Magic cookie representing not recoverable robust mutex.  */
+#define PTHREAD_MUTEX_NOTRECOVERABLE	(INT_MAX - 1)
+
+
+/* Internal mutex type value.  */
+enum
+{
+  PTHREAD_MUTEX_KIND_MASK_NP = 3,
+  PTHREAD_MUTEX_ROBUST_NORMAL_NP = 16,
+  PTHREAD_MUTEX_ROBUST_RECURSIVE_NP
+  = PTHREAD_MUTEX_ROBUST_NORMAL_NP | PTHREAD_MUTEX_RECURSIVE_NP,
+  PTHREAD_MUTEX_ROBUST_ERRORCHECK_NP
+  = PTHREAD_MUTEX_ROBUST_NORMAL_NP | PTHREAD_MUTEX_ERRORCHECK_NP,
+  PTHREAD_MUTEX_ROBUST_ADAPTIVE_NP
+  = PTHREAD_MUTEX_ROBUST_NORMAL_NP | PTHREAD_MUTEX_ADAPTIVE_NP,
+  PTHREAD_MUTEX_PRIO_INHERIT_NP = 32,
+  PTHREAD_MUTEX_PI_NORMAL_NP
+  = PTHREAD_MUTEX_PRIO_INHERIT_NP | PTHREAD_MUTEX_NORMAL,
+  PTHREAD_MUTEX_PI_RECURSIVE_NP
+  = PTHREAD_MUTEX_PRIO_INHERIT_NP | PTHREAD_MUTEX_RECURSIVE_NP,
+  PTHREAD_MUTEX_PI_ERRORCHECK_NP
+  = PTHREAD_MUTEX_PRIO_INHERIT_NP | PTHREAD_MUTEX_ERRORCHECK_NP,
+  PTHREAD_MUTEX_PI_ADAPTIVE_NP
+  = PTHREAD_MUTEX_PRIO_INHERIT_NP | PTHREAD_MUTEX_ADAPTIVE_NP,
+  PTHREAD_MUTEX_PI_ROBUST_NORMAL_NP
+  = PTHREAD_MUTEX_PRIO_INHERIT_NP | PTHREAD_MUTEX_ROBUST_NORMAL_NP,
+  PTHREAD_MUTEX_PI_ROBUST_RECURSIVE_NP
+  = PTHREAD_MUTEX_PRIO_INHERIT_NP | PTHREAD_MUTEX_ROBUST_RECURSIVE_NP,
+  PTHREAD_MUTEX_PI_ROBUST_ERRORCHECK_NP
+  = PTHREAD_MUTEX_PRIO_INHERIT_NP | PTHREAD_MUTEX_ROBUST_ERRORCHECK_NP,
+  PTHREAD_MUTEX_PI_ROBUST_ADAPTIVE_NP
+  = PTHREAD_MUTEX_PRIO_INHERIT_NP | PTHREAD_MUTEX_ROBUST_ADAPTIVE_NP,
+  PTHREAD_MUTEX_PRIO_PROTECT_NP = 64,
+  PTHREAD_MUTEX_PP_NORMAL_NP
+  = PTHREAD_MUTEX_PRIO_PROTECT_NP | PTHREAD_MUTEX_NORMAL,
+  PTHREAD_MUTEX_PP_RECURSIVE_NP
+  = PTHREAD_MUTEX_PRIO_PROTECT_NP | PTHREAD_MUTEX_RECURSIVE_NP,
+  PTHREAD_MUTEX_PP_ERRORCHECK_NP
+  = PTHREAD_MUTEX_PRIO_PROTECT_NP | PTHREAD_MUTEX_ERRORCHECK_NP,
+  PTHREAD_MUTEX_PP_ADAPTIVE_NP
+  = PTHREAD_MUTEX_PRIO_PROTECT_NP | PTHREAD_MUTEX_ADAPTIVE_NP
+};
+#define PTHREAD_MUTEX_PSHARED_BIT 128
+
+#define PTHREAD_MUTEX_TYPE(m) \
+  ((m)->__data.__kind & 127)
+
+#if LLL_PRIVATE == 0 && LLL_SHARED == 128
+# define PTHREAD_MUTEX_PSHARED(m) \
+  ((m)->__data.__kind & 128)
+#else
+# define PTHREAD_MUTEX_PSHARED(m) \
+  (((m)->__data.__kind & 128) ? LLL_SHARED : LLL_PRIVATE)
+#endif
+
+/* The kernel when waking robust mutexes on exit never uses
+   FUTEX_PRIVATE_FLAG FUTEX_WAKE.  */
+#define PTHREAD_ROBUST_MUTEX_PSHARED(m) LLL_SHARED
+
+/* Ceiling in __data.__lock.  __data.__lock is signed, so don't
+   use the MSB bit in there, but in the mask also include that bit,
+   so that the compiler can optimize & PTHREAD_MUTEX_PRIO_CEILING_MASK
+   masking if the value is then shifted down by
+   PTHREAD_MUTEX_PRIO_CEILING_SHIFT.  */
+#define PTHREAD_MUTEX_PRIO_CEILING_SHIFT	19
+#define PTHREAD_MUTEX_PRIO_CEILING_MASK		0xfff80000
+
+
+/* Flags in mutex attr.  */
+#define PTHREAD_MUTEXATTR_PROTOCOL_SHIFT	28
+#define PTHREAD_MUTEXATTR_PROTOCOL_MASK		0x30000000
+#define PTHREAD_MUTEXATTR_PRIO_CEILING_SHIFT	12
+#define PTHREAD_MUTEXATTR_PRIO_CEILING_MASK	0x00fff000
+#define PTHREAD_MUTEXATTR_FLAG_ROBUST		0x40000000
+#define PTHREAD_MUTEXATTR_FLAG_PSHARED		0x80000000
+#define PTHREAD_MUTEXATTR_FLAG_BITS \
+  (PTHREAD_MUTEXATTR_FLAG_ROBUST | PTHREAD_MUTEXATTR_FLAG_PSHARED \
+   | PTHREAD_MUTEXATTR_PROTOCOL_MASK | PTHREAD_MUTEXATTR_PRIO_CEILING_MASK)
+
+
+/* Check whether rwlock prefers readers.   */
+#define PTHREAD_RWLOCK_PREFER_READER_P(rwlock) \
+  ((rwlock)->__data.__flags == 0)
+
+
+/* Bits used in robust mutex implementation.  */
+#define FUTEX_WAITERS		0x80000000
+#define FUTEX_OWNER_DIED	0x40000000
+#define FUTEX_TID_MASK		0x3fffffff
+
+
+/* Internal variables.  */
+
+
+/* Default stack size.  */
+extern size_t __default_stacksize attribute_hidden;
+
+/* Size and alignment of static TLS block.  */
+extern size_t __static_tls_size attribute_hidden;
+extern size_t __static_tls_align_m1 attribute_hidden;
+
+/* Flag whether the machine is SMP or not.  */
+extern int __is_smp attribute_hidden;
+
+/* Thread descriptor handling.  */
+extern list_t __stack_user;
+hidden_proto (__stack_user)
+
+/* Attribute handling.  */
+extern struct pthread_attr *__attr_list attribute_hidden;
+extern int __attr_list_lock attribute_hidden;
+
+/* First available RT signal.  */
+extern int __current_sigrtmin attribute_hidden;
+/* Last available RT signal.  */
+extern int __current_sigrtmax attribute_hidden;
+
+/* Concurrency handling.  */
+extern int __concurrency_level attribute_hidden;
+
+/* Thread-local data key handling.  */
+extern struct pthread_key_struct __pthread_keys[PTHREAD_KEYS_MAX];
+hidden_proto (__pthread_keys)
+
+/* Number of threads running.  */
+extern unsigned int __nptl_nthreads attribute_hidden;
+
+#ifndef __ASSUME_SET_ROBUST_LIST
+/* Negative if we do not have the system call and we can use it.  */
+extern int __set_robust_list_avail attribute_hidden;
+#endif
+
+/* Thread Priority Protection.  */
+extern int __sched_fifo_min_prio attribute_hidden;
+extern int __sched_fifo_max_prio attribute_hidden;
+extern void __init_sched_fifo_prio (void) attribute_hidden;
+extern int __pthread_tpp_change_priority (int prev_prio, int new_prio)
+     attribute_hidden;
+extern int __pthread_current_priority (void) attribute_hidden;
+
+/* The library can run in debugging mode where it performs a lot more
+   tests.  */
+extern int __pthread_debug attribute_hidden;
+/** For now disable debugging support.  */
+#if 0
+# define DEBUGGING_P __builtin_expect (__pthread_debug, 0)
+# define INVALID_TD_P(pd) (DEBUGGING_P && __find_in_stack_list (pd) == NULL)
+# define INVALID_NOT_TERMINATED_TD_P(pd) INVALID_TD_P (pd)
+#else
+# define DEBUGGING_P 0
+/* Simplified test.  This will not catch all invalid descriptors but
+   is better than nothing.  And if the test triggers the thread
+   descriptor is guaranteed to be invalid.  */
+# define INVALID_TD_P(pd) __builtin_expect ((pd)->tid <= 0, 0)
+# define INVALID_NOT_TERMINATED_TD_P(pd) __builtin_expect ((pd)->tid < 0, 0)
+#endif
+
+
+/* Cancellation test.  */
+#define CANCELLATION_P(self) \
+  do {									      \
+    int cancelhandling = THREAD_GETMEM (self, cancelhandling);		      \
+    if (CANCEL_ENABLED_AND_CANCELED (cancelhandling))			      \
+      {									      \
+	THREAD_SETMEM (self, result, PTHREAD_CANCELED);			      \
+	__do_cancel ();							      \
+      }									      \
+  } while (0)
+
+
+extern void __pthread_unwind (__pthread_unwind_buf_t *__buf)
+     __cleanup_fct_attribute __attribute ((__noreturn__))
+#if !defined SHARED && !defined IS_IN_libpthread
+     weak_function
+#endif
+     ;
+extern void __pthread_unwind_next (__pthread_unwind_buf_t *__buf)
+     __cleanup_fct_attribute __attribute ((__noreturn__))
+#ifndef SHARED
+     weak_function
+#endif
+     ;
+extern void __pthread_register_cancel (__pthread_unwind_buf_t *__buf)
+     __cleanup_fct_attribute;
+extern void __pthread_unregister_cancel (__pthread_unwind_buf_t *__buf)
+     __cleanup_fct_attribute;
+#if defined NOT_IN_libc && defined IS_IN_libpthread
+hidden_proto (__pthread_unwind)
+hidden_proto (__pthread_unwind_next)
+hidden_proto (__pthread_register_cancel)
+hidden_proto (__pthread_unregister_cancel)
+# ifdef SHARED
+extern void attribute_hidden pthread_cancel_init (void);
+extern void __unwind_freeres (void);
+# endif
+#endif
+
+
+/* Called when a thread reacts on a cancellation request.  */
+static inline void
+__attribute ((noreturn, always_inline))
+__do_cancel (void)
+{
+  struct pthread *self = THREAD_SELF;
+
+  /* Make sure we get no more cancellations.  */
+  THREAD_ATOMIC_BIT_SET (self, cancelhandling, EXITING_BIT);
+
+  __pthread_unwind ((__pthread_unwind_buf_t *)
+		    THREAD_GETMEM (self, cleanup_jmp_buf));
+}
+
+
+/* Set cancellation mode to asynchronous.  */
+#define CANCEL_ASYNC() \
+  __pthread_enable_asynccancel ()
+/* Reset to previous cancellation mode.  */
+#define CANCEL_RESET(oldtype) \
+  __pthread_disable_asynccancel (oldtype)
+
+#if !defined NOT_IN_libc
+/* Same as CANCEL_ASYNC, but for use in libc.so.  */
+# define LIBC_CANCEL_ASYNC() \
+  __libc_enable_asynccancel ()
+/* Same as CANCEL_RESET, but for use in libc.so.  */
+# define LIBC_CANCEL_RESET(oldtype) \
+  __libc_disable_asynccancel (oldtype)
+# define LIBC_CANCEL_HANDLED() \
+  __asm (".globl " __SYMBOL_PREFIX "__libc_enable_asynccancel"); \
+  __asm (".globl " __SYMBOL_PREFIX "__libc_disable_asynccancel")
+#elif defined NOT_IN_libc && defined IS_IN_libpthread
+# define LIBC_CANCEL_ASYNC() CANCEL_ASYNC ()
+# define LIBC_CANCEL_RESET(val) CANCEL_RESET (val)
+# define LIBC_CANCEL_HANDLED() \
+  __asm (".globl " __SYMBOL_PREFIX "__pthread_enable_asynccancel"); \
+  __asm (".globl " __SYMBOL_PREFIX "__pthread_disable_asynccancel")
+#elif defined NOT_IN_libc && defined IS_IN_librt
+# define LIBC_CANCEL_ASYNC() \
+  __librt_enable_asynccancel ()
+# define LIBC_CANCEL_RESET(val) \
+  __librt_disable_asynccancel (val)
+# define LIBC_CANCEL_HANDLED() \
+  __asm (".globl " __SYMBOL_PREFIX "__librt_enable_asynccancel"); \
+  __asm (".globl " __SYMBOL_PREFIX "__librt_disable_asynccancel")
+#else
+# define LIBC_CANCEL_ASYNC()	0 /* Just a dummy value.  */
+# define LIBC_CANCEL_RESET(val)	((void)(val)) /* Nothing, but evaluate it.  */
+# define LIBC_CANCEL_HANDLED()	/* Nothing.  */
+#endif
+
+/* The signal used for asynchronous cancelation.  */
+#define SIGCANCEL	__SIGRTMIN
+
+
+/* Signal needed for the kernel-supported POSIX timer implementation.
+   We can reuse the cancellation signal since we can distinguish
+   cancellation from timer expirations.  */
+#define SIGTIMER	SIGCANCEL
+
+
+/* Signal used to implement the setuid et.al. functions.  */
+#define SIGSETXID	(__SIGRTMIN + 1)
+
+/* Used to communicate with signal handler.  */
+extern struct xid_command *__xidcmd attribute_hidden;
+
+
+/* Internal prototypes.  */
+
+/* Thread list handling.  */
+extern struct pthread *__find_in_stack_list (struct pthread *pd)
+     attribute_hidden internal_function;
+
+/* Deallocate a thread's stack after optionally making sure the thread
+   descriptor is still valid.  */
+extern void __free_tcb (struct pthread *pd) attribute_hidden internal_function;
+
+/* Free allocated stack.  */
+extern void __deallocate_stack (struct pthread *pd)
+     attribute_hidden internal_function;
+
+/* Mark all the stacks except for the current one as available.  This
+   function also re-initializes the lock for the stack cache.  */
+extern void __reclaim_stacks (void) attribute_hidden;
+
+/* Make all threads's stacks executable.  */
+extern int __make_stacks_executable (void **stack_endp)
+     internal_function attribute_hidden;
+
+/* longjmp handling.  */
+extern void __pthread_cleanup_upto (__jmp_buf target, char *targetframe);
+#if defined NOT_IN_libc && defined IS_IN_libpthread
+hidden_proto (__pthread_cleanup_upto)
+#endif
+
+
+/* Functions with versioned interfaces.  */
+extern int __pthread_create_2_1 (pthread_t *newthread,
+				 const pthread_attr_t *attr,
+				 void *(*start_routine) (void *), void *arg);
+extern int __pthread_create_2_0 (pthread_t *newthread,
+				 const pthread_attr_t *attr,
+				 void *(*start_routine) (void *), void *arg);
+extern int __pthread_attr_init_2_1 (pthread_attr_t *attr);
+extern int __pthread_attr_init_2_0 (pthread_attr_t *attr);
+
+
+/* Event handlers for libthread_db interface.  */
+extern void __nptl_create_event (void);
+extern void __nptl_death_event (void);
+hidden_proto (__nptl_create_event)
+hidden_proto (__nptl_death_event)
+
+/* Register the generation counter in the libpthread with the libc.  */
+#ifdef TLS_MULTIPLE_THREADS_IN_TCB
+extern void __libc_pthread_init (unsigned long int *ptr,
+				 void (*reclaim) (void),
+				 const struct pthread_functions *functions)
+     internal_function;
+#else
+extern int *__libc_pthread_init (unsigned long int *ptr,
+				 void (*reclaim) (void),
+				 const struct pthread_functions *functions)
+     internal_function;
+
+/* Variable set to a nonzero value if more than one thread runs or ran.  */
+extern int __pthread_multiple_threads attribute_hidden;
+/* Pointer to the corresponding variable in libc.  */
+extern int *__libc_multiple_threads_ptr attribute_hidden;
+#endif
+
+/* Find a thread given its TID.  */
+extern struct pthread *__find_thread_by_id (pid_t tid) attribute_hidden
+#ifdef SHARED
+;
+#else
+weak_function;
+#define __find_thread_by_id(tid) \
+  (__find_thread_by_id ? (__find_thread_by_id) (tid) : (struct pthread *) NULL)
+#endif
+
+extern void __pthread_init_static_tls (struct link_map *) attribute_hidden;
+
+
+/* Namespace save aliases.  */
+extern int __pthread_getschedparam (pthread_t thread_id, int *policy,
+				    struct sched_param *param);
+extern int __pthread_setschedparam (pthread_t thread_id, int policy,
+				    const struct sched_param *param);
+extern int __pthread_setcancelstate (int state, int *oldstate);
+extern int __pthread_mutex_init (pthread_mutex_t *__mutex,
+				 __const pthread_mutexattr_t *__mutexattr);
+extern int __pthread_mutex_init_internal (pthread_mutex_t *__mutex,
+					  __const pthread_mutexattr_t *__mutexattr)
+     attribute_hidden;
+extern int __pthread_mutex_destroy (pthread_mutex_t *__mutex);
+extern int __pthread_mutex_destroy_internal (pthread_mutex_t *__mutex)
+     attribute_hidden;
+extern int __pthread_mutex_trylock (pthread_mutex_t *_mutex);
+extern int __pthread_mutex_lock (pthread_mutex_t *__mutex);
+extern int __pthread_mutex_lock_internal (pthread_mutex_t *__mutex)
+     attribute_hidden;
+extern int __pthread_mutex_cond_lock (pthread_mutex_t *__mutex)
+     attribute_hidden internal_function;
+extern int __pthread_mutex_unlock (pthread_mutex_t *__mutex);
+extern int __pthread_mutex_unlock_internal (pthread_mutex_t *__mutex)
+     attribute_hidden;
+extern int __pthread_mutex_unlock_usercnt (pthread_mutex_t *__mutex,
+					   int __decr)
+     attribute_hidden internal_function;
+
+extern int __pthread_mutex_init_hppa_2_0 (pthread_mutex_hppa_2_0_t *__mutex,
+				 __const pthread_mutexattr_t *__mutexattr);
+extern int __pthread_mutex_destroy_hppa_2_0 (pthread_mutex_hppa_2_0_t *__mutex);
+extern int __pthread_mutex_hppa_2_0_trylock_hppa_2_0 (pthread_mutex_hppa_2_0_t *_mutex);
+extern int __pthread_mutex_lock_hppa_2_0 (pthread_mutex_hppa_2_0_t *__mutex);
+extern int __pthread_mutex_unlock_hppa_2_0 (pthread_mutex_hppa_2_0_t *__mutex);
+
+extern int __pthread_mutexattr_init (pthread_mutexattr_t *attr);
+extern int __pthread_mutexattr_destroy (pthread_mutexattr_t *attr);
+extern int __pthread_mutexattr_settype (pthread_mutexattr_t *attr, int kind);
+extern int __pthread_attr_destroy (pthread_attr_t *attr);
+extern int __pthread_attr_getdetachstate (const pthread_attr_t *attr,
+					  int *detachstate);
+extern int __pthread_attr_setdetachstate (pthread_attr_t *attr,
+					  int detachstate);
+extern int __pthread_attr_getinheritsched (const pthread_attr_t *attr,
+					   int *inherit);
+extern int __pthread_attr_setinheritsched (pthread_attr_t *attr, int inherit);
+extern int __pthread_attr_getschedparam (const pthread_attr_t *attr,
+					 struct sched_param *param);
+extern int __pthread_attr_setschedparam (pthread_attr_t *attr,
+					 const struct sched_param *param);
+extern int __pthread_attr_getschedpolicy (const pthread_attr_t *attr,
+					  int *policy);
+extern int __pthread_attr_setschedpolicy (pthread_attr_t *attr, int policy);
+extern int __pthread_attr_getscope (const pthread_attr_t *attr, int *scope);
+extern int __pthread_attr_setscope (pthread_attr_t *attr, int scope);
+extern int __pthread_attr_getstackaddr (__const pthread_attr_t *__restrict
+					__attr, void **__restrict __stackaddr);
+extern int __pthread_attr_setstackaddr (pthread_attr_t *__attr,
+					void *__stackaddr);
+extern int __pthread_attr_getstacksize (__const pthread_attr_t *__restrict
+					__attr,
+					size_t *__restrict __stacksize);
+extern int __pthread_attr_setstacksize (pthread_attr_t *__attr,
+					size_t __stacksize);
+extern int __pthread_attr_getstack (__const pthread_attr_t *__restrict __attr,
+				    void **__restrict __stackaddr,
+				    size_t *__restrict __stacksize);
+extern int __pthread_attr_setstack (pthread_attr_t *__attr, void *__stackaddr,
+				    size_t __stacksize);
+extern int __pthread_rwlock_init (pthread_rwlock_t *__restrict __rwlock,
+				  __const pthread_rwlockattr_t *__restrict
+				  __attr);
+extern int __pthread_rwlock_destroy (pthread_rwlock_t *__rwlock);
+extern int __pthread_rwlock_rdlock (pthread_rwlock_t *__rwlock);
+extern int __pthread_rwlock_rdlock_internal (pthread_rwlock_t *__rwlock);
+extern int __pthread_rwlock_tryrdlock (pthread_rwlock_t *__rwlock);
+extern int __pthread_rwlock_wrlock (pthread_rwlock_t *__rwlock);
+extern int __pthread_rwlock_wrlock_internal (pthread_rwlock_t *__rwlock);
+extern int __pthread_rwlock_trywrlock (pthread_rwlock_t *__rwlock);
+extern int __pthread_rwlock_unlock (pthread_rwlock_t *__rwlock);
+extern int __pthread_rwlock_unlock_internal (pthread_rwlock_t *__rwlock);
+
+extern int __pthread_rwlock_init_hppa_2_0 (pthread_rwlock_hppa_2_0_t *__restrict __rwlock,
+				  __const pthread_rwlockattr_t *__restrict
+				  __attr);
+extern int __pthread_rwlock_destroy_hppa_2_0 (pthread_rwlock_hppa_2_0_t *__rwlock);
+extern int __pthread_rwlock_rdlock_hppa_2_0 (pthread_rwlock_hppa_2_0_t *__rwlock);
+extern int __pthread_rwlock_rdlock_internal_hppa_2_0 (pthread_rwlock_hppa_2_0_t *__rwlock);
+extern int __pthread_rwlock_hppa_2_0_tryrdlock_hppa_2_0 (pthread_rwlock_hppa_2_0_t *__rwlock);
+extern int __pthread_rwlock_wrlock_hppa_2_0 (pthread_rwlock_hppa_2_0_t *__rwlock);
+extern int __pthread_rwlock_wrlock_internal_hppa_2_0 (pthread_rwlock_hppa_2_0_t *__rwlock);
+extern int __pthread_rwlock_hppa_2_0_trywrlock_hppa_2_0 (pthread_rwlock_hppa_2_0_t *__rwlock);
+extern int __pthread_rwlock_unlock_hppa_2_0 (pthread_rwlock_hppa_2_0_t *__rwlock);
+
+extern int __pthread_cond_broadcast (pthread_cond_t *cond);
+extern int __pthread_cond_destroy (pthread_cond_t *cond);
+extern int __pthread_cond_init (pthread_cond_t *cond,
+				const pthread_condattr_t *cond_attr);
+extern int __pthread_cond_signal (pthread_cond_t *cond);
+extern int __pthread_cond_wait (pthread_cond_t *cond, pthread_mutex_t *mutex);
+extern int __pthread_cond_timedwait (pthread_cond_t *cond,
+				     pthread_mutex_t *mutex,
+				     const struct timespec *abstime);
+extern int __pthread_condattr_destroy (pthread_condattr_t *attr);
+extern int __pthread_condattr_init (pthread_condattr_t *attr);
+extern int __pthread_key_create (pthread_key_t *key, void (*destr) (void *));
+extern int __pthread_key_create_internal (pthread_key_t *key,
+					  void (*destr) (void *));
+extern void *__pthread_getspecific (pthread_key_t key);
+extern void *__pthread_getspecific_internal (pthread_key_t key);
+extern int __pthread_setspecific (pthread_key_t key, const void *value);
+extern int __pthread_setspecific_internal (pthread_key_t key,
+					   const void *value);
+extern int __pthread_once (pthread_once_t *once_control,
+			   void (*init_routine) (void));
+extern int __pthread_once_internal (pthread_once_t *once_control,
+				    void (*init_routine) (void));
+extern int __pthread_atfork (void (*prepare) (void), void (*parent) (void),
+			     void (*child) (void));
+extern pthread_t __pthread_self (void);
+extern int __pthread_equal (pthread_t thread1, pthread_t thread2);
+extern int __pthread_kill (pthread_t threadid, int signo);
+extern void __pthread_exit (void *value);
+extern int __pthread_setcanceltype (int type, int *oldtype);
+extern int __pthread_enable_asynccancel (void) attribute_hidden;
+extern void __pthread_disable_asynccancel (int oldtype)
+     internal_function attribute_hidden;
+
+extern int __pthread_cond_broadcast_2_0 (pthread_cond_2_0_t *cond);
+extern int __pthread_cond_destroy_2_0 (pthread_cond_2_0_t *cond);
+extern int __pthread_cond_init_2_0 (pthread_cond_2_0_t *cond,
+				    const pthread_condattr_t *cond_attr);
+extern int __pthread_cond_signal_2_0 (pthread_cond_2_0_t *cond);
+extern int __pthread_cond_timedwait_2_0 (pthread_cond_2_0_t *cond,
+					 pthread_mutex_t *mutex,
+					 const struct timespec *abstime);
+extern int __pthread_cond_wait_2_0 (pthread_cond_2_0_t *cond,
+				    pthread_mutex_t *mutex);
+
+extern int __pthread_cond_broadcast_hppa_2_3_2 (pthread_cond_hppa_2_3_2_t *cond);
+extern int __pthread_cond_destroy_hppa_2_3_2 (pthread_cond_hppa_2_3_2_t *cond);
+extern int __pthread_cond_init_hppa_2_3_2 (pthread_cond_hppa_2_3_2_t *cond,
+				    const pthread_condattr_t *cond_attr);
+extern int __pthread_cond_signal_hppa_2_3_2 (pthread_cond_hppa_2_3_2_t *cond);
+extern int __pthread_cond_timedwait_hppa_2_3_2 (pthread_cond_hppa_2_3_2_t *cond,
+					 pthread_mutex_hppa_2_0_t *mutex,
+					 const struct timespec *abstime);
+extern int __pthread_cond_wait_hppa_2_3_2 (pthread_cond_hppa_2_3_2_t *cond,
+				    pthread_mutex_hppa_2_0_t *mutex);
+
+extern int __pthread_getaffinity_np (pthread_t th, size_t cpusetsize,
+				     cpu_set_t *cpuset);
+
+/* The two functions are in libc.so and not exported.  */
+extern int __libc_enable_asynccancel (void) attribute_hidden;
+extern void __libc_disable_asynccancel (int oldtype)
+     internal_function attribute_hidden;
+
+
+/* The two functions are in librt.so and not exported.  */
+extern int __librt_enable_asynccancel (void) attribute_hidden;
+extern void __librt_disable_asynccancel (int oldtype)
+     internal_function attribute_hidden;
+
+#ifdef IS_IN_libpthread
+/* Special versions which use non-exported functions.  */
+extern void __pthread_cleanup_push (struct _pthread_cleanup_buffer *buffer,
+				    void (*routine) (void *), void *arg)
+     attribute_hidden;
+# undef pthread_cleanup_push
+# define pthread_cleanup_push(routine,arg) \
+  { struct _pthread_cleanup_buffer _buffer;				      \
+    __pthread_cleanup_push (&_buffer, (routine), (arg));
+
+extern void __pthread_cleanup_pop (struct _pthread_cleanup_buffer *buffer,
+				   int execute) attribute_hidden;
+# undef pthread_cleanup_pop
+# define pthread_cleanup_pop(execute) \
+    __pthread_cleanup_pop (&_buffer, (execute)); }
+#endif
+
+extern void __pthread_cleanup_push_defer (struct _pthread_cleanup_buffer *buffer,
+					  void (*routine) (void *), void *arg);
+extern void __pthread_cleanup_pop_restore (struct _pthread_cleanup_buffer *buffer,
+					   int execute);
+
+/* Old cleanup interfaces, still used in libc.so.  */
+extern void _pthread_cleanup_push (struct _pthread_cleanup_buffer *buffer,
+                                   void (*routine) (void *), void *arg);
+extern void _pthread_cleanup_pop (struct _pthread_cleanup_buffer *buffer,
+                                  int execute);
+extern void _pthread_cleanup_push_defer (struct _pthread_cleanup_buffer *buffer,
+                                         void (*routine) (void *), void *arg);
+extern void _pthread_cleanup_pop_restore (struct _pthread_cleanup_buffer *buffer,
+                                          int execute);
+
+extern void __nptl_deallocate_tsd (void) attribute_hidden;
+
+extern int __nptl_setxid (struct xid_command *cmdp) attribute_hidden;
+
+extern void __free_stacks (size_t limit) attribute_hidden;
+
+extern void __wait_lookup_done (void) attribute_hidden;
+
+#ifdef SHARED
+# define PTHREAD_STATIC_FN_REQUIRE(name)
+#else
+# define PTHREAD_STATIC_FN_REQUIRE(name) __asm (".globl " #name);
+#endif
+
+
+#ifndef __NR_set_robust_list
+/* XXX For the time being...  Once we can rely on the kernel headers
+   having the definition remove these lines.  */
+# if defined __i386__
+#  define __NR_set_robust_list  311
+# elif defined __x86_64__
+#  define __NR_set_robust_list  273
+# endif
+#endif
+
+#endif	/* pthreadP.h */
Index: sysdeps/unix/sysv/linux/hppa/nptl/pthread_cond_broadcast.c
===================================================================
RCS file: sysdeps/unix/sysv/linux/hppa/nptl/pthread_cond_broadcast.c
diff -N sysdeps/unix/sysv/linux/hppa/nptl/pthread_cond_broadcast.c
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ b/ports/sysdeps/unix/sysv/linux/hppa/nptl/pthread_cond_broadcast.c	2 Apr 2009 02:34:03 -0000
@@ -0,0 +1,29 @@
+/* Copyright (C) 2009 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Carlos O'Donell <carlos@codesourcery.com>, 2009.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef INCLUDED_SELF
+# define INCLUDED_SELF
+# include <pthread_cond_broadcast.c>
+#else
+# include <shlib-compat.h>
+# undef GLIBC_2_3_2
+# define GLIBC_2_3_2 GLIBC_2_9
+# include_next <pthread_cond_broadcast.c>
+#endif
+
Index: sysdeps/unix/sysv/linux/hppa/nptl/pthread_cond_destroy.c
===================================================================
RCS file: sysdeps/unix/sysv/linux/hppa/nptl/pthread_cond_destroy.c
diff -N sysdeps/unix/sysv/linux/hppa/nptl/pthread_cond_destroy.c
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ b/ports/sysdeps/unix/sysv/linux/hppa/nptl/pthread_cond_destroy.c	2 Apr 2009 02:34:03 -0000
@@ -0,0 +1,29 @@
+/* Copyright (C) 2009 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Carlos O'Donell <carlos@codesourcery.com>, 2009.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef INCLUDED_SELF
+# define INCLUDED_SELF
+# include <pthread_cond_destroy.c>
+#else
+# include <shlib-compat.h>
+# undef GLIBC_2_3_2
+# define GLIBC_2_3_2 GLIBC_2_9
+# include_next <pthread_cond_destroy.c>
+#endif
+
Index: sysdeps/unix/sysv/linux/hppa/nptl/pthread_cond_init.c
===================================================================
RCS file: sysdeps/unix/sysv/linux/hppa/nptl/pthread_cond_init.c
diff -N sysdeps/unix/sysv/linux/hppa/nptl/pthread_cond_init.c
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ b/ports/sysdeps/unix/sysv/linux/hppa/nptl/pthread_cond_init.c	2 Apr 2009 02:34:03 -0000
@@ -0,0 +1,29 @@
+/* Copyright (C) 2009 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Carlos O'Donell <carlos@codesourcery.com>, 2009.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef INCLUDED_SELF
+# define INCLUDED_SELF
+# include <pthread_cond_init.c>
+#else
+# include <shlib-compat.h>
+# undef GLIBC_2_3_2
+# define GLIBC_2_3_2 GLIBC_2_9
+# include_next <pthread_cond_init.c>
+#endif
+
Index: sysdeps/unix/sysv/linux/hppa/nptl/pthread_cond_signal.c
===================================================================
RCS file: sysdeps/unix/sysv/linux/hppa/nptl/pthread_cond_signal.c
diff -N sysdeps/unix/sysv/linux/hppa/nptl/pthread_cond_signal.c
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ b/ports/sysdeps/unix/sysv/linux/hppa/nptl/pthread_cond_signal.c	2 Apr 2009 02:34:03 -0000
@@ -0,0 +1,29 @@
+/* Copyright (C) 2009 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Carlos O'Donell <carlos@codesourcery.com>, 2009.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef INCLUDED_SELF
+# define INCLUDED_SELF
+# include <pthread_cond_signal.c>
+#else
+# include <shlib-compat.h>
+# undef GLIBC_2_3_2
+# define GLIBC_2_3_2 GLIBC_2_9
+# include_next <pthread_cond_signal.c>
+#endif
+
Index: sysdeps/unix/sysv/linux/hppa/nptl/pthread_cond_timedwait.c
===================================================================
RCS file: sysdeps/unix/sysv/linux/hppa/nptl/pthread_cond_timedwait.c
diff -N sysdeps/unix/sysv/linux/hppa/nptl/pthread_cond_timedwait.c
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ b/ports/sysdeps/unix/sysv/linux/hppa/nptl/pthread_cond_timedwait.c	2 Apr 2009 02:34:03 -0000
@@ -0,0 +1,29 @@
+/* Copyright (C) 2009 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Carlos O'Donell <carlos@codesourcery.com>, 2009.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef INCLUDED_SELF
+# define INCLUDED_SELF
+# include <pthread_cond_timedwait.c>
+#else
+# include <shlib-compat.h>
+# undef GLIBC_2_3_2
+# define GLIBC_2_3_2 GLIBC_2_9
+# include_next <pthread_cond_timedwait.c>
+#endif
+
Index: sysdeps/unix/sysv/linux/hppa/nptl/pthread_cond_wait.c
===================================================================
RCS file: sysdeps/unix/sysv/linux/hppa/nptl/pthread_cond_wait.c
diff -N sysdeps/unix/sysv/linux/hppa/nptl/pthread_cond_wait.c
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ b/ports/sysdeps/unix/sysv/linux/hppa/nptl/pthread_cond_wait.c	2 Apr 2009 02:34:03 -0000
@@ -0,0 +1,29 @@
+/* Copyright (C) 2009 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Carlos O'Donell <carlos@codesourcery.com>, 2009.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef INCLUDED_SELF
+# define INCLUDED_SELF
+# include <pthread_cond_wait.c>
+#else
+# include <shlib-compat.h>
+# undef GLIBC_2_3_2
+# define GLIBC_2_3_2 GLIBC_2_9
+# include_next <pthread_cond_wait.c>
+#endif
+
Index: sysdeps/unix/sysv/linux/hppa/nptl/pthread_mutex_cond_lock.c
===================================================================
RCS file: sysdeps/unix/sysv/linux/hppa/nptl/pthread_mutex_cond_lock.c
diff -N sysdeps/unix/sysv/linux/hppa/nptl/pthread_mutex_cond_lock.c
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ b/ports/sysdeps/unix/sysv/linux/hppa/nptl/pthread_mutex_cond_lock.c	2 Apr 2009 02:34:03 -0000
@@ -0,0 +1,14 @@
+#include <pthreadP.h>
+
+#define LLL_MUTEX_LOCK(mutex) \
+  lll_cond_lock ((mutex)->__data.__lock, PTHREAD_MUTEX_PSHARED (mutex))
+#define LLL_MUTEX_TRYLOCK(mutex) \
+  lll_cond_trylock ((mutex)->__data.__lock)
+#define LLL_ROBUST_MUTEX_LOCK(mutex, id) \
+  lll_robust_cond_lock ((mutex)->__data.__lock, id, \
+			PTHREAD_ROBUST_MUTEX_PSHARED (mutex))
+#define __pthread_mutex_lock __pthread_mutex_cond_lock
+#define __pthread_mutex_lock_full __pthread_mutex_cond_lock_full
+#define NO_INCR
+
+#include <nptl/pthread_mutex_lock.c>
Index: sysdeps/unix/sysv/linux/hppa/nptl/pthread_mutex_destroy.c
===================================================================
RCS file: sysdeps/unix/sysv/linux/hppa/nptl/pthread_mutex_destroy.c
diff -N sysdeps/unix/sysv/linux/hppa/nptl/pthread_mutex_destroy.c
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ b/ports/sysdeps/unix/sysv/linux/hppa/nptl/pthread_mutex_destroy.c	2 Apr 2009 02:34:03 -0000
@@ -0,0 +1,36 @@
+/* Copyright (C) 2009 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Carlos O'Donell <carlos@codesourcery.com>, 2009.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef INCLUDED_SELF
+# define INCLUDED_SELF
+# include <pthread_mutex_destroy.c>
+#else
+# include <shlib-compat.h>
+# include <libc-symbols.h>
+# include "pthreadP.h"
+# undef strong_alias
+# define strong_alias(name, aliasname)
+# include_next <pthread_mutex_destroy.c>
+# undef strong_alias
+# define strong_alias(name, aliasname) _strong_alias(name, aliasname)
+versioned_symbol (libpthread, __pthread_mutex_destroy,
+		  pthread_mutex_destroy, GLIBC_2_9);
+INTDEF(__pthread_mutex_destroy)
+#endif
+
Index: sysdeps/unix/sysv/linux/hppa/nptl/pthread_mutex_init.c
===================================================================
RCS file: sysdeps/unix/sysv/linux/hppa/nptl/pthread_mutex_init.c
diff -N sysdeps/unix/sysv/linux/hppa/nptl/pthread_mutex_init.c
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ b/ports/sysdeps/unix/sysv/linux/hppa/nptl/pthread_mutex_init.c	2 Apr 2009 02:34:03 -0000
@@ -0,0 +1,36 @@
+/* Copyright (C) 2009 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Carlos O'Donell <carlos@codesourcery.com>, 2009.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef INCLUDED_SELF
+# define INCLUDED_SELF
+# include <pthread_mutex_init.c>
+#else
+# include <shlib-compat.h>
+# include <libc-symbols.h>
+# include "pthreadP.h"
+# undef strong_alias
+# define strong_alias(name, aliasname)
+# include_next <pthread_mutex_init.c>
+# undef strong_alias
+# define strong_alias(name, aliasname) _strong_alias(name, aliasname)
+versioned_symbol (libpthread, __pthread_mutex_init,
+		  pthread_mutex_init, GLIBC_2_9);
+INTDEF(__pthread_mutex_init)
+#endif
+
Index: sysdeps/unix/sysv/linux/hppa/nptl/pthread_mutex_lock.c
===================================================================
RCS file: sysdeps/unix/sysv/linux/hppa/nptl/pthread_mutex_lock.c
diff -N sysdeps/unix/sysv/linux/hppa/nptl/pthread_mutex_lock.c
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ b/ports/sysdeps/unix/sysv/linux/hppa/nptl/pthread_mutex_lock.c	2 Apr 2009 02:34:03 -0000
@@ -0,0 +1,40 @@
+/* Copyright (C) 2009 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Carlos O'Donell <carlos@codesourcery.com>, 2009.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef INCLUDED_SELF
+# define INCLUDED_SELF
+# include <pthread_mutex_lock.c>
+#else
+# include <shlib-compat.h>
+# include <libc-symbols.h>
+# include "pthreadP.h"
+# undef strong_alias
+# define strong_alias(name, aliasname)
+# include_next <pthread_mutex_lock.c>
+# undef strong_alias
+# define strong_alias(name, aliasname) _strong_alias(name, aliasname)
+/* The file pthread_mutex_cond_lock.c includes this
+   file and we do not want to version that interface.  */
+# ifndef __pthread_mutex_lock
+versioned_symbol (libpthread, __pthread_mutex_lock,
+		  pthread_mutex_lock, GLIBC_2_9);
+strong_alias (__pthread_mutex_lock, __pthread_mutex_lock_internal)
+# endif
+#endif
+
Index: sysdeps/unix/sysv/linux/hppa/nptl/pthread_mutex_timedlock.c
===================================================================
RCS file: sysdeps/unix/sysv/linux/hppa/nptl/pthread_mutex_timedlock.c
diff -N sysdeps/unix/sysv/linux/hppa/nptl/pthread_mutex_timedlock.c
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ b/ports/sysdeps/unix/sysv/linux/hppa/nptl/pthread_mutex_timedlock.c	2 Apr 2009 02:34:03 -0000
@@ -0,0 +1,38 @@
+/* Copyright (C) 2009 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Carlos O'Donell <carlos@codesourcery.com>, 2009.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef INCLUDED_SELF
+# define INCLUDED_SELF
+# include <pthread_mutex_timedlock.c>
+#else
+# include <shlib-compat.h>
+# include <libc-symbols.h>
+# include "pthreadP.h"
+# undef strong_alias
+# define strong_alias(name, aliasname)
+# undef pthread_mutex_timedlock
+# define pthread_mutex_timedlock __pthread_mutex_timedlock
+# include_next <pthread_mutex_timedlock.c>
+# undef strong_alias
+# define strong_alias(name, aliasname) _strong_alias(name, aliasname)
+# undef pthread_mutex_timedlock
+versioned_symbol (libpthread, __pthread_mutex_timedlock,
+		  pthread_mutex_timedlock, GLIBC_2_9);
+#endif
+
Index: sysdeps/unix/sysv/linux/hppa/nptl/pthread_mutex_trylock.c
===================================================================
RCS file: sysdeps/unix/sysv/linux/hppa/nptl/pthread_mutex_trylock.c
diff -N sysdeps/unix/sysv/linux/hppa/nptl/pthread_mutex_trylock.c
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ b/ports/sysdeps/unix/sysv/linux/hppa/nptl/pthread_mutex_trylock.c	2 Apr 2009 02:34:03 -0000
@@ -0,0 +1,35 @@
+/* Copyright (C) 2009 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Carlos O'Donell <carlos@codesourcery.com>, 2009.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef INCLUDED_SELF
+# define INCLUDED_SELF
+# include <pthread_mutex_trylock.c>
+#else
+# include <shlib-compat.h>
+# include <libc-symbols.h>
+# include "pthreadP.h"
+# undef strong_alias
+# define strong_alias(name, aliasname)
+# include_next <pthread_mutex_trylock.c>
+# undef strong_alias
+# define strong_alias(name, aliasname) _strong_alias(name, aliasname)
+versioned_symbol (libpthread, __pthread_mutex_trylock,
+		  pthread_mutex_trylock, GLIBC_2_9);
+#endif
+
Index: sysdeps/unix/sysv/linux/hppa/nptl/pthread_mutex_unlock.c
===================================================================
RCS file: sysdeps/unix/sysv/linux/hppa/nptl/pthread_mutex_unlock.c
diff -N sysdeps/unix/sysv/linux/hppa/nptl/pthread_mutex_unlock.c
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ b/ports/sysdeps/unix/sysv/linux/hppa/nptl/pthread_mutex_unlock.c	2 Apr 2009 02:34:03 -0000
@@ -0,0 +1,36 @@
+/* Copyright (C) 2009 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Carlos O'Donell <carlos@codesourcery.com>, 2009.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef INCLUDED_SELF
+# define INCLUDED_SELF
+# include <pthread_mutex_unlock.c>
+#else
+# include <shlib-compat.h>
+# include <libc-symbols.h>
+# include "pthreadP.h"
+# undef strong_alias
+# define strong_alias(name, aliasname)
+# include_next <pthread_mutex_unlock.c>
+# undef strong_alias
+# define strong_alias(name, aliasname) _strong_alias(name, aliasname)
+versioned_symbol (libpthread, __pthread_mutex_unlock,
+		  pthread_mutex_unlock, GLIBC_2_9);
+strong_alias (__pthread_mutex_unlock, __pthread_mutex_unlock_internal)
+#endif
+
Index: sysdeps/unix/sysv/linux/hppa/nptl/pthread_rwlock_destroy.c
===================================================================
RCS file: sysdeps/unix/sysv/linux/hppa/nptl/pthread_rwlock_destroy.c
diff -N sysdeps/unix/sysv/linux/hppa/nptl/pthread_rwlock_destroy.c
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ b/ports/sysdeps/unix/sysv/linux/hppa/nptl/pthread_rwlock_destroy.c	2 Apr 2009 02:34:03 -0000
@@ -0,0 +1,35 @@
+/* Copyright (C) 2009 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Carlos O'Donell <carlos@codesourcery.com>, 2009.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef INCLUDED_SELF
+# define INCLUDED_SELF
+# include <pthread_rwlock_destroy.c>
+#else
+# include <shlib-compat.h>
+# include <libc-symbols.h>
+# include "pthreadP.h"
+# undef strong_alias
+# define strong_alias(name, aliasname)
+# include_next <pthread_rwlock_destroy.c>
+# undef strong_alias
+# define strong_alias(name, aliasname) _strong_alias(name, aliasname)
+versioned_symbol (libpthread, __pthread_rwlock_destroy,
+		  pthread_rwlock_destroy, GLIBC_2_9);
+#endif
+
Index: sysdeps/unix/sysv/linux/hppa/nptl/pthread_rwlock_init.c
===================================================================
RCS file: sysdeps/unix/sysv/linux/hppa/nptl/pthread_rwlock_init.c
diff -N sysdeps/unix/sysv/linux/hppa/nptl/pthread_rwlock_init.c
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ b/ports/sysdeps/unix/sysv/linux/hppa/nptl/pthread_rwlock_init.c	2 Apr 2009 02:34:03 -0000
@@ -0,0 +1,35 @@
+/* Copyright (C) 2009 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Carlos O'Donell <carlos@codesourcery.com>, 2009.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef INCLUDED_SELF
+# define INCLUDED_SELF
+# include <pthread_rwlock_init.c>
+#else
+# include <shlib-compat.h>
+# include <libc-symbols.h>
+# include "pthreadP.h"
+# undef strong_alias
+# define strong_alias(name, aliasname)
+# include_next <pthread_rwlock_init.c>
+# undef strong_alias
+# define strong_alias(name, aliasname) _strong_alias(name, aliasname)
+versioned_symbol (libpthread, __pthread_rwlock_init,
+		  pthread_rwlock_init, GLIBC_2_9);
+#endif
+
Index: sysdeps/unix/sysv/linux/hppa/nptl/pthread_rwlock_rdlock.c
===================================================================
RCS file: sysdeps/unix/sysv/linux/hppa/nptl/pthread_rwlock_rdlock.c
diff -N sysdeps/unix/sysv/linux/hppa/nptl/pthread_rwlock_rdlock.c
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ b/ports/sysdeps/unix/sysv/linux/hppa/nptl/pthread_rwlock_rdlock.c	2 Apr 2009 02:34:03 -0000
@@ -0,0 +1,40 @@
+/* Copyright (C) 2009 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Carlos O'Donell <carlos@codesourcery.com>, 2009.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef INCLUDED_SELF
+# define INCLUDED_SELF
+# include <pthread_rwlock_rdlock.c>
+#else
+# include <shlib-compat.h>
+# include <libc-symbols.h>
+# include "pthreadP.h"
+# undef strong_alias
+# define strong_alias(name, aliasname)
+# undef weak_alias
+# define weak_alias(name, aliasname)
+# include_next <pthread_rwlock_rdlock.c>
+# undef strong_alias
+# define strong_alias(name, aliasname) _strong_alias(name, aliasname)
+# undef weak_alias
+# define weak_alias(name, aliasname) _weak_alias(name, aliasname)
+versioned_symbol (libpthread, __pthread_rwlock_rdlock,
+		  pthread_rwlock_rdlock, GLIBC_2_9);
+strong_alias (__pthread_rwlock_rdlock, __pthread_rwlock_rdlock_internal)
+#endif
+
Index: sysdeps/unix/sysv/linux/hppa/nptl/pthread_rwlock_timedrdlock.c
===================================================================
RCS file: sysdeps/unix/sysv/linux/hppa/nptl/pthread_rwlock_timedrdlock.c
diff -N sysdeps/unix/sysv/linux/hppa/nptl/pthread_rwlock_timedrdlock.c
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ b/ports/sysdeps/unix/sysv/linux/hppa/nptl/pthread_rwlock_timedrdlock.c	2 Apr 2009 02:34:03 -0000
@@ -0,0 +1,38 @@
+/* Copyright (C) 2009 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Carlos O'Donell <carlos@codesourcery.com>, 2009.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef INCLUDED_SELF
+# define INCLUDED_SELF
+# include <pthread_rwlock_timedrdlock.c>
+#else
+# include <shlib-compat.h>
+# include <libc-symbols.h>
+# include "pthreadP.h"
+# undef strong_alias
+# define strong_alias(name, aliasname)
+# undef pthread_rwlock_timedrdlock
+# define pthread_rwlock_timedrdlock __pthread_rwlock_timedrdlock
+# include_next <pthread_rwlock_timedrdlock.c>
+# undef strong_alias
+# define strong_alias(name, aliasname) _strong_alias(name, aliasname)
+# undef pthread_rwlock_timedrdlock
+versioned_symbol (libpthread, __pthread_rwlock_timedrdlock,
+		  pthread_rwlock_timedrdlock, GLIBC_2_9);
+#endif
+
Index: sysdeps/unix/sysv/linux/hppa/nptl/pthread_rwlock_timedwrlock.c
===================================================================
RCS file: sysdeps/unix/sysv/linux/hppa/nptl/pthread_rwlock_timedwrlock.c
diff -N sysdeps/unix/sysv/linux/hppa/nptl/pthread_rwlock_timedwrlock.c
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ b/ports/sysdeps/unix/sysv/linux/hppa/nptl/pthread_rwlock_timedwrlock.c	2 Apr 2009 02:34:03 -0000
@@ -0,0 +1,38 @@
+/* Copyright (C) 2009 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Carlos O'Donell <carlos@codesourcery.com>, 2009.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef INCLUDED_SELF
+# define INCLUDED_SELF
+# include <pthread_rwlock_timedwrlock.c>
+#else
+# include <shlib-compat.h>
+# include <libc-symbols.h>
+# include "pthreadP.h"
+# undef strong_alias
+# define strong_alias(name, aliasname)
+# undef pthread_rwlock_timedrdlock
+# define pthread_rwlock_timedwrlock __pthread_rwlock_timedwrlock
+# include_next <pthread_rwlock_timedwrlock.c>
+# undef strong_alias
+# define strong_alias(name, aliasname) _strong_alias(name, aliasname)
+# undef pthread_rwlock_timedwrlock
+versioned_symbol (libpthread, __pthread_rwlock_timedwrlock,
+		  pthread_rwlock_timedwrlock, GLIBC_2_9);
+#endif
+
Index: sysdeps/unix/sysv/linux/hppa/nptl/pthread_rwlock_tryrdlock.c
===================================================================
RCS file: sysdeps/unix/sysv/linux/hppa/nptl/pthread_rwlock_tryrdlock.c
diff -N sysdeps/unix/sysv/linux/hppa/nptl/pthread_rwlock_tryrdlock.c
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ b/ports/sysdeps/unix/sysv/linux/hppa/nptl/pthread_rwlock_tryrdlock.c	2 Apr 2009 02:34:03 -0000
@@ -0,0 +1,35 @@
+/* Copyright (C) 2009 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Carlos O'Donell <carlos@codesourcery.com>, 2009.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef INCLUDED_SELF
+# define INCLUDED_SELF
+# include <pthread_rwlock_tryrdlock.c>
+#else
+# include <shlib-compat.h>
+# include <libc-symbols.h>
+# include "pthreadP.h"
+# undef strong_alias
+# define strong_alias(name, aliasname)
+# include_next <pthread_rwlock_tryrdlock.c>
+# undef strong_alias
+# define strong_alias(name, aliasname) _strong_alias(name, aliasname)
+versioned_symbol (libpthread, __pthread_rwlock_tryrdlock,
+		  pthread_rwlock_tryrdlock, GLIBC_2_9);
+#endif
+
Index: sysdeps/unix/sysv/linux/hppa/nptl/pthread_rwlock_trywrlock.c
===================================================================
RCS file: sysdeps/unix/sysv/linux/hppa/nptl/pthread_rwlock_trywrlock.c
diff -N sysdeps/unix/sysv/linux/hppa/nptl/pthread_rwlock_trywrlock.c
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ b/ports/sysdeps/unix/sysv/linux/hppa/nptl/pthread_rwlock_trywrlock.c	2 Apr 2009 02:34:03 -0000
@@ -0,0 +1,35 @@
+/* Copyright (C) 2009 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Carlos O'Donell <carlos@codesourcery.com>, 2009.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef INCLUDED_SELF
+# define INCLUDED_SELF
+# include <pthread_rwlock_trywrlock.c>
+#else
+# include <shlib-compat.h>
+# include <libc-symbols.h>
+# include "pthreadP.h"
+# undef strong_alias
+# define strong_alias(name, aliasname)
+# include_next <pthread_rwlock_trywrlock.c>
+# undef strong_alias
+# define strong_alias(name, aliasname) _strong_alias(name, aliasname)
+versioned_symbol (libpthread, __pthread_rwlock_trywrlock,
+		  pthread_rwlock_trywrlock, GLIBC_2_9);
+#endif
+
Index: sysdeps/unix/sysv/linux/hppa/nptl/pthread_rwlock_unlock.c
===================================================================
RCS file: sysdeps/unix/sysv/linux/hppa/nptl/pthread_rwlock_unlock.c
diff -N sysdeps/unix/sysv/linux/hppa/nptl/pthread_rwlock_unlock.c
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ b/ports/sysdeps/unix/sysv/linux/hppa/nptl/pthread_rwlock_unlock.c	2 Apr 2009 02:34:03 -0000
@@ -0,0 +1,40 @@
+/* Copyright (C) 2009 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Carlos O'Donell <carlos@codesourcery.com>, 2009.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef INCLUDED_SELF
+# define INCLUDED_SELF
+# include <pthread_rwlock_unlock.c>
+#else
+# include <shlib-compat.h>
+# include <libc-symbols.h>
+# include "pthreadP.h"
+# undef strong_alias
+# define strong_alias(name, aliasname)
+# undef weak_alias
+# define weak_alias(name, aliasname)
+# include_next <pthread_rwlock_unlock.c>
+# undef strong_alias
+# define strong_alias(name, aliasname) _strong_alias(name, aliasname)
+# undef weak_alias
+# define weak_alias(name, aliasname) _weak_alias(name, aliasname)
+versioned_symbol (libpthread, __pthread_rwlock_unlock,
+		  pthread_rwlock_unlock, GLIBC_2_9);
+strong_alias (__pthread_rwlock_unlock, __pthread_rwlock_unlock_internal)
+#endif
+
Index: sysdeps/unix/sysv/linux/hppa/nptl/pthread_rwlock_wrlock.c
===================================================================
RCS file: sysdeps/unix/sysv/linux/hppa/nptl/pthread_rwlock_wrlock.c
diff -N sysdeps/unix/sysv/linux/hppa/nptl/pthread_rwlock_wrlock.c
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ b/ports/sysdeps/unix/sysv/linux/hppa/nptl/pthread_rwlock_wrlock.c	2 Apr 2009 02:34:03 -0000
@@ -0,0 +1,40 @@
+/* Copyright (C) 2009 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Carlos O'Donell <carlos@codesourcery.com>, 2009.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef INCLUDED_SELF
+# define INCLUDED_SELF
+# include <pthread_rwlock_wrlock.c>
+#else
+# include <shlib-compat.h>
+# include <libc-symbols.h>
+# include "pthreadP.h"
+# undef strong_alias
+# define strong_alias(name, aliasname)
+# undef weak_alias
+# define weak_alias(name, aliasname)
+# include_next <pthread_rwlock_wrlock.c>
+# undef strong_alias
+# define strong_alias(name, aliasname) _strong_alias(name, aliasname)
+# undef weak_alias
+# define weak_alias(name, aliasname) _weak_alias(name, aliasname)
+versioned_symbol (libpthread, __pthread_rwlock_wrlock,
+		  pthread_rwlock_wrlock, GLIBC_2_9);
+strong_alias (__pthread_rwlock_wrlock, __pthread_rwlock_wrlock_internal)
+#endif
+
