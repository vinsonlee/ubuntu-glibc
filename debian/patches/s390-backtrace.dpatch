#! /bin/sh -e

# All lines beginning with `# DP:' are a description of the patch.
# DP: Description: Improved backtrace for s390.  This patch makes the s390*
#	version of backtrace use the _Unwind_Backtrace and _Unwind_GetIP
#	functions from the libgcc to do the job.
# DP: Related bugs: #243394
# DP: Dpatch author: GOTO Masanori <gotom@debian.org>
# DP: Patch author: Martin Schwidefsky <schwidefsky@de.ibm.com>
# DP: Upstream status: In CVS
# DP: Status Details: 
# DP: Date: 2004-05-24

PATCHLEVEL=1

if [ $# -ne 2 ]; then
    echo >&2 "`basename $0`: script expects -patch|-unpatch as argument"
    exit 1
fi
case "$1" in
    -patch) patch -d "$2" -f --no-backup-if-mismatch -p$PATCHLEVEL < $0;;
    -unpatch) patch -d "$2" -f --no-backup-if-mismatch -R -p$PATCHLEVEL < $0;;
    *)
	echo >&2 "`basename $0`: script expects -patch|-unpatch as argument"
	exit 1
esac
exit 0

# append the patch here and adjust the -p? flag in the patch calls.
2003-12-05  Martin Schwidefsky  <schwidefsky@de.ibm.com>

        * sysdeps/s390/s390-32/backtrace.c (trace_arg): New structure.
        (unwind_backtrace, unwind_getip): New variables.
        (init, __backchain_backtrace, backtrace_helper): New functions.
        (__backtrace): Use unwind info for backtrace instead of backchain
        walking if the unwind functions can be found.
        * sysdeps/s390/s390-64/backtrace.c: Likewise.

diff -urN libc/sysdeps/s390/s390-32/backtrace.c libc-s390/sysdeps/s390/s390-32/backtrace.c
--- libc/sysdeps/s390/s390-32/backtrace.c       2003-03-28 14:25:36.000000000 +0100
+++ libc-s390/sysdeps/s390/s390-32/backtrace.c  2003-11-13 15:33:24.000000000 +0100
@@ -1,5 +1,5 @@
 /* Return backtrace of current program state.
-   Copyright (C) 2000, 2001 Free Software Foundation, Inc.
+   Copyright (C) 2000, 2001, 2003 Free Software Foundation, Inc.
    Contributed by Martin Schwidefsky (schwidefsky@de.ibm.com).
    This file is part of the GNU C Library.

@@ -18,8 +18,12 @@
    Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
    02111-1307 USA.  */

+#include <bits/libc-lock.h>
+#include <dlfcn.h>
 #include <execinfo.h>
 #include <stddef.h>
+#include <stdlib.h>
+#include <unwind.h>

 /* This is a global variable set at program start time.  It marks the
    highest used stack address.  */
@@ -51,10 +55,31 @@
   int empty[2];
 };

-int
-__backtrace (array, size)
-     void **array;
-     int size;
+struct trace_arg
+{
+  void **array;
+  int cnt, size;
+};
+
+static _Unwind_Reason_Code (*unwind_backtrace) (_Unwind_Trace_Fn, void *);
+static _Unwind_Ptr (*unwind_getip) (struct _Unwind_Context *);
+
+static void
+init (void)
+{
+  void *handle = __libc_dlopen ("libgcc_s.so.1");
+
+  if (handle == NULL)
+    return;
+
+  unwind_backtrace = __libc_dlsym (handle, "_Unwind_Backtrace");
+  unwind_getip = __libc_dlsym (handle, "_Unwind_GetIP");
+  if (unwind_getip == NULL)
+    unwind_backtrace = NULL;
+}
+
+static int
+__backchain_backtrace (void **array, int size)
 {
   /* We assume that all the code is generated with frame pointers set.  */
   struct layout *stack;
@@ -71,11 +96,42 @@
           out of range.  */
        break;

-      array[cnt++] = stack->save_grps[8] & 0x7fffffff;
+      array[cnt++] = (void *) (stack->save_grps[8] & 0x7fffffff);

       stack = (struct layout *) stack->back_chain;
     }

   return cnt;
 }
+
+static _Unwind_Reason_Code
+backtrace_helper (struct _Unwind_Context *ctx, void *a)
+{
+  struct trace_arg *arg = a;
+
+  /* We are first called with address in the __backtrace function.
+     Skip it.  */
+  if (arg->cnt != -1)
+    arg->array[arg->cnt] = (void *) unwind_getip (ctx);
+  if (++arg->cnt == arg->size)
+    return _URC_END_OF_STACK;
+  return _URC_NO_REASON;
+}
+
+int
+__backtrace (void **array, int size)
+{
+  struct trace_arg arg = { .array = array, .size = size, .cnt = -1 };
+  __libc_once_define (static, once);
+
+  __libc_once (once, init);
+  if (unwind_backtrace == NULL)
+    return __backchain_backtrace (array, size);
+
+  if (size >= 1)
+    unwind_backtrace (backtrace_helper, &arg);
+
+  return arg.cnt != -1 ? arg.cnt : 0;
+}
+
 weak_alias (__backtrace, backtrace)
diff -urN libc/sysdeps/s390/s390-64/backtrace.c libc-s390/sysdeps/s390/s390-64/backtrace.c
--- libc/sysdeps/s390/s390-64/backtrace.c       2003-05-06 10:05:46.000000000 +0200
+++ libc-s390/sysdeps/s390/s390-64/backtrace.c  2003-11-13 15:33:24.000000000 +0100
@@ -1,5 +1,5 @@
 /* Return backtrace of current program state.  64 bit S/390 version.
-   Copyright (C) 2001 Free Software Foundation, Inc.
+   Copyright (C) 2001, 2003 Free Software Foundation, Inc.
    Contributed by Martin Schwidefsky (schwidefsky@de.ibm.com).
    This file is part of the GNU C Library.

@@ -18,8 +18,12 @@
    Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
    02111-1307 USA.  */

+#include <bits/libc-lock.h>
+#include <dlfcn.h>
 #include <execinfo.h>
 #include <stddef.h>
+#include <stdlib.h>
+#include <unwind.h>


 /* This is a global variable set at program start time.  It marks the
@@ -50,10 +54,31 @@
   long empty[2];
 };

+struct trace_arg
+{
+  void **array;
+  int cnt, size;
+};
+
+static _Unwind_Reason_Code (*unwind_backtrace) (_Unwind_Trace_Fn, void *);
+static _Unwind_Ptr (*unwind_getip) (struct _Unwind_Context *);
+
+static void
+init (void)
+{
+  void *handle = __libc_dlopen ("libgcc_s.so.1");
+
+  if (handle == NULL)
+    return;
+
+  unwind_backtrace = __libc_dlsym (handle, "_Unwind_Backtrace");
+  unwind_getip = __libc_dlsym (handle, "_Unwind_GetIP");
+  if (unwind_getip == NULL)
+    unwind_backtrace = NULL;
+}
+
 int
-__backtrace (array, size)
-     void **array;
-     int size;
+__backchain_backtrace (void **array, int size)
 {
   /* We assume that all the code is generated with frame pointers set.  */
   struct layout *stack;
@@ -77,4 +102,35 @@

   return cnt;
 }
+
+static _Unwind_Reason_Code
+backtrace_helper (struct _Unwind_Context *ctx, void *a)
+{
+  struct trace_arg *arg = a;
+
+  /* We are first called with address in the __backtrace function.
+     Skip it.  */
+  if (arg->cnt != -1)
+    arg->array[arg->cnt] = (void *) unwind_getip (ctx);
+  if (++arg->cnt == arg->size)
+    return _URC_END_OF_STACK;
+  return _URC_NO_REASON;
+}
+
+int
+__backtrace (void **array, int size)
+{
+  struct trace_arg arg = { .array = array, .size = size, .cnt = -1 };
+  __libc_once_define (static, once);
+
+  __libc_once (once, init);
+  if (unwind_backtrace == NULL)
+    return __backchain_backtrace (array, size);
+
+  if (size >= 1)
+    unwind_backtrace (backtrace_helper, &arg);
+
+  return arg.cnt != -1 ? arg.cnt : 0;
+}
+
 weak_alias (__backtrace, backtrace)


--- libc/sysdeps/generic/unwind.h	4 Sep 2003 05:40:43 -0000	1.3
+++ libc/sysdeps/generic/unwind.h	5 Oct 2003 19:31:37 -0000	1.4
@@ -130,6 +130,14 @@
    e.g. executing cleanup code, and not to implement rethrowing.  */
 extern void _Unwind_Resume (struct _Unwind_Exception *);
 
+/* @@@ Use unwind data to perform a stack backtrace.  The trace callback
+   is called for every stack frame in the call chain, but no cleanup
+   actions are performed.  */
+typedef _Unwind_Reason_Code (*_Unwind_Trace_Fn)
+     (struct _Unwind_Context *, void *);
+
+extern _Unwind_Reason_Code _Unwind_Backtrace (_Unwind_Trace_Fn, void *);
+
 /* These functions are used for communicating information about the unwind
    context (i.e. the unwind descriptors and the user register state) between
    the unwind library and the personality routine and landing pad.  Only
