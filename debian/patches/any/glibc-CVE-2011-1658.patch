From 96611391ad8823ba58405325d78cefeae5cdf699 Mon Sep 17 00:00:00 2001
From: Andreas Schwab <schwab@redhat.com>
Date: Thu, 9 Dec 2010 15:00:59 +0100
Subject: [PATCH] Ignore origin of privileged program

---
 elf/dl-load.c   |   54 ++++++++++++++++++++++++++++++++----------------------
 elf/dl-object.c |    3 +++
 2 files changed, 35 insertions(+), 22 deletions(-)

From 101fdc24deea7f3895d82db9c89fa41af29a2f1e Mon Sep 17 00:00:00 2001
From: Andreas Schwab <schwab@redhat.com>
Date: Wed, 9 Mar 2011 18:39:31 +0100
Subject: [PATCH] Don't leave empty element in rpath when skipping the first element

---
 elf/dl-load.c   |   54 ++++++++++++++++++++++++++++++++----------------------
 elf/dl-object.c |    3 +++
 2 files changed, 35 insertions(+), 22 deletions(-)

From 049b59f78fdcb533fe2999ba73daa32c2f8cb758 Mon Sep 17 00:00:00 2001
From: Andreas Schwab <schwab@redhat.com>
Date: Wed, 9 Mar 2011 18:42:06 +0100
Subject: [PATCH] Ignore rpath elements containing non-isolated use of $ORIGIN when privileged

---
 elf/dl-load.c   |   54 ++++++++++++++++++++++++++++++++----------------------
 elf/dl-object.c |    3 +++
 2 files changed, 35 insertions(+), 22 deletions(-)

CVE-2011-1658

[Ubuntu note: patches differ from upstream in that the changes to
 the Changelog file have been dropped to minimize patch conflicts.]

Index: b/elf/dl-object.c
===================================================================
--- a/elf/dl-object.c
+++ b/elf/dl-object.c
@@ -133,6 +133,9 @@ _dl_new_object (char *realname, const ch
 
       new->l_scope[idx] = &loader->l_searchlist;
     }
+  else if (INTUSE(__libc_enable_secure) && type == lt_executable)
+    /* The origin of a privileged program cannot be trusted.  */
+    new->l_origin = (char *) -1;
 
   new->l_local_scope[0] = &new->l_searchlist;
 
Index: b/elf/dl-load.c
===================================================================
--- a/elf/dl-load.c
+++ b/elf/dl-load.c
@@ -169,8 +169,7 @@ local_strdup (const char *s)
 
 
 static size_t
-is_dst (const char *start, const char *name, const char *str,
-	int is_path, int secure)
+is_dst (const char *start, const char *name, const char *str, int is_path)
 {
   size_t len;
   bool is_curly = false;
@@ -199,11 +198,6 @@ is_dst (const char *start, const char *n
 	   && (!is_path || name[len] != ':'))
     return 0;
 
-  if (__builtin_expect (secure, 0)
-      && ((name[len] != '\0' && (!is_path || name[len] != ':'))
-	  || (name != start + 1 && (!is_path || name[-2] != ':'))))
-    return 0;
-
   return len;
 }
 
@@ -218,13 +212,10 @@ _dl_dst_count (const char *name, int is_
     {
       size_t len;
 
-      /* $ORIGIN is not expanded for SUID/GUID programs (except if it
-	 is $ORIGIN alone) and it must always appear first in path.  */
       ++name;
-      if ((len = is_dst (start, name, "ORIGIN", is_path,
-			 INTUSE(__libc_enable_secure))) != 0
-	  || (len = is_dst (start, name, "PLATFORM", is_path, 0)) != 0
-	  || (len = is_dst (start, name, "LIB", is_path, 0)) != 0)
+      if ((len = is_dst (start, name, "ORIGIN", is_path)) != 0
+	  || (len = is_dst (start, name, "PLATFORM", is_path)) != 0
+	  || (len = is_dst (start, name, "LIB", is_path)) != 0)
 	++cnt;
 
       name = strchr (name + len, '$');
@@ -256,9 +247,16 @@ _dl_dst_substitute (struct link_map *l,
 	  size_t len;
 
 	  ++name;
-	  if ((len = is_dst (start, name, "ORIGIN", is_path,
-			     INTUSE(__libc_enable_secure))) != 0)
+	  if ((len = is_dst (start, name, "ORIGIN", is_path)) != 0)
 	    {
+	      /* $ORIGIN is not expanded for SUID/GUID programs
+		 (except if it is $ORIGIN alone) and it must always
+		 appear first in path.  */
+	      if (__builtin_expect (INTUSE(__libc_enable_secure), 0)
+		  && ((name[len] != '\0' && (!is_path || name[len] != ':'))
+		      || (name != start + 1 && (!is_path || name[-2] != ':'))))
+		repl = (const char *) -1;
+	      else
 #ifndef SHARED
 	      if (l == NULL)
 		repl = _dl_get_origin ();
@@ -266,9 +264,9 @@ _dl_dst_substitute (struct link_map *l,
 #endif
 		repl = l->l_origin;
 	    }
-	  else if ((len = is_dst (start, name, "PLATFORM", is_path, 0)) != 0)
+	  else if ((len = is_dst (start, name, "PLATFORM", is_path)) != 0)
 	    repl = GLRO(dl_platform);
-	  else if ((len = is_dst (start, name, "LIB", is_path, 0)) != 0)
+	  else if ((len = is_dst (start, name, "LIB", is_path)) != 0)
 	    repl = DL_DST_LIB;
 
 	  if (repl != NULL && repl != (const char *) -1)
@@ -284,6 +282,10 @@ _dl_dst_substitute (struct link_map *l,
 	      name += len;
 	      while (*name != '\0' && (!is_path || *name != ':'))
 		++name;
+	      /* Also skip following colon if this is the first rpath
+		 element, but keep an empty element at the end.  */
+	      if (wp == result && is_path && *name == ':' && name[1] != '\0')
+		++name;
 	    }
 	  else
 	    /* No DST we recognize.  */
@@ -310,7 +312,7 @@ _dl_dst_substitute (struct link_map *l,
    belonging to the map is loaded.  In this case the path element
    containing $ORIGIN is left out.  */
 static char *
-expand_dynamic_string_token (struct link_map *l, const char *s)
+expand_dynamic_string_token (struct link_map *l, const char *s, int is_path)
 {
   /* We make two runs over the string.  First we determine how large the
      resulting string is and then we copy it over.  Since this is now
@@ -321,7 +323,7 @@ expand_dynamic_string_token (struct link
   char *result;
 
   /* Determine the number of DST elements.  */
-  cnt = DL_DST_COUNT (s, 1);
+  cnt = DL_DST_COUNT (s, is_path);
 
   /* If we do not have to replace anything simply copy the string.  */
   if (__builtin_expect (cnt, 0) == 0)
@@ -335,7 +337,7 @@ expand_dynamic_string_token (struct link
   if (result == NULL)
     return NULL;
 
-  return _dl_dst_substitute (l, s, result, 1);
+  return _dl_dst_substitute (l, s, result, is_path);
 }
 
 
@@ -551,13 +553,21 @@ decompose_rpath (struct r_search_path_st
 
   /* Make a writable copy.  At the same time expand possible dynamic
      string tokens.  */
-  copy = expand_dynamic_string_token (l, rpath);
+  copy = expand_dynamic_string_token (l, rpath, 1);
   if (copy == NULL)
     {
       errstring = N_("cannot create RUNPATH/RPATH copy");
       goto signal_error;
     }
 
+  /* Ignore empty rpaths.  */
+  if (*copy == 0)
+    {
+      free (copy);
+      sps->dirs = (struct r_search_path_elem **) -1;
+      return false;
+    }
+
   /* Count the number of necessary elements in the result array.  */
   nelems = 0;
   for (cp = copy; *cp != '\0'; ++cp)
@@ -2172,7 +2182,7 @@ _dl_map_object (struct link_map *loader,
     {
       /* The path may contain dynamic string tokens.  */
       realname = (loader
-		  ? expand_dynamic_string_token (loader, name)
+		  ? expand_dynamic_string_token (loader, name, 0)
 		  : local_strdup (name));
       if (realname == NULL)
 	fd = -1;
