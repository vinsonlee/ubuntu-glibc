diff -urN glibc-2.5~/elf/Makefile glibc-2.5/elf/Makefile
--- glibc-2.5~/elf/Makefile	2007-03-20 16:17:30.000000000 +0100
+++ glibc-2.5/elf/Makefile	2007-03-20 16:21:21.000000000 +0100
@@ -175,7 +175,7 @@
 	 tst-dlmopen1 tst-dlmopen2 tst-dlmopen3 \
 	 unload3 unload4 unload5 unload6 unload7 tst-global1 order2 \
 	 tst-audit1 tst-audit2 \
-	 tst-stackguard1 tst-addr1
+	 tst-stackguard1 tst-addr1 tst-thrlock
 #	 reldep9
 test-srcs = tst-pathopt
 tests-vis-yes = vismain
@@ -920,3 +920,5 @@
 tst-leaks1-ENV = MALLOC_TRACE=$(objpfx)tst-leaks1.mtrace
 
 $(objpfx)tst-addr1: $(libdl)
+
+$(objpfx)tst-thrlock: $(libdl) $(shared-thread-library)
diff -urN glibc-2.5~/elf/dl-close.c glibc-2.5/elf/dl-close.c
--- glibc-2.5~/elf/dl-close.c	2006-09-19 16:39:42.000000000 +0200
+++ glibc-2.5/elf/dl-close.c	2007-03-20 16:21:21.000000000 +0100
@@ -101,22 +101,9 @@
 
 
 void
-_dl_close (void *_map)
+_dl_close_worker (struct link_map *map)
 {
-  struct link_map *map = _map;
   Lmid_t ns = map->l_ns;
-  unsigned int i;
-  /* First see whether we can remove the object at all.  */
-  if (__builtin_expect (map->l_flags_1 & DF_1_NODELETE, 0)
-      && map->l_init_called)
-    /* Nope.  Do nothing.  */
-    return;
-
-  if (__builtin_expect (map->l_direct_opencount, 1) == 0)
-    GLRO(dl_signal_error) (0, map->l_name, NULL, N_("shared object not open"));
-
-  /* Acquire the lock.  */
-  __rtld_lock_lock_recursive (GL(dl_load_lock));
 
   /* One less direct use.  */
   --map->l_direct_opencount;
@@ -137,7 +124,6 @@
 	_dl_debug_printf ("\nclosing file=%s; direct_opencount=%u\n",
 			  map->l_name, map->l_direct_opencount);
 
-      __rtld_lock_unlock_recursive (GL(dl_load_lock));
       return;
     }
 
@@ -240,7 +226,7 @@
 #endif
   bool unload_any = false;
   unsigned int first_loaded = ~0;
-  for (i = 0; i < nloaded; ++i)
+  for (unsigned int i = 0; i < nloaded; ++i)
     {
       struct link_map *imap = maps[i];
 
@@ -411,7 +397,7 @@
 
   /* Check each element of the search list to see if all references to
      it are gone.  */
-  for (i = first_loaded; i < nloaded; ++i)
+  for (unsigned int i = first_loaded; i < nloaded; ++i)
     {
       struct link_map *imap = maps[i];
       if (!used[i])
@@ -627,6 +613,30 @@
     goto retry;
 
   dl_close_state = not_pending;
+}
+
+
+void
+_dl_close (void *_map)
+{
+  struct link_map *map = _map;
+
+  /* First see whether we can remove the object at all.  */
+  if (__builtin_expect (map->l_flags_1 & DF_1_NODELETE, 0))
+    {
+      assert (map->l_init_called);
+      /* Nope.  Do nothing.  */
+      return;
+    }
+
+  if (__builtin_expect (map->l_direct_opencount, 1) == 0)
+    GLRO(dl_signal_error) (0, map->l_name, NULL, N_("shared object not open"));
+
+  /* Acquire the lock.  */
+  __rtld_lock_lock_recursive (GL(dl_load_lock));
+
+  _dl_close_worker (map);
+
   __rtld_lock_unlock_recursive (GL(dl_load_lock));
 }
 
diff -urN glibc-2.5~/elf/dl-open.c glibc-2.5/elf/dl-open.c
--- glibc-2.5~/elf/dl-open.c	2006-08-29 00:56:50.000000000 +0200
+++ glibc-2.5/elf/dl-open.c	2007-03-20 16:21:21.000000000 +0100
@@ -547,15 +547,9 @@
   _dl_unload_cache ();
 #endif
 
-  /* Release the lock.  */
-  __rtld_lock_unlock_recursive (GL(dl_load_lock));
-
+  /* See if an error occurred during loading.  */
   if (__builtin_expect (errstring != NULL, 0))
     {
-      /* Some error occurred during loading.  */
-      char *local_errstring;
-      size_t len_errstring;
-
       /* Remove the object from memory.  It may be in an inconsistent
 	 state if relocation failed, for example.  */
       if (args.map)
@@ -572,12 +566,18 @@
 	    GL(dl_tls_dtv_gaps) = true;
 #endif
 
-	  _dl_close (args.map);
+	  _dl_close_worker (args.map);
 	}
 
+      assert (_dl_debug_initialize (0, args.nsid)->r_state == RT_CONSISTENT);
+
+      /* Release the lock.  */
+      __rtld_lock_unlock_recursive (GL(dl_load_lock));
+
       /* Make a local copy of the error string so that we can release the
 	 memory allocated for it.  */
-      len_errstring = strlen (errstring) + 1;
+      size_t len_errstring = strlen (errstring) + 1;
+      char *local_errstring;
       if (objname == errstring + len_errstring)
 	{
 	  size_t total_len = len_errstring + strlen (objname) + 1;
@@ -594,14 +594,15 @@
       if (malloced)
 	free ((char *) errstring);
 
-      assert (_dl_debug_initialize (0, args.nsid)->r_state == RT_CONSISTENT);
-
       /* Reraise the error.  */
       _dl_signal_error (errcode, objname, NULL, local_errstring);
     }
 
   assert (_dl_debug_initialize (0, args.nsid)->r_state == RT_CONSISTENT);
 
+  /* Release the lock.  */
+  __rtld_lock_unlock_recursive (GL(dl_load_lock));
+
 #ifndef SHARED
   DL_STATIC_INIT (args.map);
 #endif
diff -urN glibc-2.5~/elf/tst-thrlock.c glibc-2.5/elf/tst-thrlock.c
--- glibc-2.5~/elf/tst-thrlock.c	1970-01-01 01:00:00.000000000 +0100
+++ glibc-2.5/elf/tst-thrlock.c	2007-03-20 16:21:21.000000000 +0100
@@ -0,0 +1,55 @@
+#include <dlfcn.h>
+#include <pthread.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <gnu/lib-names.h>
+
+static void *
+tf (void *arg)
+{
+  void *h = dlopen (LIBM_SO, RTLD_LAZY);
+  if (h == NULL)
+    {
+      printf ("dlopen failed: %s\n", dlerror ());
+      exit (1);
+    }
+  if (dlsym (h, "sin") == NULL)
+    {
+      printf ("dlsym failed: %s\n", dlerror ());
+      exit (1);
+    }
+  if (dlclose (h) != 0)
+    {
+      printf ("dlclose failed: %s\n", dlerror ());
+      exit (1);
+    }
+  return NULL;
+}
+
+int
+main (void)
+{
+#define N 10
+  pthread_t th[N];
+  for (int i = 0; i < N; ++i)
+    {
+      int e = pthread_create (&th[i], NULL, tf, NULL);
+      if (e != 0)
+	{
+	  printf ("pthread_create failed with %d (%s)\n", e, strerror (e));
+	  return 1;
+	}
+    }
+  for (int i = 0; i < N; ++i)
+    {
+      void *res;
+      int e = pthread_join (th[i], &res);
+      if (e != 0 || res != NULL)
+	{
+	  puts ("thread failed");
+	  return 1;
+	}
+    }
+  return 0;
+}
