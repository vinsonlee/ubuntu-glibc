#! /bin/sh -e

# All lines beginning with `# DP:' are a description of the patch.
# DP: Description: Check state on initstate_r
# DP: Related bugs: Ubuntu# 10245
# DP: Dpatch author: Jeff Bailey
# DP: Patch author: Ulrich Drepper
# DP: Upstream status: In CVS
# DP: Status Details: 
# DP: Date: 2005-09-01

PATCHLEVEL=0

if [ $# -ne 2 ]; then
    echo >&2 "`basename $0`: script expects -patch|-unpatch as argument"
    exit 1
fi
case "$1" in
    -patch) patch -d "$2" -f --no-backup-if-mismatch -p$PATCHLEVEL < $0;;
    -unpatch) patch -d "$2" -f --no-backup-if-mismatch -R -p$PATCHLEVEL < $0;;
    *)
	echo >&2 "`basename $0`: script expects -patch|-unpatch as argument"
	exit 1
esac
exit 0

# append the patch here and adjust the -p? flag in the patch calls.

2005-04-12  Ulrich Drepper  <drepper@redhat.com>

        [BZ #1090]
        * stdlib/random_r.c (__initstate_r): Don't use non-existing state.
        * string/tst-strfry.c: New file.
        * string/Makefile (tests): Add tst-strfry.

--- stdlib/random_r.c	2005-02-16 06:23:58.000000000 -0500
+++ stdlib/random_r.c	2005-09-01 21:08:02.000000000 -0400
@@ -236,23 +236,20 @@ __initstate_r (seed, arg_state, n, buf)
      size_t n;
      struct random_data *buf;
 {
-  int type;
-  int degree;
-  int separation;
-  int32_t *state;
-  int old_type;
-  int32_t *old_state;
-
   if (buf == NULL)
     goto fail;
 
-  old_type = buf->rand_type;
-  old_state = buf->state;
-  if (old_type == TYPE_0)
-    old_state[-1] = TYPE_0;
-  else
-    old_state[-1] = (MAX_TYPES * (buf->rptr - old_state)) + old_type;
+  int32_t *old_state = buf->state;
+  if (old_state != NULL)
+    {
+      int old_type = buf->rand_type;
+      if (old_type == TYPE_0)
+	old_state[-1] = TYPE_0;
+      else
+	old_state[-1] = (MAX_TYPES * (buf->rptr - old_state)) + old_type;
+    }
 
+  int type;
   if (n >= BREAK_3)
     type = n < BREAK_4 ? TYPE_3 : TYPE_4;
   else if (n < BREAK_1)
@@ -267,13 +264,13 @@ __initstate_r (seed, arg_state, n, buf)
   else
     type = n < BREAK_2 ? TYPE_1 : TYPE_2;
 
-  degree = random_poly_info.degrees[type];
-  separation = random_poly_info.seps[type];
+  int degree = random_poly_info.degrees[type];
+  int separation = random_poly_info.seps[type];
 
   buf->rand_type = type;
   buf->rand_sep = separation;
   buf->rand_deg = degree;
-  state = &((int32_t *) arg_state)[1];	/* First location.  */
+  int32_t *state = &((int32_t *) arg_state)[1];	/* First location.  */
   /* Must set END_PTR before srandom.  */
   buf->end_ptr = &state[degree];
 
