#! /bin/sh -e

# All lines beginning with `# DP:' are a description of the patch.
# DP: Description: Add RLIMIT_RTPRIO and RLIMIT_NLIMITS to glibc.
# DP: Related bugs: 
# DP: Dpatch author: 
# DP: Patch author:  Jakub and Ulrich
# DP: Upstream status: In CVS
# DP: Status Details: 
# DP: Date: 2006-03-01

PATCHLEVEL=1

if [ $# -ne 2 ]; then
    echo >&2 "`basename $0`: script expects -patch|-unpatch as argument"
    exit 1
fi
case "$1" in
    -patch) patch -d "$2" -f --no-backup-if-mismatch -p$PATCHLEVEL < $0;;
    -unpatch) patch -d "$2" -f --no-backup-if-mismatch -R -p$PATCHLEVEL < $0;;
    *)
	echo >&2 "`basename $0`: script expects -patch|-unpatch as argument"
	exit 1
esac
exit 0

2005-06-21  Ulrich Drepper  <drepper@redhat.com>

        * resource/Makefile (tests): Add tst-getrlimit.
        * resource/tst-getrlimit.c: New file.

        * sysdeps/unix/sysv/linux/bits/resource.h (RLIMIT_RTPRIO): Fix typo.
        * sysdeps/unix/sysv/linux/alpha/bits/resource.h: Likewise.
        * sysdeps/unix/sysv/linux/sparc/bits/resource.h: Likewise.


2005-06-20  Jakub Jelinek  <jakub@redhat.com>

        * sysdeps/unix/sysv/linux/bits/resource.h (RLIMIT_NICE,
        RLIMIT_RTPRIO): Add.
        (RLIMIT_NLIMITS): Adjust.
        * sysdeps/unix/sysv/linux/alpha/bits/resource.h (RLIMIT_NICE,
        RLIMIT_RTPRIO): Add.
        (RLIMIT_NLIMITS): Adjust.
        * sysdeps/unix/sysv/linux/mips/bits/resource.h (RLIMIT_NICE,
        RLIMIT_RTPRIO): Add.
        (RLIMIT_NLIMITS): Adjust.
        * sysdeps/unix/sysv/linux/sparc/bits/resource.h (RLIMIT_NICE,
        RLIMIT_RTPRIO): Add.
        (RLIMIT_NLIMITS): Adjust.


# append the patch here and adjust the -p? flag in the patch calls.
diff -urN glibc-2.3.6.old/resource/Makefile glibc-2.3.6/resource/Makefile
--- glibc-2.3.6.old/resource/Makefile	2001-07-06 00:55:39.000000000 -0400
+++ glibc-2.3.6/resource/Makefile	2006-03-01 19:50:40.000000000 -0500
@@ -1,4 +1,4 @@
-# Copyright (C) 1991, 1992, 1994, 1995, 1997 Free Software Foundation, Inc.
+# Copyright (C) 1991,1992,1994,1995,1997,2005 Free Software Foundation, Inc.
 # This file is part of the GNU C Library.
 
 # The GNU C Library is free software; you can redistribute it and/or
@@ -24,4 +24,6 @@
 routines := getrlimit setrlimit getrlimit64 setrlimit64 getrusage ulimit      \
 	    vlimit vtimes getpriority setpriority nice
 
+tests = tst-getrlimit
+
 include ../Rules
diff -urN glibc-2.3.6.old/resource/tst-getrlimit.c glibc-2.3.6/resource/tst-getrlimit.c
--- glibc-2.3.6.old/resource/tst-getrlimit.c	1969-12-31 19:00:00.000000000 -0500
+++ glibc-2.3.6/resource/tst-getrlimit.c	2006-03-01 19:49:15.000000000 -0500
@@ -0,0 +1,112 @@
+#include <errno.h>
+#include <stdbool.h>
+#include <stdio.h>
+#include <sys/resource.h>
+
+
+static struct
+{
+  const char *name;
+  int resource;
+  bool required;
+} tests[] =
+  {
+    /* The following 7 limits are part of POSIX and must exist.  */
+    { "RLIMIT_CORE", RLIMIT_CORE, true },
+    { "RLIMIT_CPU", RLIMIT_CPU, true },
+    { "RLIMIT_DATA", RLIMIT_DATA, true },
+    { "RLIMIT_FSIZE", RLIMIT_FSIZE, true },
+    { "RLIMIT_NOFILE", RLIMIT_NOFILE, true },
+    { "RLIMIT_STACK", RLIMIT_STACK, true },
+    { "RLIMIT_AS", RLIMIT_AS, true },
+    /* The following are traditional Unix limits which are also
+       expected (by us).  */
+    { "RLIMIT_RSS", RLIMIT_RSS, true },
+    { "RLIMIT_NPROC", RLIMIT_NPROC, true },
+    /* The following are extensions.  */
+#ifdef RLIMIT_MEMLOCK
+    { "RLIMIT_MEMLOCK", RLIMIT_MEMLOCK, false },
+#endif
+#ifdef RLIMIT_LOCKS
+    { "RLIMIT_LOCKS", RLIMIT_LOCKS, false },
+#endif
+#ifdef RLIMIT_SIGPENDING
+    { "RLIMIT_SIGPENDING", RLIMIT_SIGPENDING, false },
+#endif
+#ifdef RLIMIT_MSGQUEUE
+    { "RLIMIT_MSGQUEUE", RLIMIT_MSGQUEUE, false },
+#endif
+#ifdef RLIMIT_NICE
+    { "RLIMIT_NICE", RLIMIT_NICE, false },
+#endif
+#ifdef RLIMIT_RTPRIO
+    { "RLIMIT_RTPRIO", RLIMIT_RTPRIO, false },
+#endif
+  };
+#define ntests (sizeof (tests) / sizeof (tests[0]))
+
+
+static int
+do_test (void)
+{
+  int status = 0;
+
+  for (int i = 0; i < ntests; ++i)
+    {
+      bool this_ok = true;
+
+      struct rlimit r;
+      int res = getrlimit (tests[i].resource, &r);
+      if (res == -1)
+	{
+	  if (errno == EINVAL)
+	    {
+	      if (tests[i].required)
+		{
+		  printf ("limit %s expectedly not available for getrlimit\n",
+			  tests[i].name);
+		  status = 1;
+		  this_ok = false;
+		}
+	    }
+	  else
+	    {
+	      printf ("getrlimit for %s returned unexpected error: %m\n",
+		      tests[i].name);
+	      status = 1;
+	      this_ok = false;
+	    }
+	}
+
+      struct rlimit64 r64;
+      res = getrlimit64 (tests[i].resource, &r64);
+      if (res == -1)
+	{
+	  if (errno == EINVAL)
+	    {
+	      if (tests[i].required)
+		{
+		  printf ("limit %s expectedly not available for getrlimit64"
+			  "\n", tests[i].name);
+		  status = 1;
+		  this_ok = false;
+		}
+	    }
+	  else
+	    {
+	      printf ("getrlimit64 for %s returned unexpected error: %m\n",
+		      tests[i].name);
+	      status = 1;
+	      this_ok = false;
+	    }
+	}
+
+      if (this_ok)
+	printf ("limit %s OK\n", tests[i].name);
+    }
+
+  return status;
+}
+
+#define TEST_FUNCTION do_test ()
+#include "../test-skeleton.c"
diff -urN glibc-2.3.6.old/sysdeps/unix/sysv/linux/alpha/bits/resource.h glibc-2.3.6/sysdeps/unix/sysv/linux/alpha/bits/resource.h
--- glibc-2.3.6.old/sysdeps/unix/sysv/linux/alpha/bits/resource.h	2004-08-16 04:51:46.000000000 -0400
+++ glibc-2.3.6/sysdeps/unix/sysv/linux/alpha/bits/resource.h	2006-03-01 19:52:11.000000000 -0500
@@ -1,5 +1,5 @@
 /* Bit values & structures for resource limits.  Alpha/Linux version.
-   Copyright (C) 1994, 1996, 1997, 1998, 1999, 2000, 2004
+   Copyright (C) 1994, 1996, 1997, 1998, 1999, 2000, 2004, 2005
    Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
@@ -89,7 +89,18 @@
   __RLIMIT_MSGQUEUE = 12,
 #define RLIMIT_MSGQUEUE __RLIMIT_MSGQUEUE
 
-  __RLIMIT_NLIMITS = 13,
+  /* Maximum nice priority allowed to raise to.
+     Nice levels 19 .. -20 correspond to 0 .. 39
+     values of this resource limit.  */
+  __RLIMIT_NICE = 13,
+#define RLIMIT_NICE __RLIMIT_NICE
+
+  /* Maximum realtime priority allowed for non-priviledged
+     processes.  */
+  __RLIMIT_RTPRIO = 14,
+#define RLIMIT_RTPRIO __RLIMIT_RTPRIO
+
+  __RLIMIT_NLIMITS = 15,
   __RLIM_NLIMITS = __RLIMIT_NLIMITS
 #define RLIMIT_NLIMITS __RLIMIT_NLIMITS
 #define RLIM_NLIMITS __RLIM_NLIMITS
diff -urN glibc-2.3.6.old/sysdeps/unix/sysv/linux/bits/resource.h glibc-2.3.6/sysdeps/unix/sysv/linux/bits/resource.h
--- glibc-2.3.6.old/sysdeps/unix/sysv/linux/bits/resource.h	2004-08-16 04:51:45.000000000 -0400
+++ glibc-2.3.6/sysdeps/unix/sysv/linux/bits/resource.h	2006-03-01 19:51:52.000000000 -0500
@@ -1,5 +1,5 @@
 /* Bit values & structures for resource limits.  Linux version.
-   Copyright (C) 1994, 1996, 1997, 1998, 1999, 2000, 2004
+   Copyright (C) 1994, 1996, 1997, 1998, 1999, 2000, 2004, 2005
    Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
@@ -89,7 +89,18 @@
   __RLIMIT_MSGQUEUE = 12,
 #define RLIMIT_MSGQUEUE __RLIMIT_MSGQUEUE
 
-  __RLIMIT_NLIMITS = 13,
+  /* Maximum nice priority allowed to raise to.
+     Nice levels 19 .. -20 correspond to 0 .. 39
+     values of this resource limit.  */
+  __RLIMIT_NICE = 13,
+#define RLIMIT_NICE __RLIMIT_NICE
+
+  /* Maximum realtime priority allowed for non-priviledged
+     processes.  */
+  __RLIMIT_RTPRIO = 14,
+#define RLIMIT_RTPRIO __RLIMIT_RTPRIO
+
+  __RLIMIT_NLIMITS = 15,
   __RLIM_NLIMITS = __RLIMIT_NLIMITS
 #define RLIMIT_NLIMITS __RLIMIT_NLIMITS
 #define RLIM_NLIMITS __RLIM_NLIMITS
diff -urN glibc-2.3.6.old/sysdeps/unix/sysv/linux/mips/resource.h glibc-2.3.6/sysdeps/unix/sysv/linux/mips/resource.h
--- glibc-2.3.6.old/sysdeps/unix/sysv/linux/mips/resource.h	1969-12-31 19:00:00.000000000 -0500
+++ glibc-2.3.6/sysdeps/unix/sysv/linux/mips/resource.h	2006-03-01 19:52:35.000000000 -0500
@@ -0,0 +1,225 @@
+/* Bit values & structures for resource limits.  Linux/MIPS version.
+   Copyright (C) 1994, 1996, 1997, 1998, 1999, 2000, 2004, 2005
+   Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _SYS_RESOURCE_H
+# error "Never use <bits/resource.h> directly; include <sys/resource.h> instead."
+#endif
+
+#include <bits/types.h>
+
+/* Transmute defines to enumerations.  The macro re-definitions are
+   necessary because some programs want to test for operating system
+   features with #ifdef RUSAGE_SELF.  In ISO C the reflexive
+   definition is a no-op.  */
+
+/* Kinds of resource limit.  */
+enum __rlimit_resource
+{
+  /* Per-process CPU limit, in seconds.  */
+  RLIMIT_CPU = 0,
+#define RLIMIT_CPU RLIMIT_CPU
+
+  /* Largest file that can be created, in bytes.  */
+  RLIMIT_FSIZE = 1,
+#define	RLIMIT_FSIZE RLIMIT_FSIZE
+
+  /* Maximum size of data segment, in bytes.  */
+  RLIMIT_DATA = 2,
+#define	RLIMIT_DATA RLIMIT_DATA
+
+  /* Maximum size of stack segment, in bytes.  */
+  RLIMIT_STACK = 3,
+#define	RLIMIT_STACK RLIMIT_STACK
+
+  /* Largest core file that can be created, in bytes.  */
+  RLIMIT_CORE = 4,
+#define	RLIMIT_CORE RLIMIT_CORE
+
+  /* Largest resident set size, in bytes.
+     This affects swapping; processes that are exceeding their
+     resident set size will be more likely to have physical memory
+     taken from them.  */
+  __RLIMIT_RSS = 7,
+#define	RLIMIT_RSS __RLIMIT_RSS
+
+  /* Number of open files.  */
+  RLIMIT_NOFILE = 5,
+  __RLIMIT_OFILE = RLIMIT_NOFILE, /* BSD name for same.  */
+#define RLIMIT_NOFILE RLIMIT_NOFILE
+#define RLIMIT_OFILE __RLIMIT_OFILE
+
+  /* Address space limit (?) */
+  RLIMIT_AS = 6,
+#define RLIMIT_AS RLIMIT_AS
+
+  /* Number of processes.  */
+  __RLIMIT_NPROC = 8,
+#define RLIMIT_NPROC __RLIMIT_NPROC
+
+  /* Locked-in-memory address space.  */
+  __RLIMIT_MEMLOCK = 9,
+#define RLIMIT_MEMLOCK __RLIMIT_MEMLOCK
+
+  /* Maximum number of file locks.  */
+  __RLIMIT_LOCKS = 10,
+#define RLIMIT_LOCKS __RLIMIT_LOCKS
+
+  /* Maximum number of pending signals.  */
+  __RLIMIT_SIGPENDING = 11,
+#define RLIMIT_SIGPENDING __RLIMIT_SIGPENDING
+
+  /* Maximum bytes in POSIX message queues.  */
+  __RLIMIT_MSGQUEUE = 12,
+#define RLIMIT_MSGQUEUE __RLIMIT_MSGQUEUE
+
+  /* Maximum nice priority allowed to raise to.
+     Nice levels 19 .. -20 correspond to 0 .. 39
+     values of this resource limit.  */
+  __RLIMIT_NICE = 13,
+#define RLIMIT_NICE __RLIMIT_NICE
+
+  /* Maximum realtime priority allowed for non-priviledged
+     processes.  */
+  __RLIMIT_RTPRIO = 14,
+#define RLIMIT_RTPRIO _RLIMIT_RTPRIO
+
+  __RLIMIT_NLIMITS = 15,
+  __RLIM_NLIMITS = __RLIMIT_NLIMITS
+#define RLIMIT_NLIMITS __RLIMIT_NLIMITS
+#define RLIM_NLIMITS __RLIM_NLIMITS
+};
+
+/* Value to indicate that there is no limit.  */
+#ifndef __USE_FILE_OFFSET64
+# define RLIM_INFINITY ((long int)(~0UL >> 1))
+#else
+# define RLIM_INFINITY 0x7fffffffffffffffLL
+#endif
+
+#ifdef __USE_LARGEFILE64
+# define RLIM64_INFINITY 0x7fffffffffffffffLL
+#endif
+
+/* We can represent all limits.  */
+#define RLIM_SAVED_MAX	RLIM_INFINITY
+#define RLIM_SAVED_CUR	RLIM_INFINITY
+
+
+/* Type for resource quantity measurement.  */
+#ifndef __USE_FILE_OFFSET64
+typedef __rlim_t rlim_t;
+#else
+typedef __rlim64_t rlim_t;
+#endif
+#ifdef __USE_LARGEFILE64
+typedef __rlim64_t rlim64_t;
+#endif
+
+struct rlimit
+  {
+    /* The current (soft) limit.  */
+    rlim_t rlim_cur;
+    /* The hard limit.  */
+    rlim_t rlim_max;
+  };
+
+#ifdef __USE_LARGEFILE64
+struct rlimit64
+  {
+    /* The current (soft) limit.  */
+    rlim64_t rlim_cur;
+    /* The hard limit.  */
+    rlim64_t rlim_max;
+ };
+#endif
+
+/* Whose usage statistics do you want?  */
+enum __rusage_who
+{
+  /* The calling process.  */
+  RUSAGE_SELF = 0,
+#define RUSAGE_SELF RUSAGE_SELF
+
+  /* All of its terminated child processes.  */
+  RUSAGE_CHILDREN = -1
+#define RUSAGE_CHILDREN RUSAGE_CHILDREN
+};
+
+#define __need_timeval
+#include <bits/time.h>		/* For `struct timeval'.  */
+
+/* Structure which says how much of each resource has been used.  */
+struct rusage
+  {
+    /* Total amount of user time used.  */
+    struct timeval ru_utime;
+    /* Total amount of system time used.  */
+    struct timeval ru_stime;
+    /* Maximum resident set size (in kilobytes).  */
+    long int ru_maxrss;
+    /* Amount of sharing of text segment memory
+       with other processes (kilobyte-seconds).  */
+    long int ru_ixrss;
+    /* Amount of data segment memory used (kilobyte-seconds).  */
+    long int ru_idrss;
+    /* Amount of stack memory used (kilobyte-seconds).  */
+    long int ru_isrss;
+    /* Number of soft page faults (i.e. those serviced by reclaiming
+       a page from the list of pages awaiting reallocation.  */
+    long int ru_minflt;
+    /* Number of hard page faults (i.e. those that required I/O).  */
+    long int ru_majflt;
+    /* Number of times a process was swapped out of physical memory.  */
+    long int ru_nswap;
+    /* Number of input operations via the file system.  Note: This
+       and `ru_oublock' do not include operations with the cache.  */
+    long int ru_inblock;
+    /* Number of output operations via the file system.  */
+    long int ru_oublock;
+    /* Number of IPC messages sent.  */
+    long int ru_msgsnd;
+    /* Number of IPC messages received.  */
+    long int ru_msgrcv;
+    /* Number of signals delivered.  */
+    long int ru_nsignals;
+    /* Number of voluntary context switches, i.e. because the process
+       gave up the process before it had to (usually to wait for some
+       resource to be available).  */
+    long int ru_nvcsw;
+    /* Number of involuntary context switches, i.e. a higher priority process
+       became runnable or the current process used up its time slice.  */
+    long int ru_nivcsw;
+  };
+
+/* Priority limits.  */
+#define PRIO_MIN	-20	/* Minimum priority a process can have.  */
+#define PRIO_MAX	20	/* Maximum priority a process can have.  */
+
+/* The type of the WHICH argument to `getpriority' and `setpriority',
+   indicating what flavor of entity the WHO argument specifies.  */
+enum __priority_which
+{
+  PRIO_PROCESS = 0,		/* WHO is a process ID.  */
+#define PRIO_PROCESS PRIO_PROCESS
+  PRIO_PGRP = 1,		/* WHO is a process group ID.  */
+#define PRIO_PGRP PRIO_PGRP
+  PRIO_USER = 2			/* WHO is a user ID.  */
+#define PRIO_USER PRIO_USER
+};
diff -urN glibc-2.3.6.old/sysdeps/unix/sysv/linux/sparc/resource.h glibc-2.3.6/sysdeps/unix/sysv/linux/sparc/resource.h
--- glibc-2.3.6.old/sysdeps/unix/sysv/linux/sparc/resource.h	1969-12-31 19:00:00.000000000 -0500
+++ glibc-2.3.6/sysdeps/unix/sysv/linux/sparc/resource.h	2006-03-01 19:53:39.000000000 -0500
@@ -0,0 +1,241 @@
+/* Bit values & structures for resource limits.  Linux/SPARC version.
+   Copyright (C) 1994, 1996, 1997, 1998, 1999, 2000, 2004, 2005
+   Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _SYS_RESOURCE_H
+# error "Never use <bits/resource.h> directly; include <sys/resource.h> instead."
+#endif
+
+#include <bits/types.h>
+
+/* Transmute defines to enumerations.  The macro re-definitions are
+   necessary because some programs want to test for operating system
+   features with #ifdef RUSAGE_SELF.  In ISO C the reflexive
+   definition is a no-op.  */
+
+/* Kinds of resource limit.  */
+enum __rlimit_resource
+{
+  /* Per-process CPU limit, in seconds.  */
+  RLIMIT_CPU = 0,
+#define RLIMIT_CPU RLIMIT_CPU
+
+  /* Largest file that can be created, in bytes.  */
+  RLIMIT_FSIZE = 1,
+#define	RLIMIT_FSIZE RLIMIT_FSIZE
+
+  /* Maximum size of data segment, in bytes.  */
+  RLIMIT_DATA = 2,
+#define	RLIMIT_DATA RLIMIT_DATA
+
+  /* Maximum size of stack segment, in bytes.  */
+  RLIMIT_STACK = 3,
+#define	RLIMIT_STACK RLIMIT_STACK
+
+  /* Largest core file that can be created, in bytes.  */
+  RLIMIT_CORE = 4,
+#define	RLIMIT_CORE RLIMIT_CORE
+
+  /* Largest resident set size, in bytes.
+     This affects swapping; processes that are exceeding their
+     resident set size will be more likely to have physical memory
+     taken from them.  */
+  __RLIMIT_RSS = 5,
+#define	RLIMIT_RSS __RLIMIT_RSS
+
+  /* Number of open files.  */
+  RLIMIT_NOFILE = 6,
+  __RLIMIT_OFILE = RLIMIT_NOFILE, /* BSD name for same.  */
+#define RLIMIT_NOFILE RLIMIT_NOFILE
+#define RLIMIT_OFILE __RLIMIT_OFILE
+
+  /* Address space limit (?) */
+  RLIMIT_AS = 9,
+#define RLIMIT_AS RLIMIT_AS
+
+  /* Number of processes.  */
+  __RLIMIT_NPROC = 7,
+#define RLIMIT_NPROC __RLIMIT_NPROC
+
+  /* Locked-in-memory address space.  */
+  __RLIMIT_MEMLOCK = 8,
+#define RLIMIT_MEMLOCK __RLIMIT_MEMLOCK
+
+  /* Maximum number of file locks.  */
+  __RLIMIT_LOCKS = 10,
+#define RLIMIT_LOCKS __RLIMIT_LOCKS
+
+  /* Maximum number of pending signals.  */
+  __RLIMIT_SIGPENDING = 11,
+#define RLIMIT_SIGPENDING __RLIMIT_SIGPENDING
+
+  /* Maximum bytes in POSIX message queues.  */
+  __RLIMIT_MSGQUEUE = 12,
+#define RLIMIT_MSGQUEUE __RLIMIT_MSGQUEUE
+
+  /* Maximum nice priority allowed to raise to.
+     Nice levels 19 .. -20 correspond to 0 .. 39
+     values of this resource limit.  */
+  __RLIMIT_NICE = 13,
+#define RLIMIT_NICE __RLIMIT_NICE
+
+  /* Maximum realtime priority allowed for non-priviledged
+     processes.  */
+  __RLIMIT_RTPRIO = 14,
+#define RLIMIT_RTPRIO __RLIMIT_RTPRIO
+
+  __RLIMIT_NLIMITS = 15,
+  __RLIM_NLIMITS = __RLIMIT_NLIMITS
+#define RLIMIT_NLIMITS __RLIMIT_NLIMITS
+#define RLIM_NLIMITS __RLIM_NLIMITS
+};
+
+/* Value to indicate that there is no limit.  */
+#if __WORDSIZE == 64
+
+#ifndef __USE_FILE_OFFSET64
+# define RLIM_INFINITY ((unsigned long int)(~0UL))
+#else
+# define RLIM_INFINITY 0xffffffffffffffffuLL
+#endif
+
+#ifdef __USE_LARGEFILE64
+# define RLIM64_INFINITY 0xffffffffffffffffuLL
+#endif
+
+#else
+
+#ifndef __USE_FILE_OFFSET64
+# define RLIM_INFINITY ((long int)(~0UL >> 1))
+#else
+# define RLIM_INFINITY 0x7fffffffffffffffLL
+#endif
+
+#ifdef __USE_LARGEFILE64
+# define RLIM64_INFINITY 0x7fffffffffffffffLL
+#endif
+
+#endif
+
+/* We can represent all limits.  */
+#define RLIM_SAVED_MAX	RLIM_INFINITY
+#define RLIM_SAVED_CUR	RLIM_INFINITY
+
+
+/* Type for resource quantity measurement.  */
+#ifndef __USE_FILE_OFFSET64
+typedef __rlim_t rlim_t;
+#else
+typedef __rlim64_t rlim_t;
+#endif
+#ifdef __USE_LARGEFILE64
+typedef __rlim64_t rlim64_t;
+#endif
+
+struct rlimit
+  {
+    /* The current (soft) limit.  */
+    rlim_t rlim_cur;
+    /* The hard limit.  */
+    rlim_t rlim_max;
+  };
+
+#ifdef __USE_LARGEFILE64
+struct rlimit64
+  {
+    /* The current (soft) limit.  */
+    rlim64_t rlim_cur;
+    /* The hard limit.  */
+    rlim64_t rlim_max;
+ };
+#endif
+
+/* Whose usage statistics do you want?  */
+enum __rusage_who
+{
+  /* The calling process.  */
+  RUSAGE_SELF = 0,
+#define RUSAGE_SELF RUSAGE_SELF
+
+  /* All of its terminated child processes.  */
+  RUSAGE_CHILDREN = -1
+#define RUSAGE_CHILDREN RUSAGE_CHILDREN
+};
+
+#define __need_timeval
+#include <bits/time.h>		/* For `struct timeval'.  */
+
+/* Structure which says how much of each resource has been used.  */
+struct rusage
+  {
+    /* Total amount of user time used.  */
+    struct timeval ru_utime;
+    /* Total amount of system time used.  */
+    struct timeval ru_stime;
+    /* Maximum resident set size (in kilobytes).  */
+    long int ru_maxrss;
+    /* Amount of sharing of text segment memory
+       with other processes (kilobyte-seconds).  */
+    long int ru_ixrss;
+    /* Amount of data segment memory used (kilobyte-seconds).  */
+    long int ru_idrss;
+    /* Amount of stack memory used (kilobyte-seconds).  */
+    long int ru_isrss;
+    /* Number of soft page faults (i.e. those serviced by reclaiming
+       a page from the list of pages awaiting reallocation.  */
+    long int ru_minflt;
+    /* Number of hard page faults (i.e. those that required I/O).  */
+    long int ru_majflt;
+    /* Number of times a process was swapped out of physical memory.  */
+    long int ru_nswap;
+    /* Number of input operations via the file system.  Note: This
+       and `ru_oublock' do not include operations with the cache.  */
+    long int ru_inblock;
+    /* Number of output operations via the file system.  */
+    long int ru_oublock;
+    /* Number of IPC messages sent.  */
+    long int ru_msgsnd;
+    /* Number of IPC messages received.  */
+    long int ru_msgrcv;
+    /* Number of signals delivered.  */
+    long int ru_nsignals;
+    /* Number of voluntary context switches, i.e. because the process
+       gave up the process before it had to (usually to wait for some
+       resource to be available).  */
+    long int ru_nvcsw;
+    /* Number of involuntary context switches, i.e. a higher priority process
+       became runnable or the current process used up its time slice.  */
+    long int ru_nivcsw;
+  };
+
+/* Priority limits.  */
+#define PRIO_MIN	-20	/* Minimum priority a process can have.  */
+#define PRIO_MAX	20	/* Maximum priority a process can have.  */
+
+/* The type of the WHICH argument to `getpriority' and `setpriority',
+   indicating what flavor of entity the WHO argument specifies.  */
+enum __priority_which
+{
+  PRIO_PROCESS = 0,		/* WHO is a process ID.  */
+#define PRIO_PROCESS PRIO_PROCESS
+  PRIO_PGRP = 1,		/* WHO is a process group ID.  */
+#define PRIO_PGRP PRIO_PGRP
+  PRIO_USER = 2			/* WHO is a user ID.  */
+#define PRIO_USER PRIO_USER
+};
