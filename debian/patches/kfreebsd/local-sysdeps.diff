--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/Dist
@@ -0,0 +1,30 @@
+bits/mcontext.h
+bits/stat16.h
+fpu.h
+machine/pal.h
+net/ethernet.h
+net/if_arp.h
+net/if_ether.h
+net/if_dl.h
+net/route.h
+nfs/nfs.h
+regdef.h
+sa_len.c
+stat16conv.c
+statconv.c
+statfsconv.c
+sys/acl.h
+sys/extattr.h
+sys/io.h
+sys/jail.h
+sys/linker.h
+sys/mount.h
+sys/perm.h
+sys/rfork.h
+sys/rtprio.h
+sys/syslimits.h
+sys/timex.h
+sys/vm86.h
+sys_lseek.S
+sysarch.h
+ucontext_i.h
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/Implies
@@ -0,0 +1,11 @@
+# The kernel include files come from the 'kernel-include' add-on.
+# This is actually added by configure.in.
+#/usr/src/sys/
+
+# One of two possible utmp file formats.
+# This is actually added by configure.in.
+#unix/bsd/bsd4.4/kfreebsd/utmp-xyz
+
+# The gnu subdirectory exists for things common to Linux-based, Hurd-based
+# and kFreeBSD-based GNU systems.
+gnu
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/Makefile
@@ -0,0 +1,124 @@
+# Use bash, not /bin/sh, for executing scripts, because the native
+# FreeBSD /bin/sh does not interpret the  IFS="<tab>" read ...  command
+# in localedata/tst-fmon.sh correctly.
+SHELL = bash
+
+# Additional header files to be installed in $prefix/include:
+
+ifeq ($(subdir),misc)
+sysdep_headers += \
+ sys/mount.h \
+ sys/kd.h \
+ sys/rfork.h
+endif
+
+ifeq ($(subdir),stdlib)
+sysdep_headers += \
+ bits/mcontext.h
+endif
+
+# Additional functions, and particular system calls:
+
+ifeq ($(subdir),csu)
+# For <errno.h>.
+sysdep_routines += errno-loc
+endif
+
+ifeq ($(subdir),assert)
+CFLAGS-assert.c += -DFATAL_PREPARE_INCLUDE='<fatal-prepare.h>'
+CFLAGS-assert-perr.c += -DFATAL_PREPARE_INCLUDE='<fatal-prepare.h>'
+endif
+
+ifeq ($(subdir),io)
+# For <unistd.h>.
+sysdep_routines += sys_getcwd sys_lseek
+# For <fcntl.h>.
+sysdep_routines += sys_open open_2
+# For <sys/stat.h>.
+sysdep_routines += sys_fstat sys_lstat sys_mknod sys_nfstat sys_nlstat sys_nstat sys_stat
+# For <sys/statfs.h>.
+sysdep_routines += fstatfs64 statfs64 sys_fstatfs sys_statfs
+# Other.
+sysdep_routines += lchmod
+endif
+
+ifeq ($(subdir),dirent)
+# For <dirent.h>.
+sysdep_routines += sys_getdents sys_getdirentries getdirentries getdirentries64
+endif
+
+ifeq ($(subdir),misc)
+# For <sched.h>.
+sysdep_routines += clone start_thread
+# For <unistd.h>.
+sysdep_routines += sys_ftruncate sys_truncate
+# For <sys/acl.h>.
+sysdep_routines += acl_aclcheck_fd acl_aclcheck_file acl_delete_fd acl_delete_file acl_get_fd acl_get_file acl_set_fd acl_set_file
+# For <sys/extattr.h>.
+sysdep_routines += extattrctl extattr_delete_file extattr_get_file extattr_set_file
+# For <sys/jail.h>.
+sysdep_routines += jail
+# For <sys/ktrace.h>.
+sysdep_routines += ktrace utrace
+# For <sys/linker.h>.
+sysdep_routines += kldfind kldfirstmod kldload kldnext kldstat kldsym kldunload kldunloadf
+# For <sys/mman.h>.
+sysdep_routines += minherit sys_mmap
+# For <sys/mount.h>.
+sysdep_routines += fhopen sys_fhstat sys_fhstatfs fhstat fhstat64 fhstatfs fhstatfs64 getfh getfsstat getfsstat64 sys_getfsstat getmntinfo getmntinfo64 mount nmount unmount
+# For <sys/ptrace.h>.
+sysdep_routines += sys_ptrace
+# For <sys/rfork.h>.
+sysdep_routines += rfork
+# For <sys/rtprio.h>.
+sysdep_routines += rtprio
+# For <sys/socket.h>.
+sysdep_routines += bsd_sendfile
+# For <sys/sysctl.h>.
+sysdep_routines += sysctl sysctlbyname
+# For <sys/uio.h>.
+sysdep_routines += sys_readv sys_writev
+# Other.
+sysdep_routines += swapon swapoff sys_aio_cancel sys_aio_error sys_aio_read sys_aio_return sys_aio_suspend sys_aio_waitcomplete sys_aio_write sys_lio_listio issetugid modfind modfnext modnext modstat obreak quotactl rfork sysarch undelete yield
+# for INLINE_SYSCALL
+sysdep_routines += sys_fork sys_execve sys_sigaction sys_close sys_fcntl
+sysdep_routines += sys_clock_getres sys_clock_gettime sys_clock_settime
+endif
+
+ifeq ($(subdir),posix)
+# For <unistd.h>.
+sysdep_routines += sys_getlogin sys_pread sys_pwrite sys_setlogin sys_read sys_write
+endif
+
+ifeq ($(subdir),inet)
+sysdep_headers += net/ethernet.h net/if_ether.h
+endif
+
+ifeq ($(subdir),time)
+# For <sys/timex.h>.
+sysdep_routines += ntp_adjtime ntp_gettime
+endif
+
+ifeq ($(subdir),socket)
+sysdep_routines += sa_len sys_bind sys_connect sys_sendto
+endif
+
+# Linuxthreads dependencies.
+
+ifeq ($(subdir),posix)
+sysdep_headers += bits/initspin.h
+endif
+
+# Don't compile the ctype glue code, since we have a much better <ctype.h>
+# than the old non-GNU C library.
+inhibit-glue = yes
+
+# Special ELF hacks.
+ifeq ($(subdir),elf)
+sysdep-rtld-routines += dl-brk dl-sbrk
+sysdep_routines += sys_umtx
+endif
+
+ifeq ($(subdir),sunrpc)
+sysdep_headers += nfs/nfs.h
+endif
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/Versions
@@ -0,0 +1,101 @@
+libc {
+  # The comment lines with "#errlist-compat" are magic; see errlist-compat.awk.
+  # When you get an error from errlist-compat.awk, you need to add a new
+  # version here.  Don't do this blindly, since this means changing the ABI
+  # for all GNU/kFreeBSD configurations.
+
+  GLIBC_2.2.6 {
+    # c*
+    clone;
+
+    # e*
+    extattrctl; extattr_delete_file; extattr_get_file; extattr_set_file;
+
+    # f*
+    fhopen; fhstat; fhstatfs; futimes;
+
+    # g*
+    getdents; getfh; getfsstat; getfsstat64; getmntinfo; getmntinfo64;
+    getresgid; getresuid;
+
+    # i*
+    issetugid;
+
+    # j*
+    jail;
+
+    # k*
+    kldfind; kldfirstmod; kldload; kldnext; kldstat; kldsym; kldunload; kldunloadf;
+    ktrace;
+
+    # l*
+    lchmod; lutimes;
+
+    # m*
+    minherit; modfind; modfnext; modnext; modstat; mount;
+
+    # n*
+    nmount; ntp_adjtime; ntp_gettime;
+
+    # q*
+    quotactl;
+
+    # r*
+    rfork; rtprio;
+
+    # s*
+    sendfile; setresgid; setresuid; swapoff; swapon; sysarch; sysctl; sysctlbyname;
+
+    # u*
+    undelete; unmount; utrace;
+
+    # see <sys/acl.h>.
+    __acl_aclcheck_fd; __acl_aclcheck_file; __acl_delete_fd; __acl_delete_file;
+    __acl_get_fd; __acl_get_file; __acl_set_fd; __acl_set_file;
+
+    # see <errno.h>.
+    __errno_location;
+
+    # see <sys/sysctl.h>.
+    __sysctl;
+
+    # Questionable system calls. These functions may be removed at any moment.
+    __syscall_aio_cancel; __syscall_aio_error; __syscall_aio_read;
+    __syscall_aio_return; __syscall_aio_suspend; __syscall_aio_waitcomplete;
+    __syscall_aio_write; __syscall_lio_listio;
+    __syscall_obreak;
+    __syscall_yield;
+  }
+  GLIBC_2.3 {
+    #errlist-compat     87
+    _sys_errlist; sys_errlist; _sys_nerr; sys_nerr;
+  }
+  GLIBC_2.3.4 {
+    # f*
+    fhstat64; fhstatfs64;
+    kqueue; kevent;
+
+    #errlist-compat     93
+    _sys_errlist; sys_errlist; _sys_nerr; sys_nerr;
+
+    # functions used in inline functions or macros
+    __libc_sa_len;
+  }
+  GLIBC_PRIVATE {
+    # needed by libpthread.
+    __clone; __libc_fork; __libc_sigaction;
+    # needed by libpthread as INLINE_SYSCALL:
+    __syscall_fork;
+    __syscall_open; __syscall_close;
+    __syscall_read; __syscall_write;
+    __syscall_wait4; __syscall_fcntl;
+    # needed by librt as INLINE_SYSCALL:
+    __syscall_clock_getres; __syscall_clock_gettime; __syscall_clock_settime;
+     # misc fixes for FreeBSD:
+    __syscall_freebsd6_lseek; __syscall_freebsd6_pread; __syscall_freebsd6_pwrite;
+    __syscall_connect; __syscall_sendto;
+    __sigprocmask; __ioctl;
+     # global variable used in brk()
+    _end;
+  }
+}
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/_G_config.h
@@ -0,0 +1,100 @@
+/* This file is needed by libio to define various configuration parameters.
+   These are always the same in the GNU C library.  */
+
+#ifndef _G_config_h
+#define _G_config_h 1
+
+/* Define types for libio in terms of the standard internal type names.  */
+
+#include <bits/types.h>
+#define __need_size_t
+#if defined _LIBC || defined _GLIBCPP_USE_WCHAR_T
+# define __need_wchar_t
+#endif
+#define __need_NULL
+#include <stddef.h>
+#define __need_mbstate_t
+#if defined _LIBC || defined _GLIBCPP_USE_WCHAR_T
+# define __need_wint_t
+#endif
+#include <wchar.h>
+#define _G_size_t	size_t
+typedef struct
+{
+  __off_t __pos;
+  __mbstate_t __state;
+} _G_fpos_t;
+typedef struct
+{
+  __off64_t __pos;
+  __mbstate_t __state;
+} _G_fpos64_t;
+#define _G_ssize_t	__ssize_t
+#define _G_off_t	__off_t
+#define _G_off64_t	__off64_t
+#define	_G_pid_t	__pid_t
+#define	_G_uid_t	__uid_t
+#define _G_wchar_t	wchar_t
+#define _G_wint_t	wint_t
+#define _G_stat64	stat64
+#if defined _LIBC || defined _GLIBCPP_USE_WCHAR_T
+# include <gconv.h>
+typedef union
+{
+  struct __gconv_info __cd;
+  struct
+  {
+    struct __gconv_info __cd;
+    struct __gconv_step_data __data;
+  } __combined;
+} _G_iconv_t;
+#endif
+
+typedef int _G_int16_t __attribute__ ((__mode__ (__HI__)));
+typedef int _G_int32_t __attribute__ ((__mode__ (__SI__)));
+typedef unsigned int _G_uint16_t __attribute__ ((__mode__ (__HI__)));
+typedef unsigned int _G_uint32_t __attribute__ ((__mode__ (__SI__)));
+
+#define _G_HAVE_BOOL 1
+
+
+/* These library features are always available in the GNU C library.  */
+#define _G_HAVE_ATEXIT 1
+#define _G_HAVE_SYS_CDEFS 1
+#define _G_HAVE_SYS_WAIT 1
+#define _G_NEED_STDARG_H 1
+#define _G_va_list __gnuc_va_list
+
+#define _G_HAVE_PRINTF_FP 1
+#define _G_HAVE_MMAP 1
+#define _G_HAVE_LONG_DOUBLE_IO 1
+#define _G_HAVE_IO_FILE_OPEN 1
+#define _G_HAVE_IO_GETLINE_INFO 1
+
+#define _G_IO_IO_FILE_VERSION 0x20001
+
+#define _G_OPEN64	__open64
+#define _G_LSEEK64	__lseek64
+#define _G_MMAP64	__mmap64
+#define _G_FSTAT64(fd,buf) __fxstat64 (_STAT_VER, fd, buf)
+
+/* This is defined by <bits/stat.h> if `st_blksize' exists.  */
+#define _G_HAVE_ST_BLKSIZE defined (_STATBUF_ST_BLKSIZE)
+
+#define _G_BUFSIZ 8192
+
+/* These are the vtbl details for ELF.  */
+#define _G_NAMES_HAVE_UNDERSCORE 0
+#define _G_VTABLE_LABEL_HAS_LENGTH 1
+#define _G_USING_THUNKS	1
+#define _G_VTABLE_LABEL_PREFIX "__vt_"
+#define _G_VTABLE_LABEL_PREFIX_ID __vt_
+
+
+#if defined __cplusplus || defined __STDC__
+# define _G_ARGS(ARGLIST) ARGLIST
+#else
+# define _G_ARGS(ARGLIST) ()
+#endif
+
+#endif	/* _G_config.h */
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/alpha/Makefile
@@ -0,0 +1,28 @@
+# Additional header files to be installed in $prefix/include:
+
+ifeq ($(subdir),misc)
+sysdep_headers += machine/pal.h
+sysdep_routines += sys_select sys_utimes sys_lutimes sys_futimes
+endif
+
+# Additional functions, and particular system calls:
+
+ifeq ($(subdir),io)
+sysdep_routines += sys_poll
+endif
+
+ifeq ($(subdir),math)
+sysdep_routines += ieee_get_fp_control ieee_set_fp_control
+endif
+
+ifeq ($(subdir),posix)
+sysdep_routines += sys_nanosleep sys_sched_rr_gi
+endif
+
+ifeq ($(subdir),time)
+sysdep_routines += sys_adjtime sys_gettimeofday sys_settimeofday sys_getitimer sys_setitimer
+endif
+
+ifeq ($(subdir),resource)
+sysdep_routines += sys_getrusage
+endif
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/alpha/README
@@ -0,0 +1,11 @@
+Note that even on 64-bit platforms, because __ino64_t != __ino_t, we have
+stat64 != stat, fstat64 != fstat, lstat64 != lstat, fhstat64 != fhstat,
+glob64 != glob.
+
+Note that on alpha glue code is used in order to use a 64-bit __time_t with a
+32-bit __kernel_time_t type. All system calls taking arguments with
+'time_t', 'struct timeval', 'struct timespec', 'struct itimerval',
+'struct rusage', 'struct msqid_ds', 'struct shmid_ds', 'struct semid_ds' need
+some special handling. The benefit is that user programs will not need to switch
+from a 32-bit time_t to a 64-bit time_t in 2038.
+
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/alpha/adjtime.c
@@ -0,0 +1,51 @@
+/* Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Bruno Haible <bruno@clisp.org>, 2002.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <stddef.h>
+#include <sys/time.h>
+#include <bits/kernel_time_t.h>
+
+extern int __syscall_adjtime (const struct __kernel_timeval *delta,
+			      struct __kernel_timeval *olddelta);
+
+int
+__adjtime (const struct timeval *delta, struct timeval *olddelta)
+{
+  struct __kernel_timeval kdelta;
+  int retval;
+
+  kdelta.tv_sec  = delta->tv_sec;
+  kdelta.tv_usec = delta->tv_usec;
+  if (olddelta != NULL)
+    {
+      struct __kernel_timeval kolddelta;
+
+      retval = __syscall_adjtime (&kdelta, &kolddelta);
+      if (retval >= 0)
+	{
+	  olddelta->tv_sec  = kolddelta.tv_sec;
+	  olddelta->tv_usec = kolddelta.tv_usec;
+	}
+    }
+  else
+    retval = __syscall_adjtime (&kdelta, NULL);
+  return retval;
+}
+
+weak_alias (__adjtime, adjtime)
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/alpha/bits/kernel_time_t.h
@@ -0,0 +1,143 @@
+/* Copyright (C) 2006 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Aurelien Jarno <aurelien@aurel32.net>, 2006.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+
+/* This header files describe the way that structures using time_t
+   are represented in the kernel */
+
+#ifndef _BITS_KERNEL_TIME_T_H
+#define _BITS_TIME_H 1
+
+#include <bits/types.h>
+#include <sys/msg.h>
+
+/* This structure corresponds to the newer FreeBSD 'struct timespec' */
+struct __kernel_timespec
+  {
+    int tv_sec;			/* Seconds.  */
+    long int tv_nsec;		/* Nanoseconds.  */
+  };
+
+/* This structure corresponds to the newer FreeBSD 'struct timeval' */
+struct __kernel_timeval
+  {
+    int tv_sec;			/* Seconds.  */
+    __suseconds_t tv_usec;	/* Microseconds.  */
+  };
+
+/* This structure corresponds to the newer FreeBSD 'struct itimerval' */
+struct __kernel_itimerval
+  {
+    /* Value to put into `it_value' when the timer expires.  */
+    struct __kernel_timeval it_interval;
+    /* Time to the next timer expiration.  */
+    struct __kernel_timeval it_value;
+  };
+
+/* This structure corresponds to the newer FreeBSD 'struct rusage' */
+struct __kernel_rusage
+  {
+    /* Total amount of user time used.  */
+    struct __kernel_timeval ru_utime;
+    /* Total amount of system time used.  */
+    struct __kernel_timeval ru_stime;
+    /* Maximum resident set size (in kilobytes).  */
+    long int ru_maxrss;
+    /* Amount of sharing of text segment memory
+       with other processes (kilobyte-seconds).  */
+    long int ru_ixrss;
+    /* Amount of data segment memory used (kilobyte-seconds).  */
+    long int ru_idrss;
+    /* Amount of stack memory used (kilobyte-seconds).  */
+    long int ru_isrss;
+    /* Number of soft page faults (i.e. those serviced by reclaiming
+       a page from the list of pages awaiting reallocation.  */
+    long int ru_minflt;
+    /* Number of hard page faults (i.e. those that required I/O).  */
+    long int ru_majflt;
+    /* Number of times a process was swapped out of physical memory.  */
+    long int ru_nswap;
+    /* Number of input operations via the file system.  Note: This
+       and `ru_oublock' do not include operations with the cache.  */
+    long int ru_inblock;
+    /* Number of output operations via the file system.  */
+    long int ru_oublock;
+    /* Number of IPC messages sent.  */
+    long int ru_msgsnd;
+    /* Number of IPC messages received.  */
+    long int ru_msgrcv;
+    /* Number of signals delivered.  */
+    long int ru_nsignals;
+    /* Number of voluntary context switches, i.e. because the process
+       gave up the process before it had to (usually to wait for some
+       resource to be available).  */
+    long int ru_nvcsw;
+    /* Number of involuntary context switches, i.e. a higher priority process
+       became runnable or the current process used up its time slice.  */
+    long int ru_nivcsw;
+  };
+
+/* This structure corresponds to the newer FreeBSD 'struct msqid_ds' */
+struct __kernel_msqid_ds
+{
+  struct ipc_perm msg_perm;	/* structure describing operation permission */
+  void *__msg_first;
+  void *__msg_last;
+  msglen_t __msg_cbytes;	/* current number of bytes on queue */
+  msgqnum_t msg_qnum;		/* number of messages currently on queue */
+  msglen_t msg_qbytes;		/* max number of bytes allowed on queue */
+  __pid_t msg_lspid;		/* pid of last msgsnd() */
+  __pid_t msg_lrpid;		/* pid of last msgrcv() */
+  int msg_stime;		/* time of last msgsnd command */
+  long __unused1;
+  int msg_rtime;		/* time of last msgrcv command */
+  long __unused2;
+  int msg_ctime;		/* time of last change */
+  long __unused3;
+  long __unused4[4];
+};
+
+/* This structure corresponds to the newer FreeBSD 'struct shmid_ds' */
+struct __kernel_shmid_ds
+  {
+    struct ipc_perm shm_perm;		/* operation permission struct */
+    int shm_segsz;			/* size of segment in bytes */
+    __pid_t shm_lpid;			/* pid of last shmop */
+    __pid_t shm_cpid;			/* pid of creator */
+    shmatt_t shm_nattch;		/* number of current attaches */
+    int shm_atime;			/* time of last shmat() */
+    int shm_dtime;			/* time of last shmdt() */
+    int shm_ctime;			/* time of last change by shmctl() */
+    void *__shm_internal;
+  };
+
+/* This structure corresponds to the newer FreeBSD 'struct semid_ds' */
+struct semid_ds
+{
+  struct ipc_perm sem_perm;		/* operation permission struct */
+  void *__sem_base;
+  unsigned short int sem_nsems;		/* number of semaphores in set */
+  int sem_otime;			/* last semop() time */
+  long __unused1;
+  int sem_ctime;			/* last time changed by semctl() */
+  long __unused2;
+  long __unused3[4];
+};
+
+#endif
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/alpha/bits/mcontext.h
@@ -0,0 +1,52 @@
+/* Machine-dependent processor state structure for FreeBSD.  alpha version.
+   Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#if !defined _SYS_UCONTEXT_H
+# error "Never use <bits/mcontext.h> directly; include <sys/ucontext.h> instead."
+#endif
+
+/* Whole processor state.  */
+typedef struct
+  {
+    long mc_onstack;		/* Nonzero if running on sigstack.  */
+
+    /* General registers.  */
+    unsigned long mc_regs[32];
+    long mc_ps;
+    long mc_pc;			/* Process counter.  */
+
+    /* Trap arguments.  */
+    unsigned long mc_traparg_a0;
+    unsigned long mc_traparg_a1;
+    unsigned long mc_traparg_a2;
+
+    /* Floating-point registers.  */
+    unsigned long mc_fpregs[32];
+    unsigned long mc_fpcr;
+    unsigned long mc_fp_control;
+#define _MC_FPOWNED_NONE        0       /* FP state not used */
+#define _MC_FPOWNED_FPU         1       /* FP state came from FPU */
+#define _MC_FPOWNED_PCB         2       /* FP state came from PCB */
+    long mc_ownedfp;
+#define _MC_REV0_SIGFRAME       1       /* context is a signal frame */
+#define _MC_REV0_TRAPFRAME      2       /* context is a trap frame */
+    long    mc_format;
+    long    mc_thrptr;                  /* Thread pointer */
+    long    mc_spare[5];
+  } mcontext_t;
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/alpha/bits/sigcontext.h
@@ -0,0 +1,84 @@
+/* Machine-dependent signal context structure for FreeBSD.  alpha version.
+   Copyright (C) 1991-1992,1994,1997,2001-2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#if !defined _SIGNAL_H && !defined _SYS_UCONTEXT_H
+# error "Never use <bits/sigcontext.h> directly; include <signal.h> instead."
+#endif
+
+#ifndef _BITS_SIGCONTEXT_H
+#define _BITS_SIGCONTEXT_H  1
+
+/* State of this thread when the signal was taken.  */
+struct sigcontext
+  {
+    __sigset_t sc_mask;		/* Blocked signals to restore.  */
+    long sc_onstack;		/* Nonzero if running on sigstack.  */
+
+    /* General registers.  */
+    unsigned long sc_regs[32];
+    long sc_ps;
+    long sc_pc;			/* Process counter.  */
+
+    /* Trap arguments.  */
+    unsigned long sc_traparg_a0;
+    unsigned long sc_traparg_a1;
+    unsigned long sc_traparg_a2;
+
+    /* Floating-point registers.  */
+    unsigned long sc_fpregs[32];
+    unsigned long sc_fpcr;
+    unsigned long sc_fp_control;
+    long sc_ownedfp;
+    long sc_format;              /* see mcontext_t */
+    long sc_spare[6];            /* XXX */
+  };
+
+/* Traditional BSD names for some members.  */
+#define sc_sp		sc_regs[30]	/* Stack pointer.  */
+#define sc_fp		sc_regs[15]	/* Frame pointer.  */
+
+
+#if 0 /* XXX These need verification.  */
+
+/* Codes for SIGFPE.  */
+#define FPE_INTDIV	1 /* integer divide by zero */
+#define FPE_INTOVF	2 /* integer overflow */
+#define FPE_FLTDIV	3 /* floating divide by zero */
+#define FPE_FLTOVF	4 /* floating overflow */
+#define FPE_FLTUND	5 /* floating underflow */
+#define FPE_FLTINX	6 /* floating loss of precision */
+#define FPE_SUBRNG_FAULT	0x7 /* BOUNDS instruction failed */
+#define FPE_FLTDNR_FAULT	0x8 /* denormalized operand */
+#define FPE_EMERR_FAULT		0xa /* mysterious emulation error 33 */
+#define FPE_EMBND_FAULT		0xb /* emulation BOUNDS instruction failed */
+
+/* Codes for SIGILL.  */
+#define ILL_PRIVIN_FAULT	1
+#define ILL_ALIGN_FAULT		14
+#define ILL_FPOP_FAULT		24
+
+/* Codes for SIGBUS.  */
+#define BUS_PAGE_FAULT		12
+#define BUS_SEGNP_FAULT		26
+#define BUS_STK_FAULT		27
+#define BUS_SEGM_FAULT		29
+
+#endif
+
+#endif /* _BITS_SIGCONTEXT_H */
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/alpha/bits/stat16.h
@@ -0,0 +1,53 @@
+/* Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+/* This structure corresponds to the original FreeBSD 'struct stat'
+   (i.e. _STAT_VER_stat), and is used by the fhstat() system call.  */
+struct stat16
+  {
+    __dev_t st_dev;		/* Device containing the file.  */
+    __ino_t st_ino;		/* File serial number.  */
+
+    __uint16_t st_mode;		/* File mode.  */
+    __uint16_t st_nlink;	/* Link count.  */
+
+    __uid_t st_uid;		/* User ID of the file's owner.  */
+    __gid_t st_gid;		/* Group ID of the file's group.  */
+
+    __dev_t st_rdev;		/* Device number, if device.  */
+
+    int st_atime;		/* Time of last access.  */
+    long int st_atimensec;	/* Nanoseconds of last access.  */
+    int st_mtime;		/* Time of last modification.  */
+    long int st_mtimensec;	/* Nanoseconds of last modification.  */
+    int st_ctime;		/* Time of last status change.  */
+    long int st_ctimensec;	/* Nanoseconds of last status change.  */
+
+    __off_t st_size;		/* Size of file, in bytes.  */
+
+    __blkcnt_t st_blocks;	/* Number of 512-byte blocks allocated.  */
+
+    __blksize_t st_blksize;	/* Optimal block size for I/O.  */
+
+    __uint32_t st_flags;	/* User defined flags.  */
+
+    __uint32_t st_gen;		/* Generation number.  */
+
+    __uint32_t __unused1;
+    __quad_t __unused2[2];
+  };
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/alpha/bits/stat32.h
@@ -0,0 +1,52 @@
+/* Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+/* This structure corresponds to the newer FreeBSD 'struct nstat'
+   (i.e. _STAT_VER_nstat).  */
+struct stat32
+  {
+    __dev_t st_dev;		/* Device containing the file.  */
+    __ino_t st_ino;		/* File serial number.  */
+
+    __uint32_t st_mode;		/* File mode.  */
+    __uint32_t st_nlink;	/* Link count.  */
+
+    __uid_t st_uid;		/* User ID of the file's owner.  */
+    __gid_t st_gid;		/* Group ID of the file's group.  */
+
+    __dev_t st_rdev;		/* Device number, if device.  */
+
+    int st_atime;		/* Time of last access.  */
+    long int st_atimensec;	/* Nanoseconds of last access.  */
+    int st_mtime;		/* Time of last modification.  */
+    long int st_mtimensec;	/* Nanoseconds of last modification.  */
+    int st_ctime;		/* Time of last status change.  */
+    long int st_ctimensec;	/* Nanoseconds of last status change.  */
+
+    __off_t st_size;		/* Size of file, in bytes.  */
+
+    __blkcnt_t st_blocks;	/* Number of 512-byte blocks allocated.  */
+
+    __blksize_t st_blksize;	/* Optimal block size for I/O.  */
+
+    __uint32_t st_flags;	/* User defined flags.  */
+
+    __uint32_t st_gen;		/* Generation number.  */
+
+    __quad_t __unused1[2];
+  };
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/alpha/bits/time.h
@@ -0,0 +1,89 @@
+/* System-dependent timing definitions.  FreeBSD version.
+   Copyright (C) 1996-1997, 1999, 2000, 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+/*
+ * Never include this file directly; use <time.h> instead.
+ */
+
+#ifndef __need_timeval
+# ifndef _BITS_TIME_H
+#  define _BITS_TIME_H	1
+
+/* ISO/IEC 9899:1990 7.12.1: <time.h>
+   The macro `CLOCKS_PER_SEC' is the number per second of the value
+   returned by the `clock' function. */
+/* CAE XSH, Issue 4, Version 2: <time.h>
+   The value of CLOCKS_PER_SEC is required to be 1 million on all
+   XSI-conformant systems. */
+#  define CLOCKS_PER_SEC  1000000l
+
+#  if !defined __STRICT_ANSI__ && !defined __USE_XOPEN2K
+/* Even though CLOCKS_PER_SEC has such a strange value CLK_TCK
+   presents the real value for clock ticks per second for the system.  */
+#   define CLK_TCK 100
+#  endif
+
+#  ifdef __USE_POSIX199309
+/* Identifier for system-wide realtime clock.  */
+#   define CLOCK_REALTIME		0
+/* High-resolution timer from the CPU.  */
+#   define CLOCK_PROCESS_CPUTIME_ID	2
+/* Thread-specific CPU-time clock.  */
+#   define CLOCK_THREAD_CPUTIME_ID	3
+/* Monotonic system-wide clock.  */
+#   define CLOCK_MONOTONIC		4
+/* These are BSD specific clocks.  */
+#   ifdef __USE_BSD
+#    define CLOCK_VIRTUAL		1
+#    define CLOCK_PROF			2
+#   endif
+
+/* Flag to indicate time is absolute.  */
+#   define TIMER_ABSTIME		1
+#  endif
+
+
+/* Getkerninfo clock information structure */
+struct clockinfo
+  {
+    int hz;		/* clock frequency */
+    int tick;		/* micro-seconds per hz tick */
+    int spare;
+    int stathz;		/* statistics clock frequency */
+    int profhz;		/* profiling clock frequency */
+  };
+
+# endif	/* bits/time.h */
+#endif
+
+#ifdef __need_timeval
+# undef __need_timeval
+# ifndef _STRUCT_TIMEVAL
+#  define _STRUCT_TIMEVAL	1
+#  include <bits/types.h>
+
+/* A time value that is accurate to the nearest
+   microsecond but also has a range of years.  */
+struct timeval
+  {
+    __time_t tv_sec;		/* Seconds.  */
+    __suseconds_t tv_usec;	/* Microseconds.  */
+  };
+# endif	/* struct timeval */
+#endif	/* need timeval */
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/alpha/brk.S
@@ -0,0 +1,73 @@
+/* Copyright (C) 1993, 1995-1997, 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+/* Traditional name for the 'brk' system call.  */
+#define SYS_brk SYS_obreak
+
+#include <sysdep.h>
+
+#ifdef PIC
+.section .bss
+	.align 3
+	.globl __curbrk
+__curbrk: .skip 8
+	.type __curbrk,@object
+	.size __curbrk,8
+#else
+.comm __curbrk, 8
+#endif
+
+	.text
+LEAF(__brk, 8)
+	ldgp	gp, 0(t12)
+	subq	sp, 8, sp
+#ifdef PROF
+	.set noat
+	lda	AT, _mcount
+	jsr	AT, (AT), _mcount
+	.set at
+#endif
+	.prologue 1
+
+	/* Save the requested brk across the system call.  */
+	stq	a0, 0(sp)
+
+	ldiq	v0, SYS_brk
+	call_pal PAL_callsys
+
+	ldq	a0, 0(sp)
+
+	/* Test for error.  */
+	bne	a3, $error
+
+	/* Don't need to handle brk(0) specially, because the kernel doesn't
+	   support this way of calling brk anyway.  */
+
+	/* Update __curbrk and return cleanly.  */
+	stq	a0, __curbrk
+	mov	zero, v0
+	addq	sp, 8, sp
+	ret
+
+	/* What a horrible way to die.  */
+$error:	addq	sp, 8, sp
+	jmp	zero, __syscall_error
+
+	END(__brk)
+
+weak_alias (__brk, brk)
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/alpha/dl-brk.S
@@ -0,0 +1 @@
+#include <brk.S>
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/alpha/dl-machine.h
@@ -0,0 +1,34 @@
+/* Dynamic linker magic for glibc on FreeBSD.
+   Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Bruno Haible <bruno@clisp.org>, 2002.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+/* FreeBSD on alpha can emulate two ABIs (= sets of system calls):
+   The native FreeBSD ABI and OSF/1.  Without additional kernel
+   modules, only the FreeBSD ABI is supported.  For this reason, we use
+   this ABI, and we have to label every executable as using this ABI,
+   by writing the string "FreeBSD" at byte offset 8 (= EI_ABIVERSION)
+   of every executable.  Strictly speaking, only ld.so and the
+   executables would need this labelling.  But it's easiest to mark
+   every executable and every shared object the same way.  */
+#define VALID_ELF_HEADER(e_ident, expected, size) \
+  (memcmp (e_ident, expected, EI_ABIVERSION) == 0			      \
+   && memcmp ((const char *) (e_ident) + EI_ABIVERSION, "FreeBSD", 8) == 0)
+#define VALID_ELF_ABIVERSION(abi) (memcmp (&(abi), "FreeBSD", 8) == 0)
+
+#include_next <dl-machine.h>
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/alpha/fhstatfs64.c
@@ -0,0 +1,2 @@
+/* 'fhstatfs64' is the same as 'fhstatfs', because
+   __fsblkcnt64_t == __fsblkcnt_t and __fsfilcnt64_t == __fsfilcnt_t.  */
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/alpha/fork.S
@@ -0,0 +1,30 @@
+/* Copyright (C) 1993, 1995, 1997, 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sysdep.h>
+
+PSEUDO (__libc_fork, fork, 0)
+	/* In the parent process, a4 == 0, v0 == child pid.  */
+	/* In the child process, a4 == 1, v0 == parent pid.  */
+	cmovne a4, zero, v0
+	ret
+
+PSEUDO_END (__libc_fork)
+
+weak_alias (__libc_fork, __fork)
+weak_alias (__fork, fork)
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/alpha/fpu.h
@@ -0,0 +1,128 @@
+/* Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _FPU_H
+#define _FPU_H	1
+
+
+/* Usage of the fpcr register.
+   The rounding mode bits (in FPCR_DYN_MASK) can be modified in user mode
+   and will be preserved by the kernel when a software assisted floating-
+   point operation or an exception occurs.  All other bits will be set by
+   the kernel when a software assisted floating-point operation or an
+   exception occurs.  */
+
+#if 0 /* Only Linux, not FreeBSD */
+#define FPCR_DNOD	(1UL<<47)	/* denorm INV trap disable */
+#define FPCR_DNZ	(1UL<<48)	/* denorms to zero */
+#endif
+#define FPCR_INVD	(1UL<<49)	/* invalid op disable (opt.) */
+#define FPCR_DZED	(1UL<<50)	/* division by zero disable (opt.) */
+#define FPCR_OVFD	(1UL<<51)	/* overflow disable (optional) */
+#define FPCR_INV	(1UL<<52)	/* invalid operation */
+#define FPCR_DZE	(1UL<<53)	/* division by zero */
+#define FPCR_OVF	(1UL<<54)	/* overflow */
+#define FPCR_UNF	(1UL<<55)	/* underflow */
+#define FPCR_INE	(1UL<<56)	/* inexact */
+#define FPCR_IOV	(1UL<<57)	/* integer overflow */
+#define FPCR_UNDZ	(1UL<<60)	/* underflow to zero (opt.) */
+#define FPCR_UNFD	(1UL<<61)	/* underflow disable (opt.) */
+#define FPCR_INED	(1UL<<62)	/* inexact disable (opt.) */
+#define FPCR_SUM	(1UL<<63)	/* summary bit, an OR of bits 52..56 */
+
+#define FPCR_DYN_SHIFT	58		/* first dynamic rounding mode bit */
+#define FPCR_DYN_CHOPPED (0x0UL << FPCR_DYN_SHIFT)	/* towards 0 */
+#define FPCR_DYN_MINUS	 (0x1UL << FPCR_DYN_SHIFT)	/* towards -INF */
+#define FPCR_DYN_NORMAL	 (0x2UL << FPCR_DYN_SHIFT)	/* towards nearest */
+#define FPCR_DYN_PLUS	 (0x3UL << FPCR_DYN_SHIFT)	/* towards +INF */
+#define FPCR_DYN_MASK	 (0x3UL << FPCR_DYN_SHIFT)
+
+#define FPCR_MASK	0xffff800000000000
+
+
+/* IEEE traps are enabled depending on a control word (not to be confused
+   with fpcr!) which can be read using __ieee_get_fp_control() and written
+   using __ieee_set_fp_control().  The bits in these control word are
+   as follows (compatible with Linux and OSF/1).  */
+
+/* Trap enable bits.  Get copied (inverted) to bits 49,50,51,61,62,47
+   of fpcr in the kernel.  */
+#define IEEE_TRAP_ENABLE_INV	(1UL<<1)	/* invalid op */
+#define IEEE_TRAP_ENABLE_DZE	(1UL<<2)	/* division by zero */
+#define IEEE_TRAP_ENABLE_OVF	(1UL<<3)	/* overflow */
+#define IEEE_TRAP_ENABLE_UNF	(1UL<<4)	/* underflow */
+#define IEEE_TRAP_ENABLE_INE	(1UL<<5)	/* inexact */
+#if 0 /* Only Linux, not FreeBSD */
+#define IEEE_TRAP_ENABLE_DNO	(1UL<<6)	/* denorm */
+#endif
+#define IEEE_TRAP_ENABLE_MASK	(IEEE_TRAP_ENABLE_INV | IEEE_TRAP_ENABLE_DZE |\
+				 IEEE_TRAP_ENABLE_OVF | IEEE_TRAP_ENABLE_UNF |\
+				 IEEE_TRAP_ENABLE_INE/*| IEEE_TRAP_ENABLE_DNO*/)
+
+#if 0 /* Only Linux, not FreeBSD */
+
+/* Denorm and Underflow flushing. */
+/* Get copied to bits 48,60 of fpcr in the kernel.  */
+#define IEEE_MAP_DMZ		(1UL<<12)	/* Map denorm inputs to zero */
+#define IEEE_MAP_UMZ		(1UL<<13)	/* Map underflowed outputs to zero */
+
+#define IEEE_MAP_MASK		(IEEE_MAP_DMZ | IEEE_MAP_UMZ)
+
+#endif
+
+/* Status bits.  Get copied to bits 52,53,54,55,56 of fpcr in the kernel.  */
+#define IEEE_STATUS_INV		(1UL<<17)	/* invalid op */
+#define IEEE_STATUS_DZE		(1UL<<18)	/* division by zero */
+#define IEEE_STATUS_OVF		(1UL<<19)	/* overflow */
+#define IEEE_STATUS_UNF		(1UL<<20)	/* underflow */
+#define IEEE_STATUS_INE		(1UL<<21)	/* inexact */
+#if 0 /* Only Linux, not FreeBSD */
+#define IEEE_STATUS_DNO		(1UL<<22)	/* denorm */
+#endif
+
+#define IEEE_STATUS_MASK	(IEEE_STATUS_INV | IEEE_STATUS_DZE |	\
+				 IEEE_STATUS_OVF | IEEE_STATUS_UNF |	\
+				 IEEE_STATUS_INE /* | IEEE_STATUS_DNO */)
+
+#define IEEE_SW_MASK		(IEEE_TRAP_ENABLE_MASK |		\
+				 IEEE_STATUS_MASK /* | IEEE_MAP_MASK */)
+
+#if 0 /* Only Linux, not FreeBSD */
+
+#define IEEE_CURRENT_RM_SHIFT	32
+#define IEEE_CURRENT_RM_MASK	(3UL<<IEEE_CURRENT_RM_SHIFT)
+
+#endif
+
+#define IEEE_INHERIT    (1UL<<63)	/* inherit on thread create? */
+
+
+#if 0 /* Unused.  */
+
+/* Exception summary bits.  */
+#define EXCSUM_SWC	(1LL << 0)	/* Software completion */
+#define EXCSUM_INV	(1LL << 1)	/* Invalid operation */
+#define EXCSUM_DZE	(1LL << 2)	/* Division by zero */
+#define EXCSUM_OVF	(1LL << 3)	/* Overflow */
+#define EXCSUM_UNF	(1LL << 4)	/* Underflow */
+#define EXCSUM_INE	(1LL << 5)	/* Inexact result */
+#define EXCSUM_IOV	(1LL << 6)	/* Integer overflow */
+
+#endif
+
+#endif /* _FPU_H */
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/alpha/fstatfs64.c
@@ -0,0 +1,2 @@
+/* 'fstatfs64' is the same as 'fstatfs', because
+   __fsblkcnt64_t == __fsblkcnt_t and __fsfilcnt64_t == __fsfilcnt_t.  */
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/alpha/futimes.c
@@ -0,0 +1,43 @@
+/* Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Bruno Haible <bruno@clisp.org>, 2002.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <stddef.h>
+#include <sys/time.h>
+#include <bits/kernel_time_t.h>
+
+extern int __syscall_futimes (int fd, const struct __kernel_timeval tvp[2]);
+
+int
+__futimes (int fd, const struct timeval tvp[2])
+{
+  if (tvp != NULL)
+    {
+      struct __kernel_timeval ktv[2];
+
+      ktv[0].tv_sec  = tvp[0].tv_sec;
+      ktv[0].tv_usec = tvp[0].tv_usec;
+      ktv[1].tv_sec  = tvp[1].tv_sec;
+      ktv[1].tv_usec = tvp[1].tv_usec;
+      return __syscall_futimes (fd, ktv);
+    }
+  else
+    return __syscall_futimes (fd, NULL);
+}
+
+weak_alias (__futimes, futimes)
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/alpha/getfsstat64.c
@@ -0,0 +1,2 @@
+/* 'getfsstat64' is the same as 'getfsstat', because
+   __fsblkcnt64_t == __fsblkcnt_t and __fsfilcnt64_t == __fsfilcnt_t.  */
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/alpha/getitimer.c
@@ -0,0 +1,49 @@
+/* Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Bruno Haible <bruno@clisp.org>, 2002.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <stddef.h>
+#include <errno.h>
+#include <sys/time.h>
+#include <bits/kernel_time_t.h>
+
+extern int __syscall_getitimer (int which, struct __kernel_itimerval *value);
+
+int
+__getitimer (enum __itimer_which which, struct itimerval *value)
+{
+  struct __kernel_itimerval kvalue;
+  int retval;
+
+  if (value == NULL)
+    {
+      errno = EFAULT;
+      return -1;
+    }
+  retval = __syscall_getitimer (which, &kvalue);
+  if (retval >= 0)
+    {
+      value->it_interval.tv_sec  = kvalue.it_interval.tv_sec;
+      value->it_interval.tv_usec = kvalue.it_interval.tv_usec;
+      value->it_value.tv_sec  = kvalue.it_value.tv_sec;
+      value->it_value.tv_usec = kvalue.it_value.tv_usec;
+    }
+  return retval;
+}
+
+weak_alias (__getitimer, getitimer)
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/alpha/getmntinfo.c
@@ -0,0 +1,8 @@
+/* 'getmntinfo64' is the same as 'getmntinfo', because
+   __fsblkcnt64_t == __fsblkcnt_t and __fsfilcnt64_t == __fsfilcnt_t.  */
+
+#define getmntinfo64 __no_getmntinfo64_decl
+#include <sysdeps/unix/bsd/bsd4.4/kfreebsd/getmntinfo.c>
+#undef getmntinfo64
+
+weak_alias (__getmntinfo, getmntinfo64)
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/alpha/getmntinfo64.c
@@ -0,0 +1,2 @@
+/* 'getmntinfo64' is the same as 'getmntinfo', because
+   __fsblkcnt64_t == __fsblkcnt_t and __fsfilcnt64_t == __fsfilcnt_t.  */
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/alpha/getrusage.c
@@ -0,0 +1,63 @@
+/* Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Bruno Haible <bruno@clisp.org>, 2002.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <stddef.h>
+#include <errno.h>
+#include <sys/resource.h>
+#include <bits/kernel_time_t.h>
+
+extern int __syscall_getrusage (int who, struct __kernel_rusage *usage);
+
+int
+__getrusage (enum __rusage_who who, struct rusage *usage)
+{
+  struct __kernel_rusage kusage;
+  int retval;
+
+  if (usage == NULL)
+    {
+      errno = EFAULT;
+      return -1;
+    }
+  retval = __syscall_getrusage (who, &kusage);
+  if (retval >= 0)
+    {
+      usage->ru_utime.tv_sec  = kusage.ru_utime.tv_sec;
+      usage->ru_utime.tv_usec = kusage.ru_utime.tv_usec;
+      usage->ru_stime.tv_sec  = kusage.ru_stime.tv_sec;
+      usage->ru_stime.tv_usec = kusage.ru_stime.tv_usec;
+      usage->ru_maxrss = kusage.ru_maxrss;
+      usage->ru_ixrss = kusage.ru_ixrss;
+      usage->ru_idrss = kusage.ru_idrss;
+      usage->ru_isrss = kusage.ru_isrss;
+      usage->ru_minflt = kusage.ru_minflt;
+      usage->ru_majflt = kusage.ru_majflt;
+      usage->ru_nswap = kusage.ru_nswap;
+      usage->ru_inblock = kusage.ru_inblock;
+      usage->ru_oublock = kusage.ru_oublock;
+      usage->ru_msgsnd = kusage.ru_msgsnd;
+      usage->ru_msgrcv = kusage.ru_msgrcv;
+      usage->ru_nsignals = kusage.ru_nsignals;
+      usage->ru_nvcsw = kusage.ru_nvcsw;
+      usage->ru_nivcsw = kusage.ru_nivcsw;
+    }
+  return retval;
+}
+
+weak_alias (__getrusage, getrusage)
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/alpha/gettimeofday.c
@@ -0,0 +1,52 @@
+/* Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Bruno Haible <bruno@clisp.org>, 2002.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <stddef.h>
+#include <errno.h>
+#include <sys/time.h>
+#include <bits/kernel_time_t.h>
+
+extern int __syscall_gettimeofday (struct __kernel_timeval *tv,
+				   struct timezone *tz);
+
+#undef __gettimeofday
+
+int
+__gettimeofday (struct timeval *tv, struct timezone *tz)
+{
+  struct __kernel_timeval ktv;
+  int retval;
+
+  if (tv == NULL)
+    {
+      errno = EFAULT;
+      return -1;
+    }
+  retval = __syscall_gettimeofday (&ktv, tz);
+  if (retval >= 0)
+    {
+      tv->tv_sec  = ktv.tv_sec;
+      tv->tv_usec = ktv.tv_usec;
+    }
+  return retval;
+}
+
+INTDEF(__gettimeofday)
+
+weak_alias (__gettimeofday, gettimeofday)
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/alpha/ieee_get_fp_control.c
@@ -0,0 +1,35 @@
+/* Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Bruno Haible <bruno@clisp.org>, 2002.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sysarch.h>
+#include <stdlib.h>
+
+unsigned long
+__ieee_get_fp_control (void)
+{
+  /* The Alpha hardware requires this to be a system call.  */
+  unsigned long word;
+
+  if (__sysarch (ALPHA_GET_FPMASK, &word) < 0)
+    abort ();
+
+  return word;
+}
+
+weak_alias (__ieee_get_fp_control, ieee_get_fp_control)
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/alpha/ieee_set_fp_control.c
@@ -0,0 +1,33 @@
+/* Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Bruno Haible <bruno@clisp.org>, 2002.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sysarch.h>
+#include <stdlib.h>
+
+void
+__ieee_set_fp_control (unsigned long trap_enable_mask)
+{
+  /* The Alpha hardware requires this to be a system call.  */
+  unsigned long word = trap_enable_mask;
+
+  if (__sysarch (ALPHA_SET_FPMASK, &word) < 0)
+    abort ();
+}
+
+weak_alias (__ieee_set_fp_control, ieee_set_fp_control)
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/alpha/lutimes.c
@@ -0,0 +1,44 @@
+/* Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Bruno Haible <bruno@clisp.org>, 2002.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <stddef.h>
+#include <sys/time.h>
+#include <bits/kernel_time_t.h>
+
+extern int __syscall_lutimes (const char *file,
+			      const struct __kernel_timeval tvp[2]);
+
+int
+__lutimes (const char *file, const struct timeval tvp[2])
+{
+  if (tvp != NULL)
+    {
+      struct __kernel_timeval ktv[2];
+
+      ktv[0].tv_sec  = tvp[0].tv_sec;
+      ktv[0].tv_usec = tvp[0].tv_usec;
+      ktv[1].tv_sec  = tvp[1].tv_sec;
+      ktv[1].tv_usec = tvp[1].tv_usec;
+      return __syscall_lutimes (file, ktv);
+    }
+  else
+    return __syscall_lutimes (file, NULL);
+}
+
+weak_alias (__lutimes, lutimes)
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/alpha/machine/pal.h
@@ -0,0 +1,57 @@
+/* Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+/* Unprivileged PAL function codes.  (The PAL codes which require
+   privileges are useful in the kernel only.)  */
+
+/* Common PAL codes.  */
+#define PAL_bpt		128
+#define PAL_bugchk	129
+#define PAL_callsys	131
+#define PAL_imb		134
+#define PAL_rduniq	158
+#define PAL_wruniq	159
+#define PAL_gentrap	170
+#define PAL_nphalt	190
+
+/* gentrap causes.  */
+#define GEN_INTOVF	-1	/* integer overflow */
+#define GEN_INTDIV	-2	/* integer division by zero */
+#define GEN_FLTOVF	-3	/* fp overflow */
+#define GEN_FLTDIV	-4	/* fp division by zero */
+#define GEN_FLTUND	-5	/* fp underflow */
+#define GEN_FLTINV	-6	/* invalid fp operand */
+#define GEN_FLTINE	-7	/* inexact fp operand */
+#define GEN_DECOVF	-8	/* decimal overflow (for COBOL??) */
+#define GEN_DECDIV	-9	/* decimal division by zero */
+#define GEN_DECINV	-10	/* invalid decimal operand */
+#define GEN_ROPRAND	-11	/* reserved operand */
+#define GEN_ASSERTERR	-12	/* assertion error */
+#define GEN_NULPTRERR	-13	/* null pointer error */
+#define GEN_STKOVF	-14	/* stack overflow */
+#define GEN_STRLENERR	-15	/* string length error */
+#define GEN_SUBSTRERR	-16	/* substring error */
+#define GEN_RANGERR	-17	/* range error */
+#define GEN_SUBRNG	-18
+#define GEN_SUBRNG1	-19
+#define GEN_SUBRNG2	-20
+#define GEN_SUBRNG3	-21	/* these report range errors for */
+#define GEN_SUBRNG4	-22	/* subscripting (indexing) at levels 0..7 */
+#define GEN_SUBRNG5	-23
+#define GEN_SUBRNG6	-24
+#define GEN_SUBRNG7	-25
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/alpha/msgctl.c
@@ -0,0 +1,62 @@
+/* Copyright (C) 2006 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Aurelien Jarno <aurelien@aurel32.net>, 2006.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sys/types.h>
+#include <sys/ipc.h>
+#include <sys/msg.h>
+#include <bits/kernel_time_t.h>
+
+extern int __syscall_msgctl (int msqid, int cmd, struct __kernel_msqid_ds *buf);
+
+int
+__msgctl (int msqid, int cmd, struct msqid_ds *buf)
+{
+  struct __kernel_msqid_ds kmsqid_ds;
+  int retval;
+
+  kmsqid_ds.msg_perm = msqid_ds->msg_perm;
+  kmsqid_ds.__msg_first = msqid_ds->__msg_first;
+  kmsqid_ds.__msg_last = msqid_ds->__msg_last;
+  kmsqid_ds.__msg_cbytes = msqid_ds->__msg_cbytes;
+  kmsqid_ds.msg_qnum = msqid_ds->msg_qnum;
+  kmsqid_ds.msg_qbytes = msqid_ds->msg_qbytes;
+  kmsqid_ds.msg_lspid = msqid_ds->msg_lspid;
+  kmsqid_ds.msg_lrpid = msqid_ds->msg_lrpid;
+  kmsqid_ds.msg_stime = msqid_ds->msg_stime;
+  kmsqid_ds.msg_rtime = msqid_ds->msg_rtime;
+  kmsqid_ds.msg_ctime = msqid_ds->msg_ctime;
+
+  retval = __syscall_msgctl (msqid, cmd, &kmsqid_ds);
+
+  msqid_ds->msg_perm = kmsqid_ds.msg_perm;
+  msqid_ds->__msg_first = kmsqid_ds.__msg_first;
+  msqid_ds->__msg_last = kmsqid_ds.__msg_last;
+  msqid_ds->__msg_cbytes = kmsqid_ds.__msg_cbytes;
+  msqid_ds->msg_qnum = kmsqid_ds.msg_qnum;
+  msqid_ds->msg_qbytes = kmsqid_ds.msg_qbytes;
+  msqid_ds->msg_lspid = kmsqid_ds.msg_lspid;
+  msqid_ds->msg_lrpid = kmsqid_ds.msg_lrpid;
+  msqid_ds->msg_stime = kmsqid_ds.msg_stime;
+  msqid_ds->msg_rtime = kmsqid_ds.msg_rtime;
+  msqid_ds->msg_ctime = kmsqid_ds.msg_ctime;
+
+  return retval;
+}
+
+weak_alias (__msgctl, msgctl)
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/alpha/nanosleep.c
@@ -0,0 +1,54 @@
+/* Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Bruno Haible <bruno@clisp.org>, 2002.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <stddef.h>
+#include <errno.h>
+#include <time.h>
+#include <bits/kernel_time_t.h>
+
+extern int __syscall_nanosleep (const struct __kernel_timespec *requested_time,
+				struct __kernel_timespec *remaining);
+
+int
+__libc_nanosleep (const struct timespec *requested_time,
+		  struct timespec *remaining)
+{
+  struct __kernel_timespec krequested_time;
+  int retval;
+
+  krequested_time.tv_sec  = requested_time->tv_sec;
+  krequested_time.tv_nsec = requested_time->tv_nsec;
+  if (remaining != NULL)
+    {
+      struct __kernel_timespec kremaining;
+
+      retval = __syscall_nanosleep (&krequested_time, &kremaining);
+      if (retval >= 0 || errno == EINTR)
+	{
+	  remaining->tv_sec  = kremaining.tv_sec;
+	  remaining->tv_nsec = kremaining.tv_nsec;
+	}
+    }
+  else
+    retval = __syscall_nanosleep (&krequested_time, NULL);
+  return retval;
+}
+
+weak_alias (__libc_nanosleep, __nanosleep)
+weak_alias (__libc_nanosleep, nanosleep)
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/alpha/poll.c
@@ -0,0 +1,46 @@
+/* Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Bruno Haible <bruno@clisp.org>, 2002.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sys/poll.h>
+#include <sysdep.h>
+#include <errno.h>
+
+/* nfds_t is defined as 'unsigned long int' in <sys/poll.h>, but the poll
+   system call expects an 'unsigned int' as second argument.  */
+
+extern int __syscall_poll (struct pollfd *fds, unsigned int nfds, int timeout);
+
+int
+__poll (struct pollfd *fds, nfds_t nfds, int timeout)
+{
+  unsigned int infds = nfds;
+
+  if (infds == nfds)
+    return INLINE_SYSCALL (poll, 3, fds, infds, timeout);
+  else
+    {
+      /* NFDS doesn't fit into an unsigned int.  FDS cannot point to such
+	 a big chunk of valid memory.  */
+      __set_errno (EFAULT);
+      return -1;
+    }
+}
+libc_hidden_def (__poll)
+
+weak_alias (__poll, poll)
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/alpha/regdef.h
@@ -0,0 +1,62 @@
+/* Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _REGDEF_H
+#define _REGDEF_H
+
+/* Common symbolic names for Alpha registers.
+   Names taken from binutils/opcodes/alpha-dis.c.
+   Register usage info taken from gcc-3.1/gcc/config/alpha/alpha.h.
+   NB: "saved" = "call-saved", "nonsaved" = "call-used".  */
+
+#define v0	$0	/* nonsaved, first return value */
+#define t0	$1	/* nonsaved, second return value, lexical closure reg */
+#define t1	$2	/* nonsaved */
+#define t2	$3	/* nonsaved */
+#define t3	$4	/* nonsaved */
+#define t4	$5	/* nonsaved */
+#define t5	$6	/* nonsaved */
+#define t6	$7	/* nonsaved */
+#define t7	$8	/* nonsaved */
+#define s0	$9	/* saved */
+#define s1	$10	/* saved */
+#define s2	$11	/* saved */
+#define s3	$12	/* saved */
+#define s4	$13	/* saved */
+#define s5	$14	/* saved */
+#define s6	$15	/* use only in leaf functions without frame pointer */
+#define fp	$15	/* frame pointer */
+#define a0	$16	/* nonsaved, argument 1 */
+#define a1	$17	/* nonsaved, argument 2 */
+#define a2	$18	/* nonsaved, argument 3 */
+#define a3	$19	/* nonsaved, argument 4 */
+#define a4	$20	/* nonsaved, argument 5 */
+#define a5	$21	/* nonsaved, argument 6 */
+#define t8	$22	/* nonsaved */
+#define t9	$23	/* nonsaved */
+#define t10	$24	/* nonsaved */
+#define t11	$25	/* nonsaved */
+#define ra	$26	/* return address */
+#define t12	$27	/* current function's address */
+#define pv	$27	/* current function's address */
+#define AT	$28	/* nonsaved, assembler temporary */
+#define gp	$29	/* global pointer */
+#define sp	$30	/* stack pointer */
+#define zero	$31	/* reads as zero, writes go to /dev/null */
+
+#endif /* _REGDEF_H */
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/alpha/rfork.S
@@ -0,0 +1,29 @@
+/* Copyright (C) 1993, 1995, 1997, 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sysdep.h>
+
+SYSCALL__ (rfork, 0)
+	/* In the parent process, a4 == 0, v0 == child pid.  */
+	/* In the child process, a4 == 1, v0 == parent pid.  */
+	cmovne a4, zero, v0
+	ret
+
+PSEUDO_END (__rfork)
+
+weak_alias (__rfork, rfork)
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/alpha/sched_rr_gi.c
@@ -0,0 +1,50 @@
+/* Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Bruno Haible <bruno@clisp.org>, 2002.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <stddef.h>
+#include <errno.h>
+#include <time.h>
+#include <sched.h>
+#include <sys/types.h>
+#include <bits/kernel_time_t.h>
+
+extern int __syscall_sched_rr_get_interval (pid_t pid,
+					    struct __kernel_timespec *t);
+
+int
+__sched_rr_get_interval (pid_t pid, struct timespec *t)
+{
+  struct __kernel_timespec kt;
+  int retval;
+
+  if (t == NULL)
+    {
+      errno = EFAULT;
+      return -1;
+    }
+  retval = __syscall_sched_rr_get_interval (pid, &kt);
+  if (retval >= 0)
+    {
+      t->tv_sec  = kt.tv_sec;
+      t->tv_nsec = kt.tv_nsec;
+    }
+  return retval;
+}
+
+weak_alias (__sched_rr_get_interval, sched_rr_get_interval)
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/alpha/select.c
@@ -0,0 +1,53 @@
+/* Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Bruno Haible <bruno@clisp.org>, 2002.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <stddef.h>
+#include <sys/types.h>
+#include <sys/time.h>
+#include <bits/kernel_time_t.h>
+
+extern int __syscall_select (int nfds,
+			     fd_set *readfds,
+			     fd_set *writefds,
+			     fd_set *exceptfds,
+			     struct __kernel_timeval *timeout);
+
+int
+__select (int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds,
+	  struct timeval *timeout)
+{
+  int retval;
+
+  if (timeout != NULL)
+    {
+      struct __kernel_timeval ktimeout;
+
+      ktimeout.tv_sec  = timeout->tv_sec;
+      ktimeout.tv_usec = timeout->tv_usec;
+      retval = __syscall_select (nfds, readfds, writefds, exceptfds, &ktimeout);
+      timeout->tv_sec  = ktimeout.tv_sec;
+      timeout->tv_usec = ktimeout.tv_usec;
+    }
+  else
+    retval = __syscall_select (nfds, readfds, writefds, exceptfds, NULL);
+  return retval;
+}
+libc_hidden_def (__select)
+
+weak_alias (__select, select)
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/alpha/semctl.c
@@ -0,0 +1,87 @@
+/* Copyright (C) 1995,1997,1998,2000,2003,2004 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Ulrich Drepper <drepper@gnu.ai.mit.edu>, August 1995.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sys/sem.h>
+#include <sys/syscall.h>
+#include <stdarg.h> /* va_list */
+#include <stdlib.h> /* NULL */
+#include <bits/kernel_time_t.h>
+
+/* union semun from FreeBSD <sys/sem.h> */
+/*
+ * semctl's arg parameter structure
+ */
+union __kernel_semun
+{
+  int val;			/* value for SETVAL */
+  struct __kernel_semid_ds *buf;		/* buffer for IPC_STAT & IPC_SET */
+  unsigned short *array;	/* array for GETALL & SETALL */
+};
+
+int
+semctl (int semid, int semnum, int cmd, ...)
+{
+  int result;
+  va_list ap;
+
+  union semun semun;
+  union semun semun_ptr;
+
+  union __kernel_semun ksemun;
+  struct __kernel_semid_ds ksemid_ds;
+
+  va_start (ap, cmd);
+  if (cmd == GETALL || cmd == SETVAL || cmd == SETALL)
+    {
+      semun = va_arg (ap, union semun);
+      semun_ptr = &semun;
+    }
+  else if (cmd == IPC_SET || cmd == IPC_STAT)
+    {
+      semun = va_arg (ap, union semun);
+
+      ksemid_ds.sem_perm = semun.buf->sem_perm;
+      ksemid_ds.sem_base = semun.buf->sem_base;
+      ksemid_ds.sem_nsems = semun.buf->sem_nsems;
+      ksemid_ds.sem_otime = semun.buf->sem_otime;
+      ksemid_ds.sem_ctime = semun.buf->sem_ctime;
+
+      ksemun.buf = &ksemid_ds
+      semun_ptr = (semun_ptr *) &ksemun;
+    }
+  else
+    {
+      semun_ptr = NULL;
+    }
+  va_end (ap);
+
+  result = syscall (SYS_semctl, semid, semnum, cmd, semun_ptr);
+
+  if (cmd == IPC_SET || cmd == IPC_STAT)
+    {
+      semun.buf->sem_perm = ksemid_ds.sem_perm;
+      semun.buf->sem_base = ksemid_ds.sem_base;
+      semun.buf->sem_nsems = ksemid_ds.sem_nsems;
+      semun.buf->sem_otime = ksemid_ds.sem_otime;
+      semun.buf->sem_ctime = ksemid_ds.sem_ctime;
+    }
+
+  return result;
+}
+
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/alpha/setfpucw.c
@@ -0,0 +1,88 @@
+/* Set FP exception mask and rounding mode.
+   Copyright (C) 1996, 1997, 1998, 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <fpu_control.h>
+#include <fpu.h>
+
+extern unsigned long __ieee_get_fp_control (void);
+extern void __ieee_set_fp_control (unsigned long);
+
+
+static inline unsigned long
+rdfpcr (void)
+{
+  unsigned long fpcr;
+  asm ("excb; mf_fpcr %0" : "=f"(fpcr));
+  return fpcr;
+}
+
+static inline void
+wrfpcr (unsigned long fpcr)
+{
+  asm volatile ("mt_fpcr %0; excb" : : "f"(fpcr));
+}
+
+
+void
+__setfpucw (fpu_control_t fpu_control)
+{
+  if (!fpu_control)
+    fpu_control = _FPU_DEFAULT;
+
+  /* Note that the fpu_control argument, as defined in <fpu_control.h>,
+     consists of bits that are not directly related to the bits of the
+     fpcr and fp_control registers.  In particular, the precision control
+     (_FPU_EXTENDED, _FPU_DOUBLE, _FPU_SINGLE) and the interrupt mask
+     _FPU_MASK_UM are without effect.  */
+
+  /* First, set dynamic rounding mode: */
+  {
+    unsigned long fpcr;
+
+    fpcr = rdfpcr();
+    fpcr &= ~FPCR_DYN_MASK;
+    switch (fpu_control & 0xc00)
+      {
+      case _FPU_RC_NEAREST:	fpcr |= FPCR_DYN_NORMAL; break;
+      case _FPU_RC_DOWN:	fpcr |= FPCR_DYN_MINUS; break;
+      case _FPU_RC_UP:		fpcr |= FPCR_DYN_PLUS; break;
+      case _FPU_RC_ZERO:	fpcr |= FPCR_DYN_CHOPPED; break;
+      }
+    wrfpcr(fpcr);
+  }
+
+  /* Now tell kernel about traps that we like to hear about: */
+  {
+    unsigned long old_fpcw, fpcw;
+
+    old_fpcw = fpcw = __ieee_get_fp_control ();
+    fpcw &= ~IEEE_TRAP_ENABLE_MASK;
+
+    if (!(fpu_control & _FPU_MASK_IM)) fpcw |= IEEE_TRAP_ENABLE_INV;
+    if (!(fpu_control & _FPU_MASK_DM)) fpcw |= IEEE_TRAP_ENABLE_UNF;
+    if (!(fpu_control & _FPU_MASK_ZM)) fpcw |= IEEE_TRAP_ENABLE_DZE;
+    if (!(fpu_control & _FPU_MASK_OM)) fpcw |= IEEE_TRAP_ENABLE_OVF;
+    if (!(fpu_control & _FPU_MASK_PM)) fpcw |= IEEE_TRAP_ENABLE_INE;
+
+    if (fpcw != old_fpcw)
+      __ieee_set_fp_control (fpcw);
+  }
+
+  __fpu_control = fpu_control;	/* update global copy */
+}
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/alpha/setitimer.c
@@ -0,0 +1,63 @@
+/* Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Bruno Haible <bruno@clisp.org>, 2002.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <stddef.h>
+#include <errno.h>
+#include <sys/time.h>
+#include <bits/kernel_time_t.h>
+
+extern int __syscall_setitimer (int which,
+				const struct __kernel_itimerval *new,
+				struct __kernel_itimerval *old);
+
+int
+__setitimer (enum __itimer_which which,
+	     const struct itimerval *new, struct itimerval *old)
+{
+  int retval;
+  struct __kernel_itimerval knew;
+
+  if (new == NULL)
+    {
+      errno = EFAULT;
+      return -1;
+    }
+  knew.it_interval.tv_sec  = new->it_interval.tv_sec;
+  knew.it_interval.tv_usec = new->it_interval.tv_usec;
+  knew.it_value.tv_sec  = new->it_value.tv_sec;
+  knew.it_value.tv_usec = new->it_value.tv_usec;
+  if (old != NULL)
+    {
+      struct __kernel_itimerval kold;
+
+      retval = __syscall_setitimer (which, &knew, &kold);
+      if (retval >= 0)
+	{
+	  old->it_interval.tv_sec  = kold.it_interval.tv_sec;
+	  old->it_interval.tv_usec = kold.it_interval.tv_usec;
+	  old->it_value.tv_sec  = kold.it_value.tv_sec;
+	  old->it_value.tv_usec = kold.it_value.tv_usec;
+	}
+    }
+  else
+    retval = __syscall_setitimer (which, &knew, NULL);
+  return retval;
+}
+
+weak_alias (__setitimer, setitimer)
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/alpha/settimeofday.c
@@ -0,0 +1,43 @@
+/* Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Bruno Haible <bruno@clisp.org>, 2002.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <stddef.h>
+#include <errno.h>
+#include <sys/time.h>
+#include <bits/kernel_time_t.h>
+
+extern int __syscall_settimeofday (const struct __kernel_timeval *tv,
+				   const struct timezone *tz);
+
+int
+__settimeofday (const struct timeval *tv, const struct timezone *tz)
+{
+  struct __kernel_timeval ktv;
+
+  if (tv == NULL)
+    {
+      errno = EFAULT;
+      return -1;
+    }
+  ktv.tv_sec  = tv->tv_sec;
+  ktv.tv_usec = tv->tv_usec;
+  return __syscall_settimeofday (&ktv, tz);
+}
+
+weak_alias (__settimeofday, settimeofday)
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/alpha/shmctl.c
@@ -0,0 +1,58 @@
+/* Copyright (C) 2006 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Aurelien Jarno <aurelien@aurel32.net>, 2006.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sys/types.h>
+#include <sys/ipc.h>
+#include <sys/shm.h>
+#include <bits/kernel_time_t.h>
+
+extern int __syscall_msgctl (int shmid, int cmd, struct __kernel_shmid_ds *buf);
+
+int
+__msgctl (int shmid, int cmd, struct shmid_ds *buf)
+{
+  struct __kernel_shmid_ds kshmid_ds;
+  int retval;
+
+  kshmid_ds.shm_perm = shmid_ds->shm_perm;
+  kshmid_ds.shm_segsz = shmid_ds->shm_segsz;
+  kshmid_ds.shm_lpid = shmid_ds->shm_lpid;
+  kshmid_ds.shm_cpid = shmid_ds->shm_cpid;
+  kshmid_ds.shm_nattch = shmid_ds->shm_nattch;
+  kshmid_ds.shm_atime = shmid_ds->shm_atime;
+  kshmid_ds.shm_dtime = shmid_ds->shm_dtime;
+  kshmid_ds.shm_ctime = shmid_ds->shm_ctime;
+  kshmid_ds.__shm_internal = shmid_ds->__shm_internal;
+
+  retval = __syscall_shmctl (shmid, cmd, &kshmid_ds);
+
+  shmid_ds->shm_perm = kshmid_ds.shm_perm;
+  shmid_ds->shm_segsz = kshmid_ds.shm_segsz;
+  shmid_ds->shm_lpid = kshmid_ds.shm_lpid;
+  shmid_ds->shm_cpid = kshmid_ds.shm_cpid;
+  shmid_ds->shm_nattch = kshmid_ds.shm_nattch;
+  shmid_ds->shm_atime = kshmid_ds.shm_atime;
+  shmid_ds->shm_dtime = kshmid_ds.shm_dtime;
+  shmid_ds->shm_ctime = kshmid_ds.shm_ctime;
+  shmid_ds->__shm_internal = kshmid_ds.__shm_internal;
+
+  return retval;
+}
+
+weak_alias (__shmctl, shmctl)
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/alpha/sigcontextinfo.h
@@ -0,0 +1,25 @@
+/* Copyright (C) 1998, 1999, 2001, 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#define SIGCONTEXT int _code, struct sigcontext *
+#define SIGCONTEXT_EXTRA_ARGS _code,
+#define GET_PC(ctx)	((void *) (ctx)->sc_pc)
+#define GET_FRAME(ctx)	((void *) (ctx)->sc_regs[15])
+#define GET_STACK(ctx)	((void *) (ctx)->sc_regs[30])
+#define CALL_SIGHANDLER(handler, signo, ctx) \
+  (handler)((signo), SIGCONTEXT_EXTRA_ARGS (ctx))
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/alpha/start_thread.S
@@ -0,0 +1,172 @@
+/* Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Bruno Haible <bruno@clisp.org>, 2002.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+/* __start_thread (flags, stack, func, arg)
+   calls __rfork (flags), and in the child sets the stack pointer and then
+   calls _exit (func (arg)).
+   It cannot be done in portable C.  */
+
+#include <sysdep.h>
+#define SIG_SETMASK	3
+
+	.text
+ENTRY (__start_thread)
+	/* There is a window of a few instructions, right after the rfork
+	   system call, where the handling of a signal would write garbage
+	   into the stack shared by the parent and the child (assuming
+	   RFMEM is set in flags).  To solve this: 1. We block all signals
+	   around the rfork system call and unblock them afterwards in
+	   the parent and in the child (but only after changing the stack
+	   pointer).  2. The child accesses only values passed in registers
+	   and on its own stack.  This way, if the parent is scheduled to
+	   run first, and handles a signal, it will not affect the child;
+	   and if the child runs first, and handles a signal, it will use
+	   the child's stack and not affect the parent.
+	   We need to pass 7 words of info to the child: stack, func, arg,
+	   and the signal mask to restore.  Since we have only 4 call-saved
+	   registers available (%ebx, %esi, %edi, %ebp), we pass only the
+	   stack pointer in a register, and the rest through the child's
+	   stack.  */
+	lda	sp,-56(sp)
+	stq	ra,0(sp)
+	stq	s0,8(sp)
+	stq	s1,16(sp)
+	stq	s2,24(sp)
+	stq	s3,32(sp)
+	.prologue 1
+
+	/* Save arguments.  */
+	mov	a0,s1		/* flags */
+	mov	a1,s0		/* stack */
+	mov	a2,s2		/* func */
+	mov	a3,s3		/* arg */
+
+	and	a0,32,t0	/* flags & RFMEM */
+	beq	t0,$simple
+
+	/* Block all signals.  */
+	lda	t0,-1
+	stq	t0,40(sp)
+	stq	t0,48(sp)
+	lda	a0,SIG_SETMASK
+	lda	a1,40(sp)
+	mov	a1,a2
+	lda	v0,SYS_sigprocmask
+	call_pal PAL_callsys
+	bne	a3,$error
+
+	/* Copy all info to the child's stack.  */
+	lda	s0,-32(s0)	/* room for func, arg, sigset_t */
+	andnot	s0,7,s0		/* make it 8-bytes aligned */
+	stq	s2,8(s0)	/* func */
+	stq	s3,0(s0)	/* arg */
+	ldq	t0,40(sp)	/* sigset_t word 0 */
+	ldq	t1,48(sp)	/* sigset_t word 1 */
+	stq	t0,16(s0)
+	stq	t1,24(s0)
+
+	/* Perform the rfork system call.  */
+	mov	s1,a0		/* flags */
+	lda	v0,SYS_rfork
+	call_pal PAL_callsys
+	bne	a3,$error
+
+	/* a4 is now 0 for the parent and 1 for the child.  */
+	bne	a4,$child
+
+	/* Save the child pid, currently in v0.  */
+	mov	v0,s1
+
+	/* Restore the previous signal mask.  */
+	lda	a0,SIG_SETMASK
+	lda	a1,40(sp)
+	mov	zero,a2
+	lda	v0,SYS_sigprocmask
+	call_pal PAL_callsys
+
+	/* Return the child pid, currently in s1.  */
+	mov	s1,v0
+$retv0:	ldq	ra,0(sp)
+	ldq	s0,8(sp)
+	ldq	s1,16(sp)
+	ldq	s2,24(sp)
+	ldq	s3,32(sp)
+	lda	sp,56(sp)
+	ret	zero,(ra),1
+
+$child:	/* Here we are in the child thread.  */
+
+	/* Set the stack pointer.  */
+	mov	s0,sp
+
+	/* Restore the previous signal mask.  */
+	lda	a0,SIG_SETMASK
+	lda	a1,16(sp)
+	mov	zero,a2
+	lda	v0,SYS_sigprocmask
+	call_pal PAL_callsys
+
+$child1:
+	/* Call func (arg).  */
+	ldq	a0,0(sp)
+	ldq	pv,8(sp)
+	jsr	ra,(pv),0
+
+	/* Tail-call _exit.  */
+	br	gp,$here
+$here:	ldgp	gp,0(gp)
+	mov	v0,a0
+	jmp	zero,_exit
+
+$simple:/* Simple case without signal mask handling.  */
+
+	/* Copy all info to the child's stack.  */
+	lda	s0,-16(s0)	/* room for func, arg */
+	andnot	s0,7,s0		/* make it 8-bytes aligned */
+	stq	s2,8(s0)	/* func */
+	stq	s3,0(s0)	/* arg */
+
+	/* Perform the rfork system call.  */
+	mov	s1,a0		/* flags */
+	lda	v0,SYS_rfork
+	call_pal PAL_callsys
+	bne	a3,$error
+
+	/* a4 is now 0 for the parent and 1 for the child.  */
+	/* If in the parent, return the child pid, currently in v0.  */
+	beq	a4,$retv0
+
+$simple_child:/* Here we are in the child thread.  */
+
+	/* Set the stack pointer.  */
+	mov	s0,sp
+
+	br	zero,$child1
+
+$error:	ldq	ra,0(sp)
+	ldq	s0,8(sp)
+	ldq	s1,16(sp)
+	ldq	s2,24(sp)
+	ldq	s3,32(sp)
+	lda	sp,56(sp)
+#if 0 /* Not needed: The PSEUDO_END expansion starts with this label.  */
+	br	zero,1996f
+#endif
+
+PSEUDO_END (__start_thread)
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/alpha/statfs64.c
@@ -0,0 +1,2 @@
+/* 'statfs64' is the same as 'statfs', because
+   __fsblkcnt64_t == __fsblkcnt_t and __fsfilcnt64_t == __fsfilcnt_t.  */
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/alpha/sysarch.h
@@ -0,0 +1,53 @@
+/* Parameters for the architecture specific system call.  alpha version.
+   Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _SYSARCH_H
+#define _SYSARCH_H	1
+
+#include <features.h>
+
+/* Function that can be used as first argument to 'sysarch'.  */
+enum
+  {
+    ALPHA_SETHAE = 0,
+#define ALPHA_SETHAE ALPHA_SETHAE
+    /* Arg is 'unsigned long *'.  Returns the current pcb_fp_control.  */
+    ALPHA_GET_FPMASK = 1,
+#define ALPHA_GET_FPMASK ALPHA_GET_FPMASK
+    /* Arg is 'unsigned long *'.  Sets the pcb_fp_control and returns its
+       old value in the same memory location.  */
+    ALPHA_SET_FPMASK = 2,
+#define ALPHA_SET_FPMASK ALPHA_SET_FPMASK
+    ALPHA_GET_UAC = 3,
+#define ALPHA_GET_UAC ALPHA_GET_UAC
+    ALPHA_SET_UAC = 4
+#define ALPHA_SET_UAC ALPHA_SET_UAC
+  };
+
+__BEGIN_DECLS
+
+extern int sysarch (int __cmd, void *__arg);
+
+#ifdef _LIBC
+extern int __sysarch (int __cmd, void *__arg);
+#endif
+
+__END_DECLS
+
+#endif /* _SYSARCH_H */
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/alpha/syscall.S
@@ -0,0 +1 @@
+#include <sysdeps/unix/sysv/linux/alpha/syscall.S>
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/alpha/syscalls.list
@@ -0,0 +1,21 @@
+# File name	Caller	Syscall name	# args	Strong name	Weak names
+
+fhstatfs	-	fhstatfs	i:pp	__fhstatfs	fhstatfs fhstatfs64
+fstatfs		-	fstatfs		i:ip	__fstatfs	fstatfs __fstatfs64 fstatfs64
+getfsstat	-	getfsstat	i:pii	__getfsstat	getfsstat __getfsstat64 getfsstat64
+sys_poll	-	poll		i:pii	__syscall_poll
+statfs		-	statfs		i:sp	__statfs	statfs statfs64
+sys_adjtime	-	adjtime			i:pp	__syscall_adjtime
+sys_futimes	-	futimes			i:ip	__syscall_futimes
+sys_getitimer	-	getitimer		i:ip	__syscall_getitimer
+sys_getrusage	-	getrusage		i:ip	__syscall_getrusage
+sys_gettimeofday -	gettimeofday		i:PP	__syscall_gettimeofday
+sys_lutimes	-	lutimes			i:sp	__syscall_lutimes
+sys_msgctl	-	msgctl			i:iip	__syscall_msgctl
+sys_nanosleep	-	nanosleep		i:pp	__syscall_nanosleep
+sys_sched_rr_gi	-	sched_rr_get_interval	i:ip	__syscall_sched_rr_get_interval
+sys_shmctl	-	shmctl			i:iip	__syscall_shmctl
+sys_select	-	select			i:iPPPP	__syscall_select
+sys_setitimer	-	setitimer		i:ipp	__syscall_setitimer
+sys_settimeofday -	settimeofday		i:PP	__syscall_settimeofday
+sys_utimes	-	utimes			i:sp	__syscall_utimes
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/alpha/sysdep.h
@@ -0,0 +1,34 @@
+/* Copyright (C) 1993, 1995, 1997, 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _FREEBSD_ALPHA_SYSDEP_H
+#define _FREEBSD_ALPHA_SYSDEP_H 1
+
+#ifdef __ASSEMBLER__
+#include <machine/pal.h>		/* get PAL_callsys */
+#else
+#include <syscalls-inline.h>
+#endif
+
+#include <sysdeps/unix/alpha/sysdep.h>
+
+/* FIXME: Is this necessary?  */
+#undef INLINE_SYSCALL
+#define INLINE_SYSCALL(name, nr, args...) __syscall_##name(args)
+
+#endif /* freebsd/alpha/sysdep.h */
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/alpha/utimes.c
@@ -0,0 +1,44 @@
+/* Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Bruno Haible <bruno@clisp.org>, 2002.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <stddef.h>
+#include <sys/time.h>
+#include <bits/kernel_time_t.h>
+
+extern int __syscall_utimes (const char *file,
+			     const struct __kernel_timeval tvp[2]);
+
+int
+__utimes (const char *file, const struct timeval tvp[2])
+{
+  if (tvp != NULL)
+    {
+      struct __kernel_timeval ktv[2];
+
+      ktv[0].tv_sec  = tvp[0].tv_sec;
+      ktv[0].tv_usec = tvp[0].tv_usec;
+      ktv[1].tv_sec  = tvp[1].tv_sec;
+      ktv[1].tv_usec = tvp[1].tv_usec;
+      return __syscall_utimes (file, ktv);
+    }
+  else
+    return __syscall_utimes (file, NULL);
+}
+
+weak_alias (__utimes, utimes)
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/alpha/vfork.S
@@ -0,0 +1,29 @@
+/* Copyright (C) 1993, 1995, 1997, 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sysdep.h>
+
+SYSCALL__ (vfork, 0)
+	/* In the parent process, a4 == 0, v0 == child pid.  */
+	/* In the child process, a4 == 1, v0 == parent pid.  */
+	cmovne a4, zero, v0
+	ret
+
+PSEUDO_END (__vfork)
+
+weak_alias (__vfork, vfork)
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/bind.c
@@ -0,0 +1,60 @@
+/* Copyright (C) 2005 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Aurelien Jarno <aurelien@aurel32.net>, 2005.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sys/socket.h>
+#include <sysdep.h>
+
+/* According to POSIX.1-2004 the len argument specifies the length of
+   the sockaddr structure pointed to by the addrarg argument. However
+   the FreeBSD kernel waits the actual length of the address stored
+   there. The code below emulate this behaviour. */
+
+extern int __libc_sa_len (sa_family_t __af);
+extern int __libc_sa_len_internal (sa_family_t __af);
+
+extern int __syscall_bind (int fd, __CONST_SOCKADDR_ARG addr,
+			   socklen_t addrlen) __THROW;
+libc_hidden_proto (__syscall_bind)
+
+/* Open a connection on socket FD to peer at ADDR (which LEN bytes long).
+   For connectionless socket types, just set the default address to send to
+   and the only address from which to accept transmissions.
+   Return 0 on success, -1 for errors.  */
+
+int
+__bind (int fd, __CONST_SOCKADDR_ARG addr, socklen_t addrlen)
+{
+  socklen_t new_addrlen;
+
+#ifndef NOT_IN_libc
+  new_addrlen = INTUSE(__libc_sa_len) ((addr.__sockaddr__)->sa_family);
+#else
+  new_addrlen = __libc_sa_len ((addr.__sockaddr__)->sa_family);
+#endif
+
+  /* Only allow a smaller size, otherwise it could lead to
+    stack corruption */
+  if (new_addrlen < addrlen)
+    addrlen = new_addrlen;
+
+  /* We pass 3 arguments.  */
+  return INLINE_SYSCALL (bind, 3, fd, addr, addrlen);
+}
+
+weak_alias (__bind, bind)
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/bits/dirent.h
@@ -0,0 +1,52 @@
+/* Directory entry structure `struct dirent'.  FreeBSD version.
+   Copyright (C) 1996-1998,2001-2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _DIRENT_H
+# error "Never use <bits/dirent.h> directly; include <dirent.h> instead."
+#endif
+
+struct dirent
+  {
+    unsigned int d_ino;		/* File serial number.  */
+    unsigned short int d_reclen; /* Length of the whole `struct dirent'.  */
+    unsigned char d_type;	/* File type, possibly unknown.  */
+    unsigned char d_namlen;	/* Length of the file name.  */
+
+    /* Only this member is in the POSIX standard.  */
+    char d_name[256];		/* File name (actually longer).  */
+  };
+
+#ifdef __USE_LARGEFILE64
+struct dirent64
+  {
+    unsigned int d_ino;		/* File serial number.  */
+    unsigned short int d_reclen; /* Length of the whole `struct dirent'.  */
+    unsigned char d_type;	/* File type, possibly unknown.  */
+    unsigned char d_namlen;	/* Length of the file name.  */
+
+    /* Only this member is in the POSIX standard.  */
+    char d_name[256];		/* File name (actually longer).  */
+  };
+#endif
+
+#define d_fileno        d_ino   /* Backwards compatibility.  */
+
+#define _DIRENT_HAVE_D_RECLEN 1
+#define _DIRENT_HAVE_D_NAMLEN 1
+#define _DIRENT_HAVE_D_TYPE 1
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/bits/errno.h
@@ -0,0 +1,182 @@
+/*-
+ * Copyright (c) 1982, 1986, 1989, 1993
+ *	The Regents of the University of California.  All rights reserved.
+ * (c) UNIX System Laboratories, Inc.
+ * All or some portions of this file are derived from material licensed
+ * to the University of California by American Telephone and Telegraph
+ * Co. or Unix System Laboratories, Inc. and are reproduced herein with
+ * the permission of UNIX System Laboratories, Inc.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 4. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ *	@(#)errno.h	8.5 (Berkeley) 1/21/94
+ * based on $FreeBSD: src/sys/sys/errno.h,v 1.28 2005/04/02 12:33:28 das Exp $
+ */
+
+#ifdef _ERRNO_H
+
+# undef EDOM
+# undef EILSEQ
+# undef ERANGE
+
+#define	EPERM		1		/* Operation not permitted */
+#define	ENOENT		2		/* No such file or directory */
+#define	ESRCH		3		/* No such process */
+#define	EINTR		4		/* Interrupted system call */
+#define	EIO		5		/* Input/output error */
+#define	ENXIO		6		/* Device not configured */
+#define	E2BIG		7		/* Argument list too long */
+#define	ENOEXEC		8		/* Exec format error */
+#define	EBADF		9		/* Bad file descriptor */
+#define	ECHILD		10		/* No child processes */
+#define	EDEADLK		11		/* Resource deadlock avoided */
+					/* 11 was EAGAIN */
+#define	ENOMEM		12		/* Cannot allocate memory */
+#define	EACCES		13		/* Permission denied */
+#define	EFAULT		14		/* Bad address */
+#define	ENOTBLK		15		/* Block device required */
+#define	EBUSY		16		/* Device busy */
+#define	EEXIST		17		/* File exists */
+#define	EXDEV		18		/* Cross-device link */
+#define	ENODEV		19		/* Operation not supported by device */
+#define	ENOTDIR		20		/* Not a directory */
+#define	EISDIR		21		/* Is a directory */
+#define	EINVAL		22		/* Invalid argument */
+#define	ENFILE		23		/* Too many open files in system */
+#define	EMFILE		24		/* Too many open files */
+#define	ENOTTY		25		/* Inappropriate ioctl for device */
+#define	ETXTBSY		26		/* Text file busy */
+#define	EFBIG		27		/* File too large */
+#define	ENOSPC		28		/* No space left on device */
+#define	ESPIPE		29		/* Illegal seek */
+#define	EROFS		30		/* Read-only filesystem */
+#define	EMLINK		31		/* Too many links */
+#define	EPIPE		32		/* Broken pipe */
+
+/* math software */
+#define	EDOM		33		/* Numerical argument out of domain */
+#define	ERANGE		34		/* Result too large */
+
+/* non-blocking and interrupt i/o */
+#define	EAGAIN		35		/* Resource temporarily unavailable */
+#define	EWOULDBLOCK	EAGAIN		/* Operation would block */
+#define	EINPROGRESS	36		/* Operation now in progress */
+#define	EALREADY	37		/* Operation already in progress */
+
+/* ipc/network software -- argument errors */
+#define	ENOTSOCK	38		/* Socket operation on non-socket */
+#define	EDESTADDRREQ	39		/* Destination address required */
+#define	EMSGSIZE	40		/* Message too long */
+#define	EPROTOTYPE	41		/* Protocol wrong type for socket */
+#define	ENOPROTOOPT	42		/* Protocol not available */
+#define	EPROTONOSUPPORT	43		/* Protocol not supported */
+#define	ESOCKTNOSUPPORT	44		/* Socket type not supported */
+#define	EOPNOTSUPP	45		/* Operation not supported */
+#define	ENOTSUP		EOPNOTSUPP	/* Operation not supported */
+#define	EPFNOSUPPORT	46		/* Protocol family not supported */
+#define	EAFNOSUPPORT	47		/* Address family not supported by protocol family */
+#define	EADDRINUSE	48		/* Address already in use */
+#define	EADDRNOTAVAIL	49		/* Can't assign requested address */
+
+/* ipc/network software -- operational errors */
+#define	ENETDOWN	50		/* Network is down */
+#define	ENETUNREACH	51		/* Network is unreachable */
+#define	ENETRESET	52		/* Network dropped connection on reset */
+#define	ECONNABORTED	53		/* Software caused connection abort */
+#define	ECONNRESET	54		/* Connection reset by peer */
+#define	ENOBUFS		55		/* No buffer space available */
+#define	EISCONN		56		/* Socket is already connected */
+#define	ENOTCONN	57		/* Socket is not connected */
+#define	ESHUTDOWN	58		/* Can't send after socket shutdown */
+#define	ETOOMANYREFS	59		/* Too many references: can't splice */
+#define	ETIMEDOUT	60		/* Operation timed out */
+#define	ECONNREFUSED	61		/* Connection refused */
+
+#define	ELOOP		62		/* Too many levels of symbolic links */
+#define	ENAMETOOLONG	63		/* File name too long */
+
+/* should be rearranged */
+#define	EHOSTDOWN	64		/* Host is down */
+#define	EHOSTUNREACH	65		/* No route to host */
+#define	ENOTEMPTY	66		/* Directory not empty */
+
+/* quotas & mush */
+#define	EPROCLIM	67		/* Too many processes */
+#define	EUSERS		68		/* Too many users */
+#define	EDQUOT		69		/* Disc quota exceeded */
+
+/* Network File System */
+#define	ESTALE		70		/* Stale NFS file handle */
+#define	EREMOTE		71		/* Too many levels of remote in path */
+#define	EBADRPC		72		/* RPC struct is bad */
+#define	ERPCMISMATCH	73		/* RPC version wrong */
+#define	EPROGUNAVAIL	74		/* RPC prog. not avail */
+#define	EPROGMISMATCH	75		/* Program version wrong */
+#define	EPROCUNAVAIL	76		/* Bad procedure for program */
+
+#define	ENOLCK		77		/* No locks available */
+#define	ENOSYS		78		/* Function not implemented */
+
+#define	EFTYPE		79		/* Inappropriate file type or format */
+#define	EAUTH		80		/* Authentication error */
+#define	ENEEDAUTH	81		/* Need authenticator */
+#define	EIDRM		82		/* Identifier removed */
+#define	ENOMSG		83		/* No message of desired type */
+#define	EOVERFLOW	84		/* Value too large to be stored in data type */
+#define	ECANCELED	85		/* Operation canceled */
+#define	EILSEQ		86		/* Illegal byte sequence */
+#define	ENOATTR		87		/* Attribute not found */
+
+#define EDOOFUS		88		/* Programming error */
+
+#define	EBADMSG		89		/* Bad message */
+#define	EMULTIHOP	90		/* Multihop attempted */
+#define	ENOLINK		91		/* Link has been severed */
+#define	EPROTO		92		/* Protocol error */
+
+#define	ELAST		92		/* Must be equal largest errno */
+
+# ifndef __ASSEMBLER__
+/* Function to get address of global `errno' variable.  */
+extern int *__errno_location (void) __THROW __attribute__ ((__const__));
+
+#  if !defined _LIBC || defined _LIBC_REENTRANT
+/* When using threads, errno is a per-thread value.  */
+#   define errno (*__errno_location ())
+#  endif
+# endif /* !__ASSEMBLER__ */
+#endif /* _ERRNO_H */
+
+#if !defined _ERRNO_H && defined __need_Emath
+/* This is ugly but the kernel header is not clean enough.  We must
+   define only the values EDOM, EILSEQ and ERANGE in case __need_Emath is
+   defined.  */
+
+#define	EDOM		33		/* Numerical argument out of domain */
+#define	ERANGE		34		/* Result too large */
+#define	EILSEQ		86		/* Illegal byte sequence */
+
+#endif /* !_ERRNO_H && __need_Emath */
+
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/bits/fcntl.h
@@ -0,0 +1,145 @@
+/* O_*, F_*, FD_* bit values for FreeBSD.
+   Copyright (C) 1991-1992, 1997, 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef	_FCNTL_H
+#error "Never use <bits/fcntl.h> directly; include <fcntl.h> instead."
+#endif
+
+#include <sys/types.h>
+
+/* File access modes for `open' and `fcntl'.  */
+#define	O_RDONLY	0	/* Open read-only.  */
+#define	O_WRONLY	1	/* Open write-only.  */
+#define	O_RDWR		2	/* Open read/write.  */
+
+
+/* Bits OR'd into the second argument to open.  */
+#define	O_CREAT		0x0200	/* Create file if it doesn't exist.  */
+#define	O_EXCL		0x0800	/* Fail if file already exists.  */
+#define	O_TRUNC		0x0400	/* Truncate file to zero length.  */
+#define	O_NOCTTY	0x8000	/* Don't assign a controlling terminal.  */
+#ifdef	__USE_MISC
+#define	O_ASYNC		0x0040	/* Send SIGIO to owner when data is ready.  */
+#define	O_FSYNC		0x0080	/* Synchronous writes.  */
+#define	O_SYNC		O_FSYNC
+#define	O_SHLOCK	0x0010	/* Open with shared file lock.  */
+#define	O_EXLOCK	0x0020	/* Open with shared exclusive lock.  */
+#define O_NOFOLLOW	0x0100	/* Don't follow symlinks.  */
+#define	O_DIRECT    0x00010000  /* Attempt to bypass buffer cache */
+#endif
+
+enum { O_DIRECTORY = 0 };
+
+/* File status flags for `open' and `fcntl'.  */
+#define	O_APPEND	0x0008	/* Writes append to the file.  */
+#define	O_NONBLOCK	0x0004	/* Non-blocking I/O.  */
+
+#ifdef __USE_BSD
+#define	O_NDELAY	O_NONBLOCK
+#endif
+
+/* Since 'off_t' is 64-bit, O_LARGEFILE is a no-op.  */
+#define O_LARGEFILE	0
+
+/* FreeBSD doesn't have smaller grained synchronicity control than per file.
+   fdatasync() is equivalent to fsync(), so we define O_DSYNC == O_SYNC.  */
+#if defined __USE_POSIX199309 || defined __USE_UNIX98
+# define O_DSYNC	O_SYNC	/* Synchronize data.  */
+# define O_RSYNC	O_SYNC	/* Synchronize read operations.  */
+#endif
+
+#ifdef __USE_BSD
+/* Bits in the file status flags returned by F_GETFL.
+   These are all the O_* flags, plus FREAD and FWRITE, which are
+   independent bits set by which of O_RDONLY, O_WRONLY, and O_RDWR, was
+   given to `open'.  */
+#define FREAD		1
+#define	FWRITE		2
+
+/* Traditional BSD names the O_* bits.  */
+#define FASYNC		O_ASYNC
+#define FCREAT		O_CREAT
+#define FEXCL		O_EXCL
+#define FTRUNC		O_TRUNC
+#define FNOCTTY		O_NOCTTY
+#define FFSYNC		O_FSYNC
+#define FSYNC		O_SYNC
+#define FAPPEND		O_APPEND
+#define FNONBLOCK	O_NONBLOCK
+#define FNDELAY		O_NDELAY
+#endif
+
+/* Mask for file access modes.  This is system-dependent in case
+   some system ever wants to define some other flavor of access.  */
+#define	O_ACCMODE	(O_RDONLY|O_WRONLY|O_RDWR)
+
+/* Values for the second argument to `fcntl'.  */
+#define	F_DUPFD	  	0	/* Duplicate file descriptor.  */
+#define	F_GETFD		1	/* Get file descriptor flags.  */
+#define	F_SETFD		2	/* Set file descriptor flags.  */
+#define	F_GETFL		3	/* Get file status flags.  */
+#define	F_SETFL		4	/* Set file status flags.  */
+#ifdef __USE_BSD
+#define	F_GETOWN	5	/* Get owner (receiver of SIGIO).  */
+#define	F_SETOWN	6	/* Set owner (receiver of SIGIO).  */
+#endif
+#define	F_GETLK		7	/* Get record locking info.  */
+#define	F_SETLK		8	/* Set record locking info (non-blocking).  */
+#define	F_SETLKW	9	/* Set record locking info (blocking).  */
+
+/* File descriptor flags used with F_GETFD and F_SETFD.  */
+#define	FD_CLOEXEC	1	/* Close on exec.  */
+
+
+#include <bits/types.h>
+
+/* The structure describing an advisory lock.  This is the type of the third
+   argument to `fcntl' for the F_GETLK, F_SETLK, and F_SETLKW requests.  */
+struct flock
+  {
+    __off_t l_start;	/* Offset where the lock begins.  */
+    __off_t l_len;	/* Size of the locked area; zero means until EOF.  */
+    __pid_t l_pid;	/* Process holding the lock.  */
+    short int l_type;	/* Type of lock: F_RDLCK, F_WRLCK, or F_UNLCK.  */
+    short int l_whence;	/* Where `l_start' is relative to (like `lseek').  */
+  };
+
+#ifdef __USE_LARGEFILE64
+struct flock64
+  {
+    __off64_t l_start;	/* Offset where the lock begins.  */
+    __off64_t l_len;	/* Size of the locked area; zero means until EOF.  */
+    __pid_t l_pid;	/* Process holding the lock.  */
+    short int l_type;	/* Type of lock: F_RDLCK, F_WRLCK, or F_UNLCK.  */
+    short int l_whence;	/* Where `l_start' is relative to (like `lseek').  */
+  };
+#endif
+
+/* Values for the `l_type' field of a `struct flock'.  */
+#define	F_RDLCK	1	/* Read lock.  */
+#define	F_WRLCK	3	/* Write lock.  */
+#define	F_UNLCK	2	/* Remove lock.  */
+
+#ifdef __USE_BSD
+/* Operations for flock().  */
+# define LOCK_SH 1	/* shared lock */
+# define LOCK_EX 2	/* exclusive lock */
+# define LOCK_NB 4	/* or'd with one of the above to prevent blocking */
+# define LOCK_UN 8	/* remove lock */
+#endif
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/bits/in.h
@@ -0,0 +1,305 @@
+/* Copyright (C) 1997, 2000, 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+/* FreeBSD version.  */
+
+#ifndef _NETINET_IN_H
+# error "Never use <bits/in.h> directly; include <netinet/in.h> instead."
+#endif
+
+
+/* Link numbers.  */
+#define	IMPLINK_IP		155
+#define	IMPLINK_LOWEXPER	156
+#define	IMPLINK_HIGHEXPER	158
+
+
+/* To select the IP level.  */
+#define SOL_IP	0
+
+/*
+ * Options for use with [gs]etsockopt at the IP level.
+ * First word of comment is data type; bool is stored in int.
+ */
+#define	IP_OPTIONS		1    /* buf/ip_opts; set/get IP options */
+#define	IP_HDRINCL		2    /* int; header is included with data */
+#define	IP_TOS			3    /* int; IP type of service and preced. */
+#define	IP_TTL			4    /* int; IP time to live */
+#define	IP_RECVOPTS		5    /* bool; receive all IP opts w/dgram */
+#define	IP_RECVRETOPTS		6    /* bool; receive IP opts for response */
+#define	IP_RECVDSTADDR		7    /* bool; receive IP dst addr w/dgram */
+#define	IP_SENDSRCADDR		IP_RECVDSTADDR /* cmsg_type to set src addr */
+#define	IP_RETOPTS		8    /* ip_opts; set/get IP options */
+#define	IP_MULTICAST_IF		9    /* struct in_addr *or* struct ip_mreqn;
+				      * set/get IP multicast i/f  */
+#define	IP_MULTICAST_TTL	10   /* u_char; set/get IP multicast ttl */
+#define	IP_MULTICAST_LOOP	11   /* u_char; set/get IP multicast loopback */
+#define	IP_ADD_MEMBERSHIP	12   /* ip_mreq; add an IP group membership */
+#define	IP_DROP_MEMBERSHIP	13   /* ip_mreq; drop an IP group membership */
+#define	IP_MULTICAST_VIF	14   /* set/get IP mcast virt. iface */
+#define	IP_RSVP_ON		15   /* enable RSVP in kernel */
+#define	IP_RSVP_OFF		16   /* disable RSVP in kernel */
+#define	IP_RSVP_VIF_ON		17   /* set RSVP per-vif socket */
+#define	IP_RSVP_VIF_OFF		18   /* unset RSVP per-vif socket */
+#define	IP_PORTRANGE		19   /* int; range to choose for unspec port */
+#define	IP_RECVIF		20   /* bool; receive reception if w/dgram */
+/* for IPSEC */
+#define	IP_IPSEC_POLICY		21   /* int; set/get security policy */
+#define	IP_FAITH		22   /* bool; accept FAITH'ed connections */
+
+#define	IP_ONESBCAST		23   /* bool: send all-ones broadcast */
+#define	IP_NONLOCALOK		24   /* bool: allow bind to spoof non-local addresses;
+					requires kernel compile option IP_NONLOCALBIND */
+
+#define	IP_FW_TABLE_ADD		40   /* add entry */
+#define	IP_FW_TABLE_DEL		41   /* delete entry */
+#define	IP_FW_TABLE_FLUSH	42   /* flush table */
+#define	IP_FW_TABLE_GETSIZE	43   /* get table size */
+#define	IP_FW_TABLE_LIST	44   /* list table contents */
+
+#define	IP_FW_ADD		50   /* add a firewall rule to chain */
+#define	IP_FW_DEL		51   /* delete a firewall rule from chain */
+#define	IP_FW_FLUSH		52   /* flush firewall rule chain */
+#define	IP_FW_ZERO		53   /* clear single/all firewall counter(s) */
+#define	IP_FW_GET		54   /* get entire firewall rule chain */
+#define	IP_FW_RESETLOG		55   /* reset logging counters */
+
+#define IP_FW_NAT_CFG           56   /* add/config a nat rule */
+#define IP_FW_NAT_DEL           57   /* delete a nat rule */
+#define IP_FW_NAT_GET_CONFIG    58   /* get configuration of a nat rule */
+#define IP_FW_NAT_GET_LOG       59   /* get log of a nat rule */
+
+#define	IP_DUMMYNET_CONFIGURE	60   /* add/configure a dummynet pipe */
+#define	IP_DUMMYNET_DEL		61   /* delete a dummynet pipe from chain */
+#define	IP_DUMMYNET_FLUSH	62   /* flush dummynet */
+#define	IP_DUMMYNET_GET		64   /* get entire dummynet pipes */
+
+#define	IP_RECVTTL		65   /* bool; receive IP TTL w/dgram */
+#define	IP_MINTTL		66   /* minimum TTL for packet or drop */
+#define	IP_DONTFRAG		67   /* don't fragment packet */
+
+/* IPv4 Source Filter Multicast API [RFC3678] */
+#define	IP_ADD_SOURCE_MEMBERSHIP	70   /* join a source-specific group */
+#define	IP_DROP_SOURCE_MEMBERSHIP	71   /* drop a single source */
+#define	IP_BLOCK_SOURCE			72   /* block a source */
+#define	IP_UNBLOCK_SOURCE		73   /* unblock a source */
+
+/* The following option is private; do not use it from user applications. */
+#define	IP_MSFILTER			74   /* set/get filter list */
+
+/* Protocol Independent Multicast API [RFC3678] */
+#define	MCAST_JOIN_GROUP		80   /* join an any-source group */
+#define	MCAST_LEAVE_GROUP		81   /* leave all sources for group */
+#define	MCAST_JOIN_SOURCE_GROUP		82   /* join a source-specific group */
+#define	MCAST_LEAVE_SOURCE_GROUP	83   /* leave a single source */
+#define	MCAST_BLOCK_SOURCE		84   /* block a source */
+#define	MCAST_UNBLOCK_SOURCE		85   /* unblock a source */
+
+/*
+ * Defaults and limits for options
+ */
+#define	IP_DEFAULT_MULTICAST_TTL  1	/* normally limit m'casts to 1 hop  */
+#define	IP_DEFAULT_MULTICAST_LOOP 1	/* normally hear sends if a member  */
+
+/*
+ * The imo_membership vector for each socket is now dynamically allocated at
+ * run-time, bounded by USHRT_MAX, and is reallocated when needed, sized
+ * according to a power-of-two increment.
+ */
+#define	IP_MIN_MEMBERSHIPS	31
+#define	IP_MAX_MEMBERSHIPS	4095
+#define	IP_MAX_SOURCE_FILTER	1024	/* # of filters per socket, per group */
+
+/*
+ * Filter modes; also used to represent per-socket filter mode internally.
+ */
+#define	MCAST_INCLUDE	1	/* fmode: include these source(s) */
+#define	MCAST_EXCLUDE	2	/* fmode: exclude these source(s) */
+
+/*
+ * Argument for IP_PORTRANGE:
+ * - which range to search when port is unspecified at bind() or connect()
+ */
+#define	IP_PORTRANGE_DEFAULT	0	/* default range */
+#define	IP_PORTRANGE_HIGH	1	/* "high" - request firewall bypass */
+#define	IP_PORTRANGE_LOW	2	/* "low" - vouchsafe security */
+
+/*
+ * Names for IP sysctl objects
+ */
+#define	IPCTL_FORWARDING	1	/* act as router */
+#define	IPCTL_SENDREDIRECTS	2	/* may send redirects when forwarding */
+#define	IPCTL_DEFTTL		3	/* default TTL */
+#ifdef notyet
+#define	IPCTL_DEFMTU		4	/* default MTU */
+#endif
+#define IPCTL_RTEXPIRE		5	/* cloned route expiration time */
+#define IPCTL_RTMINEXPIRE	6	/* min value for expiration time */
+#define IPCTL_RTMAXCACHE	7	/* trigger level for dynamic expire */
+#define	IPCTL_SOURCEROUTE	8	/* may perform source routes */
+#define	IPCTL_DIRECTEDBROADCAST	9	/* may re-broadcast received packets */
+#define IPCTL_INTRQMAXLEN	10	/* max length of netisr queue */
+#define	IPCTL_INTRQDROPS	11	/* number of netisr q drops */
+#define	IPCTL_STATS		12	/* ipstat structure */
+#define	IPCTL_ACCEPTSOURCEROUTE	13	/* may accept source routed packets */
+#define	IPCTL_FASTFORWARDING	14	/* use fast IP forwarding code */
+#define	IPCTL_KEEPFAITH		15	/* FAITH IPv4->IPv6 translater ctl */
+#define	IPCTL_GIF_TTL		16	/* default TTL for gif encap packet */
+#define	IPCTL_MAXID		17
+
+/* Structure used to describe IP options for IP_OPTIONS and IP_RETOPTS.
+   The `ip_dst' field is used for the first-hop gateway when using a
+   source route (this gets put into the header proper).  */
+struct ip_opts
+  {
+    struct in_addr ip_dst;	/* First hop; zero without source route.  */
+    char ip_opts[40];		/* Actually variable in size.  */
+  };
+
+/* Options for use with `getsockopt' and `setsockopt' at the IPv6 level.
+   The first word in the comment at the right is the data type used;
+   "bool" means a boolean value stored in an `int'.  */
+#define IPV6_SOCKOPT_RESERVED1	3  /* reserved for future use */
+#define IPV6_UNICAST_HOPS	4  /* int; IP6 hops */
+#define IPV6_MULTICAST_IF	9  /* u_int; set/get IP6 multicast i/f  */
+#define IPV6_MULTICAST_HOPS	10 /* int; set/get IP6 multicast hops */
+#define IPV6_MULTICAST_LOOP	11 /* u_int; set/get IP6 multicast loopback */
+#define IPV6_JOIN_GROUP		12 /* ip6_mreq; join a group membership */
+#define IPV6_LEAVE_GROUP	13 /* ip6_mreq; leave a group membership */
+#define IPV6_PORTRANGE		14 /* int; range to choose for unspec port */
+#define ICMP6_FILTER		18 /* icmp6_filter; icmp6 filter */
+
+#define IPV6_CHECKSUM		26 /* int; checksum offset for raw socket */
+#define IPV6_V6ONLY		27 /* bool; make AF_INET6 sockets v6 only */
+
+#define IPV6_IPSEC_POLICY	28 /* struct; get/set security policy */
+#define IPV6_FAITH		29 /* bool; accept FAITH'ed connections */
+
+#define IPV6_FW_ADD		30 /* add a firewall rule to chain */
+#define IPV6_FW_DEL		31 /* delete a firewall rule from chain */
+#define IPV6_FW_FLUSH		32 /* flush firewall rule chain */
+#define IPV6_FW_ZERO		33 /* clear single/all firewall counter(s) */
+#define IPV6_FW_GET		34 /* get entire firewall rule chain */
+#define IPV6_RTHDRDSTOPTS	35 /* ip6_dest; send dst option before rthdr */
+
+#define IPV6_RECVPKTINFO	36 /* bool; recv if, dst addr */
+#define IPV6_RECVHOPLIMIT	37 /* bool; recv hop limit */
+#define IPV6_RECVRTHDR		38 /* bool; recv routing header */
+#define IPV6_RECVHOPOPTS	39 /* bool; recv hop-by-hop option */
+#define IPV6_RECVDSTOPTS	40 /* bool; recv dst option after rthdr */
+
+#define IPV6_USE_MIN_MTU	42 /* bool; send packets at the minimum MTU */
+#define IPV6_RECVPATHMTU	43 /* bool; notify an according MTU */
+#define IPV6_PATHMTU		44 /* mtuinfo; get the current path MTU (sopt),
+				      4 bytes int; MTU notification (cmsg) */
+
+#define IPV6_PKTINFO		46 /* in6_pktinfo; send if, src addr */
+#define IPV6_HOPLIMIT		47 /* int; send hop limit */
+#define IPV6_NEXTHOP		48 /* sockaddr; next hop addr */
+#define IPV6_HOPOPTS		49 /* ip6_hbh; send hop-by-hop option */
+#define IPV6_DSTOPTS		50 /* ip6_dest; send dst option befor rthdr */
+#define IPV6_RTHDR		51 /* ip6_rthdr; send routing header */
+
+#define IPV6_RECVTCLASS		57 /* bool; recv traffic class values */
+
+#define IPV6_AUTOFLOWLABEL	59 /* bool; attach flowlabel automagically */
+
+#define IPV6_TCLASS		61 /* int; send traffic class value */
+#define IPV6_DONTFRAG		62 /* bool; disable IPv6 fragmentation */
+
+#define IPV6_PREFER_TEMPADDR	63 /* int; prefer temporary addresses as
+                                    * the source address.
+				    */
+
+/* Obsolete synonyms for the above.  */
+#define IPV6_ADD_MEMBERSHIP	IPV6_JOIN_GROUP
+#define IPV6_DROP_MEMBERSHIP	IPV6_LEAVE_GROUP
+#define IPV6_RXHOPOPTS		IPV6_HOPOPTS
+#define IPV6_RXDSTOPTS		IPV6_DSTOPTS
+
+/* Socket level values for IPv6.  */
+#define SOL_IPV6	41
+#define SOL_ICMPV6	58
+
+/*
+ * Defaults and limits for options
+ */
+#define IPV6_DEFAULT_MULTICAST_HOPS 1   /* normally limit m'casts to 1 hop */
+#define IPV6_DEFAULT_MULTICAST_LOOP 1   /* normally hear sends if a member */
+
+/*
+ * Argument for IPV6_PORTRANGE:
+ * - which range to search when port is unspecified at bind() or connect()
+ */
+#define IPV6_PORTRANGE_DEFAULT  0       /* default range */
+#define IPV6_PORTRANGE_HIGH     1       /* "high" - request firewall bypass */
+#define IPV6_PORTRANGE_LOW      2       /* "low" - vouchsafe security */
+
+/* Routing header options for IPv6.  */
+#define IPV6_RTHDR_LOOSE	0	/* Hop doesn't need to be neighbour. */
+#define IPV6_RTHDR_STRICT	1	/* Hop must be a neighbour.  */
+
+#define IPV6_RTHDR_TYPE_0	0	/* IPv6 Routing header type 0.  */
+
+/*
+ * Names for IP sysctl objects
+ */
+#define IPV6CTL_FORWARDING	1	/* act as router */
+#define IPV6CTL_SENDREDIRECTS	2	/* may send redirects when forwarding*/
+#define IPV6CTL_DEFHLIM		3	/* default Hop-Limit */
+#define IPV6CTL_FORWSRCRT	5	/* forward source-routed dgrams */
+#define IPV6CTL_STATS		6	/* stats */
+#define IPV6CTL_MRTSTATS	7	/* multicast forwarding stats */
+#define IPV6CTL_MRTPROTO	8	/* multicast routing protocol */
+#define IPV6CTL_MAXFRAGPACKETS	9	/* max packets reassembly queue */
+#define IPV6CTL_SOURCECHECK	10	/* verify source route and intf */
+#define IPV6CTL_SOURCECHECK_LOGINT 11	/* minimume logging interval */
+#define IPV6CTL_ACCEPT_RTADV	12
+#define IPV6CTL_KEEPFAITH	13
+#define IPV6CTL_LOG_INTERVAL	14
+#define IPV6CTL_HDRNESTLIMIT	15
+#define IPV6CTL_DAD_COUNT	16
+#define IPV6CTL_AUTO_FLOWLABEL	17
+#define IPV6CTL_DEFMCASTHLIM	18
+#define IPV6CTL_GIF_HLIM	19	/* default HLIM for gif encap packet */
+#define IPV6CTL_KAME_VERSION	20
+#define IPV6CTL_USE_DEPRECATED	21	/* use deprecated addr (RFC2462 5.5.4) */
+#define IPV6CTL_RR_PRUNE	22	/* walk timer for router renumbering */
+#define IPV6CTL_V6ONLY		24
+#define IPV6CTL_RTEXPIRE	25	/* cloned route expiration time */
+#define IPV6CTL_RTMINEXPIRE	26	/* min value for expiration time */
+#define IPV6CTL_RTMAXCACHE	27	/* trigger level for dynamic expire */
+
+#define IPV6CTL_USETEMPADDR	32	/* use temporary addresses (RFC3041) */
+#define IPV6CTL_TEMPPLTIME	33	/* preferred lifetime for tmpaddrs */
+#define IPV6CTL_TEMPVLTIME	34	/* valid lifetime for tmpaddrs */
+#define IPV6CTL_AUTO_LINKLOCAL	35	/* automatic link-local addr assign */
+#define IPV6CTL_RIP6STATS	36	/* raw_ip6 stats */
+#define IPV6CTL_PREFER_TEMPADDR	37	/* prefer temporary addr as src */
+#define IPV6CTL_ADDRCTLPOLICY	38	/* get/set address selection policy */
+#define IPV6CTL_USE_DEFAULTZONE	39	/* use default scope zone */
+
+#define IPV6CTL_MAXFRAGS	41	/* max fragments */
+#define IPV6CTL_MCAST_PMTU	44	/* enable pMTU discovery for multicast? */
+
+/* New entries should be added here from current IPV6CTL_MAXID value. */
+/* to define items, should talk with KAME guys first, for *BSD compatibility */
+/* 42-44 is already used in KAME */
+#define IPV6CTL_STEALTH		45
+#define	ICMPV6CTL_ND6_ONLINKNSRFC4861	47
+#define IPV6CTL_MAXID		48
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/bits/ioctl-types.h
@@ -0,0 +1,37 @@
+/* Structure types for pre-termios terminal ioctls.  FreeBSD version.
+   Copyright (C) 1996, 1997, 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _SYS_IOCTL_H
+# error "Never use <bits/ioctl-types.h> directly; include <sys/ioctl.h> instead."
+#endif
+
+/* Many systems that have TIOCGWINSZ define TIOCGSIZE for source
+   compatibility with Sun; they define `struct ttysize' to have identical
+   layout as `struct winsize' and #define TIOCGSIZE to be TIOCGWINSZ
+   (likewise TIOCSSIZE and TIOCSWINSZ).  */
+/* struct ttysize is in FreeBSD originally defined in <sys/ioctl.h>,
+   which is replaced by GLIBC version -> define here */
+struct ttysize
+{
+  unsigned short int ts_lines;
+  unsigned short int ts_cols;
+  unsigned short int ts_xxx;
+  unsigned short int ts_yyy;
+};
+#define	_IOT_ttysize	_IOT_winsize
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/bits/ioctls.h
@@ -0,0 +1,50 @@
+/*-
+ * Copyright (c) 1982, 1986, 1990 The Regents of the University of California.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 4. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ *	@(#)ioctl.h	8.6 (Berkeley) 3/28/94
+ */
+
+#ifndef	_IOCTLS_H_
+#define	_IOCTLS_H_
+
+#include <sys/ioccom.h>
+
+#include <sys/ttycom.h>
+
+/*
+ *	@(#)ioctl.h	8.6 (Berkeley) 3/28/94
+ */
+
+#define	TIOCGSIZE	TIOCGWINSZ
+#define	TIOCSSIZE	TIOCSWINSZ
+
+#include <sys/filio.h>
+
+#include <sys/sockio.h>
+
+#endif /* !_IOCTLS_H_ */
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/bits/ipc.h
@@ -0,0 +1,56 @@
+/* Copyright (C) 1995-1997, 1999, 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _SYS_IPC_H
+# error "Never use <bits/ipc.h> directly; include <sys/ipc.h> instead."
+#endif
+
+#include <bits/types.h>
+
+/* Mode bits for `msgget', `semget', and `shmget'.  */
+#define IPC_CREAT	01000		/* create key if key does not exist */
+#define IPC_EXCL	02000		/* fail if key exists */
+#define IPC_NOWAIT	04000		/* return error on wait */
+
+/* Control commands for `msgctl', `semctl', and `shmctl'.  */
+#define IPC_RMID	0		/* remove identifier */
+#define IPC_SET		1		/* set `ipc_perm' options */
+#define IPC_STAT	2		/* get `ipc_perm' options */
+
+/* Special key values.  */
+#define IPC_PRIVATE	((key_t) 0)	/* private key */
+
+#ifdef __USE_BSD
+/* Common mode bits.  */
+# define IPC_R		0400		/* read permission, same as S_IRUSR */
+# define IPC_W		0200		/* write permission, same as S_IWUSR */
+# define IPC_M		0x1000		/* control permission */
+#endif
+
+
+/* Data structure used to pass permission information to IPC operations.  */
+struct ipc_perm
+  {
+    __uint16_t /* yuck! */ cuid;	/* creator's user ID */
+    __uint16_t /* yuck! */ cgid;	/* creator's group ID */
+    __uint16_t /* yuck! */ uid;		/* owner's user ID */
+    __uint16_t /* yuck! */ gid;		/* owner's group ID */
+    __mode_t mode;			/* read/write permission */
+    __uint16_t __seq;
+    __key_t __key;
+  };
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/bits/local_lim.h
@@ -0,0 +1 @@
+#include <sys/syslimits.h>
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/bits/mman.h
@@ -0,0 +1,130 @@
+/* Definitions for POSIX memory map interface.  FreeBSD version.
+   Copyright (C) 1994-1998, 2000-2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _SYS_MMAN_H
+# error "Never use <bits/mman.h> directly; include <sys/mman.h> instead."
+#endif
+
+#include <features.h>
+#include <stddef.h>
+
+/* Protections are chosen from these bits, OR'd together.  The
+   implementation does not necessarily support PROT_EXEC or PROT_WRITE
+   without PROT_READ.  The only guarantees are that no writing will be
+   allowed without PROT_WRITE and no access will be allowed for PROT_NONE. */
+
+#define	PROT_NONE	 0x00	/* No access.  */
+#define	PROT_READ	 0x01	/* Pages can be read.  */
+#define	PROT_WRITE	 0x02	/* Pages can be written.  */
+#define	PROT_EXEC	 0x04	/* Pages can be executed.  */
+
+/* Flags contain mapping type, sharing type and options.  */
+
+/* Mapping type (must choose one and only one of these).  */
+#ifdef __USE_BSD
+# define MAP_FILE	 0x0000	/* Mapped from a file or device.  */
+# define MAP_ANON	 0x1000	/* Allocated from anonymous virtual memory.  */
+# define MAP_TYPE	 0x1000	/* Mask for type field.  */
+# ifdef __USE_MISC
+#  define MAP_ANONYMOUS  MAP_ANON /* Linux name. */
+# endif
+#endif
+
+/* Sharing types (must choose one and only one of these).  */
+#define	MAP_SHARED	 0x0001	/* Share changes.  */
+#define	MAP_PRIVATE	 0x0002	/* Changes private; copy pages on write.  */
+#ifdef __USE_BSD
+# define MAP_COPY MAP_PRIVATE	/* Virtual copy of region at mapping time.  */
+#endif
+
+/* Other flags.  */
+#define	MAP_FIXED	 0x0010	/* Map address must be exactly as requested. */
+#ifdef __USE_BSD
+#define MAP_RENAME	 0x0020 /* Sun: rename private pages to file */
+#define MAP_NORESERVE	 0x0040 /* Sun: don't reserve needed swap area */
+#define MAP_RESERVED0080 0x0080	/* previously misimplemented MAP_INHERIT */
+#define MAP_RESERVED0100 0x0100	/* previously unimplemented MAP_NOEXTEND */
+# define MAP_HASSEMPHORE 0x0200	/* Region may contain semaphores.  */
+# define MAP_STACK	 0x0400	/* Region grows down, like a stack.  */
+# define MAP_NOSYNC	 0x0800	/* Try to avoid flushing to the disk.  */
+# define MAP_NOCORE	0x20000	/* Don't include these pages in a core dump.  */
+#endif
+
+/* Advice to `madvise'.  */
+#ifdef __USE_BSD
+# define MADV_NORMAL	 0	/* No further special treatment.  */
+# define MADV_RANDOM	 1	/* Expect random page references.  */
+# define MADV_SEQUENTIAL 2	/* Expect sequential page references.  */
+# define MADV_WILLNEED	 3	/* Will need these pages.  */
+# define MADV_DONTNEED	 4	/* Don't need these pages.  */
+# define MADV_FREE	 5	/* Don't need these pages, they contain junk. */
+# define MADV_NOSYNC	 6	/* Try to avoid flushing to the disk.  */
+# define MADV_AUTOSYNC	 7	/* Use the default flushing strategy.  */
+# define MADV_NOCORE	 8	/* Don't include these pages in a core dump.  */
+# define MADV_CORE	 9	/* Include pages in a core dump (default).  */
+# define MADV_PROTECT	10	/* protect process from pageout kill */
+#endif
+
+/* The POSIX people had to invent similar names for the same things.  */
+#ifdef __USE_XOPEN2K
+# define POSIX_MADV_NORMAL	0 /* No further special treatment.  */
+# define POSIX_MADV_RANDOM	1 /* Expect random page references.  */
+# define POSIX_MADV_SEQUENTIAL	2 /* Expect sequential page references.  */
+# define POSIX_MADV_WILLNEED	3 /* Will need these pages.  */
+# define POSIX_MADV_DONTNEED	4 /* Don't need these pages.  */
+#endif
+
+/* Flags to `msync'.  */
+#define MS_ASYNC	1		/* Sync memory asynchronously.  */
+#define MS_SYNC		0		/* Synchronous memory sync.  */
+#define MS_INVALIDATE	2		/* Invalidate the caches.  */
+
+/* Flags for `mlockall' (can be OR'd together).  */
+#define MCL_CURRENT	1		/* Lock all currently mapped pages.  */
+#define MCL_FUTURE	2		/* Lock all additions to address
+					   space.  */
+
+/* Flags for 'minherit'.  */
+#ifdef __USE_BSD
+# define INHERIT_SHARE	0
+# define INHERIT_COPY	1
+# define INHERIT_NONE	2
+#endif
+
+
+/*
+ * Return bits from mincore
+ */
+#ifdef __USE_MISC
+#define	MINCORE_INCORE	 	 0x1 /* Page is incore */
+#define	MINCORE_REFERENCED	 0x2 /* Page has been referenced by us */
+#define	MINCORE_MODIFIED	 0x4 /* Page has been modified by us */
+#define	MINCORE_REFERENCED_OTHER 0x8 /* Page has been referenced */
+#define	MINCORE_MODIFIED_OTHER	0x10 /* Page has been modified */
+#endif /* Use MISC */
+
+#ifdef __USE_BSD
+
+__BEGIN_DECLS
+
+extern int minherit (void *__addr, size_t __len, int __inherit);
+
+__END_DECLS
+
+#endif /* Use BSD */
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/bits/msq.h
@@ -0,0 +1,73 @@
+/* Copyright (C) 1995, 1997, 2000, 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _SYS_MSG_H
+#error "Never use <bits/msq.h> directly; include <sys/msg.h> instead."
+#endif
+
+#include <bits/types.h>
+
+/* Define options for message queue functions.  */
+#define MSG_NOERROR	010000	/* no error if message is too big */
+
+/* Types used in the structure definition.  */
+typedef unsigned long int msgqnum_t;
+typedef unsigned long int msglen_t;
+
+
+/* Structure of record for one message inside the kernel.
+   The type `struct __msg' is opaque.  */
+struct msqid_ds
+{
+  struct ipc_perm msg_perm;	/* structure describing operation permission */
+  void *__msg_first;
+  void *__msg_last;
+  msglen_t __msg_cbytes;	/* current number of bytes on queue */
+  msgqnum_t msg_qnum;		/* number of messages currently on queue */
+  msglen_t msg_qbytes;		/* max number of bytes allowed on queue */
+  __pid_t msg_lspid;		/* pid of last msgsnd() */
+  __pid_t msg_lrpid;		/* pid of last msgrcv() */
+  __time_t msg_stime;		/* time of last msgsnd command */
+  long __unused1;
+  __time_t msg_rtime;		/* time of last msgrcv command */
+  long __unused2;
+  __time_t msg_ctime;		/* time of last change */
+  long __unused3;
+  long __unused4[4];
+};
+
+#ifdef __USE_MISC
+
+# define msg_cbytes	__msg_cbytes
+
+# ifdef _KERNEL
+
+/* buffer for msgctl calls IPC_INFO, MSG_INFO */
+struct msginfo
+  {
+    int msgmax;
+    int msgmni;
+    int msgmnb;
+    int msgtql;
+    int msgssz;
+    int msgseg;
+  };
+
+# endif
+
+#endif /* __USE_MISC */
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/bits/poll.h
@@ -0,0 +1,51 @@
+/* Copyright (C) 1997, 2001-2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _SYS_POLL_H
+# error "Never use <bits/poll.h> directly; include <sys/poll.h> instead."
+#endif
+
+/* Event types that can be polled for.  These bits may be set in `events'
+   to indicate the interesting event types; they will appear in `revents'
+   to indicate the status of the file descriptor.  */
+#define POLLIN		0x0001		/* There is data to read.  */
+#define POLLPRI		0x0002		/* There is urgent data to read.  */
+#define POLLOUT		0x0004		/* Writing now will not block.  */
+
+#ifdef __USE_XOPEN
+/* These values are defined in XPG4.2.  */
+# define POLLRDNORM	0x0040		/* Normal data may be read.  */
+# define POLLRDBAND	0x0080		/* Priority data may be read.  */
+# define POLLWRNORM	0x0004		/* Writing now will not block.  */
+# define POLLWRBAND	0x0100		/* Priority data may be written.  */
+#endif
+
+#ifdef __USE_BSD
+/* These are extensions for FreeBSD.  */
+# define POLLEXTEND	0x0200		/* File size may have grown.  */
+# define POLLATTRIB	0x0400		/* File attributes may have changed.  */
+# define POLLNLINK	0x0800		/* File may have been moved/removed.  */
+# define POLLWRITE	0x1000		/* File's contents may have changed.  */
+#endif
+
+/* Event types always implicitly polled for.  These bits need not be set in
+   `events', but they will appear in `revents' to indicate the status of
+   the file descriptor.  */
+#define POLLERR		0x0008		/* Error condition.  */
+#define POLLHUP		0x0010		/* Hung up.  */
+#define POLLNVAL	0x0020		/* Invalid polling request.  */
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/bits/posix_opt.h
@@ -0,0 +1,90 @@
+/* Define POSIX options for FreeBSD.
+   Copyright (C) 1996-1997, 1999, 2000, 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+/*
+ * Never include this file directly; use <unistd.h> instead.
+ */
+
+#ifndef	_BITS_POSIX_OPT_H
+#define	_BITS_POSIX_OPT_H	1
+
+/* Job control is supported.  */
+#define	_POSIX_JOB_CONTROL	1
+
+/* Processes have a saved set-user-ID and a saved set-group-ID.  */
+#define	_POSIX_SAVED_IDS	1
+
+/* Priority scheduling is supported.  */
+#define	_POSIX_PRIORITY_SCHEDULING	1
+
+/* Synchronizing file data is supported.  */
+#define	_POSIX_SYNCHRONIZED_IO	1
+
+/* The fsync function is present.  */
+#define	_POSIX_FSYNC	1
+
+/* Mapping of files to memory is supported.  */
+#define	_POSIX_MAPPED_FILES	1
+
+/* Locking of all memory is supported.  */
+#define	_POSIX_MEMLOCK	1
+
+/* Locking of ranges of memory is supported.  */
+#define	_POSIX_MEMLOCK_RANGE	1
+
+/* Setting of memory protections is supported.  */
+#define	_POSIX_MEMORY_PROTECTION	1
+
+/* Implementation supports `poll' function.  */
+#define	_POSIX_POLL	1
+
+/* Implementation supports `select' and `pselect' functions.  */
+#define	_POSIX_SELECT	1
+
+/* XPG4.2 shared memory is supported.  */
+#define	_XOPEN_SHM	1
+
+/* X/Open realtime support is available.  */
+#define _XOPEN_REALTIME	1
+
+/* Only root can change owner of file.  */
+#define	_POSIX_CHOWN_RESTRICTED	1
+
+/* `c_cc' member of 'struct termios' structure can be disabled by
+   using the value _POSIX_VDISABLE.  */
+#define	_POSIX_VDISABLE	((unsigned char)'\377')
+
+/* The LFS interface is available, except for the asynchronous I/O.  */
+#define _LFS_LARGEFILE		1
+#define _LFS64_LARGEFILE	1
+#define _LFS64_STDIO		1
+
+/* POSIX timers are available.  */
+#define _POSIX_TIMERS 1
+
+/* GNU libc provides regular expression handling.  */
+#define _POSIX_REGEXP	1
+
+/* We have a POSIX shell.  */
+#define _POSIX_SHELL	1
+
+/* The `spawn' function family is supported.  */
+#define _POSIX_SPAWN	200912L
+
+#endif /* bits/posix_opt.h */
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/bits/resource.h
@@ -0,0 +1,200 @@
+/* Bit values & structures for resource limits.  FreeBSD version.
+   Copyright (C) 1994, 1996-1998, 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _SYS_RESOURCE_H
+# error "Never use <bits/resource.h> directly; include <sys/resource.h> instead."
+#endif
+
+#include <bits/types.h>
+
+/* Transmute defines to enumerations.  The macro re-definitions are
+   necessary because some programs want to test for operating system
+   features with #ifdef RUSAGE_SELF.  In ISO C the reflexive
+   definition is a no-op.
+
+   These are the values for FreeBSD.  Earlier BSD systems have a subset of
+   these kinds of resource limit.  */
+
+/* Kinds of resource limit.  */
+enum __rlimit_resource
+{
+  /* Per-process CPU limit, in seconds.  */
+  RLIMIT_CPU = 0,
+#define	RLIMIT_CPU RLIMIT_CPU
+
+  /* Largest file that can be created, in bytes.  */
+  RLIMIT_FSIZE = 1,
+#define	RLIMIT_FSIZE RLIMIT_FSIZE
+
+  /* Maximum size of data segment, in bytes.  */
+  RLIMIT_DATA = 2,
+#define	RLIMIT_DATA RLIMIT_DATA
+
+  /* Maximum size of stack segment, in bytes.  */
+  RLIMIT_STACK = 3,
+#define	RLIMIT_STACK RLIMIT_STACK
+
+  /* Largest core file that can be created, in bytes.  */
+  RLIMIT_CORE = 4,
+#define	RLIMIT_CORE RLIMIT_CORE
+
+  /* Largest resident set size, in bytes.
+     This affects swapping; processes that are exceeding their
+     resident set size will be more likely to have physical memory
+     taken from them.  */
+  __RLIMIT_RSS = 5,
+#define	RLIMIT_RSS __RLIMIT_RSS
+
+  /* Locked-in-memory address space.  */
+  __RLIMIT_MEMLOCK = 6,
+#define	RLIMIT_MEMLOCK __RLIMIT_MEMLOCK
+
+  /* Number of processes.  */
+  __RLIMIT_NPROC = 7,
+#define	RLIMIT_NPROC __RLIMIT_NPROC
+
+  /* Number of open files.  */
+  RLIMIT_NOFILE = 8,
+#define	RLIMIT_NOFILE RLIMIT_NOFILE
+
+  /* Maximum size of all socket buffers.  */
+  __RLIMIT_SBSIZE = 9,
+#define RLIMIT_SBSIZE __RLIMIT_SBSIZE
+
+  /* Address space limit.  */
+  RLIMIT_AS = 10,
+#define RLIMIT_AS RLIMIT_AS
+
+  __RLIMIT_NLIMITS = 11,
+  __RLIM_NLIMITS = __RLIMIT_NLIMITS
+#define RLIMIT_NLIMITS __RLIMIT_NLIMITS
+#define RLIM_NLIMITS __RLIM_NLIMITS
+};
+
+/* Value to indicate that there is no limit.  */
+#define RLIM_INFINITY 0x7fffffffffffffffLL
+#ifdef __USE_LARGEFILE64
+# define RLIM64_INFINITY 0x7fffffffffffffffLL
+#endif
+
+
+/* Type for resource quantity measurement.  */
+typedef __rlim_t rlim_t;
+#ifdef __USE_LARGEFILE64
+typedef __rlim64_t rlim64_t;
+#endif
+
+struct rlimit
+  {
+    /* The current (soft) limit.  */
+    rlim_t rlim_cur;
+    /* The hard limit.  */
+    rlim_t rlim_max;
+  };
+
+#ifdef __USE_LARGEFILE64
+struct rlimit64
+  {
+    /* The current (soft) limit.  */
+    rlim64_t rlim_cur;
+    /* The hard limit.  */
+    rlim64_t rlim_max;
+ };
+#endif
+
+#define	CP_USER		0
+#define	CP_NICE		1
+#define	CP_SYS		2
+#define	CP_INTR		3
+#define	CP_IDLE		4
+#define	CPUSTATES	5
+
+/* Whose usage statistics do you want?  */
+enum __rusage_who
+{
+  /* The calling process.  */
+  RUSAGE_SELF = 0,
+#define RUSAGE_SELF RUSAGE_SELF
+
+  /* All of its terminated child processes.  */
+  RUSAGE_CHILDREN = -1
+#define RUSAGE_CHILDREN RUSAGE_CHILDREN
+};
+
+#define __need_timeval
+#include <bits/time.h>		/* For `struct timeval'.  */
+
+/* Structure which says how much of each resource has been used.  */
+struct rusage
+  {
+    /* Total amount of user time used.  */
+    struct timeval ru_utime;
+    /* Total amount of system time used.  */
+    struct timeval ru_stime;
+    /* Maximum resident set size (in kilobytes).  */
+    long int ru_maxrss;
+    /* Amount of sharing of text segment memory
+       with other processes (kilobyte-seconds).  */
+    long int ru_ixrss;
+    /* Amount of data segment memory used (kilobyte-seconds).  */
+    long int ru_idrss;
+    /* Amount of stack memory used (kilobyte-seconds).  */
+    long int ru_isrss;
+    /* Number of soft page faults (i.e. those serviced by reclaiming
+       a page from the list of pages awaiting reallocation.  */
+    long int ru_minflt;
+    /* Number of hard page faults (i.e. those that required I/O).  */
+    long int ru_majflt;
+    /* Number of times a process was swapped out of physical memory.  */
+    long int ru_nswap;
+    /* Number of input operations via the file system.  Note: This
+       and `ru_oublock' do not include operations with the cache.  */
+    long int ru_inblock;
+    /* Number of output operations via the file system.  */
+    long int ru_oublock;
+    /* Number of IPC messages sent.  */
+    long int ru_msgsnd;
+    /* Number of IPC messages received.  */
+    long int ru_msgrcv;
+    /* Number of signals delivered.  */
+    long int ru_nsignals;
+    /* Number of voluntary context switches, i.e. because the process
+       gave up the process before it had to (usually to wait for some
+       resource to be available).  */
+    long int ru_nvcsw;
+    /* Number of involuntary context switches, i.e. a higher priority process
+       became runnable or the current process used up its time slice.  */
+    long int ru_nivcsw;
+  };
+
+/* Priority limits.  */
+#define PRIO_MIN	-20	/* Minimum priority a process can have.  */
+#define PRIO_MAX	20	/* Maximum priority a process can have.  */
+
+/* The type of the WHICH argument to `getpriority' and `setpriority',
+   indicating what flavor of entity the WHO argument specifies.  */
+enum __priority_which
+{
+  PRIO_PROCESS = 0,		/* WHO is a process ID.  */
+#define PRIO_PROCESS PRIO_PROCESS
+  PRIO_PGRP = 1,		/* WHO is a process group ID.  */
+#define PRIO_PGRP PRIO_PGRP
+  PRIO_USER = 2			/* WHO is a user ID.  */
+#define PRIO_USER PRIO_USER
+};
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/bits/sched.h
@@ -0,0 +1,177 @@
+/* Definitions of constants and data structure for POSIX 1003.1b-1993
+   scheduling interface.
+   Copyright (C) 1996, 1997, 2001, 2003 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef __need_schedparam
+
+#ifndef _SCHED_H
+# error "Never include <bits/sched.h> directly; use <sched.h> instead."
+#endif
+
+
+/* Scheduling algorithms.  */
+#define SCHED_OTHER	2
+#define SCHED_FIFO	1
+#define SCHED_RR	3
+
+
+#ifdef __USE_MISC
+/* Cloning flags.  */
+# define CSIGNAL       0x000000ff /* Signal mask to be sent at exit.  */
+# define CLONE_VM      0x00000100 /* Set if VM shared between processes.  */
+# define CLONE_FS      0x00000200 /* Set if fs info shared between processes.  */
+# define CLONE_FILES   0x00000400 /* Set if open files shared between processes.  */
+# define CLONE_SIGHAND 0x00000800 /* Set if signal handlers shared.  */
+# define CLONE_PTRACE  0x00002000 /* Set if tracing continues on the child.  */
+# define CLONE_VFORK   0x00004000 /* Set if the parent wants the child to
+				     wake it up on mm_release.  */
+# define CLONE_SYSVSEM 0x00040000 /* share system V SEM_UNDO semantics */
+#endif
+
+/* The official definition.  */
+struct sched_param
+  {
+    int __sched_priority;
+  };
+
+__BEGIN_DECLS
+
+#ifdef __USE_MISC
+/* Clone current process.  */
+extern int clone (int (*__fn) (void *__arg), void *__child_stack,
+		  int __flags, void *__arg) __THROW;
+
+/* Unshare the specified resources.  */
+extern int unshare (int __flags) __THROW;
+
+/* Get index of currently used CPU.  */
+extern int sched_getcpu (void) __THROW;
+#endif
+
+__END_DECLS
+
+#endif	/* need schedparam */
+
+#if !defined __defined_schedparam \
+    && (defined __need_schedparam || defined _SCHED_H)
+# define __defined_schedparam	1
+/* Data structure to describe a process' schedulability.  */
+struct __sched_param
+  {
+    int __sched_priority;
+  };
+# undef __need_schedparam
+#endif
+
+
+#if defined _SCHED_H && !defined __cpu_set_t_defined
+# define __cpu_set_t_defined
+/* Size definition for CPU sets.  */
+# define __CPU_SETSIZE	1024
+# define __NCPUBITS	(8 * sizeof (__cpu_mask))
+
+/* Type for array elements in 'cpu_set_t'.  */
+typedef unsigned long int __cpu_mask;
+
+/* Basic access functions.  */
+# define __CPUELT(cpu)	((cpu) / __NCPUBITS)
+# define __CPUMASK(cpu)	((__cpu_mask) 1 << ((cpu) % __NCPUBITS))
+
+/* Data structure to describe CPU mask.  */
+typedef struct
+{
+  __cpu_mask __bits[__CPU_SETSIZE / __NCPUBITS];
+} cpu_set_t;
+
+/* Access functions for CPU masks.  */
+# if __GNUC_PREREQ (2, 91)
+#  define __CPU_ZERO_S(setsize, cpusetp) \
+  do __builtin_memset (cpusetp, '\0', setsize); while (0)
+# else
+#  define __CPU_ZERO_S(setsize, cpusetp) \
+  do {									      \
+    size_t __i;								      \
+    size_t __imax = (setsize) / sizeof (__cpu_mask);			      \
+    cpu_set_t *__arr = (cpusetp);					      \
+    for (__i = 0; __i < __imax; ++__i)					      \
+      __arr->__bits[__i] = 0;						      \
+  } while (0)
+# endif
+# define __CPU_SET_S(cpu, setsize, cpusetp) \
+  (__extension__							      \
+   ({ size_t __cpu = (cpu);						      \
+      __cpu < 8 * (setsize)						      \
+      ? ((cpusetp)->__bits[__CPUELT (__cpu)] |= __CPUMASK (__cpu)) : 0; }))
+# define __CPU_CLR_S(cpu, setsize, cpusetp) \
+  (__extension__							      \
+   ({ size_t __cpu = (cpu);						      \
+      __cpu < 8 * (setsize)						      \
+      ? ((cpusetp)->__bits[__CPUELT (__cpu)] &= ~__CPUMASK (__cpu)) : 0; }))
+# define __CPU_ISSET_S(cpu, setsize, cpusetp) \
+  (__extension__							      \
+   ({ size_t __cpu = (cpu);						      \
+      __cpu < 8 * (setsize)						      \
+      ? (((cpusetp)->__bits[__CPUELT (__cpu)] & __CPUMASK (__cpu))) != 0      \
+      : 0; }))
+
+# define __CPU_COUNT_S(setsize, cpusetp) \
+  __sched_cpucount (setsize, cpusetp)
+
+# if __GNUC_PREREQ (2, 91)
+#  define __CPU_EQUAL_S(setsize, cpusetp1, cpusetp2) \
+  (__builtin_memcmp (cpusetp1, cpusetp2, setsize) == 0)
+# else
+#  define __CPU_EQUAL_S(setsize, cpusetp1, cpusetp2) \
+  (__extension__							      \
+   ({ cpu_set_t *__arr1 = (cpusetp1);					      \
+      cpu_set_t *__arr2 = (cpusetp2);					      \
+      size_t __imax = (setsize) / sizeof (__cpu_mask);			      \
+      size_t __i;							      \
+      for (__i = 0; __i < __imax; ++__i)				      \
+	if (__arr1->__bits[__i] != __arr2->__bits[__i])			      \
+	  break;							      \
+      __i == __imax; }))
+# endif
+
+# define __CPU_OP_S(setsize, destset, srcset1, srcset2, op) \
+  (__extension__							      \
+   ({ cpu_set_t *__dest = (destset);					      \
+      cpu_set_t *__arr1 = (srcset1);					      \
+      cpu_set_t *__arr2 = (srcset2);					      \
+      size_t __imax = (setsize) / sizeof (__cpu_mask);			      \
+      size_t __i;							      \
+      for (__i = 0; __i < __imax; ++__i)				      \
+	__dest->__bits[__i] = __arr1->__bits[__i] op __arr2->__bits[__i];     \
+      __dest; }))
+
+# define __CPU_ALLOC_SIZE(count) \
+  ((((count) + __NCPUBITS - 1) / __NCPUBITS) * 8)
+# define __CPU_ALLOC(count) __sched_cpualloc (count)
+# define __CPU_FREE(cpuset) __sched_cpufree (cpuset)
+
+__BEGIN_DECLS
+
+extern int __sched_cpucount (size_t __setsize, const cpu_set_t *__setp)
+  __THROW;
+extern cpu_set_t *__sched_cpualloc (size_t __count) __THROW __wur;
+extern void __sched_cpufree (cpu_set_t *__set) __THROW;
+
+__END_DECLS
+
+#endif
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/bits/sem.h
@@ -0,0 +1,95 @@
+/* Copyright (C) 1995-1998, 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _SYS_SEM_H
+# error "Never include <bits/sem.h> directly; use <sys/sem.h> instead."
+#endif
+
+#include <sys/types.h>
+
+/* Flags for `semop'.  */
+#define SEM_UNDO	0x1000		/* undo the operation on exit */
+
+/* Commands for `semctl'.  */
+#define GETPID		4		/* get sempid */
+#define GETVAL		5		/* get semval */
+#define GETALL		6		/* get all semval's */
+#define GETNCNT		3		/* get semncnt */
+#define GETZCNT		7		/* get semzcnt */
+#define SETVAL		8		/* set semval */
+#define SETALL		9		/* set all semval's */
+
+#ifdef __USE_BSD
+# define SEM_R		IPC_R		/* read permission for user */
+# define SEM_A		IPC_W		/* alter permission for user */
+#endif
+
+
+/* Data structure describing a set of semaphores.  */
+struct semid_ds
+{
+  struct ipc_perm sem_perm;		/* operation permission struct */
+  void *__sem_base;
+  unsigned short int sem_nsems;		/* number of semaphores in set */
+  __time_t sem_otime;			/* last semop() time */
+  long __unused1;
+  __time_t sem_ctime;			/* last time changed by semctl() */
+  long __unused2;
+  long __unused3[4];
+};
+
+/* The user should define a union like the following to use it for arguments
+   for `semctl'.
+
+   union semun
+   {
+     int val;				<= value for SETVAL
+     struct semid_ds *buf;		<= buffer for IPC_STAT & IPC_SET
+     unsigned short int *array;		<= array for GETALL & SETALL
+     struct seminfo *__buf;		<= buffer for IPC_INFO
+   };
+
+   Previous versions of this file used to define this union but this is
+   incorrect.  One can test the macro _SEM_SEMUN_UNDEFINED to see whether
+   one must define the union or not.  */
+#define _SEM_SEMUN_UNDEFINED	1
+
+#ifdef __USE_MISC
+
+/* ipcs ctl cmds */
+# define SEM_STAT 10
+# define SEM_INFO 11
+
+/*
+ * semaphore info struct
+ */
+struct seminfo {
+        int     semmap,         /* # of entries in semaphore map */
+                semmni,         /* # of semaphore identifiers */
+                semmns,         /* # of semaphores in system */
+                semmnu,         /* # of undo structures in system */
+                semmsl,         /* max # of semaphores per id */
+                semopm,         /* max # of operations per semop call */
+                semume,         /* max # of undo entries per process */
+                semusz,         /* size in bytes of undo structure */
+                semvmx,         /* semaphore maximum value */
+                semaem;         /* adjust on exit max value */
+};
+
+#endif
+
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/bits/shm.h
@@ -0,0 +1,74 @@
+/* Copyright (C) 1995-1997, 2000, 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _SYS_SHM_H
+# error "Never include <bits/shm.h> directly; use <sys/shm.h> instead."
+#endif
+
+#include <bits/types.h>
+
+/* Permission flag for shmget.  */
+#ifdef __USE_BSD
+# define SHM_R		IPC_R		/* read permission for user */
+# define SHM_W		IPC_W		/* write permission for user */
+#endif
+
+/* Flags for `shmat'.  */
+#define SHM_RDONLY	010000		/* attach read-only else read-write */
+#define SHM_RND		020000		/* round attach address to SHMLBA */
+
+/* Commands for `shmctl'.  */
+#if 0 /* FreeBSD does not have these yet.  */
+#define SHM_LOCK	11		/* lock segment (root only) */
+#define SHM_UNLOCK	12		/* unlock segment (root only) */
+#endif
+
+/* Segment low boundary address multiple.  */
+#define SHMLBA		(__getpagesize ())
+extern int __getpagesize (void) __THROW __attribute__ ((__const__));
+
+
+/* Type to count number of attaches.  */
+typedef unsigned short int shmatt_t;
+
+/* Data structure describing a set of semaphores.  */
+struct shmid_ds
+  {
+    struct ipc_perm shm_perm;		/* operation permission struct */
+    int shm_segsz;			/* size of segment in bytes */
+    __pid_t shm_lpid;			/* pid of last shmop */
+    __pid_t shm_cpid;			/* pid of creator */
+    shmatt_t shm_nattch;		/* number of current attaches */
+    __time_t shm_atime;			/* time of last shmat() */
+    __time_t shm_dtime;			/* time of last shmdt() */
+    __time_t shm_ctime;			/* time of last change by shmctl() */
+    void *__shm_internal;
+  };
+
+#ifdef _KERNEL
+
+struct shminfo {
+        int     shmmax,         /* max shared memory segment size (bytes) */
+                shmmin,         /* min shared memory segment size (bytes) */
+                shmmni,         /* max number of shared memory identifiers */
+                shmseg,         /* max shared memory segments per process */
+                shmall;         /* max amount of shared memory (pages) */
+};
+
+#endif
+
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/bits/sigaction.h
@@ -0,0 +1,76 @@
+/* Copyright (C) 1991-1992,1996-1998,2001-2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _SIGNAL_H
+# error "Never include <bits/sigaction.h> directly; use <signal.h> instead."
+#endif
+
+/* These definitions match those used by the FreeBSD kernel.  */
+
+/* Structure describing the action to be taken when a signal arrives.  */
+struct sigaction
+  {
+    /* Signal handler.  */
+#ifdef __USE_POSIX199309
+    union
+      {
+	/* Used if SA_SIGINFO is not set.  */
+	__sighandler_t sa_handler;
+	/* Used if SA_SIGINFO is set.  */
+	void (*sa_sigaction) (int, siginfo_t *, void *);
+      }
+    __sigaction_handler;
+# define sa_handler	__sigaction_handler.sa_handler
+# define sa_sigaction	__sigaction_handler.sa_sigaction
+#else
+    __sighandler_t sa_handler;
+#endif
+
+    /* Special flags.  */
+    int sa_flags;
+
+    /* Additional set of signals to be blocked.  */
+    __sigset_t sa_mask;
+  };
+
+/* Bits in `sa_flags'.  */
+#if defined __USE_UNIX98 || defined __USE_MISC
+# define SA_ONSTACK	0x0001	/* Take signal on signal stack.  */
+# define SA_RESTART	0x0002	/* Restart syscall on signal return.  */
+# define SA_RESETHAND	0x0004	/* Reset to SIG_DFL on entry to handler.  */
+# define SA_NODEFER	0x0010	/* Don't automatically block the signal when
+				    its handler is being executed.  */
+# define SA_NOCLDWAIT	0x0020	/* Don't save zombie processes.  */
+# define SA_SIGINFO	0x0040	/* Provide additional info to the handler.  */
+#endif
+#define	SA_NOCLDSTOP	0x0008	/* Don't send SIGCHLD when children stop.  */
+
+#ifdef __USE_MISC
+# define SA_INTERRUPT	0	/* Historical no-op ("not SA_RESTART").  */
+
+/* Some aliases for the SA_ constants.  */
+# define SA_NOMASK    SA_NODEFER
+# define SA_ONESHOT   SA_RESETHAND
+# define SA_STACK     SA_ONSTACK
+#endif
+
+
+/* Values for the HOW argument to `sigprocmask'.  */
+#define	SIG_BLOCK	1	/* Block signals.  */
+#define	SIG_UNBLOCK	2	/* Unblock signals.  */
+#define	SIG_SETMASK	3	/* Set the set of blocked signals.  */
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/bits/siginfo.h
@@ -0,0 +1,214 @@
+/* siginfo_t, sigevent and constants.  FreeBSD version.
+   Copyright (C) 1997-1998, 2000-2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#if !defined _SIGNAL_H && !defined __need_siginfo_t \
+    && !defined __need_sigevent_t
+# error "Never include this file directly.  Use <signal.h> instead"
+#endif
+
+#if (!defined __have_sigval_t \
+     && (defined _SIGNAL_H || defined __need_siginfo_t \
+	 || defined __need_sigevent_t))
+# define __have_sigval_t 1
+
+/* Type for data associated with a signal.  */
+typedef union sigval
+  {
+    int sival_int;
+    void *sival_ptr;
+  } sigval_t;
+#endif
+
+#if (!defined __have_siginfo_t \
+     && (defined _SIGNAL_H || defined __need_siginfo_t))
+# define __have_siginfo_t	1
+
+typedef struct siginfo
+  {
+    int si_signo;		/* Signal number.  */
+    int si_errno;		/* If non-zero, an errno value associated with
+				   this signal, as defined in <errno.h>.  */
+    int si_code;		/* Signal code.  */
+    int si_pid;			/* Sending process ID.  */
+    unsigned int si_uid;	/* Real user ID of sending process.  */
+    int si_status;		/* Exit value or signal.  */
+    void *si_addr;		/* Address of faulting instruction.  */
+    union sigval si_value;	/* Signal value.  */
+    long int si_band;		/* Band event for SIGPOLL.  */
+    int __si_spare[7];
+  } siginfo_t;
+
+
+/* Values for `si_code'.  Positive values are reserved for kernel-generated
+   signals.  */
+enum
+{
+  SI_ASYNCIO = 0x10004,		/* Sent by AIO completion.  */
+# define SI_ASYNCIO	SI_ASYNCIO
+  SI_MESGQ = 0x10005,		/* Sent by real time mesq state change.  */
+# define SI_MESGQ	SI_MESGQ
+  SI_TIMER = 0x10003,		/* Sent by timer expiration.  */
+# define SI_TIMER	SI_TIMER
+  SI_QUEUE = 0x10002,		/* Sent by sigqueue.  */
+# define SI_QUEUE	SI_QUEUE
+  SI_USER = 0x10001,		/* Sent by kill, sigsend, raise.  */
+# define SI_USER	SI_USER
+  SI_UNDEFINED = 0
+# define SI_UNDEFINED	SI_UNDEFINED
+};
+
+/* `si_code' values for SIGILL signal.  */
+enum
+{
+  ILL_ILLOPC = 1,		/* Illegal opcode.  */
+# define ILL_ILLOPC	ILL_ILLOPC
+  ILL_ILLOPN,			/* Illegal operand.  */
+# define ILL_ILLOPN	ILL_ILLOPN
+  ILL_ILLADR,			/* Illegal addressing mode.  */
+# define ILL_ILLADR	ILL_ILLADR
+  ILL_ILLTRP,			/* Illegal trap. */
+# define ILL_ILLTRP	ILL_ILLTRP
+  ILL_PRVOPC,			/* Privileged opcode.  */
+# define ILL_PRVOPC	ILL_PRVOPC
+  ILL_PRVREG,			/* Privileged register.  */
+# define ILL_PRVREG	ILL_PRVREG
+  ILL_COPROC,			/* Coprocessor error.  */
+# define ILL_COPROC	ILL_COPROC
+  ILL_BADSTK			/* Internal stack error.  */
+# define ILL_BADSTK	ILL_BADSTK
+};
+
+/* `si_code' values for SIGFPE signal.  */
+enum
+{
+  FPE_INTOVF = 1,		/* Integer overflow.  */
+# define FPE_INTOVF	FPE_INTOVF
+  FPE_INTDIV,			/* Integer divide by zero.  */
+# define FPE_INTDIV	FPE_INTDIV
+  FPE_FLTDIV,			/* Floating point divide by zero.  */
+# define FPE_FLTDIV	FPE_FLTDIV
+  FPE_FLTOVF,			/* Floating point overflow.  */
+# define FPE_FLTOVF	FPE_FLTOVF
+  FPE_FLTUND,			/* Floating point underflow.  */
+# define FPE_FLTUND	FPE_FLTUND
+  FPE_FLTRES,			/* Floating point inexact result.  */
+# define FPE_FLTRES	FPE_FLTRES
+  FPE_FLTINV,			/* Floating point invalid operation.  */
+# define FPE_FLTINV	FPE_FLTINV
+  FPE_FLTSUB			/* Subscript out of range.  */
+# define FPE_FLTSUB	FPE_FLTSUB
+};
+
+/* `si_code' values for SIGSEGV signal.  */
+enum
+{
+  SEGV_MAPERR = 1,		/* Address not mapped to object.  */
+# define SEGV_MAPERR	SEGV_MAPERR
+  SEGV_ACCERR			/* Invalid permissions for mapped object.  */
+# define SEGV_ACCERR	SEGV_ACCERR
+};
+
+/* `si_code' values for SIGBUS signal.  */
+enum
+{
+  BUS_ADRALN = 1,		/* Invalid address alignment.  */
+# define BUS_ADRALN	BUS_ADRALN
+  BUS_ADRERR,			/* Non-existant physical address.  */
+# define BUS_ADRERR	BUS_ADRERR
+  BUS_OBJERR			/* Object specific hardware error.  */
+# define BUS_OBJERR	BUS_OBJERR
+};
+
+/* `si_code' values for SIGTRAP signal.  */
+enum
+{
+  TRAP_BRKPT = 1,		/* Process breakpoint.  */
+# define TRAP_BRKPT	TRAP_BRKPT
+  TRAP_TRACE			/* Process trace trap.  */
+# define TRAP_TRACE	TRAP_TRACE
+};
+
+/* `si_code' values for SIGCHLD signal.  */
+/* XXX These are only used by the waitid() function, not by the kernel.  */
+enum
+{
+  CLD_EXITED = 1,		/* Child has exited.  */
+# define CLD_EXITED	CLD_EXITED
+  CLD_KILLED,			/* Child was killed.  */
+# define CLD_KILLED	CLD_KILLED
+  CLD_DUMPED,			/* Child terminated abnormally.  */
+# define CLD_DUMPED	CLD_DUMPED
+  CLD_TRAPPED,			/* Traced child has trapped.  */
+# define CLD_TRAPPED	CLD_TRAPPED
+  CLD_STOPPED,			/* Child has stopped.  */
+# define CLD_STOPPED	CLD_STOPPED
+  CLD_CONTINUED			/* Stopped child has continued.  */
+# define CLD_CONTINUED	CLD_CONTINUED
+};
+
+/* `si_code' values for SIGPOLL signal.  */
+enum
+{
+  POLL_IN = 1,			/* Data input available.  */
+# define POLL_IN	POLL_IN
+  POLL_OUT,			/* Output buffers available.  */
+# define POLL_OUT	POLL_OUT
+  POLL_MSG,			/* Input message available.   */
+# define POLL_MSG	POLL_MSG
+  POLL_ERR,			/* I/O error.  */
+# define POLL_ERR	POLL_ERR
+  POLL_PRI,			/* High priority input available.  */
+# define POLL_PRI	POLL_PRI
+  POLL_HUP			/* Device disconnected.  */
+# define POLL_HUP	POLL_HUP
+};
+
+# undef __need_siginfo_t
+#endif	/* !have siginfo_t && (have _SIGNAL_H || need siginfo_t).  */
+
+
+#if (defined _SIGNAL_H || defined __need_sigevent_t) \
+    && !defined __have_sigevent_t
+# define __have_sigevent_t	1
+
+/* Structure to transport application-defined values with signals.  */
+
+typedef struct sigevent
+  {
+    int sigev_notify;
+    int sigev_signo;
+    sigval_t sigev_value;
+    /* Not yet supported by the kernel.  */
+    void (*sigev_notify_function) (sigval_t);	/* Function to start.  */
+    void *sigev_notify_attributes;		/* Really pthread_attr_t.  */
+  } sigevent_t;
+
+/* `sigev_notify' values.  */
+enum
+{
+  SIGEV_SIGNAL = 1,		/* Notify via signal.  */
+# define SIGEV_SIGNAL	SIGEV_SIGNAL
+  SIGEV_NONE = 0,		/* Other notification: meaningless.  */
+# define SIGEV_NONE	SIGEV_NONE
+  /* Not yet supported by the kernel.  */
+  SIGEV_THREAD = 2		/* Deliver via thread creation.  */
+# define SIGEV_THREAD	SIGEV_THREAD
+};
+
+#endif	/* have _SIGNAL_H.  */
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/bits/signum.h
@@ -0,0 +1,71 @@
+/* Signal number definitions.  FreeBSD version.
+   Copyright (C) 1991-1993, 1996, 1998, 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifdef	_SIGNAL_H
+
+/* This file defines the fake signal functions and signal
+   number constants for 4.2 or 4.3 BSD-derived Unix system.  */
+
+/* Fake signal functions.  */
+#define	SIG_ERR	((__sighandler_t) -1) /* Error return.  */
+#define	SIG_DFL	((__sighandler_t) 0) /* Default action.  */
+#define	SIG_IGN	((__sighandler_t) 1) /* Ignore signal.  */
+
+#define	SIG_CATCH ((__sighandler_t) 2) /* FreeBSD specific ? */
+#define	SIG_HOLD  ((__sighandler_t) 3) /* Add signal to hold mask.  */
+
+/* Signals.  */
+#define	SIGHUP		1	/* Hangup (POSIX).  */
+#define	SIGINT		2	/* Interrupt (ANSI).  */
+#define	SIGQUIT		3	/* Quit (POSIX).  */
+#define	SIGILL		4	/* Illegal instruction (ANSI).  */
+#define	SIGABRT		SIGIOT	/* Abort (ANSI).  */
+#define	SIGTRAP		5	/* Trace trap (POSIX).  */
+#define	SIGIOT		6	/* IOT trap (4.2 BSD).  */
+#define	SIGEMT		7	/* EMT trap (4.2 BSD).  */
+#define	SIGFPE		8	/* Floating-point exception (ANSI).  */
+#define	SIGKILL		9	/* Kill, unblockable (POSIX).  */
+#define	SIGBUS		10	/* Bus error (4.2 BSD).  */
+#define	SIGSEGV		11	/* Segmentation violation (ANSI).  */
+#define	SIGSYS		12	/* Bad argument to system call (4.2 BSD).  */
+#define	SIGPIPE		13	/* Broken pipe (POSIX).  */
+#define	SIGALRM		14	/* Alarm clock (POSIX).  */
+#define	SIGTERM		15	/* Termination (ANSI).  */
+#define	SIGURG		16	/* Urgent condition on socket (4.2 BSD).  */
+#define	SIGSTOP		17	/* Stop, unblockable (POSIX).  */
+#define	SIGTSTP		18	/* Keyboard stop (POSIX).  */
+#define	SIGCONT		19	/* Continue (POSIX).  */
+#define	SIGCHLD		20	/* Child status has changed (POSIX).  */
+#define	SIGCLD		SIGCHLD	/* Same as SIGCHLD (System V).  */
+#define	SIGTTIN		21	/* Background read from tty (POSIX).  */
+#define	SIGTTOU		22	/* Background write to tty (POSIX).  */
+#define	SIGIO		23	/* I/O now possible (4.2 BSD).  */
+#define	SIGPOLL		SIGIO	/* Pollable event occurred (System V).  */
+#define	SIGXCPU		24	/* CPU limit exceeded (4.2 BSD).  */
+#define	SIGXFSZ		25	/* File size limit exceeded (4.2 BSD).  */
+#define	SIGVTALRM	26	/* Virtual alarm clock (4.2 BSD).  */
+#define	SIGPROF		27	/* Profiling alarm clock (4.2 BSD).  */
+#define	SIGWINCH	28	/* Window size change (4.3 BSD, Sun).  */
+#define SIGINFO		29	/* Information request (4.4 BSD).  */
+#define	SIGUSR1		30	/* User-defined signal 1 (POSIX).  */
+#define	SIGUSR2		31	/* User-defined signal 2 (POSIX).  */
+
+#endif	/* <signal.h> included.  */
+
+#define	_NSIG		129	/* Biggest signal number + 1.  */
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/bits/sigset.h
@@ -0,0 +1,140 @@
+/* __sig_atomic_t, __sigset_t, and related definitions.  FreeBSD version.
+   Copyright (C) 1994-1996, 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef	_SIGSET_H_types
+# define _SIGSET_H_types	1
+
+typedef int __sig_atomic_t;
+
+/* A `sigset_t' has a bit for each signal.  */
+__extension__ typedef struct
+  {
+    __extension__ union
+      {
+        unsigned int __sigbits[4];
+        unsigned int __bits[4];
+      };
+  } __sigset_t;
+
+#endif
+
+
+/* We only want to define these functions if <signal.h> was actually
+   included; otherwise we were included just to define the types.  Since we
+   are namespace-clean, it wouldn't hurt to define extra macros.  But
+   trouble can be caused by functions being defined (e.g., any global
+   register vars declared later will cause compilation errors).  */
+
+#if !defined _SIGSET_H_fns && defined _SIGNAL_H
+# define _SIGSET_H_fns 1
+
+# ifndef _EXTERN_INLINE
+#  define _EXTERN_INLINE __extern_inline
+# endif
+
+/* Return a mask that includes the bit for SIG only.  */
+# define __sigmask(sig)	((unsigned int) 1 << ((sig) - 1) % 32)
+
+/* Return the word index for SIG.  */
+# define __sigword(sig)	(((sig) - 1) >> 5)
+
+# if defined __GNUC__ && __GNUC__ >= 2
+#  define __sigemptyset(set) \
+  (__extension__ ({ sigset_t *__set = (set);				      \
+		    __set->__sigbits[0] = 0; __set->__sigbits[1] = 0;	      \
+		    __set->__sigbits[2] = 0; __set->__sigbits[3] = 0;	      \
+		    0; }))
+#  define __sigfillset(set) \
+  (__extension__ ({ sigset_t *__set = (set);				      \
+		    __set->__sigbits[0] = ~0; __set->__sigbits[1] = ~0;	      \
+		    __set->__sigbits[2] = ~0; __set->__sigbits[3] = ~0;	      \
+		    0; }))
+
+#  ifdef __USE_GNU
+/* The POSIX does not specify for handling the whole signal set in one
+   command.  This is often wanted and so we define three more functions
+   here.  */
+#   define __sigisemptyset(set) \
+  (__extension__ ({ const sigset_t *__set = (set);			      \
+		    __set->__sigbits[0] == 0				      \
+		    && __set->__sigbits[1] == 0				      \
+		    && __set->__sigbits[2] == 0				      \
+		    && __set->__sigbits[3] == 0; }))
+#   define __sigandset(dest, left, right) \
+  (__extension__ ({ sigset_t *__dest = (dest);				      \
+		    const sigset_t *__left = (left);			      \
+		    const sigset_t *__right = (right);			      \
+		    __dest->__sigbits[0] =				      \
+		      __left->__sigbits[0] & __right->__sigbits[0];	      \
+		    __dest->__sigbits[1] =				      \
+		      __left->__sigbits[1] & __right->__sigbits[1];	      \
+		    __dest->__sigbits[2] =				      \
+		      __left->__sigbits[2] & __right->__sigbits[2];	      \
+		    __dest->__sigbits[3] =				      \
+		      __left->__sigbits[3] & __right->__sigbits[3];	      \
+		    0; }))
+#   define __sigorset(dest, left, right) \
+  (__extension__ ({ sigset_t *__dest = (dest);				      \
+		    const sigset_t *__left = (left);			      \
+		    const sigset_t *__right = (right);			      \
+		    __dest->__sigbits[0] =				      \
+		      __left->__sigbits[0] | __right->__sigbits[0];	      \
+		    __dest->__sigbits[1] =				      \
+		      __left->__sigbits[1] | __right->__sigbits[1];	      \
+		    __dest->__sigbits[2] =				      \
+		      __left->__sigbits[2] | __right->__sigbits[2];	      \
+		    __dest->__sigbits[3] =				      \
+		      __left->__sigbits[3] | __right->__sigbits[3];	      \
+		    0; }))
+#  endif
+# endif
+
+/* These functions needn't check for a bogus signal number -- error
+   checking is done in the non __ versions.  */
+
+extern int __sigismember (__const __sigset_t *, int);
+extern int __sigaddset (__sigset_t *, int);
+extern int __sigdelset (__sigset_t *, int);
+
+# ifdef __USE_EXTERN_INLINES
+
+_EXTERN_INLINE int
+__sigismember (__const __sigset_t *__set, int __sig)
+{
+  return (__set->__sigbits[__sigword (__sig)] & __sigmask (__sig) ? 1 : 0);
+}
+
+_EXTERN_INLINE int
+__sigaddset (__sigset_t *__set, int __sig)
+{
+  __set->__sigbits[__sigword (__sig)] |= __sigmask (__sig);
+  return 0;
+}
+
+_EXTERN_INLINE int
+__sigdelset (__sigset_t *__set, int __sig)
+{
+  __set->__sigbits[__sigword (__sig)] &= ~__sigmask (__sig);
+  return 0;
+}
+
+# endif
+
+
+#endif /* ! _SIGSET_H_fns.  */
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/bits/socket.h
@@ -0,0 +1,386 @@
+/* System-specific socket constants and types.  FreeBSD version.
+   Copyright (C) 1991-1992,1994-1999,2000-2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+#ifndef __BITS_SOCKET_H
+#define __BITS_SOCKET_H	1
+
+#if !defined _SYS_SOCKET_H && !defined _NETINET_IN_H
+# error "Never include <bits/socket.h> directly; use <sys/socket.h> instead."
+#endif
+
+#define	__need_size_t
+#define __need_NULL
+#include <stddef.h>
+
+#include <limits.h>		/* XXX Is this allowed?  */
+#include <bits/types.h>
+
+/* Type for length arguments in socket calls.  */
+#ifndef __socklen_t_defined
+typedef __socklen_t socklen_t;
+# define __socklen_t_defined
+#endif
+
+
+/* Types of sockets.  */
+enum __socket_type
+{
+  SOCK_STREAM = 1,		/* Sequenced, reliable, connection-based
+				   byte streams.  */
+#define SOCK_STREAM SOCK_STREAM
+  SOCK_DGRAM = 2,		/* Connectionless, unreliable datagrams
+				   of fixed maximum length.  */
+#define SOCK_DGRAM SOCK_DGRAM
+  SOCK_RAW = 3,			/* Raw protocol interface.  */
+#define SOCK_RAW SOCK_RAW
+  SOCK_RDM = 4,			/* Reliably-delivered messages.  */
+#define SOCK_RDM SOCK_RDM
+  SOCK_SEQPACKET = 5		/* Sequenced, reliable, connection-based,
+				   datagrams of fixed maximum length.  */
+#define SOCK_SEQPACKET SOCK_SEQPACKET
+};
+
+/* Protocol families.  */
+#define	PF_UNSPEC	0	/* Unspecified.  */
+#define	PF_LOCAL	1	/* Local to host (pipes and file-domain).  */
+#define	PF_UNIX		PF_LOCAL /* Old BSD name for PF_LOCAL.  */
+#define	PF_FILE		PF_LOCAL /* POSIX name for PF_LOCAL.  */
+#define	PF_INET		2	/* IP protocol family.  */
+#define	PF_IMPLINK	3	/* ARPAnet IMP protocol.  */
+#define	PF_PUP		4	/* PUP protocols.  */
+#define	PF_CHAOS	5	/* MIT Chaos protocols.  */
+#define	PF_NS		6	/* Xerox NS protocols.  */
+#define	PF_ISO		7	/* ISO protocols.  */
+#define	PF_OSI		PF_ISO
+#define	PF_ECMA		8	/* ECMA protocols.  */
+#define	PF_DATAKIT	9	/* AT&T Datakit protocols.  */
+#define	PF_CCITT	10	/* CCITT protocols (X.25 et al).  */
+#define	PF_SNA		11	/* IBM SNA protocol.  */
+#define	PF_DECnet	12	/* DECnet protocols.  */
+#define	PF_DLI		13	/* Direct data link interface.  */
+#define	PF_LAT		14	/* DEC Local Area Transport protocol.  */
+#define	PF_HYLINK	15	/* NSC Hyperchannel protocol.  */
+#define	PF_APPLETALK	16	/* Don't use this.  */
+#define	PF_ROUTE	17	/* Internal Routing Protocol.  */
+#define	PF_LINK		18	/* Link layer interface.  */
+#define	PF_XTP		19	/* eXpress Transfer Protocol (no AF).  */
+#define	PF_COIP		20	/* Connection-oriented IP, aka ST II.  */
+#define	PF_CNT		21	/* Computer Network Technology.  */
+#define PF_RTIP		22	/* Help Identify RTIP packets.  **/
+#define	PF_IPX		23	/* Novell Internet Protocol.  */
+#define	PF_SIP		24	/* Simple Internet Protocol.  */
+#define PF_PIP		25	/* Help Identify PIP packets.  */
+#define PF_ISDN		26	/* Integrated Services Digital Network.  */
+#define PF_KEY		27	/* Internal key-management function.  */
+#define PF_INET6	28	/* IP version 6.  */
+#define PF_NATM		29	/* Native ATM access.  */
+#define PF_ATM		30	/* ATM.  */
+#define PF_HDRCMPLT	31	/* Used by BPF to not rewrite headers in
+				   interface output routine.  */
+#define PF_NETGRAPH	32	/* Netgraph sockets.  */
+#define	PF_MAX		33
+
+/* Address families.  */
+#define	AF_UNSPEC	PF_UNSPEC
+#define	AF_LOCAL	PF_LOCAL
+#define	AF_UNIX		PF_UNIX
+#define	AF_FILE		PF_FILE
+#define	AF_INET		PF_INET
+#define	AF_IMPLINK	PF_IMPLINK
+#define	AF_PUP		PF_PUP
+#define	AF_CHAOS	PF_CHAOS
+#define	AF_NS		PF_NS
+#define	AF_ISO		PF_ISO
+#define	AF_OSI		PF_OSI
+#define	AF_ECMA		PF_ECMA
+#define	AF_DATAKIT	PF_DATAKIT
+#define	AF_CCITT	PF_CCITT
+#define	AF_SNA		PF_SNA
+#define	AF_DECnet	PF_DECnet
+#define	AF_DLI		PF_DLI
+#define	AF_LAT		PF_LAT
+#define	AF_HYLINK	PF_HYLINK
+#define	AF_APPLETALK	PF_APPLETALK
+#define	AF_ROUTE	PF_ROUTE
+#define	AF_LINK		PF_LINK
+#define	pseudo_AF_XTP	PF_XTP
+#define	AF_COIP		PF_COIP
+#define	AF_CNT		PF_CNT
+#define pseudo_AF_RTIP	PF_RTIP
+#define	AF_IPX		PF_IPX
+#define	AF_SIP		PF_SIP
+#define pseudo_AF_PIP	PF_PIP
+#define AF_ISDN		PF_ISDN
+#define AF_E164		AF_ISDN		/* CCITT E.164 recommendation.  */
+#define pseudo_AF_KEY	PF_KEY
+#define AF_INET6	PF_INET6
+#define AF_NATM		PF_NATM
+#define AF_ATM		PF_ATM
+#define pseudo_AF_HDRCMPLT PF_HDRCMPLT
+#define AF_NETGRAPH	PF_NETGRAPH
+#define	AF_MAX		PF_MAX
+
+/* Maximum queue length specifiable by listen.  */
+#define SOMAXCONN	128	/* 5 on the original 4.4 BSD.  */
+
+/* Get the definition of the macro to define the common sockaddr members.  */
+#include <bits/sockaddr.h>
+
+/* Structure describing a generic socket address.  */
+struct sockaddr
+  {
+    __SOCKADDR_COMMON (sa_);	/* Common data: address family and length.  */
+    char sa_data[14];		/* Address data.  */
+  };
+
+
+/* Structure large enough to hold any socket address (with the historical
+   exception of AF_UNIX).  We reserve 128 bytes.  */
+#if ULONG_MAX > 0xffffffff
+# define __ss_aligntype	__uint64_t
+#else
+# define __ss_aligntype	__uint32_t
+#endif
+#define _SS_SIZE	128
+#define _SS_PADSIZE	(_SS_SIZE - (2 * sizeof (__ss_aligntype)))
+
+struct sockaddr_storage
+  {
+    __SOCKADDR_COMMON (ss_);	/* Address family, etc.  */
+    __ss_aligntype __ss_align;	/* Force desired alignment.  */
+    char __ss_padding[_SS_PADSIZE];
+  };
+
+
+/* Bits in the FLAGS argument to `send', `recv', et al.  */
+enum
+  {
+    MSG_OOB		= 0x01,	/* Process out-of-band data.  */
+#define MSG_OOB MSG_OOB
+    MSG_PEEK		= 0x02,	/* Peek at incoming messages.  */
+#define MSG_PEEK MSG_PEEK
+    MSG_DONTROUTE	= 0x04,	/* Don't use local routing.  */
+#define MSG_DONTROUTE MSG_DONTROUTE
+    MSG_EOR		= 0x08,	/* Data completes record.  */
+#define MSG_EOR MSG_EOR
+    MSG_TRUNC		= 0x10,	/* Data discarded before delivery.  */
+#define MSG_TRUNC MSG_TRUNC
+    MSG_CTRUNC		= 0x20,	/* Control data lost before delivery.  */
+#define MSG_CTRUNC MSG_CTRUNC
+    MSG_WAITALL		= 0x40,	/* Wait for full request or error.  */
+#define MSG_WAITALL MSG_WAITALL
+    MSG_DONTWAIT	= 0x80,	/* This message should be nonblocking.  */
+#define MSG_DONTWAIT MSG_DONTWAIT
+    MSG_EOF		= 0x100, /* Data completes connection.  */
+#define MSG_EOF MSG_EOF
+    MSG_COMPAT		= 0x8000,/* Used in sendit().  */
+#define MSG_COMPAT MSG_COMPAT
+    MSG_NOSIGNAL	= 0x20000 /* do not generate SIGPIPE on EOF */
+#if 0 /* available since FreeBSD 6.0 */
+#define MSG_NOSIGNAL MSG_NOSIGNAL
+#endif
+  };
+
+
+/* Structure describing messages sent by
+   `sendmsg' and received by `recvmsg'.  */
+struct msghdr
+  {
+    void *msg_name;		/* Address to send to/receive from.  */
+    socklen_t msg_namelen;	/* Length of address data.  */
+
+    struct iovec *msg_iov;	/* Vector of data to send/receive into.  */
+    int msg_iovlen;		/* Number of elements in the vector.  */
+
+    void *msg_control;		/* Ancillary data (eg BSD filedesc passing). */
+    socklen_t msg_controllen;	/* Ancillary data buffer length.  */
+
+    int msg_flags;		/* Flags in received message.  */
+  };
+
+/* Structure used for storage of ancillary data object information.  */
+struct cmsghdr
+  {
+    socklen_t cmsg_len;		/* Length of data in cmsg_data plus length
+				   of cmsghdr structure.  */
+    int cmsg_level;		/* Originating protocol.  */
+    int cmsg_type;		/* Protocol specific type.  */
+#if (!defined __STRICT_ANSI__ && __GNUC__ >= 2) || __STDC_VERSION__ >= 199901L
+    __extension__ unsigned char __cmsg_data  __flexarr __attribute__ ((aligned (__alignof__(size_t)))); /* Ancillary data.  */
+#endif
+  };
+
+#define CMSG_NXTHDR(mhdr, cmsg) __cmsg_nxthdr (mhdr, cmsg)
+
+#define CMSG_FIRSTHDR(mhdr) \
+  ((size_t) (mhdr)->msg_controllen >= sizeof (struct cmsghdr)		      \
+   ? (struct cmsghdr *) (mhdr)->msg_control : (struct cmsghdr *) NULL)
+
+#define CMSG_ALIGN(len) (((len) + sizeof (size_t) - 1) \
+			   & (size_t) ~(sizeof (size_t) - 1))
+#define CMSG_SPACE(len) (CMSG_ALIGN (len) \
+			 + CMSG_ALIGN (sizeof (struct cmsghdr)))
+#define CMSG_LEN(len)   (CMSG_ALIGN (sizeof (struct cmsghdr)) + (len))
+
+/* Ancillary data object manipulation macros.  */
+#if (!defined __STRICT_ANSI__ && __GNUC__ >= 2) || __STDC_VERSION__ >= 199901L
+# define CMSG_DATA(cmsg) ((cmsg)->__cmsg_data)
+#else
+# define CMSG_DATA(cmsg) ((unsigned char *) (cmsg) + CMSG_ALIGN(sizeof (struct cmsghdr)))
+#endif
+
+extern struct cmsghdr *__cmsg_nxthdr (struct msghdr *__mhdr,
+				      struct cmsghdr *__cmsg) __THROW;
+#ifdef __USE_EXTERN_INLINES
+# ifndef _EXTERN_INLINE
+#  define _EXTERN_INLINE __extern_inline
+# endif
+_EXTERN_INLINE struct cmsghdr *
+__NTH (__cmsg_nxthdr (struct msghdr *__mhdr, struct cmsghdr *__cmsg))
+{
+  if ((size_t) __cmsg->cmsg_len < sizeof (struct cmsghdr))
+    /* The kernel header does this so there may be a reason.  */
+    return 0;
+
+  __cmsg = (struct cmsghdr *) ((unsigned char *) __cmsg
+			       + CMSG_ALIGN (__cmsg->cmsg_len));
+  if ((unsigned char *) (__cmsg + 1) > ((unsigned char *) __mhdr->msg_control
+					+ __mhdr->msg_controllen)
+      || ((unsigned char *) __cmsg + CMSG_ALIGN (__cmsg->cmsg_len)
+	  > ((unsigned char *) __mhdr->msg_control + __mhdr->msg_controllen)))
+    /* No more entries.  */
+    return 0;
+  return __cmsg;
+}
+#endif	/* Use `extern inline'.  */
+
+/* Socket level message types.  */
+enum
+  {
+    SCM_RIGHTS = 0x01,		/* Access rights (array of int).  */
+#define SCM_RIGHTS SCM_RIGHTS
+    SCM_TIMESTAMP = 0x02,	/* Timestamp (struct timeval).  */
+#define SCM_TIMESTAMP SCM_TIMESTAMP
+    SCM_CREDS = 0x03		/* Process creds (struct cmsgcred).  */
+#define SCM_CREDS SCM_CREDS
+  };
+
+/* Unfortunately, BSD practice dictates this structure be of fixed size.
+   If there are more than CMGROUP_MAX groups, the list is truncated.
+   (On GNU systems, the `cmcred_euid' field is just the first in the
+   list of effective UIDs.)  */
+#define CMGROUP_MAX	16
+
+/* Structure delivered by SCM_CREDS.  This describes the identity of the
+   sender of the data simultaneously received on the socket.  By BSD
+   convention, this is included only when a sender on a AF_LOCAL socket
+   sends cmsg data of this type and size; the sender's structure is
+   ignored, and the system fills in the various IDs of the sender process.  */
+struct cmsgcred
+  {
+    __pid_t cmcred_pid;
+    __uid_t cmcred_uid;
+    __uid_t cmcred_euid;
+    __gid_t cmcred_gid;
+    short cmcred_ngroups;
+    __gid_t cmcred_groups[CMGROUP_MAX];
+  };
+
+/* Protocol number used to manipulate socket-level options
+   with `getsockopt' and `setsockopt'.  */
+#define	SOL_SOCKET	0xffff
+
+/* Socket-level options for `getsockopt' and `setsockopt'.  */
+enum
+  {
+    SO_DEBUG = 0x0001,		/* Record debugging information.  */
+#define SO_DEBUG SO_DEBUG
+    SO_ACCEPTCONN = 0x0002,	/* Accept connections on socket.  */
+#define SO_ACCEPTCONN SO_ACCEPTCONN
+    SO_REUSEADDR = 0x0004,	/* Allow reuse of local addresses.  */
+#define SO_REUSEADDR SO_REUSEADDR
+    SO_KEEPALIVE = 0x0008,	/* Keep connections alive and send
+				   SIGPIPE when they die.  */
+#define SO_KEEPALIVE SO_KEEPALIVE
+    SO_DONTROUTE = 0x0010,	/* Don't do local routing.  */
+#define SO_DONTROUTE SO_DONTROUTE
+    SO_BROADCAST = 0x0020,	/* Allow transmission of
+				   broadcast messages.  */
+#define SO_BROADCAST SO_BROADCAST
+    SO_USELOOPBACK = 0x0040,	/* Use the software loopback to avoid
+				   hardware use when possible.  */
+#define SO_USELOOPBACK SO_USELOOPBACK
+    SO_LINGER = 0x0080,		/* Block on close of a reliable
+				   socket to transmit pending data.  */
+#define SO_LINGER SO_LINGER
+    SO_OOBINLINE = 0x0100,	/* Receive out-of-band data in-band.  */
+#define SO_OOBINLINE SO_OOBINLINE
+    SO_REUSEPORT = 0x0200,	/* Allow local address and port reuse.  */
+#define SO_REUSEPORT SO_REUSEPORT
+    SO_TIMESTAMP = 0x0400,	/* Timestamp received dgram traffic.  */
+#define SO_TIMESTAMP SO_TIMESTAMP
+    SO_SNDBUF = 0x1001,		/* Send buffer size.  */
+#define SO_SNDBUF SO_SNDBUF
+    SO_RCVBUF = 0x1002,		/* Receive buffer.  */
+#define SO_RCVBUF SO_RCVBUF
+    SO_SNDLOWAT = 0x1003,	/* Send low-water mark.  */
+#define SO_SNDLOWAT SO_SNDLOWAT
+    SO_RCVLOWAT = 0x1004,	/* Receive low-water mark.  */
+#define SO_RCVLOWAT SO_RCVLOWAT
+    SO_SNDTIMEO = 0x1005,	/* Send timeout.  */
+#define SO_SNDTIMEO SO_SNDTIMEO
+    SO_RCVTIMEO = 0x1006,	/* Receive timeout.  */
+#define SO_RCVTIMEO SO_RCVTIMEO
+    SO_ERROR = 0x1007,		/* Get and clear error status.  */
+#define SO_ERROR SO_ERROR
+    SO_STYLE = 0x1008,		/* Get socket connection style.  */
+#define SO_STYLE SO_STYLE
+    SO_TYPE = SO_STYLE		/* Compatible name for SO_STYLE.  */
+#define SO_TYPE SO_TYPE
+  };
+
+/* Socket options. */
+#define LOCAL_PEERCRED          0x001   /* retrieve peer credentials */
+#define LOCAL_CREDS             0x002   /* pass credentials to receiver */
+#define LOCAL_CONNWAIT          0x004   /* connects block until accepted */
+
+/* Structure used to manipulate the SO_LINGER option.  */
+struct linger
+  {
+    int l_onoff;		/* Nonzero to linger on close.  */
+    int l_linger;		/* Time to linger.  */
+  };
+
+
+#ifdef __USE_BSD
+
+struct sf_hdtr;
+
+__BEGIN_DECLS
+
+extern int bsd_sendfile (int __in_fd, int __out_sock,
+			 __off_t __in_offset, size_t __nbytes,
+			 struct sf_hdtr *__hdtr, __off_t *__sockbytes,
+			 int __flags) __THROW;
+
+__END_DECLS
+
+#endif /* Use BSD */
+
+#endif	/* bits/socket.h */
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/bits/stat.h
@@ -0,0 +1,199 @@
+/* Copyright (C) 1992, 1996-1997, 2000, 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _SYS_STAT_H
+# error "Never include <bits/stat.h> directly; use <sys/stat.h> instead."
+#endif
+
+/* This structure needs to be defined in accordance with the
+   implementation of __stat, __fstat, and __lstat.  */
+
+#include <bits/types.h>
+
+/* Versions of the 'struct stat' data structure.  */
+#define _STAT_VER_ostat	0	/* 'struct ostat' in /usr/src/sys/sys/stat.h */
+#define _STAT_VER_stat	1	/* 'struct stat' in /usr/src/sys/sys/stat.h */
+#define _STAT_VER_nstat	2	/* 'struct nstat' in /usr/src/sys/sys/stat.h */
+#define _STAT_VER_gstat 3	/* glibc's 'struct stat' without LFS */
+/* By default we use _STAT_VER_gstat, but we support also _STAT_VER_stat */
+#define _STAT_VER	_STAT_VER_gstat
+
+/* Structure describing file characteristics.  */
+struct stat
+  {
+    __dev_t st_dev;		/* Device containing the file.  */
+#ifndef __USE_FILE_OFFSET64
+    __ino_t st_ino;		/* File serial number.  */
+#else
+    __ino64_t st_ino;		/* File serial number.	*/
+#endif
+
+    __uint32_t st_mode;		/* File mode.  */
+    __uint32_t st_nlink;	/* Link count.  */
+
+    __uid_t st_uid;		/* User ID of the file's owner.  */
+    __gid_t st_gid;		/* Group ID of the file's group.  */
+
+    __dev_t st_rdev;		/* Device number, if device.  */
+
+#ifdef __USE_MISC
+    /* Nanosecond resolution timestamps are stored in a format
+       equivalent to 'struct timespec'.  This is the type used
+       whenever possible but the Unix namespace rules do not allow the
+       identifier 'timespec' to appear in the <sys/stat.h> header.
+       Therefore we have to handle the use of this header in strictly
+       standard-compliant sources special.  */
+    struct timespec st_atim;		/* Time of last access.  */
+    struct timespec st_mtim;		/* Time of last modification.  */
+    struct timespec st_ctim;		/* Time of last status change.  */
+# define st_atime st_atim.tv_sec	/* Backward compatibility.  */
+# define st_mtime st_mtim.tv_sec
+# define st_ctime st_ctim.tv_sec
+#else
+    __time_t st_atime;		/* Time of last access.  */
+    long int st_atimensec;	/* Nanoseconds of last access.  */
+    __time_t st_mtime;		/* Time of last modification.  */
+    long int st_mtimensec;	/* Nanoseconds of last modification.  */
+    __time_t st_ctime;		/* Time of last status change.  */
+    long int st_ctimensec;	/* Nanoseconds of last status change.  */
+#endif
+
+    __off_t st_size;		/* Size of file, in bytes.  */
+
+    __blkcnt_t st_blocks;	/* Number of 512-byte blocks allocated.  */
+
+    __blksize_t st_blksize;	/* Optimal block size for I/O.  */
+#define _STATBUF_ST_BLKSIZE	/* Tell code we have this member.  */
+
+    __uint32_t st_flags;	/* User defined flags.  */
+
+    __uint32_t st_gen;		/* Generation number.  */
+
+    __quad_t __unused1[2];
+  };
+
+#ifdef __USE_LARGEFILE64
+struct stat64
+  {
+    __dev_t st_dev;		/* Device containing the file.  */
+    __ino64_t st_ino;		/* File serial number.	*/
+
+    __uint32_t st_mode;		/* File mode.  */
+    __uint32_t st_nlink;	/* Link count.  */
+
+    __uid_t st_uid;		/* User ID of the file's owner.  */
+    __gid_t st_gid;		/* Group ID of the file's group.  */
+
+    __dev_t st_rdev;		/* Device number, if device.  */
+
+#ifdef __USE_MISC
+    /* Nanosecond resolution timestamps are stored in a format
+       equivalent to 'struct timespec'.  This is the type used
+       whenever possible but the Unix namespace rules do not allow the
+       identifier 'timespec' to appear in the <sys/stat.h> header.
+       Therefore we have to handle the use of this header in strictly
+       standard-compliant sources special.  */
+    struct timespec st_atim;		/* Time of last access.  */
+    struct timespec st_mtim;		/* Time of last modification.  */
+    struct timespec st_ctim;		/* Time of last status change.  */
+# define st_atime st_atim.tv_sec	/* Backward compatibility.  */
+# define st_mtime st_mtim.tv_sec
+# define st_ctime st_ctim.tv_sec
+#else
+    __time_t st_atime;		/* Time of last access.  */
+    long int st_atimensec;	/* Nanoseconds of last access.  */
+    __time_t st_mtime;		/* Time of last modification.  */
+    long int st_mtimensec;	/* Nanoseconds of last modification.  */
+    __time_t st_ctime;		/* Time of last status change.  */
+    long int st_ctimensec;	/* Nanoseconds of last status change.  */
+#endif
+
+    __off_t st_size;		/* Size of file, in bytes.  */
+
+    __blkcnt_t st_blocks;	/* Number of 512-byte blocks allocated.  */
+
+    __blksize_t st_blksize;	/* Optimal block size for I/O.  */
+
+    __uint32_t st_flags;	/* User defined flags.  */
+
+    __uint32_t st_gen;		/* Generation number.  */
+
+    __quad_t __unused1[2];
+  };
+#endif
+
+/* Encoding of the file mode.  These are the standard Unix values,
+   but POSIX.1 does not specify what values should be used.  */
+
+#define __S_IFMT	0170000	/* These bits determine file type.  */
+
+/* File types.  */
+#define __S_IFDIR	0040000	/* Directory.  */
+#define __S_IFCHR	0020000	/* Character device.  */
+#define __S_IFBLK	0060000	/* Block device.  */
+#define __S_IFREG	0100000	/* Regular file.  */
+#define __S_IFLNK	0120000	/* Symbolic link.  */
+#define __S_IFSOCK	0140000	/* Socket.  */
+#define __S_IFWHT	0160000	/* Whiteout.  */
+#define __S_IFIFO	0010000	/* FIFO.  */
+
+/* POSIX.1b objects.  */
+#define __S_TYPEISMQ(buf) 0
+#define __S_TYPEISSEM(buf) 0
+#define __S_TYPEISSHM(buf) 0
+
+/* Protection bits.  */
+
+#define __S_ISUID	04000	/* Set user ID on execution.  */
+#define __S_ISGID	02000	/* Set group ID on execution.  */
+#define __S_ISVTX	01000	/* Save swapped text after use (sticky).  */
+#define __S_IREAD	0400	/* Read by owner.  */
+#define __S_IWRITE	0200	/* Write by owner.  */
+#define __S_IEXEC	0100	/* Execute by owner.  */
+
+#ifdef __USE_BSD
+
+/* Definitions of flags stored in file flags word.  */
+
+/* Super-user and owner changeable flags.  */
+# define UF_SETTABLE	0x0000ffff	/* mask of owner changeable flags */
+# define UF_NODUMP	0x00000001	/* do not dump file */
+# define UF_IMMUTABLE	0x00000002	/* file may not be changed */
+# define UF_APPEND	0x00000004	/* writes to file may only append */
+# define UF_OPAQUE	0x00000008	/* directory is opaque wrt. union */
+# define UF_NOUNLINK	0x00000010	/* file may not be removed or renamed */
+
+/* Super-user changeable flags.  */
+# define SF_SETTABLE	0xffff0000	/* mask of superuser changeable flags */
+# define SF_ARCHIVED	0x00010000	/* file is archived */
+# define SF_IMMUTABLE	0x00020000	/* file may not be changed */
+# define SF_APPEND	0x00040000	/* writes to file may only append */
+# define SF_NOUNLINK	0x00100000	/* file may not be removed or renamed */
+# define SF_SNAPSHOT	0x00200000	/* snapshot inode */
+
+__BEGIN_DECLS
+
+/* Set file flags for FILE to FLAGS.  */
+extern int chflags (__const char *__file, unsigned long int __flags) __THROW;
+
+/* Set file flags of the file referred to by FD to FLAGS.  */
+extern int fchflags (int __fd, unsigned long int __flags) __THROW;
+
+__END_DECLS
+
+#endif /* __USE_BSD */
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/bits/stat16.h
@@ -0,0 +1,56 @@
+/* Copyright (C) 2002, 2006 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+/* This structure corresponds to the standard FreeBSD 'struct stat'
+   (i.e. _STAT_VER_stat), and is used by the stat() system call family. */
+
+struct stat16
+  {
+    __dev_t st_dev;		/* Device containing the file.  */
+    __ino_t st_ino;		/* File serial number.  */
+
+    __uint16_t st_mode;		/* File mode.  */
+    __uint16_t st_nlink;	/* Link count.  */
+
+    __uid_t st_uid;		/* User ID of the file's owner.  */
+    __gid_t st_gid;		/* Group ID of the file's group.  */
+
+    __dev_t st_rdev;		/* Device number, if device.  */
+
+    struct  timespec st_atimespec;  /* time of last access */
+    struct  timespec st_mtimespec;  /* time of last data modification */
+    struct  timespec st_ctimespec;  /* time of last file status change */
+
+    __off_t st_size;		/* Size of file, in bytes.  */
+
+    __blkcnt_t st_blocks;	/* Number of 512-byte blocks allocated.  */
+
+    __blksize_t st_blksize;	/* Optimal block size for I/O.  */
+
+    __uint32_t st_flags;	/* User defined flags.  */
+
+    __uint32_t st_gen;		/* Generation number.  */
+
+    __uint32_t __unused1;
+
+    long int st_birthtime;	/* Time of file creation.  */
+    long int st_birthtimensec;	/* Nanoseconds of file creation.  */
+
+#define _BIRTH_PADSIZE     (2*(8 - sizeof (long)))
+    char __birth_padding[_BIRTH_PADSIZE];
+  };
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/bits/statfs.h
@@ -0,0 +1,91 @@
+/* Definition of `struct statfs', information about a filesystem.
+   Copyright (C) 1996-1997, 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _BITS_STATFS_H
+#define _BITS_STATFS_H	1
+
+#if !defined _SYS_STATFS_H && !defined _SYS_MOUNT_H
+# error "Never include <bits/statfs.h> directly; use <sys/statfs.h> instead."
+#endif
+
+#include <bits/types.h>
+
+struct statfs
+  {
+    unsigned long f_version;
+    unsigned long f_bsize;
+    unsigned long f_iosize;
+#ifndef __USE_FILE_OFFSET64
+    __fsblkcnt_t f_blocks;
+    __fsblkcnt_t f_bfree;
+    __fsblkcnt_t f_bavail;
+    __fsfilcnt_t f_files;
+    __fsfilcnt_t f_ffree;
+#else
+    __fsblkcnt64_t f_blocks;
+    __fsblkcnt64_t f_bfree;
+    __fsblkcnt64_t f_bavail;
+    __fsfilcnt64_t f_files;
+    __fsfilcnt64_t f_ffree;
+#endif
+    __fsid_t f_fsid;
+    __uid_t f_owner;
+    int f_type;
+    int f_flags;
+    unsigned long int f_syncwrites;
+    unsigned long int f_asyncwrites;
+    char f_fstypename[16];
+    char f_mntonname[80];
+    unsigned long int f_syncreads;
+    unsigned long int f_asyncreads;
+    unsigned short f_namemax;
+    char f_mntfromname[80];
+    short __unused3;
+    long __unused4[2];
+  };
+
+#ifdef __USE_LARGEFILE64
+struct statfs64
+  {
+    unsigned long f_version;
+    unsigned long f_bsize;
+    unsigned long f_iosize;
+    __fsblkcnt64_t f_blocks;
+    __fsblkcnt64_t f_bfree;
+    __fsblkcnt64_t f_bavail;
+    __fsfilcnt64_t f_files;
+    __fsfilcnt64_t f_ffree;
+    __fsid_t f_fsid;
+    __uid_t f_owner;
+    int f_type;
+    int f_flags;
+    unsigned long int f_syncwrites;
+    unsigned long int f_asyncwrites;
+    char f_fstypename[16];
+    char f_mntonname[80];
+    unsigned long int f_syncreads;
+    unsigned long int f_asyncreads;
+    unsigned short f_namemax;
+    char f_mntfromname[80];
+    short __unused3;
+    long __unused4[2];
+  };
+#endif
+
+#endif /* _BITS_STATFS_H */
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/bits/statvfs.h
@@ -0,0 +1,95 @@
+/* Definition of `struct statvfs', information about a filesystem.
+   Copyright (C) 1998, 2000-2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _SYS_STATVFS_H
+# error "Never include <bits/statvfs.h> directly; use <sys/statvfs.h> instead."
+#endif
+
+#include <bits/types.h>
+
+#if __WORDSIZE == 32
+#define _STATVFSBUF_F_UNUSED
+#endif
+
+struct statvfs
+  {
+    unsigned long int f_bsize;
+    unsigned long int f_frsize;
+#ifndef __USE_FILE_OFFSET64
+    __fsblkcnt_t f_blocks;
+    __fsblkcnt_t f_bfree;
+    __fsblkcnt_t f_bavail;
+    __fsfilcnt_t f_files;
+    __fsfilcnt_t f_ffree;
+    __fsfilcnt_t f_favail;
+#else
+    __fsblkcnt64_t f_blocks;
+    __fsblkcnt64_t f_bfree;
+    __fsblkcnt64_t f_bavail;
+    __fsfilcnt64_t f_files;
+    __fsfilcnt64_t f_ffree;
+    __fsfilcnt64_t f_favail;
+#endif
+    unsigned long int f_fsid;
+#ifdef _STATVFSBUF_F_UNUSED
+    int __f_unused;
+#endif
+    unsigned long int f_flag;
+    unsigned long int f_namemax;
+    unsigned int f_spare[6];
+  };
+
+#ifdef __USE_LARGEFILE64
+struct statvfs64
+  {
+    unsigned long int f_bsize;
+    unsigned long int f_frsize;
+    __fsblkcnt64_t f_blocks;
+    __fsblkcnt64_t f_bfree;
+    __fsblkcnt64_t f_bavail;
+    __fsfilcnt64_t f_files;
+    __fsfilcnt64_t f_ffree;
+    __fsfilcnt64_t f_favail;
+    unsigned long int f_fsid;
+#ifdef _STATVFSBUF_F_UNUSED
+    int __f_unused;
+#endif
+    unsigned long int f_flag;
+    unsigned long int f_namemax;
+    unsigned int f_spare[6];
+  };
+#endif
+
+/* Definitions for the flag in `f_flag'.  */
+enum
+{
+  ST_RDONLY = 1,		/* Mount read-only.  */
+#define ST_RDONLY	ST_RDONLY
+  ST_NOSUID = 2			/* Ignore suid and sgid bits.  */
+#define ST_NOSUID	ST_NOSUID
+#ifdef __USE_GNU
+  ,
+  ST_NODEV = 4,			/* Disallow access to device special files.  */
+# define ST_NODEV	ST_NODEV
+  ST_NOEXEC = 8,		/* Disallow program execution.  */
+# define ST_NOEXEC	ST_NOEXEC
+  ST_SYNCHRONOUS = 16		/* Writes are synced at once.  */
+# define ST_SYNCHRONOUS	ST_SYNCHRONOUS
+#endif	/* Use GNU.  */
+};
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/bits/sys_errlist.h
@@ -0,0 +1,33 @@
+/* Declare sys_errlist and sys_nerr, or don't.  Compatibility (do) version.
+   Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _STDIO_H
+# error "Never include <bits/sys_errlist.h> directly; use <stdio.h> instead."
+#endif
+
+/* sys_errlist and sys_nerr are deprecated.  Use strerror instead.  */
+
+#ifdef  __USE_BSD
+extern int sys_nerr;
+extern __const char *__const sys_errlist[];
+#endif
+#ifdef  __USE_GNU
+extern int _sys_nerr;
+extern __const char *__const _sys_errlist[];
+#endif
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/bits/syslog-path.h
@@ -0,0 +1,31 @@
+/* <bits/syslog-path.h> -- _PATH_LOG definition
+   Copyright (C) 2006 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _SYS_SYSLOG_H
+# error "Never include this file directly.  Use <sys/syslog.h> instead"
+#endif
+
+#ifndef _BITS_SYSLOG_PATH_H
+#define _BITS_SYSLOG_PATH_H 1
+
+/* On kFreeBSD, named pipes are not allowed in /dev (devfs), so we pick this
+   alternate path. */
+#define _PATH_LOG	"/var/run/log"
+
+#endif /* bits/syslog-path.h */
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/bits/termios.h
@@ -0,0 +1,253 @@
+/* termios type and macro definitions.  FreeBSD version.
+   Copyright (C) 1993-1994,1996-1997,1999,2001-2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _TERMIOS_H
+# error "Never include <bits/termios.h> directly; use <termios.h> instead."
+#endif
+
+/* These macros are also defined in some <bits/ioctls.h> files (with
+   numerically identical values), but this serves to shut up cpp's
+   complaining. */
+#ifdef __USE_BSD
+
+# ifdef MDMBUF
+#  undef MDMBUF
+# endif
+# ifdef FLUSHO
+#  undef FLUSHO
+# endif
+# ifdef PENDIN
+#  undef PENDIN
+# endif
+
+#endif /* __USE_BSD */
+
+#ifdef ECHO
+# undef ECHO
+#endif
+#ifdef TOSTOP
+# undef TOSTOP
+#endif
+#ifdef NOFLSH
+# undef NOFLSH
+#endif
+
+
+typedef unsigned char	cc_t;
+typedef unsigned int	speed_t;
+typedef unsigned int	tcflag_t;
+
+#define NCCS 20
+struct termios
+  {
+    tcflag_t c_iflag;		/* input mode flags */
+    tcflag_t c_oflag;		/* output mode flags */
+    tcflag_t c_cflag;		/* control mode flags */
+    tcflag_t c_lflag;		/* local mode flags */
+    cc_t c_cc[NCCS];		/* control characters */
+    speed_t c_ispeed;		/* input speed */
+    speed_t c_ospeed;		/* output speed */
+#define __ispeed c_ispeed
+#define __ospeed c_ospeed
+#define _HAVE_STRUCT_TERMIOS_C_ISPEED 1
+#define _HAVE_STRUCT_TERMIOS_C_OSPEED 1
+  };
+
+/* c_cc characters */
+#define VEOF 0
+#define VEOL 1
+#define VEOL2 2
+#define VERASE 3
+#define VWERASE 4
+#define VKILL 5
+#define VREPRINT 6
+#ifdef __USE_BSD
+# define VERASE2 7
+#endif
+#define VINTR 8
+#define VQUIT 9
+#define VSUSP 10
+#ifdef __USE_BSD
+# define VDSUSP 11
+#endif
+#define VSTART 12
+#define VSTOP 13
+#define VLNEXT 14
+#define VDISCARD 15
+#define VMIN 16
+#define VTIME 17
+#ifdef __USE_BSD
+# define VSTATUS 18
+#endif
+
+/* c_iflag bits */
+#define IGNBRK	0000001
+#define BRKINT	0000002
+#define IGNPAR	0000004
+#define PARMRK	0000010
+#define INPCK	0000020
+#define ISTRIP	0000040
+#define INLCR	0000100
+#define IGNCR	0000200
+#define ICRNL	0000400
+#define IXON	0001000
+#define IXOFF	0002000
+#define IXANY	0004000
+#define IMAXBEL	0020000
+
+/* c_oflag bits */
+#define	OPOST	(1 << 0)	/* Perform output processing.  */
+#define	ONLCR	(1 << 1)	/* Map NL to CR-NL on output.  */
+#if defined __USE_MISC || defined __USE_XOPEN
+# define TAB0   (0 << 2)	/* no tab delay and expansion */
+# define TAB3   (1 << 2)	/* expand tabs to spaces */
+# define TABDLY	TAB3		/* tab delay mask */
+# define OXTABS	TAB3
+# define XTABS	TAB3
+#endif
+#ifdef	__USE_BSD
+# define ONOEOT	(1 << 3)	/* Discard EOT (^D) on output.  */
+#endif
+#define	OCRNL	(1 << 4)	/* map CR to NL on output */
+#define	ONOCR	(1 << 5)	/* no CR output at column 0 */
+#define	ONLRET	(1 << 6)	/* NL performs CR function */
+
+/* c_cflag bit meaning */
+#ifdef	__USE_BSD
+# define CIGNORE	(1 << 0)	/* Ignore these control flags.  */
+#endif
+#define	CSIZE	(CS5|CS6|CS7|CS8)	/* Number of bits per byte (mask).  */
+#define	CS5	(0 << 8)	/* 5 bits per byte.  */
+#define	CS6	(1 << 8)	/* 6 bits per byte.  */
+#define	CS7	(2 << 8)	/* 7 bits per byte.  */
+#define	CS8	(3 << 8)	/* 8 bits per byte.  */
+#define	CSTOPB	(1 << 10)	/* Two stop bits instead of one.  */
+#define	CREAD	(1 << 11)	/* Enable receiver.  */
+#define	PARENB	(1 << 12)	/* Parity enable.  */
+#define	PARODD	(1 << 13)	/* Odd parity instead of even.  */
+#define	HUPCL	(1 << 14)	/* Hang up on last close.  */
+#define	CLOCAL	(1 << 15)	/* Ignore modem status lines.  */
+#ifdef	__USE_BSD
+# define CCTS_OFLOW	(1 << 16)	/* CTS flow control of output.  */
+# define CRTS_IFLOW	(1 << 17)	/* RTS flow control of input.  */
+# define CRTSCTS	(CCTS_OFLOW|CRTS_IFLOW)	/* CTS/RTS flow control.  */
+# define CDTR_IFLOW	(1 << 18)	/* DTR flow control of input.  */
+# define CDSR_OFLOW	(1 << 19)	/* DSR flow control of output.  */
+# define CCAR_OFLOW	(1 << 20)	/* DCD flow control of output.  */
+# define MDMBUF		(1 << 20)	/* Carrier flow control of output.  */
+#endif
+
+/* c_lflag bits */
+#ifdef	__USE_BSD
+# define ECHOKE	(1 << 0)	/* Visual erase for KILL.  */
+#endif
+#define	_ECHOE	(1 << 1)	/* Visual erase for ERASE.  */
+#define	ECHOE	_ECHOE
+#define	_ECHOK	(1 << 2)	/* Echo NL after KILL.  */
+#define	ECHOK	_ECHOK
+#define	_ECHO	(1 << 3)	/* Enable echo.  */
+#define	ECHO	_ECHO
+#define	_ECHONL	(1 << 4)	/* Echo NL even if ECHO is off.  */
+#define	ECHONL	_ECHONL
+#ifdef	__USE_BSD
+# define ECHOPRT	(1 << 5)	/* Hardcopy visual erase.  */
+# define ECHOCTL	(1 << 6)	/* Echo control characters as ^X.  */
+#endif
+#define	_ISIG	(1 << 7)	/* Enable signals.  */
+#define	ISIG	_ISIG
+#define	_ICANON	(1 << 8)	/* Do erase and kill processing.  */
+#define	ICANON	_ICANON
+#ifdef	__USE_BSD
+# define ALTWERASE (1 << 9)	/* Alternate WERASE algorithm.  */
+#endif
+#define	_IEXTEN	(1 << 10)	/* Enable DISCARD and LNEXT.  */
+#define	IEXTEN	_IEXTEN
+#define	_EXTPROC (1 << 11)	/* External processing.  */
+#define EXTPROC	_EXTPROC
+#define	_TOSTOP	(1 << 22)	/* Send SIGTTOU for background output.  */
+#define	TOSTOP	_TOSTOP
+#ifdef	__USE_BSD
+# define FLUSHO	(1 << 23)	/* Output being flushed (state).  */
+# define NOKERNINFO (1 << 25)	/* Disable VSTATUS.  */
+# define PENDIN	(1 << 29)	/* Retype pending input (state).  */
+#endif
+#define	_NOFLSH	(1 << 31)	/* Disable flush after interrupt.  */
+#define	NOFLSH	_NOFLSH
+
+  /* Input and output baud rates.  */
+#define	B0	0		/* Hang up.  */
+#define	B50	50		/* 50 baud.  */
+#define	B75	75		/* 75 baud.  */
+#define	B110	110		/* 110 baud.  */
+#define	B134	134		/* 134.5 baud.  */
+#define	B150	150		/* 150 baud.  */
+#define	B200	200		/* 200 baud.  */
+#define	B300	300		/* 300 baud.  */
+#define	B600	600		/* 600 baud.  */
+#define	B1200	1200		/* 1200 baud.  */
+#define	B1800	1800		/* 1800 baud.  */
+#define	B2400	2400		/* 2400 baud.  */
+#define	B4800	4800		/* 4800 baud.  */
+#define	B9600	9600		/* 9600 baud.  */
+#define	B19200	19200		/* 19200 baud.  */
+#define	B38400	38400		/* 38400 baud.  */
+#define B76800	76800
+#ifdef	__USE_MISC
+# define EXTA	19200
+# define EXTB	38400
+#endif
+#define B7200	7200
+#define B14400	14400
+#define B28800	28800
+#define	B57600	57600
+#define	B115200	115200
+#define	B230400	230400
+#define	B460800	460800
+#define	B500000	500000
+#define	B576000	576000
+#define	B921600	921600
+#define	B1000000 1000000
+#define	B1152000 1152000
+#define	B1500000 1500000
+#define	B2000000 2000000
+#define	B2500000 2500000
+#define	B3000000 3000000
+#define	B3500000 3500000
+#define	B4000000 4000000
+#define	__MAX_BAUD B4000000
+
+/* tcflow() and TCXONC use these */
+#define	TCOOFF		1
+#define	TCOON		2
+#define	TCIOFF		3
+#define	TCION		4
+
+/* tcflush() and TCFLSH use these */
+#define	TCIFLUSH	1
+#define	TCOFLUSH	2
+#define	TCIOFLUSH	3
+
+/* tcsetattr uses these */
+#define	TCSANOW		0
+#define	TCSADRAIN	1
+#define	TCSAFLUSH	2
+#ifdef	__USE_BSD
+# define TCSASOFT	0x10	/* Flag: Don't alter hardware state.  */
+#endif
+
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/bits/typesizes.h
@@ -0,0 +1,66 @@
+/* bits/typesizes.h -- underlying types for *_t.  kFreeBSD version.
+   Copyright (C) 2002, 2003 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _BITS_TYPES_H
+# error "Never include <bits/typesizes.h> directly; use <sys/types.h> instead."
+#endif
+
+#ifndef	_BITS_TYPESIZES_H
+#define	_BITS_TYPESIZES_H	1
+
+/* See <bits/types.h> for the meaning of these macros.  This file exists so
+   that <bits/types.h> need not vary across different GNU platforms.  */
+
+#define __DEV_T_TYPE		__U32_TYPE
+#define __UID_T_TYPE		__U32_TYPE
+#define __GID_T_TYPE		__U32_TYPE
+#define __INO_T_TYPE		__U32_TYPE
+#define __INO64_T_TYPE		__UQUAD_TYPE
+#define __MODE_T_TYPE		__U16_TYPE
+#define __NLINK_T_TYPE		__U16_TYPE
+#define __OFF_T_TYPE		__SQUAD_TYPE
+#define __OFF64_T_TYPE		__SQUAD_TYPE
+#define __PID_T_TYPE		__S32_TYPE
+#define __RLIM_T_TYPE		__SQUAD_TYPE
+#define __RLIM64_T_TYPE		__SQUAD_TYPE
+#define	__BLKCNT_T_TYPE		__SQUAD_TYPE
+#define	__BLKCNT64_T_TYPE	__SQUAD_TYPE
+#define	__FSBLKCNT_T_TYPE	__ULONGWORD_TYPE
+#define	__FSBLKCNT64_T_TYPE	__UQUAD_TYPE
+#define	__FSFILCNT_T_TYPE	__ULONGWORD_TYPE
+#define	__FSFILCNT64_T_TYPE	__UQUAD_TYPE
+#define	__ID_T_TYPE		__U32_TYPE
+#define __CLOCK_T_TYPE		__S32_TYPE
+#define __TIME_T_TYPE		__SLONGWORD_TYPE
+#define __USECONDS_T_TYPE	__U32_TYPE
+#define __SUSECONDS_T_TYPE	__SLONGWORD_TYPE
+#define __DADDR_T_TYPE		__S32_TYPE
+#define __SWBLK_T_TYPE		__S32_TYPE
+#define __KEY_T_TYPE		__SLONGWORD_TYPE
+#define __CLOCKID_T_TYPE	__S32_TYPE
+#define __TIMER_T_TYPE		__S32_TYPE
+#define __BLKSIZE_T_TYPE	__U32_TYPE
+#define __FSID_T_TYPE		struct { int __val[2]; }
+#define __SSIZE_T_TYPE		__SWORD_TYPE
+
+/* Number of descriptors that can fit in an `fd_set'.  */
+#define	__FD_SETSIZE		1024
+
+
+#endif /* bits/typesizes.h */
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/bits/uio.h
@@ -0,0 +1,49 @@
+/* Copyright (C) 1996-1997, 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _SYS_UIO_H
+# error "Never include <bits/uio.h> directly; use <sys/uio.h> instead."
+#endif
+
+
+/* `struct iovec' -- Structure describing a section of memory.  */
+
+struct iovec
+{
+  /* Starting address.  */
+  __ptr_t iov_base;
+  /* Length in bytes.  */
+  size_t iov_len;
+};
+
+/* Maximum number of 'struct iovec's that can be passed to a readv() or
+   writev() system call.  For larger arrays of 'struct iovec', the libc
+   uses a single read() or write() call to guarantee atomicity.  */
+#define UIO_MAXIOV	1024
+
+#ifdef __USE_BSD
+enum    uio_rw { UIO_READ, UIO_WRITE };
+
+/* Segment flag values. */
+enum uio_seg {
+        UIO_USERSPACE,          /* from user data space */
+        UIO_SYSSPACE,           /* from system space */
+        UIO_NOCOPY              /* don't copy, already in object */
+};
+#endif
+
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/bits/utsname.h
@@ -0,0 +1,27 @@
+/* Copyright (C) 1997, 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _SYS_UTSNAME_H
+# error "Never include <bits/utsname.h> directly; use <sys/utsname.h> instead."
+#endif
+
+/* Length of the entries in 'struct utsname' is 32.  */
+#define _UTSNAME_LENGTH 32
+
+/* But the version entry is longer.  */
+#define _UTSNAME_VERSION_LENGTH 256
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/bits/waitflags.h
@@ -0,0 +1,37 @@
+/* Definitions of flag bits for `waitpid' et al.
+   Copyright (C) 1992, 1996-1997, 2000, 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#if !defined _SYS_WAIT_H && !defined _STDLIB_H
+# error "Never include <bits/waitflags.h> directly; use <sys/wait.h> instead."
+#endif
+
+
+/* Bits in the third argument to `waitpid'.  */
+#define	WNOHANG		1	/* Don't block waiting.  */
+#define	WUNTRACED	2	/* Report status of stopped children.  */
+
+/* Bits in the fourth argument to `waitid'.  */
+#define	WSTOPPED	2	/* Report stopped child (same as WUNTRACED). */
+#define	WCONTINUED	4	/* Report continued child.  */
+#define	WNOWAIT		8	/* Poll only. Don't delete the proc entry. */
+
+#define __WCLONE	0x80000000	/* Wait for cloned process.  */
+#ifdef __USE_BSD
+# define WLINUXCLONE	__WCLONE	/* FreeBSD name for __WCLONE.  */
+#endif
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/brk.c
@@ -0,0 +1,53 @@
+/* Copyright (C) 2004 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Robert Millan <robertmh@gnu.org>
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <errno.h>
+#include <unistd.h>
+#include <sys/syscall.h>
+
+#ifndef SYS_break
+#define SYS_break SYS_obreak
+#endif
+
+int __syscall(int number, ...);
+
+extern void _end;
+
+/* sbrk.c expects this.  */
+void *__curbrk = &_end;
+
+/* Set the end of the process's data space to ADDR.
+   Return 0 if successful, -1 if not.  */
+int
+__brk (addr)
+     void *addr;
+{
+  if (addr < &_end)
+    return 0;
+
+  if (__syscall (SYS_break, addr) == -1)
+    {
+      __set_errno (ENOMEM);
+      return -1;
+    }
+
+  __curbrk = addr;
+  return 0;
+}
+weak_alias (__brk, brk)
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/check_fds.c
@@ -0,0 +1 @@
+void __libc_check_standard_fds (void) {;}
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/check_native.c
@@ -0,0 +1,42 @@
+/* Determine whether interfaces use native transport.  Dummy version.
+   Copyright (C) 2008 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <assert.h>
+#include <errno.h>
+#include <ifaddrs.h>
+#include <stddef.h>
+#include <stdint.h>
+#include <stdlib.h>
+#include <time.h>
+#include <unistd.h>
+#include <net/if.h>
+#include <net/if_arp.h>
+#include <sys/ioctl.h>
+
+#include <not-cancel.h>
+
+
+void
+__check_native (uint32_t a1_index, int *a1_native,
+		uint32_t a2_index, int *a2_native)
+{
+
+#warning __check_native() not yet implemented
+  return;
+}
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/check_pf.c
@@ -0,0 +1 @@
+#include <inet/check_pf.c>
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/clock_getres.c
@@ -0,0 +1,33 @@
+/* Copyright (C) 2006 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sysdep.h>
+
+int __syscall_clock_getres(clockid_t clock_id, struct timespec *tp);
+libc_hidden_proto (__syscall_clock_getres)
+
+# define SYSDEP_GETRES \
+  case CLOCK_REALTIME:							      \
+  case CLOCK_MONOTONIC:							      \
+    retval = INLINE_SYSCALL (clock_getres, 2, clock_id, res);		      \
+    break
+
+/* We handled the REALTIME clock here.  */
+# define HANDLED_REALTIME	1
+
+#include <sysdeps/posix/clock_getres.c>
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/clock_gettime.c
@@ -0,0 +1,33 @@
+/* Copyright (C) 2006 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sysdep.h>
+#include "kernel-posix-cpu-timers.h"
+
+int __syscall_clock_gettime(clockid_t clock_id, struct timespec *tp);
+libc_hidden_proto (__syscall_clock_gettime)
+
+# define SYSDEP_GETTIME \
+  case CLOCK_REALTIME:							      \
+  case CLOCK_MONOTONIC:							      \
+    retval = INLINE_SYSCALL (clock_gettime, 2, clock_id, tp);		      \
+    break
+
+/* We handled the REALTIME clock here.  */
+# define HANDLED_REALTIME	1
+#include <sysdeps/unix/clock_gettime.c>
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/clock_settime.c
@@ -0,0 +1,32 @@
+/* Copyright (C) 2006 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sysdep.h>
+#include "kernel-posix-cpu-timers.h"
+
+int __syscall_clock_settime(clockid_t clock_id, const struct timespec *tp);
+libc_hidden_proto (__syscall_clock_settime)
+
+# define SYSDEP_SETTIME \
+  case CLOCK_REALTIME:							      \
+    retval = INLINE_SYSCALL (clock_settime, 2, clock_id, tp);		      \
+    break
+/* We handled the REALTIME clock here.  */
+# define HANDLED_REALTIME	1
+
+#include <sysdeps/unix/clock_settime.c>
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/clone.c
@@ -0,0 +1,105 @@
+/* Create a thread.
+   Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Bruno Haible <bruno@clisp.org>, 2002.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#define __clone __no_broken_clone_decl
+#include <sched.h>
+#include <sys/rfork.h>
+#include <errno.h>
+#include <signal.h>
+#include <stddef.h>
+#undef __clone
+
+/* __start_thread (flags, child_stack, fn, arg)
+   is roughly equivalent to
+
+     int retval = __rfork (flags);
+     if (retval == 0)
+       {
+         // Here we are in the child thread.
+         %stackpointer = child_stack;
+         _exit (fn (arg));
+       }
+     return retval;
+
+   but it cannot be done in portable C because it must access fn and arg
+   after having replaced the stack pointer.  */
+
+extern int __start_thread (int flags, void *child_stack,
+			   int (*fn) (void *), void *arg);
+
+int __clone (int (*fn) (void *), void *child_stack, int flags, void *arg)
+{
+  int rfork_flags = RFPROC;
+
+  if (fn == NULL || child_stack == NULL)
+    {
+      __set_errno (EINVAL);
+      return -1;
+    }
+
+  /* This implementation of clone() does not support all Linux flags.  */
+  if (flags & ~(CSIGNAL | CLONE_VM | CLONE_FS | CLONE_FILES | CLONE_SIGHAND
+		| CLONE_VFORK | CLONE_SYSVSEM))
+    {
+      __set_errno (EINVAL);
+      return -1;
+    }
+
+  if ((flags & CSIGNAL) != 0 && (flags & CSIGNAL) != SIGCHLD)
+    {
+      if ((flags & CSIGNAL) & ~RFTHPNMASK)
+	{
+	  __set_errno (EINVAL);
+	  return -1;
+	}
+      rfork_flags |= (RFLINUXTHPN | ((flags & CSIGNAL) <<  RFTHPNSHIFT));
+    }
+
+  if (flags & CLONE_VM)
+    rfork_flags |= RFMEM;
+
+  if (flags & CLONE_FS)
+    /* Sharing the filesystem related info (umask, cwd, root dir)
+       is not supported by rfork.  Ignore this; let's hope programs
+       will set their umask and cwd before spawning threads.  */
+    ;
+
+  if (flags & CLONE_SYSVSEM)
+    /* Ignore this; it has been introduced into linuxthreads in post 2.4 glibc */
+    ;
+
+  if (!(flags & CLONE_FILES))
+    rfork_flags |= RFFDG;
+
+  if (flags & CLONE_SIGHAND)
+    {
+      rfork_flags |= RFSIGSHARE;
+      /* Also set the undocumented flag RFTHREAD.  It has the effect that when
+	 the thread leader exits, all threads belonging to it are killed.  */
+      rfork_flags |= RFTHREAD;
+    }
+
+  if (flags & CLONE_VFORK)
+    rfork_flags |= RFPPWAIT;
+
+  return __start_thread (rfork_flags, child_stack, fn, arg);
+}
+
+weak_alias (__clone, clone)
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/configure
@@ -0,0 +1,342 @@
+# This file is generated from configure.in by Autoconf.  DO NOT EDIT!
+ # Local configure fragment for sysdeps/unix/bsd/bsd4.4/kfreebsd.
+
+case "$machine" in
+  x86_64*)
+	echo "Adding extra sysnames for kfreebsd/x86_64/elf"
+	sysnames="ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/x86_64/elf $sysnames"
+    ;;
+esac
+
+# The kFreeBSD headers can be found in
+#   /usr/src/sys/
+# Check whether this directory is available.
+if test -z "$sysheaders" &&
+   test "x$cross_compiling" = xno &&
+   test -d /usr/src/sys/ ; then
+  sysheaders="/usr/src/sys/"
+  ccheaders=`$CC -print-file-name=include`
+      SYSINCLUDES="-I $sysheaders"
+fi
+
+# Don't bother trying to generate any glue code to be compatible with the
+# existing system library, because we are the only system library.
+inhibit_glue=yes
+
+if test -n "$sysheaders"; then
+  OLD_CPPFLAGS=$CPPFLAGS
+  CPPFLAGS="$CPPFLAGS $SYSINCLUDES"
+fi
+
+
+echo "$as_me:$LINENO: checking for egrep" >&5
+echo $ECHO_N "checking for egrep... $ECHO_C" >&6
+if test "${ac_cv_prog_egrep+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  if echo a | (grep -E '(a|b)') >/dev/null 2>&1
+    then ac_cv_prog_egrep='grep -E'
+    else ac_cv_prog_egrep='egrep'
+    fi
+fi
+echo "$as_me:$LINENO: result: $ac_cv_prog_egrep" >&5
+echo "${ECHO_T}$ac_cv_prog_egrep" >&6
+ EGREP=$ac_cv_prog_egrep
+
+
+echo "$as_me:$LINENO: checking installed kFreeBSD kernel header files" >&5
+echo $ECHO_N "checking installed kFreeBSD kernel header files... $ECHO_C" >&6
+if test "${libc_cv_kfreebsd540+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#include <osreldate.h>
+#if !defined(__FreeBSD_kernel_version) && defined(__FreeBSD_version)
+#define __FreeBSD_kernel_version __FreeBSD_version
+#endif
+#if !defined __FreeBSD_kernel_version || __FreeBSD_kernel_version <  (5 *10000+ 4 *100+ 0) /* 5.4.0 */
+eat flaming death
+#endif
+_ACEOF
+if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
+  $EGREP "eat flaming death" >/dev/null 2>&1; then
+  libc_cv_kfreebsd540='TOO OLD!'
+else
+  libc_cv_kfreebsd540='5.4.0 or later'
+fi
+rm -f conftest*
+
+fi
+echo "$as_me:$LINENO: result: $libc_cv_kfreebsd540" >&5
+echo "${ECHO_T}$libc_cv_kfreebsd540" >&6
+if test "$libc_cv_kfreebsd540" != '5.4.0 or later'; then
+  { { echo "$as_me:$LINENO: error: GNU libc requires kernel header files from
+kFreeBSD 5.4.0 or later to be installed before configuring.
+The kernel header files are found usually in /usr/src/sys/; make sure
+these directories use files from kFreeBSD 5.4.0 or later.
+This check uses <osreldate.h>, so
+make sure that file was built correctly when installing the kernel header
+files.  To use kernel headers not from /usr/src/sys/, use the
+configure option --with-headers." >&5
+echo "$as_me: error: GNU libc requires kernel header files from
+kFreeBSD 5.4.0 or later to be installed before configuring.
+The kernel header files are found usually in /usr/src/sys/; make sure
+these directories use files from kFreeBSD 5.4.0 or later.
+This check uses <osreldate.h>, so
+make sure that file was built correctly when installing the kernel header
+files.  To use kernel headers not from /usr/src/sys/, use the
+configure option --with-headers." >&2;}
+   { (exit 1); exit 1; }; }
+fi
+
+# Check whether --enable-compatible-utmp or --disable-compatible-utmp was given.
+if test "${enable_compatible_utmp+set}" = set; then
+  enableval="$enable_compatible_utmp"
+  enable_utmp_compat=$enableval
+else
+  enable_utmp_compat=no
+fi;
+if test "$enable_utmp_compat" = no; then
+  utmp_subdir=utmp-utmpx
+else
+  utmp_subdir=utmp-compat
+fi
+sysnames="$sysnames sysdeps/unix/bsd/bsd4.4/kfreebsd/$utmp_subdir"
+
+# If the user gave a minimal version number test whether the available
+# kernel headers are young enough.  Additionally we have minimal
+# kernel versions for some architectures.  If a previous configure fragment
+# set arch_minimum_kernel already, let that override our defaults here.
+# Note that we presume such a fragment has set libc_cv_gcc_unwind_find_fde
+# if appropriate too.
+test -n "$arch_minimum_kernel" ||
+case "$machine" in
+  i386*)
+    libc_cv_gcc_unwind_find_fde=yes
+    arch_minimum_kernel=5.4.0
+    ;;
+  x86_64*)
+    arch_minimum_kernel=5.4.0
+    ;;
+  *)
+    arch_minimum_kernel=5.4.0
+    ;;
+esac
+if test -n "$minimum_kernel"; then
+
+  user_version=$((`echo "$minimum_kernel.0.0.0" | sed 's/\([0-9]*\)\.\([0-9]*\)\.\([0-9]*\).*/\1 \* 10000 + \2 \* 100 + \3/'`))
+  arch_version=$((`echo "$arch_minimum_kernel.0.0.0" | sed 's/\([0-9]*\)\.\([0-9]*\)\.\([0-9]*\).*/\1 \* 10000 + \2 \* 100 + \3/'`))
+
+  if test $user_version -lt $arch_version; then
+    { echo "$as_me:$LINENO: WARNING: minimum kernel version reset to $arch_minimum_kernel" >&5
+echo "$as_me: WARNING: minimum kernel version reset to $arch_minimum_kernel" >&2;}
+    minimum_kernel=$arch_minimum_kernel
+  fi
+else
+  if test $arch_minimum_kernel != '5.4.0'; then
+    minimum_kernel=$arch_minimum_kernel
+  fi
+fi
+
+if test -n "$minimum_kernel"; then
+  echo "$as_me:$LINENO: checking for kernel header at least $minimum_kernel" >&5
+echo $ECHO_N "checking for kernel header at least $minimum_kernel... $ECHO_C" >&6
+  decnum=`echo "$minimum_kernel.0.0.0" | sed 's/\([0-9]*\)\.\([0-9]*\)\.\([0-9]*\).*/(\1 * 10000 + \2 * 100 + \3)/'`;
+  abinum=`echo "$minimum_kernel.0.0.0" | sed 's/\([0-9]*\)\.\([0-9]*\)\.\([0-9]*\).*/\1,\2,\3/'`;
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#include <osreldate.h>
+#if !defined(__FreeBSD_kernel_version) && defined(__FreeBSD_version)
+#define __FreeBSD_kernel_version __FreeBSD_version
+#endif
+#if __FreeBSD_kernel_version < $decnum
+eat flaming death
+#endif
+_ACEOF
+if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
+  $EGREP "eat flaming death" >/dev/null 2>&1; then
+  libc_minimum_kernel='too old!'
+else
+  libc_minimum_kernel=ok
+fi
+rm -f conftest*
+
+  echo "$as_me:$LINENO: result: $libc_minimum_kernel" >&5
+echo "${ECHO_T}$libc_minimum_kernel" >&6
+  if test "$libc_minimum_kernel" = ok; then
+    cat >>confdefs.h <<_ACEOF
+#define __KFREEBSD_KERNEL_VERSION $decnum
+_ACEOF
+
+    cat >>confdefs.h <<_ACEOF
+#define __ABI_TAG_VERSION $abinum
+_ACEOF
+
+  else
+    { { echo "$as_me:$LINENO: error: *** The available kernel headers are older than the requested
+*** compatible kernel version" >&5
+echo "$as_me: error: *** The available kernel headers are older than the requested
+*** compatible kernel version" >&2;}
+   { (exit 1); exit 1; }; }
+  fi
+fi
+
+if test -n "$sysheaders"; then
+  CPPFLAGS=$OLD_CPPFLAGS
+fi
+# The Linux filesystem standard prescribes where to place "essential"
+# files.  I.e., when the installation prefix is "/usr" we have to place
+# shared library objects and the configuration files on the root partition
+# in /lib and /etc.
+case "$prefix" in
+/usr | /usr/)
+  # 64-bit libraries on bi-arch platforms go in /lib64 instead of /lib
+  case $machine in
+  sparc/sparc64 | x86_64 | powerpc/powerpc64 | s390/s390-64 | \
+  mips/mips64/n64/* )
+    libc_cv_slibdir="/lib64"
+    if test "$libdir" = '${exec_prefix}/lib'; then
+      libdir='${exec_prefix}/lib64';
+      # Locale data can be shared between 32bit and 64bit libraries
+      libc_cv_localedir='${exec_prefix}/lib/locale'
+    fi
+    ;;
+  mips/mips64/n32/* )
+    libc_cv_slibdir="/lib32"
+    if test "$libdir" = '${exec_prefix}/lib'; then
+      libdir='${exec_prefix}/lib32';
+      # Locale data can be shared between 32bit and 64bit libraries
+      libc_cv_localedir='${exec_prefix}/lib/locale'
+    fi
+    ;;
+  *)
+    libc_cv_slibdir="/lib"
+    ;;
+  esac
+  # Allow the user to override the path with --sysconfdir
+  if test $sysconfdir = '${prefix}/etc'; then
+    libc_cv_sysconfdir=/etc
+  else
+    libc_cv_sysconfdir=$sysconfdir
+   fi
+  libc_cv_rootsbindir="/sbin"
+  ;;
+esac
+
+
+# Put exception handling support into libc, so that not every shared
+# library needs to include it.
+# FIXME: Does not work yet.
+libc_cv_gcc_unwind_find_fde=no
+
+
+# Under kFreeBSD the LinuxThreads or (may be later) NPTL add-on should be available.
+case $add_ons in
+  # Only one of the add-ons should be available.
+  *linuxthreads*nptl*|*nptl*linuxthreads*)
+    echo "\
+*** LinuxThreads and NPTL add-ons are both available.  Only one must be used."
+    exit 1
+    ;;
+  # It is available.  Good.
+  *linuxthreads*)
+    linuxthreads_missing=
+    ;;
+  *nptl*)
+    linuxthreads_missing=
+    ;;
+  *)
+    linuxthreads_missing=yes
+    ;;
+esac
+
+if test "$linuxthreads_missing"; then
+  if test $enable_sanity = yes; then
+    echo "\
+*** On GNU/kFreeBSD systems it is normal to compile GNU libc with the
+*** \`linuxthreads' add-on.  Without that, the library will be
+*** incompatible with normal GNU/kFreeBSD systems.
+*** If you really mean to not use this add-on, run configure again
+*** using the extra parameter \`--disable-sanity-checks'."
+    exit 1
+  else
+    echo "\
+*** WARNING: Are you sure you do not want to use the \`linuxthreads'
+*** add-on?"
+  fi
+fi
+
+if test "$prefix" = "/usr/local" -o "$prefix" = "/usr/local/" -o "$prefix" = "NONE"; then
+  if test $enable_sanity = yes; then
+    echo "\
+*** On GNU/kFreeBSD systems the GNU C Library should not be installed into
+*** /usr/local since this might make your system totally unusable.
+*** We strongly advise to use a different prefix.  For details read the FAQ.
+*** If you really mean to do this, run configure again using the extra
+*** parameter \`--disable-sanity-checks'."
+    exit 1
+  else
+    echo "\
+*** WARNING: Do you really want to install the GNU C Library into /usr/local?
+*** This might make your system totally unusable, for details read the FAQ."
+  fi
+fi
+
+
+# One kFreeBSD we use ldconfig.
+use_ldconfig=yes
+
+# We need some extensions to the `ldd' script.
+case "$machine" in
+  x86_64*)
+    ldd_rewrite_script=../ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/x86_64/ldd-rewrite.sed
+    ;;
+  *)
+    ;;
+esac
+
+
+if test $host = $build; then
+  # If $prefix/include/{net,scsi} are symlinks, make install will
+  # clobber what they're linked to (probably a kernel tree).
+  # test -L ought to work on all Linux boxes.
+  if test "x$prefix" != xNONE; then
+    ac_prefix=$prefix
+  else
+    ac_prefix=$ac_default_prefix
+  fi
+  echo "$as_me:$LINENO: checking for symlinks in ${ac_prefix}/include" >&5
+echo $ECHO_N "checking for symlinks in ${ac_prefix}/include... $ECHO_C" >&6
+  ac_message=
+  if test -L ${ac_prefix}/include/net; then
+    ac_message="$ac_message
+   ${ac_prefix}/include/net is a symlink"
+  fi
+  if test -L ${ac_prefix}/include/scsi; then
+    ac_message="$ac_message
+   ${ac_prefix}/include/scsi is a symlink"
+  fi
+  if test -n "$ac_message"; then
+    { { echo "$as_me:$LINENO: error: $ac_message
+\`make install' will destroy the target of the link(s).
+Delete the links and re-run configure, or better still, move the entire
+${ac_prefix}/include directory out of the way." >&5
+echo "$as_me: error: $ac_message
+\`make install' will destroy the target of the link(s).
+Delete the links and re-run configure, or better still, move the entire
+${ac_prefix}/include directory out of the way." >&2;}
+   { (exit 1); exit 1; }; }
+  else
+    echo "$as_me:$LINENO: result: ok" >&5
+echo "${ECHO_T}ok" >&6
+  fi
+fi
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/configure.in
@@ -0,0 +1,268 @@
+GLIBC_PROVIDES dnl See aclocal.m4 in the top level source directory.
+# Local configure fragment for sysdeps/unix/bsd/bsd4.4/kfreebsd.
+
+case "$machine" in
+  x86_64*)
+	echo "Adding extra sysnames for kfreebsd/x86_64/elf"
+	sysnames="ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/x86_64/elf $sysnames"
+    ;;
+esac
+
+# The kFreeBSD headers can be found in
+#   /usr/src/sys/
+# Check whether this directory is available.
+if test -z "$sysheaders" &&
+   test "x$cross_compiling" = xno &&
+   test -d /usr/src/sys/ ; then
+  sysheaders="/usr/src/sys/"
+  ccheaders=`$CC -print-file-name=include`
+  dnl We don't have to use -nostdinc.  We just want one more directory
+  dnl to be used.
+  SYSINCLUDES="-I $sysheaders"
+fi
+
+# Don't bother trying to generate any glue code to be compatible with the
+# existing system library, because we are the only system library.
+inhibit_glue=yes
+
+define([LIBC_KFREEBSD_VERSION],[5.4.0])dnl
+if test -n "$sysheaders"; then
+  OLD_CPPFLAGS=$CPPFLAGS
+  CPPFLAGS="$CPPFLAGS $SYSINCLUDES"
+fi
+define([libc_cv_kfreebsdVER], [libc_cv_kfreebsd]patsubst(LIBC_KFREEBSD_VERSION,[\.]))dnl
+AC_CACHE_CHECK(installed kFreeBSD kernel header files, libc_cv_kfreebsdVER, [dnl
+AC_EGREP_CPP([eat flaming death], [#include <osreldate.h>
+#if !defined(__FreeBSD_kernel_version) && defined(__FreeBSD_version)
+#define __FreeBSD_kernel_version __FreeBSD_version
+#endif
+#if !defined __FreeBSD_kernel_version || __FreeBSD_kernel_version < ]dnl
+patsubst(LIBC_KFREEBSD_VERSION,[^\([^.]*\)\.\([^.]*\)\.\([^.]*\)$],dnl
+[ (\1 *10000+ \2 *100+ \3) /* \1.\2.\3 */])[
+eat flaming death
+#endif],
+	     libc_cv_kfreebsdVER='TOO OLD!',
+	     libc_cv_kfreebsdVER='LIBC_KFREEBSD_VERSION or later')])
+if test "$libc_cv_kfreebsdVER" != 'LIBC_KFREEBSD_VERSION or later'; then
+  AC_MSG_ERROR([GNU libc requires kernel header files from
+kFreeBSD LIBC_KFREEBSD_VERSION or later to be installed before configuring.
+The kernel header files are found usually in /usr/src/sys/; make sure
+these directories use files from kFreeBSD LIBC_KFREEBSD_VERSION or later.
+This check uses <osreldate.h>, so
+make sure that file was built correctly when installing the kernel header
+files.  To use kernel headers not from /usr/src/sys/, use the
+configure option --with-headers.])
+fi
+
+AC_ARG_ENABLE(compatible-utmp, dnl
+[  --disable-compatible-utmp  use a struct utmp which is the same as struct
+                          utmpx, as on kFreeBSD, but incompatible with FreeBSD],
+              enable_utmp_compat=$enableval, enable_utmp_compat=no)
+if test "$enable_utmp_compat" = no; then
+  utmp_subdir=utmp-utmpx
+else
+  utmp_subdir=utmp-compat
+fi
+sysnames="$sysnames sysdeps/unix/bsd/bsd4.4/kfreebsd/$utmp_subdir"
+
+# If the user gave a minimal version number test whether the available
+# kernel headers are young enough.  Additionally we have minimal
+# kernel versions for some architectures.  If a previous configure fragment
+# set arch_minimum_kernel already, let that override our defaults here.
+# Note that we presume such a fragment has set libc_cv_gcc_unwind_find_fde
+# if appropriate too.
+test -n "$arch_minimum_kernel" ||
+case "$machine" in
+  i386*)
+    libc_cv_gcc_unwind_find_fde=yes
+    arch_minimum_kernel=5.4.0
+    ;;
+  x86_64*)
+    arch_minimum_kernel=5.4.0
+    ;;
+  *)
+    arch_minimum_kernel=5.4.0
+    ;;
+esac
+if test -n "$minimum_kernel"; then
+  changequote(,)
+  user_version=$((`echo "$minimum_kernel.0.0.0" | sed 's/\([0-9]*\)\.\([0-9]*\)\.\([0-9]*\).*/\1 \* 10000 + \2 \* 100 + \3/'`))
+  arch_version=$((`echo "$arch_minimum_kernel.0.0.0" | sed 's/\([0-9]*\)\.\([0-9]*\)\.\([0-9]*\).*/\1 \* 10000 + \2 \* 100 + \3/'`))
+  changequote([,])
+  if test $user_version -lt $arch_version; then
+    AC_MSG_WARN([minimum kernel version reset to $arch_minimum_kernel])
+    minimum_kernel=$arch_minimum_kernel
+  fi
+else
+  if test $arch_minimum_kernel != '5.4.0'; then
+    minimum_kernel=$arch_minimum_kernel
+  fi
+fi
+
+if test -n "$minimum_kernel"; then
+  AC_MSG_CHECKING(for kernel header at least $minimum_kernel)
+changequote(,)dnl
+  decnum=`echo "$minimum_kernel.0.0.0" | sed 's/\([0-9]*\)\.\([0-9]*\)\.\([0-9]*\).*/(\1 * 10000 + \2 * 100 + \3)/'`;
+  abinum=`echo "$minimum_kernel.0.0.0" | sed 's/\([0-9]*\)\.\([0-9]*\)\.\([0-9]*\).*/\1,\2,\3/'`;
+changequote([,])dnl
+  AC_EGREP_CPP([eat flaming death], [#include <osreldate.h>
+#if !defined(__FreeBSD_kernel_version) && defined(__FreeBSD_version)
+#define __FreeBSD_kernel_version __FreeBSD_version
+#endif
+#if __FreeBSD_kernel_version < $decnum
+eat flaming death
+#endif], libc_minimum_kernel='too old!', libc_minimum_kernel=ok)
+  AC_MSG_RESULT($libc_minimum_kernel)
+  if test "$libc_minimum_kernel" = ok; then
+    AC_DEFINE_UNQUOTED(__KFREEBSD_KERNEL_VERSION, $decnum)
+    AC_DEFINE_UNQUOTED(__ABI_TAG_VERSION, $abinum)
+  else
+    AC_MSG_ERROR([*** The available kernel headers are older than the requested
+*** compatible kernel version])
+  fi
+fi
+
+if test -n "$sysheaders"; then
+  CPPFLAGS=$OLD_CPPFLAGS
+fi
+# The Linux filesystem standard prescribes where to place "essential"
+# files.  I.e., when the installation prefix is "/usr" we have to place
+# shared library objects and the configuration files on the root partition
+# in /lib and /etc.
+case "$prefix" in
+/usr | /usr/)
+  # 64-bit libraries on bi-arch platforms go in /lib64 instead of /lib
+  case $machine in
+  sparc/sparc64 | x86_64 | powerpc/powerpc64 | s390/s390-64 | \
+  mips/mips64/n64/* )
+    libc_cv_slibdir="/lib64"
+    if test "$libdir" = '${exec_prefix}/lib'; then
+      libdir='${exec_prefix}/lib64';
+      # Locale data can be shared between 32bit and 64bit libraries
+      libc_cv_localedir='${exec_prefix}/lib/locale'
+    fi
+    ;;
+  mips/mips64/n32/* )
+    libc_cv_slibdir="/lib32"
+    if test "$libdir" = '${exec_prefix}/lib'; then
+      libdir='${exec_prefix}/lib32';
+      # Locale data can be shared between 32bit and 64bit libraries
+      libc_cv_localedir='${exec_prefix}/lib/locale'
+    fi
+    ;;
+  *)
+    libc_cv_slibdir="/lib"
+    ;;
+  esac
+  # Allow the user to override the path with --sysconfdir
+  if test $sysconfdir = '${prefix}/etc'; then
+    libc_cv_sysconfdir=/etc
+  else
+    libc_cv_sysconfdir=$sysconfdir
+   fi
+  libc_cv_rootsbindir="/sbin"
+  ;;
+esac
+
+
+# Put exception handling support into libc, so that not every shared
+# library needs to include it.
+# FIXME: Does not work yet.
+libc_cv_gcc_unwind_find_fde=no
+
+
+# Under kFreeBSD the LinuxThreads or (may be later) NPTL add-on should be available.
+case $add_ons in
+  # Only one of the add-ons should be available.
+  *linuxthreads*nptl*|*nptl*linuxthreads*)
+    echo "\
+*** LinuxThreads and NPTL add-ons are both available.  Only one must be used."
+    exit 1
+    ;;
+  # It is available.  Good.
+  *linuxthreads*)
+    linuxthreads_missing=
+    ;;
+  *nptl*)
+    linuxthreads_missing=
+    ;;
+  *)
+    linuxthreads_missing=yes
+    ;;
+esac
+
+if test "$linuxthreads_missing"; then
+  if test $enable_sanity = yes; then
+    echo "\
+*** On GNU/kFreeBSD systems it is normal to compile GNU libc with the
+*** \`linuxthreads' add-on.  Without that, the library will be
+*** incompatible with normal GNU/kFreeBSD systems.
+*** If you really mean to not use this add-on, run configure again
+*** using the extra parameter \`--disable-sanity-checks'."
+    exit 1
+  else
+    echo "\
+*** WARNING: Are you sure you do not want to use the \`linuxthreads'
+*** add-on?"
+  fi
+fi
+
+if test "$prefix" = "/usr/local" -o "$prefix" = "/usr/local/" -o "$prefix" = "NONE"; then
+  if test $enable_sanity = yes; then
+    echo "\
+*** On GNU/kFreeBSD systems the GNU C Library should not be installed into
+*** /usr/local since this might make your system totally unusable.
+*** We strongly advise to use a different prefix.  For details read the FAQ.
+*** If you really mean to do this, run configure again using the extra
+*** parameter \`--disable-sanity-checks'."
+    exit 1
+  else
+    echo "\
+*** WARNING: Do you really want to install the GNU C Library into /usr/local?
+*** This might make your system totally unusable, for details read the FAQ."
+  fi
+fi
+
+
+# One kFreeBSD we use ldconfig.
+use_ldconfig=yes
+
+# We need some extensions to the `ldd' script.
+changequote(,)
+case "$machine" in
+  x86_64*)
+    ldd_rewrite_script=../ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/x86_64/ldd-rewrite.sed
+    ;;
+  *)
+    ;;
+esac
+changequote([,])
+
+if test $host = $build; then
+  # If $prefix/include/{net,scsi} are symlinks, make install will
+  # clobber what they're linked to (probably a kernel tree).
+  # test -L ought to work on all Linux boxes.
+  if test "x$prefix" != xNONE; then
+    ac_prefix=$prefix
+  else
+    ac_prefix=$ac_default_prefix
+  fi
+  AC_MSG_CHECKING([for symlinks in ${ac_prefix}/include])
+  ac_message=
+  if test -L ${ac_prefix}/include/net; then
+    ac_message="$ac_message
+   ${ac_prefix}/include/net is a symlink"
+  fi
+  if test -L ${ac_prefix}/include/scsi; then
+    ac_message="$ac_message
+   ${ac_prefix}/include/scsi is a symlink"
+  fi
+  if test -n "$ac_message"; then
+    AC_MSG_ERROR([$ac_message
+\`make install' will destroy the target of the link(s).
+Delete the links and re-run configure, or better still, move the entire
+${ac_prefix}/include directory out of the way.])
+  else
+    AC_MSG_RESULT(ok)
+  fi
+fi
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/connect.c
@@ -0,0 +1,69 @@
+/* Copyright (C) 2005 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Aurelien Jarno <aurelien@aurel32.net>, 2005.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sys/socket.h>
+#include <sysdep.h>
+#include <sysdep-cancel.h>
+
+/* According to POSIX.1-2004 the len argument specifies the length of
+   the sockaddr structure pointed to by the addrarg argument. However
+   the FreeBSD kernel waits the actual length of the address stored
+   there. The code below emulate this behaviour.  */
+
+extern int __libc_sa_len (sa_family_t __af);
+extern int __libc_sa_len_internal (sa_family_t __af);
+
+extern int __syscall_connect (int fd, __CONST_SOCKADDR_ARG addr,
+			      socklen_t addrlen);
+libc_hidden_proto (__syscall_connect)
+
+/* Open a connection on socket FD to peer at ADDR (which LEN bytes long).
+   For connectionless socket types, just set the default address to send to
+   and the only address from which to accept transmissions.
+   Return 0 on success, -1 for errors.  */
+
+int
+__libc_connect (int fd, __CONST_SOCKADDR_ARG addr, socklen_t addrlen)
+{
+  socklen_t new_addrlen;
+
+#ifndef NOT_IN_libc
+  new_addrlen = INTUSE(__libc_sa_len) ((addr.__sockaddr__)->sa_family);
+#else
+  new_addrlen = __libc_sa_len ((addr.__sockaddr__)->sa_family);
+#endif
+
+  /* Only allow a smaller size, otherwise it could lead to
+    stack corruption */
+  if (new_addrlen < addrlen)
+    addrlen = new_addrlen;
+
+  /* We pass 3 arguments.  */
+  if (SINGLE_THREAD_P)
+    return INLINE_SYSCALL (connect, 3, fd, addr, addrlen);
+
+  int oldtype = LIBC_CANCEL_ASYNC ();
+  int result = INLINE_SYSCALL (connect, 3, fd, addr, addrlen);
+  LIBC_CANCEL_RESET (oldtype);
+  return result;
+}
+
+strong_alias (__libc_connect, __connect_internal)
+weak_alias (__libc_connect, __connect)
+weak_alias (__libc_connect, connect)
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/dl-execstack.c
@@ -0,0 +1,58 @@
+/* Stack executability handling for GNU dynamic linker.  Linux version.
+   Copyright (C) 2003, 2004 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <ldsodefs.h>
+#include <sys/mman.h>
+#include <errno.h>
+#include <libintl.h>
+#include <stdbool.h>
+#include <stackinfo.h>
+#include <caller.h>
+
+
+extern int __stack_prot attribute_relro attribute_hidden;
+
+
+int
+internal_function
+_dl_make_stack_executable (void **stack_endp)
+{
+  /* This gives us the highest/lowest page that needs to be changed.  */
+  uintptr_t page = ((uintptr_t) *stack_endp
+		    & -(intptr_t) GLRO(dl_pagesize));
+
+  /* Challenge the caller.  */
+  if (__builtin_expect (__check_caller (RETURN_ADDRESS (0),
+					allow_ldso|allow_libpthread) != 0, 0)
+      || __builtin_expect (*stack_endp != __libc_stack_end, 0))
+    return EPERM;
+
+  if (__builtin_expect (__mprotect ((void *) page, GLRO(dl_pagesize),
+				    __stack_prot) != 0, 0))
+    return errno;
+
+  /* Clear the address.  */
+  *stack_endp = NULL;
+
+  /* Remember that we changed the permission.  */
+  GL(dl_stack_flags) |= PF_X;
+
+  return 0;
+}
+rtld_hidden_def (_dl_make_stack_executable)
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/dl-machine.h
@@ -0,0 +1,31 @@
+/* Dynamic linker magic for glibc on FreeBSD kernel.
+   Copyright (C) 2006 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Aurelien Jarno <aurelien@aurel32.net>, 2006.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+/* Contrary to most kernels which use ELFOSABI_SYSV aka ELFOSABI_NONE,
+   FreeBSD uses ELFOSABI_FREEBSD for the OSABI field. */
+
+# define VALID_ELF_OSABI(osabi)		(osabi == ELFOSABI_FREEBSD)
+# define VALID_ELF_ABIVERSION(ver)	(ver == 0)
+# define VALID_ELF_HEADER(hdr,exp,size) \
+  memcmp (hdr,exp,size-2) == 0 \
+  && VALID_ELF_OSABI (hdr[EI_OSABI]) \
+  && VALID_ELF_ABIVERSION (hdr[EI_ABIVERSION])
+
+#include_next <dl-machine.h>
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/dl-osinfo.h
@@ -0,0 +1,120 @@
+/* Operating system specific code  for generic dynamic loader functions.
+   Copyright (C) 2006 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <string.h>
+#include <fcntl.h>
+#include <sys/sysctl.h>
+#include <sys/utsname.h>
+#include <kernel-features.h>
+
+#ifndef MIN
+# define MIN(a,b) (((a)<(b))?(a):(b))
+#endif
+
+#ifdef SHARED
+/* This is the function used in the dynamic linker to print the fatal error
+   message.  */
+static inline void
+__attribute__ ((__noreturn__))
+dl_fatal (const char *str)
+{
+  _dl_dprintf (2, str);
+  _exit (1);
+}
+#endif
+
+
+#define DL_SYSDEP_OSCHECK(FATAL) \
+  do {									      \
+    /* Test whether the kernel is new enough.  This test is only	      \
+       performed if the library is not compiled to run on all		      \
+       kernels.  */							      \
+    if (__KFREEBSD_KERNEL_VERSION > 0)					      \
+      {									      \
+	char bufmem[64];						      \
+	char *buf = bufmem;						      \
+	unsigned int version;						      \
+	int parts;							      \
+	char *cp;							      \
+	struct utsname uts;						      \
+									      \
+	/* Try the uname syscall */					      \
+	if (! __uname (&uts))					      	      \
+	  {							      	      \
+	    /* Now convert it into a number.  The string consists of at most  \
+	       three parts.  */						      \
+	    version = 0;						      \
+	    parts = 0;							      \
+            buf = uts.release;						      \
+	    cp = buf;							      \
+	    while ((*cp >= '0') && (*cp <= '9'))			      \
+	      {								      \
+	        unsigned int here = *cp++ - '0';			      \
+									      \
+	        while ((*cp >= '0') && (*cp <= '9'))			      \
+	          {							      \
+		    here *= 10;						      \
+		    here += *cp++ - '0';				      \
+	          }							      \
+									      \
+	        ++parts;						      \
+	        version *= 100;						      \
+	        version |= here;					      \
+									      \
+	        if (*cp++ != '.')					      \
+	          /* Another part following?  */			      \
+	          break;						      \
+	      }								      \
+									      \
+	    if (parts == 2)						      \
+	      version *= 100;						      \
+									      \
+	    if (parts == 1)						      \
+	      version *= 10000;						      \
+									      \
+	    /* Now we can test with the required version.  */		      \
+	    if (version < __KFREEBSD_KERNEL_VERSION)			      \
+	      /* Not sufficent.  */					      \
+	      FATAL ("FATAL: kernel too old\n");			      \
+									      \
+	    GLRO(dl_osversion) = version;				      \
+          }								      \
+      }									      \
+  } while (0)
+
+static inline uintptr_t __attribute__ ((always_inline))
+_dl_setup_stack_chk_guard (void)
+{
+  uintptr_t ret;
+#ifdef ENABLE_STACKGUARD_RANDOMIZE
+  int fd = __open ("/dev/urandom", O_RDONLY);
+  if (fd >= 0)
+    {
+      ssize_t reslen = __read (fd, &ret, sizeof (ret));
+      __close (fd);
+      if (reslen == (ssize_t) sizeof (ret))
+        return ret;
+    }
+#endif
+  ret = 0;
+  unsigned char *p = (unsigned char *) &ret;
+  p[sizeof (ret) - 1] = 255;
+  p[sizeof (ret) - 2] = '\n';
+  return ret;
+}
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/dl-sysdep.c
@@ -0,0 +1,31 @@
+/* Dynamic linker system dependencies for GNU/kFreeBSD.
+   Copyright (C) 2008 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+/* For SHARED, use the generic dynamic linker system interface code. */
+/* otherwise the code is in dl-support.c */
+
+#include <string.h>
+#include <fcntl.h>
+#include <unistd.h>
+#include <ldsodefs.h>
+#include <kernel-features.h>
+
+#ifdef SHARED
+# include <elf/dl-sysdep.c>
+#endif
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/fcntl.c
@@ -0,0 +1 @@
+#include <sysdeps/unix/sysv/linux/fcntl.c>
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/fhstat.c
@@ -0,0 +1,40 @@
+/* Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Bruno Haible <bruno@clisp.org>, 2002.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sys/mount.h>
+#include <sys/stat.h>
+#include <sysdep.h>
+
+#include "stat16conv.c"
+
+int
+__fhstat (const fhandle_t *fhp, struct stat *buf)
+{
+  struct stat16 buf16;
+
+  if (__syscall_fhstat (fhp, &buf16) < 0)
+    return -1;
+
+  /* Convert a 'struct stat16' to 'struct stat'.  */
+  stat16_to_stat (&buf16, buf);
+
+  return 0;
+}
+
+weak_alias (__fhstat, fhstat)
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/fhstat64.c
@@ -0,0 +1,38 @@
+/* Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Bruno Haible <bruno@clisp.org>, 2002.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sys/mount.h>
+#include <sys/stat.h>
+#include <sysdep.h>
+
+#include "stat16conv.c"
+
+int
+fhstat64 (const fhandle_t *fhp, struct stat64 *buf)
+{
+  struct stat16 buf16;
+
+  if (__syscall_fhstat (fhp, &buf16) < 0)
+    return -1;
+
+  /* Convert a 'struct stat16' to 'struct stat64'.  */
+  stat16_to_stat64 (&buf16, buf);
+
+  return 0;
+}
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/fhstatfs.c
@@ -0,0 +1,35 @@
+/* Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Petr Salinger, 2006.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sys/mount.h>
+
+#include "statfsconv.c"
+
+int
+fhstatfs (const fhandle_t *fhp, struct statfs *buf)
+{
+  struct statfs_fbsd5 kbuf;
+
+  if (__syscall_fhstatfs (fhp, &kbuf) < 0)
+    return -1;
+
+  statfs5_to_statfs (&kbuf, buf);
+
+  return 0;
+}
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/fhstatfs64.c
@@ -0,0 +1,36 @@
+/* Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Bruno Haible <bruno@clisp.org>, 2002.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sys/mount.h>
+
+#include "statfsconv.c"
+
+int
+fhstatfs64 (const fhandle_t *fhp, struct statfs64 *buf)
+{
+  struct statfs_fbsd5 kbuf;
+
+  if (__syscall_fhstatfs (fhp, &kbuf) < 0)
+    return -1;
+
+  /* Convert a 'struct statfs' to 'struct statfs64'.  */
+  statfs5_to_statfs64 (&kbuf, buf);
+
+  return 0;
+}
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/fstatfs.c
@@ -0,0 +1,38 @@
+/* Return information about the filesystem on which FD resides.
+   Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Petr Salinger, 2006.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sys/statfs.h>
+
+#include "statfsconv.c"
+
+/* Return information about the filesystem on which FD resides.  */
+int
+__fstatfs (int fd, struct statfs *buf)
+{
+  struct statfs_fbsd5 kbuf;
+
+  if (__syscall_fstatfs (fd, &kbuf) < 0)
+    return -1;
+
+  statfs5_to_statfs (&kbuf, buf);
+
+  return 0;
+}
+weak_alias (__fstatfs, fstatfs)
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/fstatfs64.c
@@ -0,0 +1,40 @@
+/* Return information about the filesystem on which FD resides.
+   Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Bruno Haible <bruno@clisp.org>, 2002.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sys/statfs.h>
+
+#include "statfsconv.c"
+
+/* Return information about the filesystem on which FD resides.  */
+int
+__fstatfs64 (int fd, struct statfs64 *buf)
+{
+  struct statfs_fbsd5 kbuf;
+
+  if (__syscall_fstatfs (fd, &kbuf) < 0)
+    return -1;
+
+  /* Convert a 'struct statfs' to 'struct statfs64'.  */
+  statfs5_to_statfs64 (&kbuf, buf);
+
+  return 0;
+}
+
+weak_alias (__fstatfs64, fstatfs64)
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/fstatvfs.c
@@ -0,0 +1,40 @@
+/* Return information about the filesystem on which FD resides.
+   Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Bruno Haible <bruno@clisp.org>, 2002.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sys/statvfs.h>
+#include <sys/statfs.h>
+
+#include "statfsconv.c"
+
+/* Return information about the filesystem on which FD resides.  */
+int
+fstatvfs (int fd, struct statvfs *buf)
+{
+  struct statfs_fbsd5 kbuf;
+
+  if (__syscall_fstatfs (fd, &kbuf) < 0)
+    return -1;
+
+  /* Convert a 'struct statfs' to 'struct statvfs'.  */
+  statfs5_to_statvfs (&kbuf, buf);
+
+  return 0;
+}
+libc_hidden_def (fstatvfs)
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/fstatvfs64.c
@@ -0,0 +1,41 @@
+/* Return information about the filesystem on which FD resides.
+   Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Bruno Haible <bruno@clisp.org>, 2002.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sys/statvfs.h>
+#include <sys/statfs.h>
+
+#include "statfsconv.c"
+
+/* Return information about the filesystem on which FD resides.  */
+int
+__fstatvfs64 (int fd, struct statvfs64 *buf)
+{
+  struct statfs_fbsd5 kbuf;
+
+  if (__syscall_fstatfs (fd, &kbuf) < 0)
+    return -1;
+
+  /* Convert a 'struct statfs' to 'struct statvfs64'.  */
+  statfs5_to_statvfs64 (&kbuf, buf);
+
+  return 0;
+}
+
+weak_alias (__fstatvfs64, fstatvfs64)
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/ftruncate.c
@@ -0,0 +1,41 @@
+/* Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Bruno Haible <bruno@clisp.org>, 2002.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <unistd.h>
+#include <sys/types.h>
+#include <sysdep.h>
+
+/* The real system call has a word of padding before the 64-bit off_t
+   argument.  */
+extern int __syscall_freebsd6_ftruncate (int __fd, int __unused1,
+				__off_t __length) __THROW;
+libc_hidden_proto (__syscall_freebsd6_ftruncate)
+
+int
+__ftruncate (int fd, __off_t length)
+{
+  /* We pass 2 arguments in 4 words.  */
+  return INLINE_SYSCALL (freebsd6_ftruncate, 2, fd, 0, length);
+}
+
+weak_alias (__ftruncate, ftruncate)
+
+/* 'ftruncate64' is the same as 'ftruncate', because __off64_t == __off_t.  */
+strong_alias (__ftruncate, __ftruncate64)
+weak_alias (__ftruncate64, ftruncate64)
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/ftruncate64.c
@@ -0,0 +1 @@
+/* 'ftruncate64' is the same as 'ftruncate', because __off64_t == __off_t.  */
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/fxstat.c
@@ -0,0 +1,48 @@
+/* fxstat using FreeBSD fstat, nfstat system calls.
+   Copyright (C) 1991,1995-1997,2000,2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <errno.h>
+#include <stddef.h>
+#include <sys/stat.h>
+#include <bp-checks.h>
+
+#include "stat16conv.c"
+
+int
+__fxstat (int vers, int fd, struct stat *buf)
+{
+  if (__builtin_expect (vers == _STAT_VER, 1))
+    {
+      struct stat16 buf16;
+      int result = __syscall_fstat (fd, __ptrvalue (&buf16));
+      if (result == 0)
+	stat16_to_stat (&buf16, buf);
+      return result;
+    }
+  else if (__builtin_expect (vers == _STAT_VER_stat, 1))
+    return __syscall_fstat (fd, CHECK_1 ((struct stat16 *) buf));
+  else
+    {
+      __set_errno (EINVAL);
+      return -1;
+    }
+}
+hidden_def (__fxstat)
+
+weak_alias (__fxstat, _fxstat)
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/fxstat64.c
@@ -0,0 +1,44 @@
+/* fxstat using FreeBSD fstat, nfstat system calls.
+   Copyright (C) 1991,1995-1997,2000,2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <errno.h>
+#include <stddef.h>
+#include <sys/stat.h>
+#include <bp-checks.h>
+
+#include "stat16conv.c"
+
+int
+__fxstat64 (int vers, int fd, struct stat64 *buf)
+{
+  if (__builtin_expect (vers == _STAT_VER, 1))
+    {
+      struct stat16 buf16;
+      int result = __syscall_fstat (fd, __ptrvalue (&buf16));
+      if (result == 0)
+	stat16_to_stat64 (&buf16, buf);
+      return result;
+    }
+  else
+    {
+      __set_errno (EINVAL);
+      return -1;
+    }
+}
+hidden_def (__fxstat64)
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/getcwd.c
@@ -0,0 +1,91 @@
+/* Determine current working directory.  FreeBSD version.
+   Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Bruno Haible <bruno@clisp.org>, 2002.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <errno.h>
+#include <limits.h>
+#include <stdlib.h>
+#include <string.h>
+#include <unistd.h>
+
+#include <sysdep.h>
+#include <bp-checks.h>
+
+/* The system calls only makes a lookup in the VFS cache, which can easily
+   fail.  Therefore we use the generic version as a fallback.  */
+extern int __syscall_getcwd (char *__unbounded buf, unsigned int size);
+libc_hidden_proto (__syscall_getcwd)
+
+static char *generic_getcwd (char *buf, size_t size) internal_function;
+
+char *
+__getcwd (char *buf, size_t size)
+{
+  char tmpbuf[PATH_MAX];
+
+  if (INLINE_SYSCALL (getcwd, 2, tmpbuf, PATH_MAX) >= 0)
+    {
+      size_t len = strlen (tmpbuf) + 1;
+
+      if (size == 0)
+	{
+	  if (__builtin_expect (buf != NULL, 0))
+	    {
+	      __set_errno (EINVAL);
+	      return NULL;
+	    }
+
+	  buf = (char *) malloc (len);
+	  if (__builtin_expect (buf == NULL, 0))
+	    {
+	      __set_errno (ENOMEM);
+	      return NULL;
+	    }
+	}
+      else
+	{
+	  if (size < len)
+	    {
+	      __set_errno (ERANGE);
+	      return NULL;
+	    }
+
+	  if (buf == NULL)
+	    {
+	      buf = (char *) malloc (size);
+	      if (__builtin_expect (buf == NULL, 0))
+		{
+		  __set_errno (ENOMEM);
+		  return NULL;
+		}
+	    }
+	}
+
+      memcpy (buf, tmpbuf, len);
+      return buf;
+    }
+  return generic_getcwd (buf, size);
+}
+
+weak_alias (__getcwd, getcwd)
+
+/* Get the code for the generic version.  */
+#define GETCWD_RETURN_TYPE	static char * internal_function
+#define __getcwd		generic_getcwd
+#include <sysdeps/posix/getcwd.c>
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/getdents.c
@@ -0,0 +1,90 @@
+/* Read directory entries, 3 argument function.  FreeBSD version.
+   Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Bruno Haible <bruno@clisp.org>, 2002.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <dirent.h>
+#include <sys/types.h>
+#include <errno.h>
+#include <sysdep.h>
+
+#if 1
+
+/* Use the 3-argument system call.  */
+
+extern int __syscall_getdents (int fd, char *buf, size_t nbytes);
+libc_hidden_proto (__syscall_getdents)
+
+/* Read directory entries from FD into BUF, reading at most NBYTES.
+   Returns the number of bytes read; zero when at end of directory; or
+   -1 for errors.  */
+ssize_t
+internal_function
+__getdents (int fd, char *buf, size_t nbytes)
+{
+  return __syscall_getdents (fd, buf, nbytes);
+}
+
+/* Export getdents().  Not an internal_function.  */
+ssize_t
+getdents (int fd, char *buf, size_t nbytes)
+{
+  return __syscall_getdents (fd, buf, nbytes);
+}
+
+#else
+
+/* Use the 4-argument system call.  */
+
+extern int __syscall_getdirentries (int fd, char *buf, unsigned int nbytes,
+				    long *basep);
+
+/* Read directory entries from FD into BUF, reading at most NBYTES.
+   Returns the number of bytes read; zero when at end of directory; or
+   -1 for errors.  */
+ssize_t
+internal_function
+__getdents (int fd, char *buf, size_t nbytes)
+{
+  /* On 64-bit platforms, the system call differs from this function
+     because it takes an 'unsigned int', not a 'size_t'.  */
+  unsigned int nbytes32;
+
+  nbytes32 = nbytes;
+  if (nbytes32 == nbytes)
+    return __syscall_getdirentries (fd, buf, nbytes32, NULL);
+  else
+    {
+      /* NBYTES is too large.  */
+      __set_errno (EINVAL);
+      return -1;
+    }
+}
+
+/* Export getdents().  Not an internal_function.  */
+ssize_t
+getdents (int fd, char *buf, size_t nbytes)
+{
+  return __getdents (fd, buf, nbytes);
+}
+
+#endif
+
+/* Since 'struct dirent64' == 'struct dirent', the functions '__getdents64'
+   and '__getdents' are equal.  */
+strong_alias (__getdents, __getdents64)
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/getdents64.c
@@ -0,0 +1 @@
+/* We have the function getdirentries64 in file getdirentries64.c.  */
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/getdirentries.c
@@ -0,0 +1,100 @@
+/* Read directory entries, 4 argument function.  FreeBSD version.
+   Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Bruno Haible <bruno@clisp.org>, 2002.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef GETDIRENTRIES
+# define GETDIRENTRIES getdirentries
+# define OFF_T off_t
+#endif
+
+#include <dirent.h>
+#include <sys/types.h>
+#include <unistd.h>
+#include <errno.h>
+#include <sysdep.h>
+
+#if 1
+
+/* Use the 4-argument system call.  */
+
+extern int __syscall_getdirentries (int fd, char *buf, unsigned int nbytes,
+				    long *basep);
+
+/* Read directory entries from FD into BUF, reading at most NBYTES.
+   Reading starts at offset *BASEP, and *BASEP is updated with the new
+   position after reading.  Returns the number of bytes read; zero when at
+   end of directory; or -1 for errors.  */
+/* FIXME: This is not what this function does.  It starts reading at the
+   current position of FD, not at *BASEP.  */
+ssize_t
+GETDIRENTRIES (int fd, char *buf, size_t nbytes, OFF_T *basep)
+{
+  /* On 32-bit platforms, the system call differs from this function because
+     it takes a 'long *', not an 'OFF_T *'.  On 64-bit platforms, the system
+     call differs from this function because it takes an 'unsigned int', not
+     a 'size_t'.  */
+  unsigned int nbytes32;
+
+  nbytes32 = nbytes;
+  if (nbytes32 == nbytes)
+    {
+      long base;
+      int result = __syscall_getdirentries (fd, buf, nbytes32, &base);
+
+      if (result >= 0 && basep != NULL)
+	*basep = base;
+      return result;
+    }
+  else
+    {
+      /* NBYTES is too large.  */
+      __set_errno (EINVAL);
+      return -1;
+    }
+}
+
+#else
+
+/* Use the 3-argument system call.  */
+
+extern int __syscall_getdents (int fd, char *buf, size_t nbytes);
+
+/* Read directory entries from FD into BUF, reading at most NBYTES.
+   Reading starts at offset *BASEP, and *BASEP is updated with the new
+   position after reading.  Returns the number of bytes read; zero when at
+   end of directory; or -1 for errors.  */
+/* FIXME: This is not what this function does.  It starts reading at the
+   current position of FD, not at *BASEP.  */
+ssize_t
+GETDIRENTRIES (int fd, char *buf, size_t nbytes, OFF_T *basep)
+{
+  OFF_T base = 0;
+  ssize_t result;
+
+  if (basep)
+    base = __lseek (fd, (off_t) 0, SEEK_CUR);
+
+  result = __syscall_getdents (fd, buf, nbytes);
+
+  if (basep && result >= 0)
+    *basep = base;
+  return result;
+}
+
+#endif
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/getdirentries64.c
@@ -0,0 +1,5 @@
+/* Since 'struct dirent64' == 'struct dirent', the functions 'getdirentries64'
+   and 'getdirentries' differ only in the type of the BASEP argument.  */
+#define GETDIRENTRIES getdirentries64
+#define OFF_T off64_t
+#include <getdirentries.c>
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/getfsstat.c
@@ -0,0 +1,49 @@
+/* Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Petr Salinger, 2006.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sys/mount.h>
+#include <alloca.h>
+
+#include "statfsconv.c"
+
+int
+__getfsstat (struct statfs *buf, long bufsize, int flags)
+{
+  long bufcount;
+  struct statfs_fbsd5 *tmpbuf;
+  int count, i;
+
+  if (bufsize < 0)
+    bufsize = 0;
+  bufcount = bufsize / sizeof (struct statfs);
+
+  if ((bufcount == 0) || (buf == NULL))
+    tmpbuf = NULL;
+  else
+    tmpbuf = alloca(bufcount * sizeof (struct statfs_fbsd5));
+
+  count = __syscall_getfsstat (tmpbuf, bufcount * sizeof (struct statfs_fbsd5), flags);
+  if (tmpbuf && count > 0)
+    for (i = count - 1; i >= 0; i--)
+      statfs5_to_statfs (&tmpbuf[i], &buf[i]);
+
+  return count;
+}
+
+weak_alias (__getfsstat, getfsstat)
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/getfsstat64.c
@@ -0,0 +1,49 @@
+/* Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Bruno Haible <bruno@clisp.org>, 2002.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sys/mount.h>
+#include <alloca.h>
+
+#include "statfsconv.c"
+
+int
+__getfsstat64 (struct statfs64 *buf, long bufsize, int flags)
+{
+  long bufcount;
+  struct statfs_fbsd5 *tmpbuf;
+  int count, i;
+
+  if (bufsize < 0)
+    bufsize = 0;
+  bufcount = bufsize / sizeof (struct statfs64);
+
+  if ((bufcount == 0) || (buf == NULL))
+    tmpbuf = NULL;
+  else
+    tmpbuf = alloca(bufcount * sizeof (struct statfs_fbsd5));
+
+  count = __syscall_getfsstat (tmpbuf, bufcount * sizeof (struct statfs_fbsd5), flags);
+  if (tmpbuf && count > 0)
+    for (i = count - 1; i >= 0; i--)
+      statfs5_to_statfs64 (&tmpbuf[i], &buf[i]);
+
+  return count;
+}
+
+weak_alias (__getfsstat64, getfsstat64)
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/gethostid.c
@@ -0,0 +1,37 @@
+/* Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Bruno Haible <bruno@clisp.org>, 2002.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <unistd.h>
+#include <sys/sysctl.h>
+
+/* Return the current machine's Internet number.  */
+long int
+gethostid (void)
+{
+  /* Fetch sysctl value of "kern.hostid".  */
+  int request[2] = { CTL_KERN, KERN_HOSTID };
+  int result;
+  size_t result_len = sizeof (result);
+
+  if (__sysctl (request, 2, &result, &result_len, NULL, 0) < 0)
+    /* Dummy result.  */
+    return 0;
+
+  return result;
+}
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/gethostname.c
@@ -0,0 +1,52 @@
+/* Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Bruno Haible <bruno@clisp.org>, 2002.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <unistd.h>
+#include <sys/sysctl.h>
+#include <errno.h>
+
+/* Put the name of the current host in no more than LEN bytes of NAME.
+   The result is null-terminated if LEN is large enough for the full
+   name and the terminator.  */
+
+int
+__gethostname (char *name, size_t len)
+{
+  /* Fetch the "kern.hostname" sysctl value.  */
+  int request[2] = { CTL_KERN, KERN_HOSTNAME };
+  size_t result_len = len;
+
+  if (__sysctl (request, 2, name, &result_len, NULL, 0) < 0)
+    {
+      if (errno == ENOMEM)
+	__set_errno (ENAMETOOLONG);
+      return -1;
+    }
+
+  if (result_len >= len)
+    {
+      __set_errno (ENAMETOOLONG);
+      return -1;
+    }
+
+  name[result_len] = '\0';
+  return 0;
+}
+
+weak_alias (__gethostname, gethostname)
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/getloadavg.c
@@ -0,0 +1,53 @@
+/* Get system load averages.  FreeBSD version.
+   Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Bruno Haible <bruno@clisp.org>, 2002.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <stdlib.h>
+#include <sys/sysctl.h>
+
+struct loadavg
+  {
+    unsigned int ldavg[3];
+    long fscale;
+  };
+
+/* Put the 1 minute, 5 minute and 15 minute load averages into the first
+   NELEM elements of LOADAVG.  Return the number written (never more than
+   three, but may be less than NELEM), or -1 if an error occurred.  */
+int
+getloadavg (double loadavg[], int nelem)
+{
+  if (nelem > 3)
+    nelem = 3;
+  if (nelem > 0)
+    {
+      /* Fetch the "vm.loadavg" sysctl value.  */
+      int request[2] = { CTL_VM, VM_LOADAVG };
+      struct loadavg result;
+      size_t result_len = sizeof (result);
+      int i;
+
+      if (__sysctl (request, 2, &result, &result_len, NULL, 0) < 0)
+	return -1;
+
+      for (i = 0; i < nelem; i++)
+	loadavg[i] = (double) result.ldavg[i] / (double) result.fscale;
+    }
+  return nelem;
+}
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/getlogin.c
@@ -0,0 +1,50 @@
+/* Non-reentrant function to return the current login name.  FreeBSD version.
+   Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Bruno Haible <bruno@clisp.org>, 2002.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <stdlib.h>
+#include <string.h>
+#include <unistd.h>
+#include <sys/param.h>
+#include <sysdep.h>
+
+/* Defined in getlogin_r.c.  */
+extern char *__getlogin_cache;
+extern char __getlogin_cache_room[MAXLOGNAME];
+
+extern int __syscall_getlogin (char *__name, size_t __name_len);
+libc_hidden_proto (__syscall_getlogin)
+
+/* Return the login name of the user, or NULL if it can't be determined.
+   The returned pointer, if not NULL, is good only until the next call.  */
+
+char *
+getlogin (void)
+{
+  if (__getlogin_cache == NULL)
+    {
+      if (INLINE_SYSCALL (getlogin, 2, __getlogin_cache_room, MAXLOGNAME) < 0)
+	return NULL;
+      /* The system call should return a NULL terminated name.  */
+      if (__memchr (__getlogin_cache_room, '\0', MAXLOGNAME) == NULL)
+	abort ();
+      __getlogin_cache = __getlogin_cache_room;
+    }
+  return (__getlogin_cache[0] ? __getlogin_cache : NULL);
+}
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/getlogin_r.c
@@ -0,0 +1,70 @@
+/* Reentrant function to return the current login name.  FreeBSD version.
+   Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Bruno Haible <bruno@clisp.org>, 2002.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <errno.h>
+#include <stdlib.h>
+#include <string.h>
+#include <unistd.h>
+#include <sys/param.h>
+#include <sysdep.h>
+
+/* Cache the system call's return value.  */
+char *__getlogin_cache;
+/* The kernel never returns more than MAXLOGNAME bytes, therefore we don't
+   need more than that either.  */
+char __getlogin_cache_room[MAXLOGNAME];
+
+extern int __syscall_getlogin (char *__name, size_t __name_len);
+libc_hidden_proto (__syscall_getlogin)
+
+/* Return at most NAME_LEN characters of the login name of the user in NAME.
+   If it cannot be determined or some other error occurred, return the error
+   code.  Otherwise return 0.
+   Note that the getlogin_r function in FreeBSD libc returns a 'char *',
+   but SUSV2 wants a return type of 'int'.  */
+
+int
+getlogin_r (char *name, size_t name_len)
+{
+  size_t len;
+
+  if (__getlogin_cache == NULL)
+    {
+      if (INLINE_SYSCALL (getlogin, 2, __getlogin_cache_room, MAXLOGNAME) < 0)
+	return -1;
+      /* The system call should return a NULL terminated name.  */
+      if (__memchr (__getlogin_cache_room, '\0', MAXLOGNAME) == NULL)
+	abort ();
+      __getlogin_cache = __getlogin_cache_room;
+    }
+
+  len = strlen (__getlogin_cache);
+  if (__builtin_expect (len < name_len, 1))
+    {
+      memcpy (name, __getlogin_cache, len + 1);
+      return 0;
+    }
+  else
+    {
+      __set_errno (ERANGE);
+      return -1;
+    }
+}
+libc_hidden_def (getlogin_r)
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/getmntinfo.c
@@ -0,0 +1,80 @@
+/* Return list of mounted filesystems.  FreeBSD version.
+   Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Bruno Haible <bruno@clisp.org>, 2002.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sys/mount.h>
+#include <stdlib.h>
+#include <errno.h>
+
+static int mntbufsize;
+static struct statfs *mntbuf;
+
+/* Return list of mounted filesystems.
+   Inherently not multithread-safe.  */
+int
+__getmntinfo (struct statfs **mntbufp, int flags)
+{
+  for (;;)
+    {
+      int count = __getfsstat (NULL, 0, flags);
+      int count2;
+
+      if (count < 0)
+	return 0;
+
+      if (count == 0)
+	{
+	  __set_errno (0);
+	  return 0;
+	}
+
+      if (count > mntbufsize)
+	{
+	  if (mntbuf != NULL)
+	    free (mntbuf);
+	  mntbufsize = 0;
+	  mntbuf = (struct statfs *) malloc (count * sizeof (struct statfs));
+	  if (mntbuf == NULL)
+	    {
+	      __set_errno (ENOMEM);
+	      return 0;
+	    }
+	  mntbufsize = count;
+	}
+
+      count2 = __getfsstat (mntbuf, count * sizeof (struct statfs), flags);
+
+      if (count2 < 0)
+	return 0;
+
+      if (count2 == 0)
+	{
+	  __set_errno (0);
+	  return 0;
+	}
+
+      if (count2 <= count)
+	{
+	  *mntbufp = mntbuf;
+	  return count2;
+	}
+    }
+}
+
+weak_alias (__getmntinfo, getmntinfo)
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/getmntinfo64.c
@@ -0,0 +1,78 @@
+/* Return list of mounted filesystems.  FreeBSD version.
+   Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Bruno Haible <bruno@clisp.org>, 2002.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sys/mount.h>
+#include <stdlib.h>
+#include <errno.h>
+
+static int mntbufsize;
+static struct statfs64 *mntbuf;
+
+/* Return list of mounted filesystems.
+   Inherently not multithread-safe.  */
+int
+getmntinfo64 (struct statfs64 **mntbufp, int flags)
+{
+  for (;;)
+    {
+      int count = __getfsstat64 (NULL, 0, flags);
+      int count2;
+
+      if (count < 0)
+	return 0;
+
+      if (count == 0)
+	{
+	  __set_errno (0);
+	  return 0;
+	}
+
+      if (count > mntbufsize)
+	{
+	  if (mntbuf != NULL)
+	    free (mntbuf);
+	  mntbufsize = 0;
+	  mntbuf = (struct statfs64 *) malloc (count * sizeof (struct statfs64));
+	  if (mntbuf == NULL)
+	    {
+	      __set_errno (ENOMEM);
+	      return 0;
+	    }
+	  mntbufsize = count;
+	}
+
+      count2 = __getfsstat64 (mntbuf, count * sizeof (struct statfs64), flags);
+
+      if (count2 < 0)
+	return 0;
+
+      if (count2 == 0)
+	{
+	  __set_errno (0);
+	  return 0;
+	}
+
+      if (count2 <= count)
+	{
+	  *mntbufp = mntbuf;
+	  return count2;
+	}
+    }
+}
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/getpagesize.c
@@ -0,0 +1,42 @@
+/* Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Bruno Haible <bruno@clisp.org>, 2002.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <unistd.h>
+#include <sys/sysctl.h>
+
+/* Return the system page size.  */
+int
+__getpagesize (void)
+{
+  static int cached_pagesize /* = 0 */;
+
+  if (cached_pagesize == 0)
+    {
+      /* Fetch sysctl value of "hw.pagesize".  */
+      int request[2] = { CTL_HW, HW_PAGESIZE };
+      size_t result_len = sizeof (cached_pagesize);
+
+      if (__sysctl (request, 2, &cached_pagesize, &result_len, NULL, 0) < 0)
+	return -1;
+    }
+  return cached_pagesize;
+}
+libc_hidden_def (__getpagesize)
+
+weak_alias (__getpagesize, getpagesize)
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/getpt.c
@@ -0,0 +1,92 @@
+/* Copyright (C) 1998-1999, 2000-2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <errno.h>
+#include <fcntl.h>
+#include <string.h>
+#include <unistd.h>
+#include <sys/ioctl.h>
+
+
+/* Prefix for master pseudo terminal nodes.  */
+#define _PATH_PTY "/dev/pty"
+
+
+/* Letters indicating a series of pseudo terminals.  */
+#ifndef PTYNAME1
+#define PTYNAME1 "pqrs"
+#endif
+const char __libc_ptyname1[] attribute_hidden = PTYNAME1;
+
+/* Letters indicating the position within a series.  */
+#ifndef PTYNAME2
+#define PTYNAME2 "0123456789abcdefghijklmnopqrstuv";
+#endif
+const char __libc_ptyname2[] attribute_hidden = PTYNAME2;
+
+
+/* Open a master pseudo terminal and return its file descriptor.  */
+int
+__posix_openpt (int oflag)
+{
+  char buf[sizeof (_PATH_PTY) + 2];
+  const char *p, *q;
+  char *s;
+
+  s = __mempcpy (buf, _PATH_PTY, sizeof (_PATH_PTY) - 1);
+  /* s[0] and s[1] will be filled in the loop.  */
+  s[2] = '\0';
+
+  for (p = __libc_ptyname1; *p != '\0'; ++p)
+    {
+      s[0] = *p;
+
+      for (q = __libc_ptyname2; *q != '\0'; ++q)
+	{
+	  int fd;
+
+	  s[1] = *q;
+
+	  fd = __open (buf, oflag);
+	  if (fd >= 0)
+	    {
+	      if (!(oflag & O_NOCTTY))
+		__ioctl (fd, TIOCSCTTY, NULL);
+
+	      return fd;
+	    }
+
+	  if (errno == ENOENT)
+	    return -1;
+	}
+    }
+
+  __set_errno (ENOENT);
+  return -1;
+}
+
+weak_alias (__posix_openpt, posix_openpt)
+
+
+int
+__getpt (void)
+{
+  return __posix_openpt (O_RDWR);
+}
+
+weak_alias (__getpt, getpt)
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/getrlimit64.c
@@ -0,0 +1 @@
+/* 'getrlimit64' is the same as 'getrlimit', because __rlim64_t == __rlim_t.  */
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/getsysstats.c
@@ -0,0 +1,108 @@
+/* Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Bruno Haible <bruno@clisp.org>, 2002.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sys/sysctl.h>
+#include <stddef.h>
+
+
+int
+__get_nprocs (void)
+{
+  /* Fetch sysctl value of "hw.ncpu".  */
+  int request[2] = { CTL_HW, HW_NCPU };
+  int result;
+  size_t result_len = sizeof (result);
+
+  if (__sysctl (request, 2, &result, &result_len, NULL, 0) < 0)
+    /* Dummy result.  */
+    return 1;
+
+  return result;
+}
+
+weak_alias (__get_nprocs, get_nprocs)
+
+
+int
+__get_nprocs_conf (void)
+{
+  /* We don't know how to distinguish between configured and active CPUs.  */
+  return __get_nprocs ();
+}
+
+weak_alias (__get_nprocs_conf, get_nprocs_conf)
+
+
+long int
+__get_phys_pages (void)
+{
+  /* Fetch sysctl value of "hw.physmem".  This is a little smaller than
+     the real installed memory size, but so what.  */
+  int request[2] = { CTL_HW, HW_PHYSMEM };
+  int result;
+  size_t result_len = sizeof (result);
+
+  if (__sysctl (request, 2, &result, &result_len, NULL, 0) < 0)
+    return -1;
+
+  return result;
+}
+
+weak_alias (__get_phys_pages, get_phys_pages)
+
+
+long int
+__get_avphys_pages (void)
+{
+#if 1
+  int result1;
+  int result2;
+  {
+    /* Fetch sysctl value of "vm.stats.vm.v_inactive_count".  */
+    size_t result_len = sizeof (result1);
+
+    if (__sysctlbyname ("vm.stats.vm.v_inactive_count", &result1, &result_len,
+			NULL, 0) < 0)
+      return -1;
+  }
+  {
+    /* Fetch sysctl value of "vm.stats.vm.v_free_count".  */
+    size_t result_len = sizeof (result2);
+
+    if (__sysctlbyname ("vm.stats.vm.v_free_count", &result2, &result_len,
+			NULL, 0) < 0)
+      return -1;
+  }
+
+  return result1 + result2;
+#else
+  /* This does not appear to work.  */
+  /* Fetch v_inactive_count field of sysctl value of "vm.vmmeter".  */
+  int request[2] = { CTL_VM, VM_METER };
+  struct vmmeter result;
+  size_t result_len = sizeof (result);
+
+  if (__sysctl (request, 2, &result, &result_len, NULL, 0) < 0)
+    return -1;
+
+  return result.v_inactive_count;
+#endif
+}
+
+weak_alias (__get_avphys_pages, get_avphys_pages)
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/glob.c
@@ -0,0 +1,3 @@
+/* 'glob64' is different from 'glob', because
+   'struct stat64' != 'struct stat'.  */
+#include <posix/glob.c>
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/glob64.c
@@ -0,0 +1,3 @@
+/* 'glob64' is different from 'glob', because
+   'struct stat64' != 'struct stat'.  */
+#include <sysdeps/gnu/glob64.c>
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/gtty.c
@@ -0,0 +1,2 @@
+/* use stub only variant */
+#include <misc/gtty.c>
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/i386/Makefile
@@ -0,0 +1,19 @@
+# Additional header files to be installed in $prefix/include:
+
+ifeq ($(subdir),misc)
+sysdep_headers += \
+ sys/io.h \
+ sys/perm.h \
+ sys/vm86.h
+endif
+
+# Additional functions, and particular system calls:
+
+ifeq ($(subdir),misc)
+# For <sys/io.h> and <sys/perm.h>.
+sysdep_routines += i386_get_ioperm i386_set_ioperm iopl
+# For <sys/vm86.h>.
+sysdep_routines += i386_vm86
+# For <machine/sysarch.h>.
+sysdep_routines += i386_get_ldt i386_set_ldt
+endif
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/i386/Versions
@@ -0,0 +1,7 @@
+libc {
+  GLIBC_2.2.6 {
+    i386_get_ioperm; i386_set_ioperm; i386_vm86;
+    ioperm; iopl;
+    i386_get_ldt; i386_set_ldt;
+  }
+}
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/i386/bits/mcontext.h
@@ -0,0 +1,111 @@
+/* Machine-dependent processor state structure for FreeBSD.
+   Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.  i386 version.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#if !defined _SYS_UCONTEXT_H
+# error "Never use <bits/mcontext.h> directly; include <sys/ucontext.h> instead."
+#endif
+
+/*-
+ * Copyright (c) 1999 Marcel Moolenaar
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer
+ *    in this position and unchanged.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * based on $FreeBSD: src/sys/i386/include/ucontext.h,v 1.10 2002/12/02 19:58:55 deischen Exp $
+ */
+
+/* Whole processor state.  */
+typedef struct
+  {
+    /*
+     * The first 20 fields must match the definition of
+     * sigcontext. So that we can support sigcontext
+     * and ucontext_t at the same time.
+     */
+
+    int mc_onstack;		/* Nonzero if running on sigstack.  */
+
+    /* Segment registers.  */
+    int mc_gs;
+    int mc_fs;
+    int mc_es;
+    int mc_ds;
+
+    /* "General" registers.  These members are in the order that the i386
+       `pusha' and `popa' instructions use (`popa' ignores %esp).  */
+    int mc_edi;
+    int mc_esi;
+    int mc_ebp;
+    int mc_isp;			/* Not used; sc_esp is used instead.  */
+    int mc_ebx;
+    int mc_edx;
+    int mc_ecx;
+    int mc_eax;
+
+    int mc_trapno;
+    int mc_err;
+
+    int mc_eip;			/* Instruction pointer.  */
+    int mc_cs;			/* Code segment register.  */
+
+    int mc_efl;			/* Processor flags.  */
+
+    int mc_esp;			/* This stack pointer is used.  */
+    int mc_ss;			/* Stack segment register.  */
+
+    int mc_len;			/* sizeof(mcontext_t) */
+#define	_MC_FPFMT_NODEV		0x10000	/* device not present or configured */
+#define	_MC_FPFMT_387		0x10001
+#define	_MC_FPFMT_XMM		0x10002
+    int mc_fpformat;
+#define	_MC_FPOWNED_NONE	0x20000	/* FP state not used */
+#define	_MC_FPOWNED_FPU		0x20001	/* FP state came from FPU */
+#define	_MC_FPOWNED_PCB		0x20002	/* FP state came from PCB */
+    int mc_ownedfp;
+    int mc_spare1[1];		/* align next field to 16 bytes */
+    /*
+     * See <machine/npx.h> for the internals of mc_fpstate[].
+     */
+    int mc_fpstate[128] __attribute__((aligned(16)));
+    int mc_spare2[8];
+  } mcontext_t;
+
+/* Traditional BSD names for some members.  */
+#define mc_eflags	mc_efl
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/i386/bits/sigcontext.h
@@ -0,0 +1,97 @@
+/* Machine-dependent signal context structure for FreeBSD.  i386 version.
+   Copyright (C) 1991-1992,1994,1997,2001-2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#if !defined _SIGNAL_H && !defined _SYS_UCONTEXT_H
+# error "Never use <bits/sigcontext.h> directly; include <signal.h> instead."
+#endif
+
+#ifndef _BITS_SIGCONTEXT_H
+#define _BITS_SIGCONTEXT_H  1
+
+/* State of this thread when the signal was taken.
+   The unions below are for compatibility with Linux (whose sigcontext
+   components don't have sc_ prefix) */
+struct sigcontext
+  {
+    __sigset_t 	sc_mask;		/* Blocked signals to restore.  */
+    int 	sc_onstack;		/* Nonzero if running on sigstack.  */
+
+    /* Segment registers.  */
+    union { int sc_gs; int gs; };
+    union { int sc_fs; int fs; };
+    union { int sc_es; int es; };
+    union { int sc_ds; int ds; };
+
+    /* "General" registers.  These members are in the order that the i386
+       `pusha' and `popa' instructions use (`popa' ignores %esp).  */
+    union { int sc_edi; int edi; };
+    union { int sc_esi; int esi; };
+    union { int sc_ebp; int ebp; };
+    union { int sc_isp; int isp; };		/* Not used; sc_esp is used instead.  */
+    union { int sc_ebx; int ebx; };
+    union { int sc_edx; int edx; };
+    union { int sc_ecx; int ecx; };
+    union { int sc_eax; int eax; };
+
+    union { int sc_trapno; int trapno; };
+    union { int sc_err; int err; };
+
+    union { int sc_eip; int eip; };		/* Instruction pointer.  */
+    union { int sc_cs; int cs; };		/* Code segment register.  */
+
+    union { int sc_efl; int eflags; }; 		/* Processor flags.  */
+
+    union { int sc_esp; int esp; };		/* This stack pointer is used.  */
+    union { int sc_ss; int ss; };		/* Stack segment register.  */
+
+    int     sc_len;                 /* sizeof(mcontext_t) */
+    /*
+     * XXX - See <machine/ucontext.h> and <machine/npx.h> for
+     *       the following fields.
+     */
+    int     sc_fpformat;
+    int     sc_ownedfp;
+    int     sc_spare1[1];
+    int     sc_fpstate[128] __attribute__((aligned(16)));
+    int     sc_spare2[8];
+  };
+
+/* Traditional BSD names for some members.  */
+#define sc_sp		sc_esp		/* Stack pointer.  */
+#define sc_fp		sc_ebp		/* Frame pointer.  */
+#define sc_pc		sc_eip		/* Process counter.  */
+#define sc_ps		sc_efl
+#define sc_eflags	sc_efl
+
+#if 1 /* FIXME: These need verification.  */
+
+/* Codes for SIGILL.  */
+#define ILL_PRIVIN_FAULT	1
+#define ILL_ALIGN_FAULT		14
+#define ILL_FPOP_FAULT		24
+
+/* Codes for SIGBUS.  */
+#define BUS_PAGE_FAULT		12
+#define BUS_SEGNP_FAULT		26
+#define BUS_STK_FAULT		27
+#define BUS_SEGM_FAULT		29
+
+#endif
+
+#endif /* _BITS_SIGCONTEXT_H */
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/i386/bits/time.h
@@ -0,0 +1,89 @@
+/* System-dependent timing definitions.  FreeBSD version.
+   Copyright (C) 1996-1997, 1999, 2000, 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+/*
+ * Never include this file directly; use <time.h> instead.
+ */
+
+#ifndef __need_timeval
+# ifndef _BITS_TIME_H
+#  define _BITS_TIME_H	1
+
+/* ISO/IEC 9899:1990 7.12.1: <time.h>
+   The macro `CLOCKS_PER_SEC' is the number per second of the value
+   returned by the `clock' function. */
+/* CAE XSH, Issue 4, Version 2: <time.h>
+   The value of CLOCKS_PER_SEC is required to be 1 million on all
+   XSI-conformant systems. */
+#  define CLOCKS_PER_SEC  1000000l
+
+#  if !defined __STRICT_ANSI__ && !defined __USE_XOPEN2K
+/* Even though CLOCKS_PER_SEC has such a strange value CLK_TCK
+   presents the real value for clock ticks per second for the system.  */
+#   define CLK_TCK 128
+#  endif
+
+#  ifdef __USE_POSIX199309
+/* Identifier for system-wide realtime clock.  */
+#   define CLOCK_REALTIME		0
+/* High-resolution timer from the CPU.  */
+#   define CLOCK_PROCESS_CPUTIME_ID	2
+/* Thread-specific CPU-time clock.  */
+#   define CLOCK_THREAD_CPUTIME_ID	3
+/* Monotonic system-wide clock.  */
+#   define CLOCK_MONOTONIC		4
+/* These are BSD specific clocks.  */
+#   ifdef __USE_BSD
+#    define CLOCK_VIRTUAL		1
+#    define CLOCK_PROF			2
+#   endif
+
+/* Flag to indicate time is absolute.  */
+#   define TIMER_ABSTIME		1
+#  endif
+
+
+/* Getkerninfo clock information structure */
+struct clockinfo
+  {
+    int hz;		/* clock frequency */
+    int tick;		/* micro-seconds per hz tick */
+    int spare;
+    int stathz;		/* statistics clock frequency */
+    int profhz;		/* profiling clock frequency */
+  };
+
+# endif	/* bits/time.h */
+#endif
+
+#ifdef __need_timeval
+# undef __need_timeval
+# ifndef _STRUCT_TIMEVAL
+#  define _STRUCT_TIMEVAL	1
+#  include <bits/types.h>
+
+/* A time value that is accurate to the nearest
+   microsecond but also has a range of years.  */
+struct timeval
+  {
+    __time_t tv_sec;		/* Seconds.  */
+    __suseconds_t tv_usec;	/* Microseconds.  */
+  };
+# endif	/* struct timeval */
+#endif	/* need timeval */
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/i386/dl-machine.h
@@ -0,0 +1,124 @@
+/* Machine-dependent ELF dynamic relocation inline functions.
+   FreeBSD i386 specific version of dl_platform_init()
+   Copyright (C) 2006 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Petr Salinger, 2006.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+
+/* For FreeBSD we redefine an initialization function.
+   This is called very early in dl_sysdep_start.  */
+
+#include_next <dl-machine.h>
+
+#undef  DL_PLATFORM_INIT
+#define DL_PLATFORM_INIT dl_platform_kfreebsd_i386_init ()
+
+#ifndef _DL_MACHINE_KFREEBSD
+#define _DL_MACHINE_KFREEBSD
+
+#define X86_EFLAGS_AC   0x00040000 /* Alignment Check */
+#define X86_EFLAGS_ID   0x00200000 /* CPUID detection flag */
+
+static inline int try_flip_flags(int val)
+{
+    int ret;
+    __asm__(
+	"pushfl\n\t"
+	"pushfl\n\t"
+	"popl %%ecx\n\t"
+	"xorl %%ecx,%%eax\n\t"
+	"pushl %%eax\n\t"
+	"popfl\n\t"
+	"pushfl\n\t"
+	"popl %%eax\n\t"
+	"xorl %%ecx,%%eax\n\t"
+	"popfl\n\t"
+	: "=a" (ret)
+	: "0" (val)
+        : "cx"
+    );
+    return ret;
+}
+
+static inline void cpuid(int op, int *eax, int *edx)
+{
+    __asm__(
+	"push %%ebx\n\t"
+	"cpuid\n\t"
+	"pop %%ebx\n\t"
+	: "=a" (*eax),
+	  "=d" (*edx)
+	: "0" (op)
+	: "cx"
+    );
+}
+
+static inline void __attribute__ ((unused))
+dl_platform_kfreebsd_i386_init (void)
+{
+    if ((GLRO(dl_platform) == NULL) || (*GLRO(dl_platform) == '\0'))
+    {
+	/* we don't have reasonable AT_PLATFORM from kernel
+	   try to use cpuid to get one, also guess AT_HWCAP */
+
+	int val, hwcap;
+
+	val = try_flip_flags(X86_EFLAGS_AC | X86_EFLAGS_ID);
+
+	if (!(val & X86_EFLAGS_AC))
+	{
+		/* 386 */
+		GLRO(dl_platform) = GLRO(dl_x86_platforms)[0];
+		GLRO(dl_hwcap) = 0;
+	}
+	else if (!(val & X86_EFLAGS_ID))
+	{
+		/* 486 */
+		GLRO(dl_platform) = GLRO(dl_x86_platforms)[1];
+		GLRO(dl_hwcap) = 0;
+	}
+	else
+	{
+	    cpuid(0, &val, &hwcap);
+	    if (val == 0)
+	    {
+		/* 486 */
+		GLRO(dl_platform) = GLRO(dl_x86_platforms)[1];
+		GLRO(dl_hwcap) = 0;
+	    }
+	    else
+	    {
+		cpuid(1, &val, &hwcap);
+		GLRO(dl_hwcap) = hwcap;
+		switch (val & 0xf00)
+		{
+		case 0x400: /* 486 */
+			GLRO(dl_platform) = GLRO(dl_x86_platforms)[1];
+		break;
+		case 0x500: /* 586 */
+			GLRO(dl_platform) = GLRO(dl_x86_platforms)[2];
+		break;
+		default:    /* 686 */
+			GLRO(dl_platform) = GLRO(dl_x86_platforms)[3];
+		}
+            }
+	}
+    }
+}
+
+#endif
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/i386/dl-procinfo.h
@@ -0,0 +1 @@
+#include <sysdeps/unix/sysv/linux/i386/dl-procinfo.h>
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/i386/get_clockfreq.c
@@ -0,0 +1 @@
+#include <sysdeps/unix/sysv/linux/i386/get_clockfreq.c>
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/i386/getcontext.S
@@ -0,0 +1,38 @@
+/* Save current context.
+   Copyright (C) 2006 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sysdep.h>
+
+.text
+ENTRY(__getcontext)
+        clc
+        movl 0(%esp), %ecx	/* save the return PC value */
+
+        DO_CALL (getcontext, 1)
+        jb SYSCALL_ERROR_LABEL
+
+        addl $4, %esp		/* remove stale return address */
+        jmp  *%ecx
+
+L(pseudo_end):
+	ret
+
+PSEUDO_END(__getcontext)
+
+weak_alias(__getcontext, getcontext)
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/i386/i386_get_ioperm.c
@@ -0,0 +1,36 @@
+/* Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sys/perm.h>
+#include <sysarch.h>
+
+int
+i386_get_ioperm (unsigned long int from, unsigned long int *num, int *turned_on)
+{
+  struct i386_ioperm_args args;
+
+  args.start = from;
+
+  if (__sysarch (I386_GET_IOPERM, &args) < 0)
+    return -1;
+
+  *num = args.length;
+  *turned_on = args.enable;
+
+  return 0;
+}
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/i386/i386_get_ldt.c
@@ -0,0 +1,38 @@
+/* Copyright (C) 2006 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   Contributed by Robert Millan  <robertmh@gnu.org>
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sys/cdefs.h>
+#include <machine/segments.h>
+#include <machine/sysarch.h>
+
+int
+i386_get_ldt (int from, union descriptor *descs, int num)
+{
+  struct i386_ldt_args args;
+
+  args.start = from;
+  args.descs = descs;
+  args.num = num;
+
+  if (__sysarch (I386_GET_LDT, &args) < 0)
+    return -1;
+
+  return 0;
+}
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/i386/i386_set_ioperm.c
@@ -0,0 +1,34 @@
+/* Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sys/perm.h>
+#include <sysarch.h>
+
+int
+i386_set_ioperm (unsigned long int from, unsigned long int num, int turn_on)
+{
+  struct i386_ioperm_args args;
+
+  args.start = from;
+  args.length = num;
+  args.enable = turn_on;
+
+  return __sysarch (I386_SET_IOPERM, &args);
+}
+
+strong_alias (i386_set_ioperm, ioperm)
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/i386/i386_set_ldt.c
@@ -0,0 +1,38 @@
+/* Copyright (C) 2006 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   Contributed by Robert Millan  <robertmh@gnu.org>
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sys/cdefs.h>
+#include <machine/segments.h>
+#include <machine/sysarch.h>
+
+int
+i386_set_ldt (int from, union descriptor *descs, int num)
+{
+  struct i386_ldt_args args;
+
+  args.start = from;
+  args.descs = descs;
+  args.num = num;
+
+  if (__sysarch (I386_SET_LDT, &args) < 0)
+    return -1;
+
+  return 0;
+}
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/i386/i386_vm86.c
@@ -0,0 +1,31 @@
+/* Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sys/vm86.h>
+#include <sysarch.h>
+
+int
+i386_vm86 (int cmd, void *arg)
+{
+  struct i386_vm86_args args;
+
+  args.sub_op = cmd;
+  args.sub_args = arg;
+
+  return __sysarch (I386_VM86, &args);
+}
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/i386/i486/linuxthreads/pt-machine.h
@@ -0,0 +1,8 @@
+
+/* i486+ is almost same as plain i386 version */
+#include_next <pt-machine.h>
+
+/* but compare-and-swap is always available  */
+
+#undef TEST_FOR_COMPARE_AND_SWAP
+
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/i386/i586/linuxthreads/pt-machine.h
@@ -0,0 +1,8 @@
+
+/* i486+ is almost same as plain i386 version */
+#include_next <pt-machine.h>
+
+/* but compare-and-swap is always available  */
+
+#undef TEST_FOR_COMPARE_AND_SWAP
+
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/i386/i686/linuxthreads/pt-machine.h
@@ -0,0 +1,8 @@
+
+/* i486+ is almost same as plain i386 version */
+#include_next <pt-machine.h>
+
+/* but compare-and-swap is always available  */
+
+#undef TEST_FOR_COMPARE_AND_SWAP
+
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/i386/iopl.c
@@ -0,0 +1,54 @@
+/* Copyright (C) 2004 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Robert Millan <robertmh@gnu.org>
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <errno.h>
+#include <fcntl.h>	/* open */
+#include <unistd.h>	/* close */
+
+static int __iopl_fd = -1;
+
+int
+iopl (int level)
+  {
+    switch (level)
+      {
+        case 3:
+          if (__iopl_fd != -1)
+            return 0;
+
+          __iopl_fd = open ("/dev/io", O_RDWR);
+          if (__iopl_fd == -1)
+            {
+              if (errno == EACCES)
+                __set_errno (EPERM);
+              return -1;
+            }
+          return 0;
+
+        case 0:
+          if (__iopl_fd != -1)
+            if (close (__iopl_fd) == -1)
+              return 1;
+          return 0;
+
+        default:
+          __set_errno (EINVAL);
+          return -1;
+      }
+  }
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/i386/ldconfig.h
@@ -0,0 +1,37 @@
+/* Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sysdeps/generic/ldconfig.h>
+
+#define SYSDEP_KNOWN_INTERPRETER_NAMES \
+  { "/lib/ld.so.1", FLAG_ELF_LIBC6 },				\
+  { "/libexec/ld-elf.so.1", FLAG_ELF_LIBC5 },
+
+#define SYSDEP_KNOWN_LIBRARY_NAMES \
+  { "libc.so.0.1", FLAG_ELF_LIBC6 },				\
+  { "libm.so.1", FLAG_ELF_LIBC6 },				\
+  { "libc.so.4", FLAG_ELF_LIBC5 },				\
+  { "libm.so.4", FLAG_ELF_LIBC5 },				\
+  { "libc.so.5", FLAG_ELF_LIBC5 },				\
+  { "libm.so.5", FLAG_ELF_LIBC5 },				\
+  { "libc.so.6", FLAG_ELF_LIBC5 },				\
+  { "libm.so.6", FLAG_ELF_LIBC5 },				\
+  { "libc.so.7", FLAG_ELF_LIBC5 },				\
+  { "libm.so.7", FLAG_ELF_LIBC5 },				\
+  { "libc.so.8", FLAG_ELF_LIBC5 },				\
+  { "libm.so.8", FLAG_ELF_LIBC5 },
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/i386/linuxthreads/pt-machine.h
@@ -0,0 +1,76 @@
+/* Machine-dependent pthreads configuration and inline functions.
+   ix86 version for FreeBSD.
+   Copyright (C) 1996-2001, 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Petr Salinger, 2005.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public License as
+   published by the Free Software Foundation; either version 2.1 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+#ifndef _FREEBSD_PT_MACHINE_H
+#define _FREEBSD_PT_MACHINE_H   1
+
+/*
+  some parts are common with linux/i386 version
+
+  linux specific parts should be in
+  linuxthreads/sysdeps/unix/sysv/linux/i386/
+  but they are included directly in
+  linuxthreads/sysdeps/i386/
+
+  so include them
+
+ */
+
+#include <linuxthreads/sysdeps/i386/pt-machine.h>
+#include <linuxthreads/sysdeps/i386/useldt.h>
+
+/* hack them */
+
+#ifndef __ASSEMBLER__
+
+#undef INIT_THREAD_SELF
+#undef FREE_THREAD
+
+/* The P4 and above really want some help to prevent overheating.  */
+#define BUSY_WAIT_NOP   __asm__ ("rep; nop")
+
+/* and add few FreeBSD specifics */
+
+#include <sysarch.h>
+
+/* Initialize the thread-unique value. */
+
+#define INIT_THREAD_SELF(descr, nr)		\
+{						\
+  long tmp;					\
+  tmp = (long) descr;				\
+  if (sysarch(I386_SET_GSBASE, &tmp)  != 0)	\
+  {						\
+    abort();					\
+  }						\
+}
+
+#define FREE_THREAD(descr, nr) do { } while (0)
+
+#endif /* __ASSEMBLER__ */
+
+/* We want the OS to assign stack addresses.  */
+#define FLOATING_STACKS 1
+
+/* Maximum size of the stack if the rlimit is unlimited.  */
+#define ARCH_STACK_MAX_SIZE     8*1024*1024
+
+#endif /* _FREEBSD_PT_MACHINE_H  */
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/i386/linuxthreads/sysdep-cancel.h
@@ -0,0 +1,166 @@
+/* Copyright (C) 2002, 2003, 2004 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Jakub Jelinek <jakub@redhat.com>, 2002.
+   Modification for FreeBSD by Petr Salinger, 2005.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sysdep.h>
+#include <tls.h>
+#include <pt-machine.h>
+#ifndef __ASSEMBLER__
+# include <linuxthreads/internals.h>
+#endif
+
+#if !defined NOT_IN_libc || defined IS_IN_libpthread || defined IS_IN_librt
+
+# undef PSEUDO
+# define PSEUDO(name, syscall_name, args)				      \
+  .text;								      \
+  ENTRY (name)								      \
+    SINGLE_THREAD_P;							      \
+    jne L(pseudo_cancel);						      \
+    DO_CALL (syscall_name, args);					      \
+    jb SYSCALL_ERROR_LABEL;						      \
+    ret;								      \
+  L(pseudo_cancel):							      \
+    CENABLE								      \
+    movl %eax, %ecx;							      \
+    movl $SYS_ify (syscall_name), %eax;					      \
+    int $0x80;								      \
+    PUSHRESULT;							      	      \
+    movl %ecx, %eax; 							      \
+    CDISABLE;							 	      \
+    POPRESULT;							      	      \
+    jb SYSCALL_ERROR_LABEL;						      \
+  L(pseudo_end):
+
+/*
+  on FreeBSD some syscalls return result in pair edx+eax,
+  therefore proper way would be
+
+# define PUSHRESULT	pushl %edx; pushl %eax; pushfl
+# define POPRESULT	popfl; popl %eax; popl %edx
+
+  for FreeBSD 5.4 affected syscalls are
+
+	lseek()
+	fork()
+	vfork()
+	rfork()
+	pipe()
+
+   none of them is cancelable, therefore
+*/
+
+# define PUSHRESULT	pushl %eax; cfi_adjust_cfa_offset (4);  pushfl;    cfi_adjust_cfa_offset (4)
+# define POPRESULT	popfl;      cfi_adjust_cfa_offset (-4); popl %eax; cfi_adjust_cfa_offset (-4)
+
+# ifdef IS_IN_libpthread
+#  define CENABLE	call __pthread_enable_asynccancel;
+#  define CDISABLE	call __pthread_disable_asynccancel
+# elif defined IS_IN_librt
+#  ifdef PIC
+#   define CENABLE	pushl %ebx; \
+			cfi_adjust_cfa_offset (4); \
+			cfi_rel_offset (ebx, 0); \
+			call __i686.get_pc_thunk.bx; \
+			addl     $_GLOBAL_OFFSET_TABLE_, %ebx; \
+			call __librt_enable_asynccancel@PLT; \
+			popl %ebx; \
+			cfi_adjust_cfa_offset (-4); \
+			cfi_restore (ebx);
+#   define CDISABLE	pushl %ebx; \
+			cfi_adjust_cfa_offset (4); \
+			cfi_rel_offset (ebx, 0); \
+			call __i686.get_pc_thunk.bx; \
+			addl     $_GLOBAL_OFFSET_TABLE_, %ebx; \
+			call __librt_disable_asynccancel@PLT; \
+			popl %ebx; \
+			cfi_adjust_cfa_offset (-4); \
+			cfi_restore (ebx);
+#  else
+#   define CENABLE	call __librt_enable_asynccancel;
+#   define CDISABLE	call __librt_disable_asynccancel
+#  endif
+# else
+#  define CENABLE	call __libc_enable_asynccancel;
+#  define CDISABLE	call __libc_disable_asynccancel
+# endif
+
+#if !defined NOT_IN_libc
+# define __local_multiple_threads __libc_multiple_threads
+#elif defined IS_IN_libpthread
+# define __local_multiple_threads __pthread_multiple_threads
+#else
+# define __local_multiple_threads __librt_multiple_threads
+#endif
+
+# ifndef __ASSEMBLER__
+#  if defined FLOATING_STACKS && USE___THREAD && defined PIC
+#   define SINGLE_THREAD_P \
+  __builtin_expect (THREAD_GETMEM (THREAD_SELF,				      \
+				   p_header.data.multiple_threads) == 0, 1)
+#  else
+extern int __local_multiple_threads
+#   if !defined NOT_IN_libc || defined IS_IN_libpthread
+  attribute_hidden;
+#   else
+  ;
+#   endif
+#   define SINGLE_THREAD_P __builtin_expect (__local_multiple_threads == 0, 1)
+#  endif
+# else
+#  if !defined PIC
+#   define SINGLE_THREAD_P cmpl $0, __local_multiple_threads
+#  elif defined FLOATING_STACKS && USE___THREAD
+#   define SINGLE_THREAD_P cmpl $0, %gs:MULTIPLE_THREADS_OFFSET
+#  else
+#   if !defined NOT_IN_libc || defined IS_IN_libpthread
+#    define __SINGLE_THREAD_CMP cmpl $0, __local_multiple_threads@GOTOFF(%ecx)
+#   else
+#    define __SINGLE_THREAD_CMP \
+  movl __local_multiple_threads@GOT(%ecx), %ecx;\
+  cmpl $0, (%ecx)
+#   endif
+#   if !defined HAVE_HIDDEN || !USE___THREAD
+#    define SINGLE_THREAD_P \
+  SETUP_PIC_REG (cx);				\
+  addl $_GLOBAL_OFFSET_TABLE_, %ecx;		\
+  __SINGLE_THREAD_CMP
+#   else
+#    define SINGLE_THREAD_P \
+  call __i686.get_pc_thunk.cx;			\
+  addl $_GLOBAL_OFFSET_TABLE_, %ecx;		\
+  __SINGLE_THREAD_CMP
+#   endif
+#  endif
+# endif
+
+#elif !defined __ASSEMBLER__
+
+/* This code should never be used but we define it anyhow.  */
+# define SINGLE_THREAD_P (1)
+# define NO_CANCELLATION 1
+
+#endif
+
+#ifndef __ASSEMBLER__
+# define RTLD_SINGLE_THREAD_P \
+  __builtin_expect (THREAD_GETMEM (THREAD_SELF, \
+                                     p_header.data.multiple_threads) == 0, 1)
+#endif
+
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/i386/linuxthreads/tls.h
@@ -0,0 +1,93 @@
+/* Definition for thread-local data handling.  linuxthreads/i386 version.
+   Copyright (C) 2002, 2003, 2004 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Modification for FreeBSD by Petr Salinger, 2005.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _FREEBSD_TLS_H
+#define _FREEBSD_TLS_H
+
+#include <linuxthreads/sysdeps/i386/tls.h>
+
+/* We can support TLS only if the floating-stack support is available.
+   To avoid bothering with the TLS support code at all,
+   use configure --without-tls.
+
+   We need USE_TLS to be consistently defined, for ldsodefs.h conditionals.
+   But some of the code below can cause problems in building libpthread
+*/
+
+#if defined HAVE_TLS_SUPPORT \
+    && (defined FLOATING_STACKS || !defined IS_IN_libpthread)
+
+# ifndef __ASSEMBLER__
+
+#undef TLS_INIT_TP
+#undef TLS_SETUP_GS_SEGMENT
+
+#include <sysarch.h>
+#include <sys/syscall.h>
+
+
+/* Code to initially initialize the thread pointer.  This might need
+   special attention since 'errno' is not yet available and if the
+   operation can cause a failure 'errno' must not be touched. */
+
+#  define TLS_DO_SET_GSBASE(descr)		\
+({                                      	\
+  long base = (long) descr;             	\
+  int result;                           	\
+  asm volatile (                        	\
+                "pushl %3\n\t"          	\
+                "pushl %2\n\t"          	\
+                "pushl %1\n\t"       		\
+                "int $0x80\n\t"         	\
+                "popl %3\n\t"        		\
+                "popl %3\n\t"        		\
+                "popl %3\n\t"        		\
+                : "=a" (result)         	\
+                : "0" (SYS_sysarch),     	\
+                  "i" (I386_SET_GSBASE),       	\
+                  "d" (&base)			\
+                : "memory", "cc" );    		\
+  result;                                       \
+})
+
+#   define TLS_SETUP_GS_SEGMENT(descr, secondcall)                            \
+  (TLS_DO_SET_GSBASE(descr)                                                   \
+   ? "set_thread_area failed when setting up thread-local storage\n" : NULL)
+
+/*   The value of this macro is null if successful, or an error string.  */
+
+#  define TLS_INIT_TP(descr, secondcall)				      \
+  ({									      \
+    void *_descr = (descr);						      \
+    tcbhead_t *head = _descr;						      \
+									      \
+    head->tcb = _descr;							      \
+    /* For now the thread descriptor is at the same address.  */	      \
+    head->self = _descr;						      \
+									      \
+    INIT_SYSINFO;							      \
+    TLS_SETUP_GS_SEGMENT (_descr, secondcall);				      \
+  })
+
+# endif /* __ASSEMBLER__ */
+
+#endif	/* HAVE_TLS_SUPPORT && (FLOATING_STACKS || !IS_IN_libpthread) */
+
+#endif	/* _FREEBSD_TLS_H */
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/i386/makecontext.S
@@ -0,0 +1,113 @@
+/* Create new context.
+   Copyright (C) 2001,02 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Ulrich Drepper <drepper@redhat.com>, 2001.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sysdep.h>
+
+#include <ucontext_i.h>
+
+
+ENTRY(__makecontext)
+	movl	4(%esp), %eax
+
+	/* Load the address of the function we are supposed to run.  */
+	movl	8(%esp), %ecx
+
+	/* Compute the address of the stack.  The information comes from
+	   to us_stack element.  */
+	movl	oSS_SP(%eax), %edx
+	movl	%ecx, oEIP(%eax)
+	addl	oSS_SIZE(%eax), %edx
+
+	/* Put the next context on the new stack (from the uc_link
+	   element).  */
+	movl	oLINK(%eax), %ecx
+	movl	%ecx, -4(%edx)
+
+	/* Remember the number of parameters for the exit handler since
+	   it has to remove them.  We store the number in the EBX register
+	   which the function we will call must preserve.  */
+	movl	12(%esp), %ecx
+	movl	%ecx, oEBX(%eax)
+
+	/* Make room on the new stack for the parameters.  */
+	negl	%ecx
+	leal	-8(%edx,%ecx,4), %edx
+	negl	%ecx
+	/* Store the future stack pointer.  */
+	movl	%edx, oESP(%eax)
+
+	/* Copy all the parameters.  */
+	jecxz	2f
+1:	movl	12(%esp,%ecx,4), %eax
+	movl	%eax, (%edx,%ecx,4)
+	decl	%ecx
+	jnz	1b
+2:
+
+	/* If the function we call returns we must continue with the
+	   context which is given in the uc_link element.  To do this
+	   set the return address for the function the user provides
+	   to a little bit of helper code which does the magic (see
+	   below).  */
+#ifdef PIC
+	call	1f
+1:	popl	%ecx
+	addl	$L(exitcode)-1b, %ecx
+	movl	%ecx, (%edx)
+#else
+	movl	$L(exitcode), (%edx)
+#endif
+	/* 'makecontext' returns no value.  */
+	ret
+
+	/* This is the helper code which gets called if a function which
+	   is registered with 'makecontext' returns.  In this case we
+	   have to install the context listed in the uc_link element of
+	   the context 'makecontext' manipulated at the time of the
+	   'makecontext' call.  If the pointer is NULL the process must
+	   terminate.  */
+L(exitcode):
+	/* This removes the parameters passed to the function given to
+	   'makecontext' from the stack.  EBX contains the number of
+	   parameters (see above).  */
+	leal	(%esp,%ebx,4), %esp
+
+#ifdef	PIC
+	call	1f
+1:	popl	%ebx
+	addl	$_GLOBAL_OFFSET_TABLE_+[.-1b], %ebx
+#endif
+	popl	%eax			/* This is the next context.  */
+	testl	%eax, %eax
+	je	2f			/* If it is zero exit.  */
+
+	pushl	%eax
+	call	JUMPTARGET(__setcontext)
+	/* If this returns (which can happen if the syscall fails) we'll
+	   exit the program with the return error value (-1).  */
+
+2:	pushl	%eax
+	call	HIDDEN_JUMPTARGET(exit)
+	/* The 'exit' call should never return.  In case it does cause
+	   the process to terminate.  */
+	hlt
+END(__makecontext)
+
+weak_alias(__makecontext, makecontext)
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/i386/rfork.S
@@ -0,0 +1,44 @@
+/* Copyright (C) 1991-1992, 1994-1995, 1997, 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sysdep.h>
+
+.text;
+ENTRY (__rfork)
+	/* save the return PC value into ECX,
+	   preserve stack frame with argument  */
+	movl 0(%esp), %ecx;
+	DO_CALL (rfork, 1)
+	jb SYSCALL_ERROR_LABEL;
+	/* R1 is now 0 for the parent and 1 for the child.  Decrement it to
+	   make it -1 (all bits set) for the parent, and 0 (no bits set)
+	   for the child.  Then AND it with R0, so the parent gets
+	   R0&-1==R0, and the child gets R0&0==0.  */
+	decl %edx
+	andl %edx, %eax
+
+	popl %edx
+	cfi_adjust_cfa_offset(-4)
+	jmp  *%ecx
+
+L(pseudo_end):
+	ret
+PSEUDO_END (__rfork)
+
+weak_alias (__rfork, rfork)
+
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/i386/sigcontextinfo.h
@@ -0,0 +1,35 @@
+/* Copyright (C) 1998, 1999, 2001, 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+/*
+native FreeBSD:
+        sighandler(int signum, int code,       struct sigcontext * sg, void * fault_ip)
+posix like:
+        sighandler(int signum, siginfo_t * si, struct sigcontext * sg, void * fault_ip)
+*/
+
+#define SIGCONTEXT long _code, struct sigcontext * _sg, void *
+#define SIGCONTEXT_EXTRA_ARGS _code, _sg,
+
+/* really, really, rest of glibc expects that struct sigcontext is the last argument */
+#define GET_PC(ctx)	((void *) (_sg)->sc_eip)
+#define GET_FRAME(ctx)	((void *) (_sg)->sc_ebp)
+#define GET_STACK(ctx)	((void *) (_sg)->sc_esp)
+
+#define CALL_SIGHANDLER(handler, signo, ctx) \
+  (handler)((signo), SIGCONTEXT_EXTRA_ARGS (ctx))
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/i386/start_thread.S
@@ -0,0 +1,207 @@
+/* Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Bruno Haible <bruno@clisp.org>, 2002.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+/* __start_thread (flags, stack, func, arg)
+   calls __rfork (flags), and in the child sets the stack pointer and then
+   calls _exit (func (arg)).
+   It cannot be done in portable C.  */
+
+#include <sysdep.h>
+#include <asm-syntax.h>
+#define SIG_SETMASK	3
+
+	.text
+ENTRY (__start_thread)
+	/* End FDE now, because in the child the unwind info will be
+	   wrong.  */
+	cfi_endproc
+
+	/* There is a window of a few instructions, right after the rfork
+	   system call, where the handling of a signal would write garbage
+	   into the stack shared by the parent and the child (assuming
+	   RFMEM is set in flags).  To solve this: 1. We block all signals
+	   around the rfork system call and unblock them afterwards in
+	   the parent and in the child (but only after changing the stack
+	   pointer).  2. The child accesses only values passed in registers
+	   and on its own stack.  This way, if the parent is scheduled to
+	   run first, and handles a signal, it will not affect the child;
+	   and if the child runs first, and handles a signal, it will use
+	   the child's stack and not affect the parent.
+	   We need to pass 7 words of info to the child: stack, func, arg,
+	   and the signal mask to restore.  Since we have only 4 call-saved
+	   registers available (%ebx, %esi, %edi, %ebp), we pass only the
+	   stack pointer in a register, and the rest through the child's
+	   stack.  */
+	pushl	%ebp
+	movl	%esp, %ebp
+	subl	$36, %esp
+	movl	%ebx, 32(%esp)
+
+	movl	8(%ebp), %eax	/* flags */
+	testl	$32, %eax	/* flags & RFMEM */
+	jz	L(simple)
+
+	/* Block all signals.  */
+	movl	$-1, %eax
+	movl	%eax, 16(%esp)
+	movl	%eax, 20(%esp)
+	movl	%eax, 24(%esp)
+	movl	%eax, 28(%esp)
+	leal	16(%esp), %eax
+	movl	$SIG_SETMASK, 4(%esp)
+	movl	%eax, 8(%esp)
+	movl	%eax, 12(%esp)
+	DO_CALL (sigprocmask, 3)
+	jb	L(error)
+
+	/* Copy all info to the child's stack.  */
+	movl	12(%ebp), %ebx	/* stack */
+	subl	$32, %ebx	/* room for func, arg, sigset_t */
+	andl	$-16, %ebx	/* make it 16-bytes aligned */
+	movl	16(%ebp), %eax	/* func */
+	movl	20(%ebp), %edx	/* arg */
+	movl	%eax, 4(%ebx)
+	movl	%edx, (%ebx)
+	movl	16(%esp), %eax	/* sigset_t word 0 */
+	movl	20(%esp), %edx	/* sigset_t word 1 */
+	movl	%eax, 16(%ebx)
+	movl	%edx, 20(%ebx)
+	movl	24(%esp), %eax	/* sigset_t word 2 */
+	movl	28(%esp), %edx	/* sigset_t word 3 */
+	movl	%eax, 24(%ebx)
+	movl	%edx, 28(%ebx)
+
+	/* Perform the rfork system call.  */
+	movl	8(%ebp), %eax	/* flags */
+	movl	%eax, 4(%esp)
+	DO_CALL (rfork, 1)
+	jb	L(error_unmask)
+
+	/* %edx is now 0 for the parent and 1 for the child.  */
+	testl	%edx, %edx
+	jnz	L(child)
+
+	/* Save the child pid, currently in %eax.  */
+	movl	%eax, %ebx
+
+	/* Restore the previous signal mask.  */
+	leal	16(%esp), %eax
+	movl	$SIG_SETMASK, 4(%esp)
+	movl	%eax, 8(%esp)
+	movl	$0, 12(%esp)
+	DO_CALL (sigprocmask, 3)
+
+	/* Return the child pid, currently in %ebx.  */
+	movl	%ebx, %eax
+	addl	$32, %esp
+	popl	%ebx
+	popl	%ebp
+	ret
+
+L(child):/* Here we are in the child thread.  */
+
+	/* Set the stack pointer.  */
+	movl	%ebx, %esp
+	/* Terminate the stack frame.  */
+	subl	%ebp, %ebp
+
+	movl	4(%esp), %edi
+
+	/* Restore the previous signal mask.  */
+	leal	16(%esp), %eax
+	movl	$SIG_SETMASK, 4(%esp)
+	movl	%eax, 8(%esp)
+	movl	$0, 12(%esp)
+	DO_CALL (sigprocmask, 3)
+
+L(child1):
+	/* Call func (arg).  */
+	call	*%edi
+
+	/* Call _exit.  */
+#ifdef PIC
+	call	L(here)
+L(here):
+	popl	%ebx
+	addl	$_GLOBAL_OFFSET_TABLE_+[.-L(here)], %ebx
+#endif
+	pushl	%eax
+	call	HIDDEN_JUMPTARGET (_exit)
+
+L(simple):/* Simple case without signal mask handling.  */
+
+	/* Copy all info to the child's stack.  */
+	movl	12(%ebp), %ebx	/* stack */
+	subl	$8, %ebx	/* room for func, arg */
+	andl	$-16, %ebx	/* make it 16-bytes aligned */
+	movl	16(%ebp), %eax	/* func */
+	movl	20(%ebp), %edx	/* arg */
+	movl	%eax, 4(%ebx)
+	movl	%edx, (%ebx)
+
+	/* Perform the rfork system call.  */
+	movl	8(%ebp), %eax	/* flags */
+	movl	%eax, 4(%esp)
+	DO_CALL (rfork, 1)
+	jb	L(error)
+
+	/* %edx is now 0 for the parent and 1 for the child.  */
+	testl	%edx, %edx
+	jnz	L(simple_child)
+
+	/* Return the child pid, currently in %eax.  */
+	addl	$32, %esp
+	popl	%ebx
+	popl	%ebp
+L(pseudo_end):
+	ret
+
+L(simple_child):/* Here we are in the child thread.  */
+
+	/* Set the stack pointer.  */
+	movl	%ebx, %esp
+	/* Terminate the stack frame.  */
+	subl	%ebp, %ebp
+
+	movl	4(%esp), %edi
+
+	jmp	L(child1)
+
+L(error_unmask):
+
+	/* Save the error code, currently in %eax.  */
+	movl	%eax, %ebx
+
+	/* Restore the previous signal mask.  */
+	leal	16(%esp), %eax
+	movl	$SIG_SETMASK, 4(%esp)
+	movl	%eax, 8(%esp)
+	movl	$0, 12(%esp)
+	DO_CALL (sigprocmask, 3)
+
+	/* load saved error code */
+	movl	%ebx, %eax
+
+L(error):
+	addl	$32, %esp
+	popl	%ebx
+	popl	%ebp
+	jmp	SYSCALL_ERROR_LABEL
+	cfi_startproc
+PSEUDO_END (__start_thread)
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/i386/swapcontext.S
@@ -0,0 +1,32 @@
+/* swap current context.
+   Copyright (C) 2006 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sysdep.h>
+
+.text
+ENTRY(__swapcontext)
+        clc
+        DO_CALL (swapcontext, 2)
+        jb SYSCALL_ERROR_LABEL
+L(pseudo_end):
+	ret
+
+PSEUDO_END(__swapcontext)
+
+weak_alias(__swapcontext, swapcontext)
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/i386/sys/io.h
@@ -0,0 +1,180 @@
+/* Copyright (C) 1996, 2000, 2002, 2004 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef	_SYS_IO_H
+#define	_SYS_IO_H	1
+
+#include <features.h>
+
+__BEGIN_DECLS
+
+/* If TURN_ON is TRUE, request for permission to do direct i/o on the
+   port numbers in the range [FROM,FROM+NUM-1].  Otherwise, turn I/O
+   permission off for that range.  This call requires root privileges.
+
+   Portability note: not all kFreeBSD platforms support this call.  Most
+   platforms based on the PC I/O architecture probably will, however. */
+extern int ioperm (unsigned long int __from, unsigned long int __num,
+                   int __turn_on) __THROW;
+
+/* Set the I/O privilege level to LEVEL.  If LEVEL>3, permission to
+   access any I/O port is granted.  This call requires root
+   privileges. */
+extern int iopl (int __level) __THROW;
+
+#if defined __GNUC__ && __GNUC__ >= 2
+
+static __inline unsigned char
+inb (unsigned short int port)
+{
+  unsigned char _v;
+
+  __asm__ __volatile__ ("inb %w1,%0":"=a" (_v):"Nd" (port));
+  return _v;
+}
+
+static __inline unsigned char
+inb_p (unsigned short int port)
+{
+  unsigned char _v;
+
+  __asm__ __volatile__ ("inb %w1,%0\noutb %%al,$0x80":"=a" (_v):"Nd" (port));
+  return _v;
+}
+
+static __inline unsigned short int
+inw (unsigned short int port)
+{
+  unsigned short _v;
+
+  __asm__ __volatile__ ("inw %w1,%0":"=a" (_v):"Nd" (port));
+  return _v;
+}
+
+static __inline unsigned short int
+inw_p (unsigned short int port)
+{
+  unsigned short int _v;
+
+  __asm__ __volatile__ ("inw %w1,%0\noutb %%al,$0x80":"=a" (_v):"Nd" (port));
+  return _v;
+}
+
+static __inline unsigned int
+inl (unsigned short int port)
+{
+  unsigned int _v;
+
+  __asm__ __volatile__ ("inl %w1,%0":"=a" (_v):"Nd" (port));
+  return _v;
+}
+
+static __inline unsigned int
+inl_p (unsigned short int port)
+{
+  unsigned int _v;
+  __asm__ __volatile__ ("inl %w1,%0\noutb %%al,$0x80":"=a" (_v):"Nd" (port));
+  return _v;
+}
+
+static __inline void
+outb (unsigned char value, unsigned short int port)
+{
+  __asm__ __volatile__ ("outb %b0,%w1": :"a" (value), "Nd" (port));
+}
+
+static __inline void
+outb_p (unsigned char value, unsigned short int port)
+{
+  __asm__ __volatile__ ("outb %b0,%w1\noutb %%al,$0x80": :"a" (value),
+			"Nd" (port));
+}
+
+static __inline void
+outw (unsigned short int value, unsigned short int port)
+{
+  __asm__ __volatile__ ("outw %w0,%w1": :"a" (value), "Nd" (port));
+
+}
+
+static __inline void
+outw_p (unsigned short int value, unsigned short int port)
+{
+  __asm__ __volatile__ ("outw %w0,%w1\noutb %%al,$0x80": :"a" (value),
+			"Nd" (port));
+}
+
+static __inline void
+outl (unsigned int value, unsigned short int port)
+{
+  __asm__ __volatile__ ("outl %0,%w1": :"a" (value), "Nd" (port));
+}
+
+static __inline void
+outl_p (unsigned int value, unsigned short int port)
+{
+  __asm__ __volatile__ ("outl %0,%w1\noutb %%al,$0x80": :"a" (value),
+			"Nd" (port));
+}
+
+static __inline void
+insb (unsigned short int port, void *addr, unsigned long int count)
+{
+  __asm__ __volatile__ ("cld ; rep ; insb":"=D" (addr),
+			"=c" (count):"d" (port), "0" (addr), "1" (count));
+}
+
+static __inline void
+insw (unsigned short int port, void *addr, unsigned long int count)
+{
+  __asm__ __volatile__ ("cld ; rep ; insw":"=D" (addr),
+			"=c" (count):"d" (port), "0" (addr), "1" (count));
+}
+
+static __inline void
+insl (unsigned short int port, void *addr, unsigned long int count)
+{
+  __asm__ __volatile__ ("cld ; rep ; insl":"=D" (addr),
+			"=c" (count):"d" (port), "0" (addr), "1" (count));
+}
+
+static __inline void
+outsb (unsigned short int port, const void *addr, unsigned long int count)
+{
+  __asm__ __volatile__ ("cld ; rep ; outsb":"=S" (addr),
+			"=c" (count):"d" (port), "0" (addr), "1" (count));
+}
+
+static __inline void
+outsw (unsigned short int port, const void *addr, unsigned long int count)
+{
+  __asm__ __volatile__ ("cld ; rep ; outsw":"=S" (addr),
+			"=c" (count):"d" (port), "0" (addr), "1" (count));
+}
+
+static __inline void
+outsl (unsigned short int port, const void *addr, unsigned long int count)
+{
+  __asm__ __volatile__ ("cld ; rep ; outsl":"=S" (addr),
+			"=c" (count):"d" (port), "0" (addr), "1" (count));
+}
+
+#endif	/* GNU C */
+
+__END_DECLS
+#endif /* _SYS_IO_H */
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/i386/sys/perm.h
@@ -0,0 +1,43 @@
+/* Copyright (C) 1996, 1999, 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _SYS_PERM_H
+#define _SYS_PERM_H	1
+
+#include <features.h>
+
+__BEGIN_DECLS
+
+/* Set port input/output permissions.  */
+extern int ioperm (unsigned long int __from, unsigned long int __num,
+		   int __turn_on) __THROW;
+
+
+/* Change I/O privilege level.  */
+extern int iopl (int __level) __THROW;
+
+extern int i386_set_ioperm (unsigned long int __from, unsigned long int __num,
+			    int __turn_on) __THROW;
+
+/* Retrieve a contiguous range of port input/output permissions.  */
+extern int i386_get_ioperm (unsigned long int __from, unsigned long int *__num,
+			    int *__turned_on) __THROW;
+
+__END_DECLS
+
+#endif	/* _SYS_PERM_H */
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/i386/sys/vm86.h
@@ -0,0 +1,53 @@
+/* Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _SYS_VM86_H
+#define _SYS_VM86_H	1
+
+#include <features.h>
+
+/* Possible values for the 'cmd' argument to i386_vm86.  */
+enum
+  {
+    VM86_INIT = 1,
+#define VM86_INIT VM86_INIT
+    VM86_GET_VME = 3
+#define VM86_GET_VME VM86_GET_VME
+  };
+
+/* Argument structure for VM86_INIT.  */
+struct vm86_init_args
+  {
+    int debug;
+    int cpu_type;
+    unsigned char int_map[32];
+  };
+
+/* Argument structure for VM86_GET_VME.  */
+struct vm86_vme_args
+  {
+    int state;
+  };
+
+__BEGIN_DECLS
+
+extern int i386_vm86 (int __cmd, void *__arg);
+
+__END_DECLS
+
+#endif	/* _SYS_VM86_H */
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/i386/sys_fork.S
@@ -0,0 +1,34 @@
+/* Copyright (C) 1991-1992, 1994-1995, 1997, 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sysdep.h>
+
+.text;
+ENTRY (__syscall_fork)
+	DO_CALL (fork, 0)
+	jb SYSCALL_ERROR_LABEL;
+	/* R1 is now 0 for the parent and 1 for the child.  Decrement it to
+	   make it -1 (all bits set) for the parent, and 0 (no bits set)
+	   for the child.  Then AND it with R0, so the parent gets
+	   R0&-1==R0, and the child gets R0&0==0.  */
+	decl r1
+	andl r1, r0
+L(pseudo_end):
+	ret
+PSEUDO_END (__syscall_fork)
+libc_hidden_def (__syscall_fork)
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/i386/sys_lseek.S
@@ -0,0 +1,32 @@
+/* Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sysdep.h>
+
+/* lseek returns a 64-bit result in %eax, %edx.  This means that in the
+   error case we have to set both %eax and %edx to -1.  */
+
+PSEUDO_NOERRNO(__syscall_freebsd6_lseek, freebsd6_lseek, 4)
+        jnb L(no_error)
+	call SYSCALL_ERROR_LABEL;
+	orl $-1, %edx;
+L(pseudo_end):
+L(no_error):
+	ret
+PSEUDO_END(__syscall_freebsd6_lseek)
+libc_hidden_def (__syscall_freebsd6_lseek)
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/i386/sysarch.h
@@ -0,0 +1,81 @@
+/* Parameters for the architecture specific system call.  i386 version.
+   Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _SYSARCH_H
+#define _SYSARCH_H	1
+
+#include <features.h>
+
+/* Function that can be used as first argument to 'sysarch'.  */
+enum
+  {
+    I386_GET_LDT = 0,
+#define I386_GET_LDT I386_GET_LDT
+    I386_SET_LDT = 1,
+#define I386_SET_LDT I386_SET_LDT
+    I386_GET_IOPERM = 3,
+#define I386_GET_IOPERM I386_GET_IOPERM
+    I386_SET_IOPERM = 4,
+#define I386_SET_IOPERM I386_SET_IOPERM
+    I386_VM86 = 6,
+#define I386_VM86 I386_VM86
+    I386_GET_FSBASE = 7,
+#define I386_GET_FSBASE I386_GET_FSBASE
+    I386_SET_FSBASE = 8,
+#define I386_SET_FSBASE I386_SET_FSBASE
+    I386_GET_GSBASE = 9,
+#define I386_GET_GSBASE I386_GET_GSBASE
+    I386_SET_GSBASE = 10
+#define I386_SET_GSBASE I386_SET_GSBASE
+  };
+
+/* Argument struct for I386_GET_LDT and I386_SET_LDT.  */
+struct i386_ldt_args
+  {
+    int start;
+    union descriptor *descs;
+    int num;
+  };
+
+/* Argument struct for I386_GET_IOPERM and I386_SET_IOPERM.  */
+struct i386_ioperm_args
+  {
+    unsigned int start;
+    unsigned int length;
+    int enable;
+  };
+
+/* Argument struct for I386_VM86.  */
+struct i386_vm86_args
+  {
+    int sub_op;
+    void *sub_args;
+  };
+
+__BEGIN_DECLS
+
+extern int sysarch (int __cmd, void *__arg);
+
+#ifdef _LIBC
+extern int __sysarch (int __cmd, void *__arg);
+#endif
+
+__END_DECLS
+
+#endif /* _SYSARCH_H */
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/i386/syscall.S
@@ -0,0 +1,34 @@
+/* Copyright (C) 1993, 1995-1998, 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sysdep.h>
+
+	  .text;
+ENTRY (__syscall)
+	popl %ecx		/* Pop return address into %ecx.  */
+	cfi_adjust_cfa_offset (-4)
+	movl 0(%esp), %eax	/* Load syscall number into %eax. */
+	int $0x80		/* Do the system call.  */
+	pushl %ecx		/* Push back return address.  */
+	cfi_adjust_cfa_offset (4)
+	jb SYSCALL_ERROR_LABEL;	/* Jump to error handler if error.  */
+
+L(pseudo_end):
+	ret			/* Return to caller.  */
+PSEUDO_END (__syscall)
+weak_alias (__syscall, syscall)
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/i386/sysdep.S
@@ -0,0 +1,38 @@
+/* Copyright (C) 1995-1998, 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sysdep.h>
+
+/* The following code is only used in the shared library when we
+   compile the reentrant version.  Otherwise each system call defines
+   its own version.  */
+
+#ifndef PIC
+
+/* The syscall stubs jump here when they detect an error.
+   The code for FreeBSD is identical to the canonical Unix/i386 code.  */
+
+#undef CALL_MCOUNT
+#define CALL_MCOUNT /* Don't insert the profiling call, it clobbers %eax.  */
+
+	.text
+ENTRY (__syscall_error)
+#define __syscall_error __syscall_error_1
+#include <sysdeps/unix/i386/sysdep.S>
+
+#endif	/* !PIC */
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/i386/sysdep.h
@@ -0,0 +1,235 @@
+/* Copyright (C) 1992,1993,1995-2000,2002,2003,2004
+   Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Ulrich Drepper, <drepper@gnu.org>, August 1995.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _FREEBSD_I386_SYSDEP_H
+#define _FREEBSD_I386_SYSDEP_H 1
+
+/* There is some commonality.  */
+#include <sysdeps/unix/i386/sysdep.h>
+#include <bp-sym.h>
+#include <bp-asm.h>
+/* Defines RTLD_PRIVATE_ERRNO and USE_DL_SYSINFO.  */
+#include <dl-sysdep.h>
+#include <tls.h>
+
+#ifdef __ASSEMBLER__
+
+/* We don't want the label for the error handle to be global when we define
+   it here.  */
+#ifdef PIC
+# define SYSCALL_ERROR_LABEL 0f
+#else
+# define SYSCALL_ERROR_LABEL syscall_error
+#endif
+
+#undef	PSEUDO
+#define	PSEUDO(name, syscall_name, args)				      \
+  .text;								      \
+  ENTRY (name)								      \
+    DO_CALL (syscall_name, args);					      \
+    jb SYSCALL_ERROR_LABEL;						      \
+  L(pseudo_end):
+
+#undef	PSEUDO_END
+#define	PSEUDO_END(name)						      \
+  SYSCALL_ERROR_HANDLER							      \
+  END (name)
+
+#undef	PSEUDO_NOERRNO
+#define	PSEUDO_NOERRNO(name, syscall_name, args)			      \
+  .text;								      \
+  ENTRY (name)								      \
+    DO_CALL (syscall_name, args)
+
+#undef	PSEUDO_END_NOERRNO
+#define	PSEUDO_END_NOERRNO(name)					      \
+  END (name)
+
+#define ret_NOERRNO ret
+
+/* The function has to return the error code.  */
+#undef	PSEUDO_ERRVAL
+#define	PSEUDO_ERRVAL(name, syscall_name, args) \
+  .text;								      \
+  ENTRY (name)								      \
+    DO_CALL (syscall_name, args);					      \
+
+#undef	PSEUDO_END_ERRVAL
+#define	PSEUDO_END_ERRVAL(name) \
+  END (name)
+
+#define ret_ERRVAL ret
+
+#ifndef PIC
+# define SYSCALL_ERROR_HANDLER	/* Nothing here; code in sysdep.S is used.  */
+#else
+
+# if RTLD_PRIVATE_ERRNO
+#  define SYSCALL_ERROR_HANDLER						      \
+0:SETUP_PIC_REG(cx);							      \
+  addl $_GLOBAL_OFFSET_TABLE_, %ecx;					      \
+  movl %eax, rtld_errno@GOTOFF(%ecx);					      \
+  orl $-1, %eax;							      \
+  jmp L(pseudo_end);
+
+# elif defined _LIBC_REENTRANT
+
+#  if USE___THREAD
+#   ifndef NOT_IN_libc
+#    define SYSCALL_ERROR_ERRNO __libc_errno
+#   else
+#    define SYSCALL_ERROR_ERRNO errno
+#   endif
+#   define SYSCALL_ERROR_HANDLER					      \
+0:SETUP_PIC_REG (cx);							      \
+  addl $_GLOBAL_OFFSET_TABLE_, %ecx;					      \
+  movl SYSCALL_ERROR_ERRNO@GOTNTPOFF(%ecx), %ecx;			      \
+  SYSCALL_ERROR_HANDLER_TLS_STORE (%eax, %ecx);				      \
+  orl $-1, %eax;							      \
+  jmp L(pseudo_end);
+#   ifndef NO_TLS_DIRECT_SEG_REFS
+#    define SYSCALL_ERROR_HANDLER_TLS_STORE(src, destoff)		      \
+  movl src, %gs:(destoff)
+#   else
+#    define SYSCALL_ERROR_HANDLER_TLS_STORE(src, destoff)		      \
+  addl %gs:0, destoff;							      \
+  movl src, (destoff)
+#   endif
+#  else
+#   define SYSCALL_ERROR_HANDLER					      \
+0:pushl %ebx;								      \
+  cfi_adjust_cfa_offset (4);                                                  \
+  cfi_rel_offset (ebx, 0);                                                    \
+  SETUP_PIC_REG (bx);							      \
+  addl $_GLOBAL_OFFSET_TABLE_, %ebx;					      \
+  pushl %eax;								      \
+  cfi_adjust_cfa_offset (4);                                                  \
+  PUSH_ERRNO_LOCATION_RETURN;						      \
+  call BP_SYM (__errno_location)@PLT;					      \
+  POP_ERRNO_LOCATION_RETURN;						      \
+  popl %ecx;								      \
+  cfi_adjust_cfa_offset (-4);                                                 \
+  popl %ebx;								      \
+  cfi_adjust_cfa_offset (-4);                                                 \
+  cfi_restore (ebx);                                                          \
+  movl %ecx, (%eax);							      \
+  orl $-1, %eax;							      \
+  jmp L(pseudo_end);
+/* A quick note: it is assumed that the call to `__errno_location' does
+   not modify the stack!  */
+#  endif
+# else
+/* Store (%eax) into errno through the GOT.  */
+#  define SYSCALL_ERROR_HANDLER						      \
+0:SETUP_PIC_REG(cx);							      \
+  addl $_GLOBAL_OFFSET_TABLE_, %ecx;					      \
+  movl errno@GOT(%ecx), %ecx;						      \
+  movl %eax, (%ecx);							      \
+  orl $-1, %eax;							      \
+  jmp L(pseudo_end);
+# endif	/* _LIBC_REENTRANT */
+#endif	/* PIC */
+
+/*
+    FreeBSD expects the system call arguments on the stack,
+   syscall number is in %eax.
+   return value is in %eax + %edx
+   error is signaled via cflags.
+   all other data registers are preserved
+
+	syscall number	%eax	     call-clobbered
+
+   The stack layout upon entering the function is:
+
+	20(%esp)	Arg# 5
+	16(%esp)	Arg# 4
+	12(%esp)	Arg# 3
+	 8(%esp)	Arg# 2
+	 4(%esp)	Arg# 1
+	  (%esp)	Return address
+
+   (Of course a function with say 3 arguments does not have entries for
+   arguments 4 and 5.)
+
+*/
+
+#undef	DO_CALL
+#define DO_CALL(syscall_name, args)			      		      \
+    movl $SYS_ify (syscall_name), %eax;					      \
+    int $0x80								      \
+
+#else	/* !__ASSEMBLER__ */
+
+#include <syscalls-inline.h>
+
+/* Consistency check for position-independent code.  */
+#ifdef __PIC__
+# define check_consistency()						      \
+  ({ int __res;								      \
+     __asm__ __volatile__						      \
+       ("call __i686.get_pc_thunk.cx;"					      \
+	"addl $_GLOBAL_OFFSET_TABLE_, %%ecx;"				      \
+	"subl %%ebx, %%ecx;"						      \
+	"je 1f;"							      \
+	"ud2;"								      \
+	"1:\n"								      \
+	".section .gnu.linkonce.t.__i686.get_pc_thunk.cx,\"ax\",@progbits;"   \
+	".globl __i686.get_pc_thunk.cx;"				      \
+	".hidden __i686.get_pc_thunk.cx;"				      \
+	".type __i686.get_pc_thunk.cx,@function;"			      \
+	"__i686.get_pc_thunk.cx:"					      \
+	"movl (%%esp), %%ecx;"						      \
+	"ret;"								      \
+	".previous"							      \
+	: "=c" (__res));						      \
+     __res; })
+#endif
+
+#endif	/* __ASSEMBLER__ */
+
+
+/* Pointer mangling support.  */
+#if defined NOT_IN_libc && defined IS_IN_rtld
+/* We cannot use the thread descriptor because in ld.so we use setjmp
+   earlier than the descriptor is initialized.  Using a global variable
+   is too complicated here since we have no PC-relative addressing mode.  */
+#else
+# ifdef __ASSEMBLER__
+#  define PTR_MANGLE(reg)	xorl %gs:POINTER_GUARD, reg;		      \
+				roll $9, reg
+#  define PTR_DEMANGLE(reg)	rorl $9, reg;				      \
+				xorl %gs:POINTER_GUARD, reg
+# else
+#  define PTR_MANGLE(var)	asm ("xorl %%gs:%c2, %0\n"		      \
+				     "roll $9, %0"			      \
+				     : "=r" (var)			      \
+				     : "0" (var),			      \
+				       "i" (offsetof (tcbhead_t,	      \
+						      pointer_guard)))
+#  define PTR_DEMANGLE(var)	asm ("rorl $9, %0\n"			      \
+				     "xorl %%gs:%c2, %0"		      \
+				     : "=r" (var)			      \
+				     : "0" (var),			      \
+				       "i" (offsetof (tcbhead_t,	      \
+						      pointer_guard)))
+# endif
+#endif
+
+#endif /* _FREEBSD_I386_SYSDEP_H */
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/i386/ucontext_i.h
@@ -0,0 +1,38 @@
+/* Offsets and other constants needed in the *context() function
+   implementation.
+   Copyright (C) 2001 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+/* Offsets of the fields in the ucontext_t structure.  */
+#define oSIGMASK	0
+#define oGS		20
+#define oFS		24
+#define oEDI		36
+#define oESI		40
+#define oEBP		44
+#define oEBX		52
+#define oEDX		56
+#define oECX		60
+#define oEAX		64
+
+#define oEIP		76
+#define oESP		88
+
+#define oLINK		656
+#define oSS_SP		660
+#define oSS_SIZE	664
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/i386/vfork.S
@@ -0,0 +1,58 @@
+/* Copyright (C) 1999, 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sysdep.h>
+
+/* Clone the calling process, but without copying the whole address space.
+   The calling process is suspended until the new process exits or is
+   replaced by a call to `execve'.  Return -1 for errors, 0 to the new process,
+   and the process ID of the new process to the old process.  */
+
+ENTRY (__vfork)
+
+	/* Pop the return PC value into ECX.  */
+	popl	%ecx
+	cfi_adjust_cfa_offset(-4)
+
+	/* Perform the system call.  */
+	DO_CALL (vfork, 0)
+	jb	L(error)	/* Branch forward if it failed.  */
+
+	/* In the parent process, %edx == 0, %eax == child pid.  */
+	/* In the child process, %edx == 1, %eax == parent pid.  */
+
+	/* Change %eax to be 0 in the child process.  */
+	decl	%edx
+	andl	%edx, %eax
+
+	/* Jump to the return PC.  */
+	jmp	*%ecx
+
+L(error):
+	/* Push back the return PC.  */
+	pushl	%ecx
+	cfi_adjust_cfa_offset(4)
+
+	/* Branch to the error handler, hidden in PSEUDO_END.  */
+	jmp	SYSCALL_ERROR_LABEL
+L(pseudo_end):
+	ret
+PSEUDO_END (__vfork)
+libc_hidden_def (__vfork)
+
+weak_alias (__vfork, vfork)
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/if_index.c
@@ -0,0 +1,303 @@
+/* Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Bruno Haible <bruno@clisp.org>, 2002.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <net/if.h>
+#include <sys/sysctl.h>
+#include <sys/socket.h>
+#include <net/route.h>
+#include <net/if_dl.h>
+#include <alloca.h>
+#include <stdlib.h>
+#include <errno.h>
+#include <string.h>
+
+
+typedef int (*if_fn) (void *private, unsigned int index, const char *name);
+
+/* Iterate through all present interfaces.
+   Call FN once for every interface, returning immediately if FN returns
+   a nonzero value.  */
+static void
+if_iterate (if_fn fn, void *private)
+{
+  int request[6] = { CTL_NET, PF_ROUTE, 0, 0, NET_RT_IFLIST, 0 };
+  char *buf;
+  size_t bufsize = 512;
+  char *bufend;
+  char *p;
+
+  /* Call the kernel function sysctl_iflist() in /usr/src/sys/net/rtsock.c.  */
+  for (;;)
+    {
+      buf = alloca (bufsize);
+      if (__sysctl (request, 6, buf, &bufsize, NULL, 0) >= 0)
+	break;
+      if (errno != ENOMEM)
+	return;
+      bufsize *= 2;
+    }
+
+  bufend = buf + bufsize;
+  for (p = buf; p < bufend; )
+    {
+      struct if_msghdr *msg = (struct if_msghdr *) p;
+
+      if (msg->ifm_version != RTM_VERSION)
+	abort ();
+
+      switch (msg->ifm_type)
+	{
+	case RTM_IFINFO:
+	  if (msg->ifm_addrs & RTA_IFP)
+	    {
+	      unsigned int index;
+	      struct sockaddr_dl *sdl;
+	      char namebuf[IFNAMSIZ + 1];
+	      size_t namelen;
+
+	      index = msg->ifm_index;
+	      if (index == 0)
+		abort ();
+
+	      sdl = (struct sockaddr_dl *) (msg + 1);
+	      namelen = sdl->sdl_nlen;
+	      /* Avoid overflowing namebuf[].  */
+	      if (namelen > IFNAMSIZ)
+		namelen = IFNAMSIZ;
+	      memcpy (namebuf, sdl->sdl_data, namelen);
+	      namebuf[namelen] = '\0';
+
+	      /* Call FN now.  */
+	      if (fn (private, index, namebuf))
+		return;
+	    }
+	  break;
+
+	case RTM_NEWADDR:
+	  break;
+
+	default:
+	  abort ();
+	}
+
+      p += msg->ifm_msglen;
+    }
+}
+
+/* ------------------------------------------------------------------------- */
+
+struct nametoindex_locals
+  {
+    const char *name;
+    unsigned int index;
+  };
+
+static int
+nametoindex_aux (void *private, unsigned int index, const char *name)
+{
+  struct nametoindex_locals *l = (struct nametoindex_locals *) private;
+  if (strcmp (name, l->name) == 0)
+    {
+      l->index = index;
+      return 1;
+    }
+  return 0;
+}
+
+/* Return the index of an interface given by name.  */
+unsigned int
+if_nametoindex (const char *ifname)
+{
+  struct nametoindex_locals l;
+
+  l.name = ifname;
+  l.index = 0;
+  if_iterate (nametoindex_aux, &l);
+
+  return l.index;
+}
+libc_hidden_def (if_nametoindex)
+
+/* ------------------------------------------------------------------------- */
+
+struct indextoname_locals
+  {
+    unsigned int index;
+    char *name;
+    char *retval;
+  };
+
+static int
+indextoname_aux (void *private, unsigned int index, const char *name)
+{
+  struct indextoname_locals *l = (struct indextoname_locals *) private;
+  if (index == l->index)
+    {
+      strncpy (l->name, name, IF_NAMESIZE);
+      l->retval = l->name;
+      return 1;
+    }
+  __set_errno (ENXIO);
+  return 0;
+}
+
+/* Return the name of an interface given by name.  */
+char *
+if_indextoname (unsigned int ifindex, char *ifname)
+{
+  struct indextoname_locals l;
+
+  l.index = ifindex;
+  l.name = ifname;
+  l.retval = NULL;
+  if_iterate (indextoname_aux, &l);
+  return l.retval;
+}
+libc_hidden_def (if_indextoname)
+
+/* ------------------------------------------------------------------------- */
+
+struct nameindex_locals
+  {
+    /* Resizable array of 'struct if_nameindex'.  */
+    struct if_nameindex *s_array;
+    size_t s_len;
+    size_t s_allocated;
+    /* Resizable array of char.  */
+    char *c_array;
+    size_t c_len;
+    size_t c_allocated;
+    /* Out-of-memory indicator.  */
+    int oom;
+  };
+
+static void
+add_s (struct nameindex_locals *l, unsigned int index, char *name)
+{
+  if (l->s_len == l->s_allocated)
+    {
+      size_t new_allocated = 2 * l->s_allocated + 1;
+      struct if_nameindex *new_array =
+	(struct if_nameindex *)
+	realloc (l->s_array, new_allocated * sizeof (struct if_nameindex));
+      if (new_array == NULL)
+	{
+	  l->oom = 1;
+	  return;
+	}
+      l->s_array = new_array;
+      l->s_allocated = new_allocated;
+    }
+  /* Now l->s_len < l->s_allocated.  */
+  l->s_array[l->s_len].if_index = index;
+  l->s_array[l->s_len].if_name = name;
+  l->s_len++;
+}
+
+static __inline size_t
+add_c (struct nameindex_locals *l, const char *name)
+{
+  size_t n = strlen (name) + 1;
+  size_t result_offset;
+  if (l->c_len + n > l->c_allocated)
+    {
+      size_t new_allocated =
+	(l->c_len + n < 2 * l->c_allocated + 1
+	 ? l->c_len + n
+	 : 2 * l->c_allocated + 1);
+      char *new_array = (char *) realloc (l->c_array, new_allocated);
+      if (new_array == NULL)
+	{
+	  l->oom = 1;
+	  return 0;
+	}
+      l->c_array = new_array;
+      l->c_allocated = new_allocated;
+    }
+  /* Now l->c_len + n <= l->c_allocated.  */
+  result_offset = l->c_len;
+  memcpy (l->c_array + l->c_len, name, n);
+  l->c_len += n;
+  return result_offset;
+}
+
+static int
+nameindex_aux (void *private, unsigned int index, const char *name)
+{
+  struct nameindex_locals *l = (struct nameindex_locals *) private;
+
+  size_t name_offset = add_c (l, name);
+  if (!l->oom)
+    {
+      add_s (l, index, (char *) NULL + name_offset);
+      if (!l->oom)
+	return 0;
+    }
+  return 1;
+}
+
+/* Return an array of 'struct if_nameindex', one for each present
+   interface.  */
+struct if_nameindex *
+if_nameindex (void)
+{
+  struct nameindex_locals l;
+
+  l.s_array = NULL; l.s_len = 0; l.s_allocated = 0;
+  l.c_array = NULL; l.c_len = 0; l.c_allocated = 0;
+  l.oom = 0;
+  if_iterate (nameindex_aux, &l);
+  if (!l.oom)
+    {
+      /* Convert all offsets to real pointers.  */
+      struct if_nameindex *p;
+      struct if_nameindex *p_end;
+
+      for (p = l.s_array, p_end = p + l.s_len; p < p_end; p++)
+	p->if_name = l.c_array + (p->if_name - (char *) NULL);
+
+      /* Add a terminating entry.  */
+      add_s (&l, 0, NULL);
+    }
+  if (l.oom)
+    {
+      free (l.s_array);
+      free (l.c_array);
+      __set_errno (ENOMEM);
+      return NULL;
+    }
+  return l.s_array;
+}
+libc_hidden_def (if_nameindex)
+
+/* ------------------------------------------------------------------------- */
+
+/* Free an array returned by if_nameindex().  */
+void
+if_freenameindex (struct if_nameindex *ifn)
+{
+  if (ifn != NULL)
+    {
+      /* Free c_array.  */
+      free (ifn[0].if_name);
+      /* Free s_array.  */
+      free (ifn);
+    }
+}
+libc_hidden_def (if_freenameindex)
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/ifaddrs.c
@@ -0,0 +1,362 @@
+/*	$KAME: getifaddrs.c,v 1.9 2001/08/20 02:31:20 itojun Exp $	*/
+
+/*
+ * Copyright (c) 1995, 1999
+ *	Berkeley Software Design, Inc.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Berkeley Software Design, Inc. ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL Berkeley Software Design, Inc. BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ *	BSDI getifaddrs.c,v 2.12 2000/02/23 14:51:59 dab Exp
+ */
+
+#include <sys/cdefs.h>
+
+ /*
+__FBSDID("$FreeBSD: src/lib/libc/net/getifaddrs.c,v 1.6 2002/07/25 08:08:30 ume Exp $");
+ */
+
+#include <sys/types.h>
+#include <sys/ioctl.h>
+#include <sys/socket.h>
+#include <sys/sysctl.h>
+#include <net/if.h>
+
+#ifdef	NET_RT_IFLIST
+#include <sys/param.h>
+#include <net/route.h>
+#include <sys/sysctl.h>
+#include <net/if_dl.h>
+#else
+#error NET_RT_IFLIST is required
+#endif
+
+#include <errno.h>
+#include <ifaddrs.h>
+#include <stdlib.h>
+#include <string.h>
+
+#if !defined(AF_LINK)
+#define	SA_LEN(sa)	sizeof(struct sockaddr)
+#endif
+
+#if !defined(SA_LEN)
+#define	SA_LEN(sa)	(sa)->sa_len
+#endif
+
+#define	SALIGN	(sizeof(long) - 1)
+#define	SA_RLEN(sa)	((sa)->sa_len ? (((sa)->sa_len + SALIGN) & ~SALIGN) : (SALIGN + 1))
+
+#ifndef	ALIGNBYTES
+/*
+ * On systems with a routing socket, ALIGNBYTES should match the value
+ * that the kernel uses when building the messages.
+ */
+#define	ALIGNBYTES	XXX
+#endif
+#ifndef	ALIGN
+#define	ALIGN(p)	(((u_long)(p) + ALIGNBYTES) &~ ALIGNBYTES)
+#endif
+
+#define	HAVE_IFM_DATA
+#define MAX_SYSCTL_TRY 5
+
+int
+getifaddrs(struct ifaddrs **pif)
+{
+	int icnt = 1;
+	int dcnt = 0;
+	int ncnt = 0;
+#ifdef	NET_RT_IFLIST
+	int ntry = 0;
+	int mib[6];
+	size_t needed;
+	char *buf;
+	char *next;
+	struct ifaddrs *cif = 0;
+	char *p, *p0;
+	struct rt_msghdr *rtm;
+	struct if_msghdr *ifm;
+	struct ifa_msghdr *ifam;
+	struct sockaddr_dl *dl;
+	struct sockaddr *sa;
+	struct ifaddrs *ifa, *ift;
+	u_short idx = 0;
+#else	/* NET_RT_IFLIST */
+#endif	/* NET_RT_IFLIST */
+	int i;
+	size_t len, alen;
+	char *data;
+	char *names;
+
+#ifdef	NET_RT_IFLIST
+	mib[0] = CTL_NET;
+	mib[1] = PF_ROUTE;
+	mib[2] = 0;             /* protocol */
+	mib[3] = 0;             /* wildcard address family */
+	mib[4] = NET_RT_IFLIST;
+	mib[5] = 0;             /* no flags */
+	do {
+		/*
+		 * We'll try to get addresses several times in case that
+		 * the number of addresses is unexpectedly increased during
+		 * the two sysctl calls.  This should rarely happen, but we'll
+		 * try to do our best for applications that assume success of
+		 * this library (which should usually be the case).
+		 * Portability note: since FreeBSD does not add margin of
+		 * memory at the first sysctl, the possibility of failure on
+		 * the second sysctl call is a bit higher.
+		 */
+
+		if (__sysctl(mib, 6, NULL, &needed, NULL, 0) < 0)
+			return (-1);
+		if ((buf = malloc(needed)) == NULL)
+			return (-1);
+		if (__sysctl(mib, 6, buf, &needed, NULL, 0) < 0) {
+			if (errno != ENOMEM || ++ntry >= MAX_SYSCTL_TRY) {
+				free(buf);
+				return (-1);
+			}
+			free(buf);
+			buf = NULL;
+		}
+	} while (buf == NULL);
+
+	for (next = buf; next < buf + needed; next += rtm->rtm_msglen) {
+		rtm = (struct rt_msghdr *)(void *)next;
+		if (rtm->rtm_version != RTM_VERSION)
+			continue;
+		switch (rtm->rtm_type) {
+		case RTM_IFINFO:
+			ifm = (struct if_msghdr *)(void *)rtm;
+			if (ifm->ifm_addrs & RTA_IFP) {
+				idx = ifm->ifm_index;
+				++icnt;
+				dl = (struct sockaddr_dl *)(void *)(ifm + 1);
+				dcnt += SA_RLEN((struct sockaddr *)(void*)dl) +
+				    ALIGNBYTES;
+#ifdef	HAVE_IFM_DATA
+				dcnt += sizeof(ifm->ifm_data);
+#endif	/* HAVE_IFM_DATA */
+				ncnt += dl->sdl_nlen + 1;
+			} else
+				idx = 0;
+			break;
+
+		case RTM_NEWADDR:
+			ifam = (struct ifa_msghdr *)(void *)rtm;
+			if (idx && ifam->ifam_index != idx)
+			{
+				errno = EINVAL;		/* this cannot happen */
+				return -1;
+			};
+#define	RTA_MASKS	(RTA_NETMASK | RTA_IFA | RTA_BRD)
+			if (idx == 0 || (ifam->ifam_addrs & RTA_MASKS) == 0)
+				break;
+			p = (char *)(void *)(ifam + 1);
+			++icnt;
+#ifdef	HAVE_IFAM_DATA
+			dcnt += sizeof(ifam->ifam_data) + ALIGNBYTES;
+#endif	/* HAVE_IFAM_DATA */
+			/* Scan to look for length of address */
+			alen = 0;
+			for (p0 = p, i = 0; i < RTAX_MAX; i++) {
+				if ((RTA_MASKS & ifam->ifam_addrs & (1 << i))
+				    == 0)
+					continue;
+				sa = (struct sockaddr *)(void *)p;
+				len = SA_RLEN(sa);
+				if (i == RTAX_IFA) {
+					alen = len;
+					break;
+				}
+				p += len;
+			}
+			for (p = p0, i = 0; i < RTAX_MAX; i++) {
+				if ((RTA_MASKS & ifam->ifam_addrs & (1 << i))
+				    == 0)
+					continue;
+				sa = (struct sockaddr *)(void *)p;
+				len = SA_RLEN(sa);
+				if (i == RTAX_NETMASK && SA_LEN(sa) == 0)
+					dcnt += alen;
+				else
+					dcnt += len;
+				p += len;
+			}
+			break;
+		}
+	}
+#else	/* NET_RT_IFLIST */
+#endif	/* NET_RT_IFLIST */
+
+	if (icnt + dcnt + ncnt == 1) {
+		*pif = NULL;
+		free(buf);
+		return (0);
+	}
+	data = malloc(sizeof(struct ifaddrs) * icnt + dcnt + ncnt);
+	if (data == NULL) {
+		free(buf);
+		return(-1);
+	}
+
+	ifa = (struct ifaddrs *)(void *)data;
+	data += sizeof(struct ifaddrs) * icnt;
+	names = data + dcnt;
+
+	memset(ifa, 0, sizeof(struct ifaddrs) * icnt);
+	ift = ifa;
+
+#ifdef	NET_RT_IFLIST
+	idx = 0;
+	for (next = buf; next < buf + needed; next += rtm->rtm_msglen) {
+		rtm = (struct rt_msghdr *)(void *)next;
+		if (rtm->rtm_version != RTM_VERSION)
+			continue;
+		switch (rtm->rtm_type) {
+		case RTM_IFINFO:
+			ifm = (struct if_msghdr *)(void *)rtm;
+			if (ifm->ifm_addrs & RTA_IFP) {
+				idx = ifm->ifm_index;
+				dl = (struct sockaddr_dl *)(void *)(ifm + 1);
+
+				cif = ift;
+				ift->ifa_name = names;
+				ift->ifa_flags = (int)ifm->ifm_flags;
+				memcpy(names, dl->sdl_data,
+				    (size_t)dl->sdl_nlen);
+				names[dl->sdl_nlen] = 0;
+				names += dl->sdl_nlen + 1;
+
+				ift->ifa_addr = (struct sockaddr *)(void *)data;
+				memcpy(data, dl,
+				    (size_t)SA_LEN((struct sockaddr *)
+				    (void *)dl));
+				data += SA_RLEN((struct sockaddr *)(void *)dl);
+
+#ifdef	HAVE_IFM_DATA
+				/* ifm_data needs to be aligned */
+				ift->ifa_data = data = (void *)ALIGN(data);
+				memcpy(data, &ifm->ifm_data, sizeof(ifm->ifm_data));
+ 				data += sizeof(ifm->ifm_data);
+#else	/* HAVE_IFM_DATA */
+				ift->ifa_data = NULL;
+#endif	/* HAVE_IFM_DATA */
+
+				ift = (ift->ifa_next = ift + 1);
+			} else
+				idx = 0;
+			break;
+
+		case RTM_NEWADDR:
+			ifam = (struct ifa_msghdr *)(void *)rtm;
+			if (idx && ifam->ifam_index != idx)
+			{
+				errno = EINVAL;		/* this cannot happen */
+				return -1;
+			};
+			if (idx == 0 || (ifam->ifam_addrs & RTA_MASKS) == 0)
+				break;
+			ift->ifa_name = cif->ifa_name;
+			ift->ifa_flags = cif->ifa_flags;
+			ift->ifa_data = NULL;
+			p = (char *)(void *)(ifam + 1);
+			/* Scan to look for length of address */
+			alen = 0;
+			for (p0 = p, i = 0; i < RTAX_MAX; i++) {
+				if ((RTA_MASKS & ifam->ifam_addrs & (1 << i))
+				    == 0)
+					continue;
+				sa = (struct sockaddr *)(void *)p;
+				len = SA_RLEN(sa);
+				if (i == RTAX_IFA) {
+					alen = len;
+					break;
+				}
+				p += len;
+			}
+			for (p = p0, i = 0; i < RTAX_MAX; i++) {
+				if ((RTA_MASKS & ifam->ifam_addrs & (1 << i))
+				    == 0)
+					continue;
+				sa = (struct sockaddr *)(void *)p;
+				len = SA_RLEN(sa);
+				switch (i) {
+				case RTAX_IFA:
+					ift->ifa_addr =
+					    (struct sockaddr *)(void *)data;
+					memcpy(data, p, len);
+					data += len;
+					break;
+
+				case RTAX_NETMASK:
+					ift->ifa_netmask =
+					    (struct sockaddr *)(void *)data;
+					if (SA_LEN(sa) == 0) {
+						memset(data, 0, alen);
+						data += alen;
+						break;
+					}
+					memcpy(data, p, len);
+					data += len;
+					break;
+
+				case RTAX_BRD:
+					ift->ifa_broadaddr =
+					    (struct sockaddr *)(void *)data;
+					memcpy(data, p, len);
+					data += len;
+					break;
+				}
+				p += len;
+			}
+
+#ifdef	HAVE_IFAM_DATA
+			/* ifam_data needs to be aligned */
+			ift->ifa_data = data = (void *)ALIGN(data);
+			memcpy(data, &ifam->ifam_data, sizeof(ifam->ifam_data));
+			data += sizeof(ifam->ifam_data);
+#endif	/* HAVE_IFAM_DATA */
+
+			ift = (ift->ifa_next = ift + 1);
+			break;
+		}
+	}
+
+	free(buf);
+#else	/* NET_RT_IFLIST */
+#endif	/* NET_RT_IFLIST */
+	if (--ift >= ifa) {
+		ift->ifa_next = NULL;
+		*pif = ifa;
+	} else {
+		*pif = NULL;
+		free(ifa);
+	}
+	return (0);
+}
+libc_hidden_def (getifaddrs)
+
+void
+freeifaddrs(struct ifaddrs *ifp)
+{
+
+	free(ifp);
+}
+libc_hidden_def (freeifaddrs)
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/ifreq.c
@@ -0,0 +1,93 @@
+/* Copyright (C) 1999, 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <net/if.h>
+#include <sys/socket.h>
+#include <sys/ioctl.h>
+
+#include <ifreq.h>
+
+/* The FreeBSD ioctl SIOCGIFCONF returns the list if interfaces as a
+   concatenation of records of different size, each having at least
+   sizeof (struct ifreq) bytes.  */
+
+
+void
+__ifreq (struct ifreq **ifreqs, int *num_ifs, int sockfd)
+{
+  int fd = sockfd;
+  struct ifconf ifc;
+  int rq_len;
+  int nifs;
+  char *ifstart;
+  char *ifend;
+  struct ifreq *ifr;
+  /* FreeBSD has many interfaces, many of them are usually down.  */
+# define RQ_IFS	16
+  /* We have to assume all records are of limited size, so that we know
+     when we can stop enlarging the buffer.  */
+# define RQ_MAXSIZE 256
+
+  if (fd < 0)
+    fd = __opensock ();
+  if (fd < 0)
+    {
+      *num_ifs = 0;
+      *ifreqs = NULL;
+      return;
+    }
+
+  ifc.ifc_buf = NULL;
+  rq_len = RQ_IFS * sizeof (struct ifreq) + RQ_MAXSIZE;
+  for (;;)
+    {
+      ifc.ifc_len = rq_len;
+      ifc.ifc_buf = realloc (ifc.ifc_buf, ifc.ifc_len);
+      if (ifc.ifc_buf == NULL || __ioctl (fd, SIOCGIFCONF, &ifc) < 0)
+	{
+	  if (ifc.ifc_buf)
+	    free (ifc.ifc_buf);
+
+	  if (fd != sockfd)
+	    __close (fd);
+	  *num_ifs = 0;
+	  *ifreqs = NULL;
+	  return;
+	}
+      if (ifc.ifc_len + RQ_MAXSIZE <= rq_len)
+	break;
+      rq_len *= 2;
+    }
+
+  nifs = 0;
+  ifstart = (char *) ifc.ifc_buf;
+  ifend = ifstart + ifc.ifc_len;
+  for (ifr = (struct ifreq *) ifstart;
+       (char *) ifr < ifend;
+       ifr = __if_nextreq (ifr))
+    nifs++;
+
+  if (fd != sockfd)
+    __close (fd);
+
+  *num_ifs = nifs;
+  *ifreqs = realloc (ifc.ifc_buf, ifc.ifc_len);
+}
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/init-first.c
@@ -0,0 +1,128 @@
+/* Initialization code run first thing by the ELF startup code.  Linux version.
+   Copyright (C) 1995-1999,2000,01,02,03,2004 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <fcntl.h>
+#include <unistd.h>
+#include <sysdep.h>
+#include <fpu_control.h>
+#include <sys/param.h>
+#include <sys/types.h>
+#include <libc-internal.h>
+
+#include <ldsodefs.h>
+
+/* The function is called from assembly stubs the compiler can't see.  */
+static void init (int, char **, char **) __attribute__ ((used));
+
+/* Set nonzero if we have to be prepared for more then one libc being
+   used in the process.  Safe assumption if initializer never runs.  */
+int __libc_multiple_libcs attribute_hidden = 1;
+
+/* Remember the command line argument and enviroment contents for
+   later calls of initializers for dynamic libraries.  */
+int __libc_argc attribute_hidden;
+char **__libc_argv attribute_hidden;
+
+
+static void
+init (int argc, char **argv, char **envp)
+{
+#ifdef USE_NONOPTION_FLAGS
+  extern void __getopt_clean_environment (char **);
+#endif
+
+  __libc_multiple_libcs = &_dl_starting_up && !_dl_starting_up;
+
+  /* Make sure we don't initialize twice.  */
+  if (!__libc_multiple_libcs)
+    {
+      /* Set the FPU control word to the proper default value if the
+	 kernel would use a different value.  (In a static program we
+	 don't have this information.)  */
+#if 0
+      /* at least on kFreeBSD set it even if SHARED,
+      fixes "make check" failures like math/test-fpucw.out */
+#ifdef SHARED
+      if (__fpu_control != GLRO(dl_fpu_control))
+#endif
+#endif
+	__setfpucw (__fpu_control);
+    }
+
+  /* Save the command-line arguments.  */
+  __libc_argc = argc;
+  __libc_argv = argv;
+  __environ = envp;
+
+#ifndef SHARED
+  __libc_init_secure ();
+
+  /* First the initialization which normally would be done by the
+     dynamic linker.  */
+  _dl_non_dynamic_init ();
+#endif
+
+  __init_misc (argc, argv, envp);
+
+#ifdef USE_NONOPTION_FLAGS
+  /* This is a hack to make the special getopt in GNU libc working.  */
+  __getopt_clean_environment (envp);
+#endif
+
+#ifdef SHARED
+  __libc_global_ctors ();
+#endif
+}
+
+#ifdef SHARED
+
+strong_alias (init, _init);
+
+extern void __libc_init_first (void);
+
+void
+__libc_init_first (void)
+{
+}
+
+#else
+extern void __libc_init_first (int argc, char **argv, char **envp);
+
+void
+__libc_init_first (int argc, char **argv, char **envp)
+{
+  init (argc, argv, envp);
+}
+#endif
+
+
+/* This function is defined here so that if this file ever gets into
+   ld.so we will get a link error.  Having this file silently included
+   in ld.so causes disaster, because the _init definition above will
+   cause ld.so to gain an init function, which is not a cool thing. */
+
+extern void _dl_start (void) __attribute__ ((noreturn));
+
+void
+_dl_start (void)
+{
+  abort ();
+}
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/kernel-features.h
@@ -0,0 +1,43 @@
+/* Set flags signalling availability of kernel features based on given
+   kernel version number.
+   Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef __KFREEBSD_KERNEL_VERSION
+/* We assume the worst; all kernels should be supported.  */
+# define __KFREEBSD_KERNEL_VERSION	0
+#endif
+
+/* We assume for __KFREEBSD_KERNEL_VERSION the same encoding used in
+   osreldate.h.  I.e., the major, minor, and subminor are all
+   concatenated, with two digits for each.  This means we can do
+   numeric comparisons.
+
+   In the following we will define certain symbols depending on
+   whether the describes kernel feature is available in the kernel
+   version given by __KFREEBSD_KERNEL_VERSION.  We are not always exactly
+   recording the correct versions in which the features were
+   introduced.  If somebody cares these values can afterwards be
+   corrected.  */
+
+/* No real-time signals in FreeBSD 5.x or 6.x.  */
+#define __ASSUME_REALTIME_SIGNALS	0
+
+/* Use signals #32, #33, #34 for internal linuxthreads communication */
+#define PTHREAD_SIGBASE 32
+
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/kernel-posix-cpu-timers.h
@@ -0,0 +1,5 @@
+/* Parameters for the FreeBSD kernel ABI for CPU clocks.  */
+
+#define CPUCLOCK_WHICH(clock)   ((clock) & (clockid_t) CPUCLOCK_CLOCK_MASK)
+#define CPUCLOCK_CLOCK_MASK     7
+
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/ldsodefs.h
@@ -0,0 +1,39 @@
+/* Run-time dynamic linker data structures for loaded ELF shared objects.
+   Copyright (C) 2001, 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef	_LDSODEFS_H
+
+/* Get the real definitions.  */
+#include_next <ldsodefs.h>
+
+/* Now define our stuff.  */
+
+/* FreeBSD puts some extra information into an auxiliary vector when it
+   execs ELF executables.  Note that it uses AT_* values of 10 and 11
+   to denote something different than AT_NOTELF and AT_UID, but this is
+   not a problem since elf/dl-support.c ignores these AT_* values.  */
+#define HAVE_AUX_VECTOR
+
+/* Used by static binaries to check the auxiliary vector.  */
+extern void _dl_aux_init (ElfW(auxv_t) *av) internal_function;
+
+/* Initialization which is normally done by the dynamic linker.  */
+extern void _dl_non_dynamic_init (void) internal_function;
+
+#endif /* ldsodefs.h */
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/linuxthreads/Implies
@@ -0,0 +1 @@
+pthread
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/linuxthreads/Makefile
@@ -0,0 +1,3 @@
+ifeq ($(subdir),linuxthreads)
+sysdep_routines += register-atfork unregister-atfork
+endif
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/linuxthreads/Versions
@@ -0,0 +1,5 @@
+libc {
+  GLIBC_2.3.2 {
+    __register_atfork;
+  }
+}
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/linuxthreads/allocrtsig.c
@@ -0,0 +1,14 @@
+#if 1
+
+#define __SIGRTMIN 65
+#define __SIGRTMAX 126
+#include <linuxthreads/sysdeps/unix/sysv/linux/allocrtsig.c>
+
+#else
+
+#include <signal/allocrtsig.c>
+strong_alias (__libc_current_sigrtmin, __libc_current_sigrtmin_private);
+strong_alias (__libc_current_sigrtmax, __libc_current_sigrtmax_private);
+strong_alias (__libc_allocate_rtsig, __libc_allocate_rtsig_private);
+
+#endif
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/linuxthreads/bits/local_lim.h
@@ -0,0 +1,48 @@
+/* Minimum guaranteed maximum values for system limits.  FreeBSD version.
+   Copyright (C) 1993-1998, 2000, 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sys/syslimits.h>
+
+/* The number of data keys per process.  */
+#define _POSIX_THREAD_KEYS_MAX	128
+/* This is the value this implementation supports.  */
+#define PTHREAD_KEYS_MAX	1024
+
+/* Controlling the iterations of destructors for thread-specific data.  */
+#define _POSIX_THREAD_DESTRUCTOR_ITERATIONS	4
+/* Number of iterations this implementation does.  */
+#define PTHREAD_DESTRUCTOR_ITERATIONS	_POSIX_THREAD_DESTRUCTOR_ITERATIONS
+
+/* The number of threads per process.  */
+#define _POSIX_THREAD_THREADS_MAX	64
+/* This is the value this implementation supports.  */
+#define PTHREAD_THREADS_MAX	1024
+
+/* Maximum amount by which a process can descrease its asynchronous I/O
+   priority level.  */
+#define AIO_PRIO_DELTA_MAX	20
+
+/* Minimum size for a thread.  We are free to choose a reasonable value.  */
+#define PTHREAD_STACK_MIN	16384
+
+/* Maximum number of POSIX timers available.  */
+#define TIMER_MAX	256
+
+/* Maximum number of timer expiration overruns.  */
+#define DELAYTIMER_MAX	2147483647
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/linuxthreads/bits/posix_opt.h
@@ -0,0 +1,190 @@
+/* Define POSIX options for FreeBSD.
+   Copyright (C) 1996-1997, 1999, 2000, 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+/*
+ * Never include this file directly; use <unistd.h> instead.
+ */
+
+#ifndef	_BITS_POSIX_OPT_H
+#define	_BITS_POSIX_OPT_H	1
+
+/* Job control is supported.  */
+#define	_POSIX_JOB_CONTROL	1
+
+/* Processes have a saved set-user-ID and a saved set-group-ID.  */
+#define	_POSIX_SAVED_IDS	1
+
+/* Priority scheduling is supported.  */
+#define	_POSIX_PRIORITY_SCHEDULING	200112L
+
+/* Synchronizing file data is supported.  */
+#define	_POSIX_SYNCHRONIZED_IO	200112L
+
+/* The fsync function is present.  */
+#define	_POSIX_FSYNC	200112L
+
+/* Mapping of files to memory is supported.  */
+#define	_POSIX_MAPPED_FILES	200112L
+
+/* Locking of all memory is supported.  */
+#define	_POSIX_MEMLOCK	200112L
+
+/* Locking of ranges of memory is supported.  */
+#define	_POSIX_MEMLOCK_RANGE	200112L
+
+/* Setting of memory protections is supported.  */
+#define	_POSIX_MEMORY_PROTECTION	200112L
+
+/* Only root can change owner of file.  */
+#define	_POSIX_CHOWN_RESTRICTED	1
+
+/* `c_cc' member of 'struct termios' structure can be disabled by
+   using the value _POSIX_VDISABLE.  */
+#define	_POSIX_VDISABLE	((unsigned char)'\377')
+
+/* Filenames are not silently truncated.  */
+#define	_POSIX_NO_TRUNC	1
+/* X/Open realtime support is only partially available.  */
+#define _XOPEN_REALTIME	-1
+
+/* X/Open realtime thread support is only partially available.  */
+#define _XOPEN_REALTIME_THREADS	-1
+
+/* Implementation supports `poll' function.  */
+#define	_POSIX_POLL	1
+
+/* Implementation supports `select' and `pselect' functions.  */
+#define	_POSIX_SELECT	1
+
+/* XPG4.2 shared memory is supported.  */
+#define	_XOPEN_SHM	1
+
+/* Tell we have POSIX threads.  */
+#define _POSIX_THREADS	200112L
+
+/* We have the reentrant functions described in POSIX.  */
+#define _POSIX_REENTRANT_FUNCTIONS	1
+#define _POSIX_THREAD_SAFE_FUNCTIONS	200112L
+
+/* We provide priority scheduling for threads.  */
+#define _POSIX_THREAD_PRIORITY_SCHEDULING	200112L
+
+/* We support user-defined stack sizes.  */
+#define _POSIX_THREAD_ATTR_STACKSIZE	200112L
+
+/* We support user-defined stacks.  */
+#define _POSIX_THREAD_ATTR_STACKADDR	200112L
+
+/* We support POSIX.1b semaphores, but only the non-shared form for now.  */
+#define _POSIX_SEMAPHORES	200112L
+
+/* Real-time signals are not available.  */
+#define _POSIX_REALTIME_SIGNALS	-1
+
+/* We support asynchronous I/O.  */
+#define _POSIX_ASYNCHRONOUS_IO	200112L
+#define _POSIX_ASYNC_IO		1
+/* Alternative name for Unix98.  */
+#define _LFS_ASYNCHRONOUS_IO	1
+/* Support for prioritization is not available.  */
+#define _POSIX_PRIORITIZED_IO	-1
+
+/* The LFS support in asynchronous I/O is also available.  */
+#define _LFS64_ASYNCHRONOUS_IO	1
+
+/* The rest of the LFS is also available.  */
+#define _LFS_LARGEFILE		1
+#define _LFS64_LARGEFILE	1
+#define _LFS64_STDIO		1
+
+/* POSIX shared memory objects are implemented.  */
+#define _POSIX_SHARED_MEMORY_OBJECTS	200112L
+
+/* CPU-time clocks somewhere supported.  */
+#define _POSIX_CPUTIME	0
+
+/* We support somewhere the clock also in threads.  */
+#define _POSIX_THREAD_CPUTIME	0
+
+/* GNU libc provides regular expression handling.  */
+#define _POSIX_REGEXP	1
+
+/* Reader/Writer locks are available.  */
+#define _POSIX_READER_WRITER_LOCKS	200112L
+
+/* We have a POSIX shell.  */
+#define _POSIX_SHELL	1
+
+/* We support the Timeouts option.  */
+#define _POSIX_TIMEOUTS	200112L
+
+/* We support spinlocks.  */
+#define _POSIX_SPIN_LOCKS	200112L
+
+/* The `spawn' function family is supported.  */
+#define _POSIX_SPAWN	200112L
+
+/* We have POSIX timers.  */
+#define _POSIX_TIMERS	200112L
+
+/* The barrier functions are available.  */
+#define _POSIX_BARRIERS	200112L
+
+/* POSIX message queues are not available.  */
+#define _POSIX_MESSAGE_PASSING	-1
+
+/* Thread process-shared synchronization is not supported.  */
+#define _POSIX_THREAD_PROCESS_SHARED	-1
+
+/* The monotonic clock is available.  */
+#define _POSIX_MONOTONIC_CLOCK	200112L
+
+/* The clock selection interfaces are not available.  */
+#define _POSIX_CLOCK_SELECTION	-1
+
+/* Advisory information interfaces are not available.  */
+#define _POSIX_ADVISORY_INFO	-1
+
+/* IPv6 support is available.  */
+#define _POSIX_IPV6	200112L
+
+/* Raw socket support is available.  */
+#define _POSIX_RAW_SOCKETS	200112L
+
+/* We have at least one terminal.  */
+#define _POSIX2_CHAR_TERM	200112L
+
+/* Neither process nor thread sporadic server interfaces is available.  */
+#define _POSIX_SPORADIC_SERVER	-1
+#define _POSIX_THREAD_SPORADIC_SERVER	-1
+
+/* trace.h is not available.  */
+#define _POSIX_TRACE	-1
+#define _POSIX_TRACE_EVENT_FILTER	-1
+#define _POSIX_TRACE_INHERIT	-1
+#define _POSIX_TRACE_LOG	-1
+
+/* Typed memory objects are not available.  */
+#define _POSIX_TYPED_MEMORY_OBJECTS	-1
+
+/* No support for priority inheritance or protection.  */
+#define _POSIX_THREAD_PRIO_INHERIT	-1
+#define _POSIX_THREAD_PRIO_PROTECT	-1
+
+#endif /* bits/posix_opt.h */
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/linuxthreads/bits/sigthread.h
@@ -0,0 +1,38 @@
+/* Signal handling function for threaded programs.
+   Copyright (C) 1998, 1999, 2000, 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _BITS_SIGTHREAD_H
+#define _BITS_SIGTHREAD_H	1
+
+#if !defined _SIGNAL_H && !defined _PTHREAD_H
+# error "Never include this file directly.  Use <pthread.h> instead"
+#endif
+
+/* Functions for handling signals. */
+
+/* Modify the signal mask for the calling thread.  The arguments have
+   the same meaning as for sigprocmask(2). */
+extern int pthread_sigmask (int __how,
+			    __const __sigset_t *__restrict __newmask,
+			    __sigset_t *__restrict __oldmask) __THROW;
+
+/* Send signal SIGNO to the given thread. */
+extern int pthread_kill (pthread_t __threadid, int __signo) __THROW;
+
+#endif	/* bits/sigthread.h */
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/linuxthreads/bits/typesizes.h
@@ -0,0 +1,66 @@
+/* bits/typesizes.h -- underlying types for *_t.  kFreeBSD version.
+   Copyright (C) 2002, 2003 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _BITS_TYPES_H
+# error "Never include <bits/typesizes.h> directly; use <sys/types.h> instead."
+#endif
+
+#ifndef	_BITS_TYPESIZES_H
+#define	_BITS_TYPESIZES_H	1
+
+/* See <bits/types.h> for the meaning of these macros.  This file exists so
+   that <bits/types.h> need not vary across different GNU platforms.  */
+
+#define __DEV_T_TYPE		__U32_TYPE
+#define __UID_T_TYPE		__U32_TYPE
+#define __GID_T_TYPE		__U32_TYPE
+#define __INO_T_TYPE		__U32_TYPE
+#define __INO64_T_TYPE		__UQUAD_TYPE
+#define __MODE_T_TYPE		__U16_TYPE
+#define __NLINK_T_TYPE		__U16_TYPE
+#define __OFF_T_TYPE		__SQUAD_TYPE
+#define __OFF64_T_TYPE		__SQUAD_TYPE
+#define __PID_T_TYPE		__S32_TYPE
+#define __RLIM_T_TYPE		__SQUAD_TYPE
+#define __RLIM64_T_TYPE		__SQUAD_TYPE
+#define	__BLKCNT_T_TYPE		__SQUAD_TYPE
+#define	__BLKCNT64_T_TYPE	__SQUAD_TYPE
+#define	__FSBLKCNT_T_TYPE	__ULONGWORD_TYPE
+#define	__FSBLKCNT64_T_TYPE	__UQUAD_TYPE
+#define	__FSFILCNT_T_TYPE	__ULONGWORD_TYPE
+#define	__FSFILCNT64_T_TYPE	__UQUAD_TYPE
+#define	__ID_T_TYPE		__U32_TYPE
+#define __CLOCK_T_TYPE		__S32_TYPE
+#define __TIME_T_TYPE		__SLONGWORD_TYPE
+#define __USECONDS_T_TYPE	__U32_TYPE
+#define __SUSECONDS_T_TYPE	__SLONGWORD_TYPE
+#define __DADDR_T_TYPE		__S32_TYPE
+#define __SWBLK_T_TYPE		__S32_TYPE
+#define __KEY_T_TYPE		__SLONGWORD_TYPE
+#define __CLOCKID_T_TYPE	__S32_TYPE
+#define __TIMER_T_TYPE		__S32_TYPE
+#define __BLKSIZE_T_TYPE	__U32_TYPE
+#define __FSID_T_TYPE		struct { int __val[2]; }
+#define __SSIZE_T_TYPE		__SWORD_TYPE
+
+/* Number of descriptors that can fit in an `fd_set'.  */
+#define	__FD_SETSIZE		1024
+
+
+#endif /* bits/typesizes.h */
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/linuxthreads/execve.c
@@ -0,0 +1,2 @@
+#include <linuxthreads/sysdeps/unix/sysv/linux/execve.c>
+libc_hidden_proto (__syscall_execve )
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/linuxthreads/fatal-prepare.h
@@ -0,0 +1,39 @@
+/* Copyright (C) 2003, 2007 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <pthread.h>
+
+/* We have to completely disable cancellation.  assert() must not be a
+   cancellation point but the implementation uses write() etc.  */
+#ifdef SHARED
+# include <pthread-functions.h>
+# define FATAL_PREPARE \
+  {									      \
+    int (*fp) (int, int *);                                                   \
+    fp = __libc_pthread_functions.ptr_pthread_setcancelstate;                 \
+    if (fp != NULL)                                                           \
+      fp (PTHREAD_CANCEL_DISABLE, NULL);                                      \
+  }
+#else
+# pragma weak pthread_setcancelstate
+# define FATAL_PREPARE \
+  {									      \
+    if (pthread_setcancelstate != NULL)					      \
+      pthread_setcancelstate (PTHREAD_CANCEL_DISABLE, NULL);		      \
+  }
+#endif
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/linuxthreads/fork.c
@@ -0,0 +1 @@
+#include <linuxthreads/sysdeps/unix/sysv/linux/fork.c>
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/linuxthreads/fork.h
@@ -0,0 +1 @@
+#include <linuxthreads/sysdeps/unix/sysv/linux/fork.h>
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/linuxthreads/jmp-unwind.c
@@ -0,0 +1 @@
+#include <linuxthreads/sysdeps/unix/sysv/linux/jmp-unwind.c>
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/linuxthreads/lowlevellock.h
@@ -0,0 +1,47 @@
+/* Copyright (C) 2007 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _LOWLEVELLOCK_H
+#define _LOWLEVELLOCK_H	1
+
+#include <atomic.h>
+
+typedef union
+{
+  volatile void *	uv;	/* in fact struct umtx from <sys/umtx.h> */
+  volatile int		iv;
+  volatile long		lv;
+
+} __rtld_mrlock_t;
+
+#define UMTX_OP_WAIT	2	/*  <sys/umtx.h> */
+#define UMTX_OP_WAKE	3	/*  <sys/umtx.h> */
+
+extern int __syscall__umtx_op(void *, int, long, void*, void*);
+
+static inline void lll_futex_wake(long *umtx, unsigned int nr_wakeup)
+{
+  __syscall__umtx_op(umtx, UMTX_OP_WAKE, nr_wakeup, NULL, NULL);
+}
+
+static inline void lll_futex_wait(long *umtx, unsigned int old_val)
+{
+  __syscall__umtx_op(umtx, UMTX_OP_WAIT, old_val, NULL, NULL);
+}
+
+#endif	/* lowlevellock.h */
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/linuxthreads/pt-sigsuspend.S
@@ -0,0 +1,29 @@
+/* Internal sigsuspend system call for LinuxThreads. FreeBSD version.
+   Copyright (C) 2003 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+
+#include <sysdep.h>
+
+PSEUDO_NOERRNO(__pthread_sigsuspend, sigsuspend, 1)
+	ret_NOERRNO
+PSEUDO_END_NOERRNO(__pthread_sigsuspend)
+
+PSEUDO(__syscall_sigsuspend, sigsuspend, 1)
+	ret
+PSEUDO_END(__syscall_sigsuspend)
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/linuxthreads/raise.c
@@ -0,0 +1 @@
+#include <linuxthreads/sysdeps/unix/sysv/linux/raise.c>
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/linuxthreads/register-atfork.c
@@ -0,0 +1 @@
+#include <linuxthreads/sysdeps/unix/sysv/linux/register-atfork.c>
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/linuxthreads/smp.h
@@ -0,0 +1,36 @@
+/* Determine whether the host has multiple processors.  FreeBSD version.
+   Copyright (C) 1996, 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+#include <sys/sysctl.h>
+
+/* Test whether the machine has more than one processor.  */
+static inline int
+is_smp_system (void)
+{
+  /* Fetch sysctl value of "hw.ncpu".  */
+  int request[] = { CTL_HW, HW_NCPU };
+  int result;
+  size_t result_len = sizeof (result);
+
+  if (__sysctl (request, 2, &result, &result_len, NULL, 0) < 0)
+    /* Dummy result.  */
+    return 0;
+
+  return (result > 1);
+}
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/linuxthreads/unregister-atfork.c
@@ -0,0 +1 @@
+#include <linuxthreads/sysdeps/unix/sysv/linux/unregister-atfork.c>
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/llseek.c
@@ -0,0 +1,6 @@
+/* We don't need a definition since the lseek64 function is what we need.  */
+/* llseek doesn't have a prototype.  Since the second parameter is a
+   64bit type, this results in wrong behaviour if no prototype is
+   provided.  */
+link_warning (llseek, "\
+the `llseek' function may be dangerous; use `lseek64' instead.")
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/lseek.c
@@ -0,0 +1,86 @@
+/* Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Bruno Haible <bruno@clisp.org>, 2002.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <unistd.h>
+#include <sys/types.h>
+#include <sysdep.h>
+#include <errno.h>
+
+/* The real system call has a word of padding before the 64-bit off_t
+   argument.  */
+extern __off_t __syscall_freebsd6_lseek (int __fd, int __unused1, __off_t __offset,
+				int __whence) __THROW;
+libc_hidden_proto (__syscall_freebsd6_lseek)
+
+__off_t
+__libc_lseek (int fd, __off_t offset, int whence)
+{
+#if 0 /* If the kernel would work right... */
+  /* We pass 3 arguments in 5 words.  */
+  return INLINE_SYSCALL (freebsd6_lseek, 3, fd, 0, offset, whence);
+#else
+  /* According to POSIX:2001, if the resulting file offset would become
+     negative, this function has to return an EINVAL error and leave the
+     file offset unchanged.  But the FreeBSD 4.0 kernel doesn't do this,
+     so we emulate it.  */
+  if (offset >= 0)
+    /* No risk that the file offset could become negative.  */
+    return INLINE_SYSCALL (freebsd6_lseek, 3, fd, 0, offset, whence);
+  else
+    {
+      /* Test whether the file offset becomes negative.  */
+      __off_t old_position;
+      __off_t new_position;
+      int saved_errno;
+
+      saved_errno = errno;
+      old_position = INLINE_SYSCALL (freebsd6_lseek, 3, fd, 0, 0, SEEK_CUR);
+      errno = 0;
+      new_position = INLINE_SYSCALL (freebsd6_lseek, 3, fd, 0, offset, whence);
+      if (new_position < 0)
+	{
+	  if (errno == 0)
+	    {
+	      /* The file offset became negative, and the kernel didn't
+		 notice it.  */
+	      if (old_position >= 0)
+		INLINE_SYSCALL (freebsd6_lseek, 3, fd, 0, old_position, SEEK_SET);
+	      new_position = -1;
+	      errno = EINVAL;
+	    }
+	}
+      else
+	errno = saved_errno;
+      return new_position;
+    }
+#endif
+}
+
+weak_alias (__libc_lseek, __lseek)
+libc_hidden_def (__lseek)
+weak_alias (__libc_lseek, lseek)
+
+/* 'lseek64' is the same as 'lseek', because __off64_t == __off_t.  */
+strong_alias (__libc_lseek, __libc_lseek64)
+weak_alias (__libc_lseek64, __lseek64)
+weak_alias (__lseek64, lseek64)
+
+/* 'llseek' is the same as 'lseek', because __off64_t == __off_t.  */
+strong_alias (__libc_lseek, __llseek)
+weak_alias (__llseek, llseek)
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/lseek64.c
@@ -0,0 +1 @@
+/* 'lseek64' is the same as 'lseek', because __off64_t == __off_t.  */
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/lxstat.c
@@ -0,0 +1,49 @@
+/* lxstat using FreeBSD lstat, nlstat system calls.
+   Copyright (C) 1991,1995-1997,2000,2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <errno.h>
+#include <stddef.h>
+#include <sys/stat.h>
+#include <bp-checks.h>
+
+#include "stat16conv.c"
+
+int
+__lxstat (int vers, const char *file, struct stat *buf)
+{
+  if (__builtin_expect (vers == _STAT_VER, 1))
+    {
+      struct stat16 buf16;
+      int result = __syscall_lstat (CHECK_STRING (file), __ptrvalue (&buf16));
+      if (result == 0)
+	stat16_to_stat (&buf16, buf);
+      return result;
+    }
+  else if (__builtin_expect (vers == _STAT_VER_stat, 1))
+    return __syscall_lstat (CHECK_STRING (file),
+			    CHECK_1 ((struct stat16 *) buf));
+  else
+    {
+      __set_errno (EINVAL);
+      return -1;
+    }
+}
+hidden_def (__lxstat)
+
+weak_alias (__lxstat, _lxstat)
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/lxstat64.c
@@ -0,0 +1,44 @@
+/* lxstat using FreeBSD lstat, nlstat system calls.
+   Copyright (C) 1991,1995-1997,2000,2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <errno.h>
+#include <stddef.h>
+#include <sys/stat.h>
+#include <bp-checks.h>
+
+#include "stat16conv.c"
+
+int
+__lxstat64 (int vers, const char *file, struct stat64 *buf)
+{
+  if (__builtin_expect (vers == _STAT_VER, 1))
+    {
+      struct stat16 buf16;
+      int result = __syscall_lstat (CHECK_STRING (file), __ptrvalue (&buf16));
+      if (result == 0)
+	stat16_to_stat64 (&buf16, buf);
+      return result;
+    }
+  else
+    {
+      __set_errno (EINVAL);
+      return -1;
+    }
+}
+hidden_def (__lxstat64)
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/mmap.c
@@ -0,0 +1,84 @@
+/* Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Bruno Haible <bruno@clisp.org>, 2002.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sys/types.h>
+#include <sys/mman.h>
+#include <unistd.h>
+#include <errno.h>
+#include <sysdep.h>
+
+/* The real system call has a word of padding before the 64-bit off_t
+   argument.  */
+extern void *__syscall_freebsd6_mmap (void *__addr, size_t __len, int __prot,
+			     int __flags, int __fd, int __unused1,
+			     __off_t __offset) __THROW;
+libc_hidden_proto (__syscall_freebsd6_mmap)
+
+extern ssize_t __syscall_freebsd6_pread (int __fd, void *__buf, size_t __nbytes,
+                                int __unused1, __off_t __offset) __THROW;
+
+libc_hidden_proto (__syscall_freebsd6_pread)
+void *
+__mmap (void *addr, size_t len, int prot, int flags, int fd, __off_t offset)
+{
+  void *result;
+
+  /* Validity checks not done by the kernel.  */
+  if ((flags & MAP_FIXED) || (offset != 0))
+    {
+      int pagesize = __getpagesize ();
+
+      if (((flags & MAP_FIXED)
+	   && (__builtin_expect (pagesize & (pagesize - 1), 0)
+	       ? (unsigned long) addr % pagesize
+	       : (unsigned long) addr & (pagesize - 1)))
+	  || (__builtin_expect (pagesize & (pagesize - 1), 0)
+	      ? offset % pagesize
+	      : offset & (pagesize - 1)))
+	{
+	  __set_errno (EINVAL);
+	  return (void *) (-1);
+	}
+    }
+
+  /* We pass 7 arguments in 8 words.  */
+  /* for ANON mapping we must pass -1 in place of fd */
+  if (flags & MAP_ANON)
+    return INLINE_SYSCALL (freebsd6_mmap, 7, addr, len, prot, flags, -1, 0, offset);
+  result = INLINE_SYSCALL (freebsd6_mmap, 7, addr, len, prot, flags, fd, 0, offset);
+
+  if (result != (void *) (-1) && fd >= 0 && len > 0)
+    {
+      /* Force an update of the atime.  POSIX:2001 mandates that this happens
+	 at some time between the mmap() call and the first page-in.  Since
+	 the FreeBSD 4.0 kernel doesn't update the atime upon a page-in, we
+	 do it here.  */
+      char dummy;
+
+      INLINE_SYSCALL (freebsd6_pread, 5, fd, &dummy, 1, 0, offset);
+    }
+
+  return result;
+}
+
+weak_alias (__mmap, mmap)
+
+/* 'mmap64' is the same as 'mmap', because __off64_t == __off_t.  */
+strong_alias (__mmap, __mmap64)
+weak_alias (__mmap64, mmap64)
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/mmap64.c
@@ -0,0 +1 @@
+/* 'mmap64' is the same as 'mmap', because __off64_t == __off_t.  */
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/munmap.c
@@ -0,0 +1,41 @@
+/* Copyright (C) 2006 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Petr Salinger, 2006.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sys/types.h>
+#include <sys/mman.h>
+#include <unistd.h>
+#include <errno.h>
+#include <sysdep.h>
+
+extern int __syscall_munmap (void *__addr, size_t __len) __THROW;
+libc_hidden_proto (__syscall_munmap)
+
+int
+__munmap (void *addr, size_t len)
+{
+    int pagesize = __getpagesize ();
+    if ((unsigned long) addr & (pagesize - 1))
+    {
+	__set_errno (EINVAL);
+	return -1;
+    }
+  return INLINE_SYSCALL (munmap, 2, addr, len);
+}
+
+weak_alias (__munmap, munmap)
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/net/ethernet.h
@@ -0,0 +1,76 @@
+/* Copyright (C) 1997, 1999, 2001, 2006 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+/* Based on the FreeBSD version of this file. Curiously, that file
+   lacks a copyright in the header. */
+
+#ifndef __NET_ETHERNET_H
+#define __NET_ETHERNET_H 1
+
+#include <sys/cdefs.h>
+#include <sys/types.h>
+#include <net/if_ether.h>     /* IEEE 802.3 Ethernet constants */
+
+__BEGIN_DECLS
+
+/* This is a name for the 48 bit ethernet address available on many
+   systems.  */
+struct ether_addr
+{
+  u_int8_t ether_addr_octet[ETH_ALEN];
+} __attribute__ ((__packed__));
+
+/* 10Mb/s ethernet header */
+struct ether_header
+{
+  u_int8_t  ether_dhost[ETH_ALEN];	/* destination eth addr	*/
+  u_int8_t  ether_shost[ETH_ALEN];	/* source ether addr	*/
+  u_int16_t ether_type;		        /* packet type ID field	*/
+} __attribute__ ((__packed__));
+
+/* Ethernet protocol ID's */
+#define	ETHERTYPE_PUP		0x0200          /* Xerox PUP */
+#define	ETHERTYPE_IP		0x0800		/* IP */
+#define	ETHERTYPE_ARP		0x0806		/* Address resolution */
+#define	ETHERTYPE_REVARP	0x8035		/* Reverse ARP */
+
+#define	ETHER_ADDR_LEN	ETH_ALEN                 /* size of ethernet addr */
+#define	ETHER_TYPE_LEN	2                        /* bytes in type field */
+#define	ETHER_CRC_LEN	4                        /* bytes in CRC field */
+#define	ETHER_HDR_LEN	ETH_HLEN                 /* total octets in header */
+#define	ETHER_MIN_LEN	(ETH_ZLEN + ETHER_CRC_LEN) /* min packet length */
+#define	ETHER_MAX_LEN	(ETH_FRAME_LEN + ETHER_CRC_LEN) /* max packet length */
+
+/* make sure ethenet length is valid */
+#define	ETHER_IS_VALID_LEN(foo)	\
+	((foo) >= ETHER_MIN_LEN && (foo) <= ETHER_MAX_LEN)
+
+/*
+ * The ETHERTYPE_NTRAILER packet types starting at ETHERTYPE_TRAIL have
+ * (type-ETHERTYPE_TRAIL)*512 bytes of data followed
+ * by an ETHER type (as given above) and then the (variable-length) header.
+ */
+#define	ETHERTYPE_TRAIL		0x1000		/* Trailer packet */
+#define	ETHERTYPE_NTRAILER	16
+
+#define	ETHERMTU	ETH_DATA_LEN
+#define	ETHERMIN	(ETHER_MIN_LEN - ETHER_HDR_LEN - ETHER_CRC_LEN)
+
+__END_DECLS
+
+#endif	/* net/ethernet.h */
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/net/if.h
@@ -0,0 +1,432 @@
+/*-
+ * Copyright (c) 1982, 1986, 1989, 1993
+ *	The Regents of the University of California.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 4. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ *	@(#)if.h	8.1 (Berkeley) 6/10/93
+ * $FreeBSD: src/sys/net/if.h,v 1.108 2007/06/11 20:08:11 andre Exp $
+ */
+
+#ifndef _NET_IF_H_
+#define	_NET_IF_H_
+
+#include <sys/cdefs.h>
+
+#include <features.h>
+
+#include <sys/types.h>
+#include <sys/socket.h>
+
+struct ifnet;
+
+/*
+ * Length of interface external name, including terminating '\0'.
+ * Note: this is the same size as a generic device's external name.
+ */
+#define		IF_NAMESIZE	16
+#define		IFNAMSIZ	IF_NAMESIZE
+#define		IF_MAXUNIT	0x7fff	/* historical value */
+
+/*
+ * Structure used to query names of interface cloners.
+ */
+
+struct if_clonereq {
+	int	ifcr_total;		/* total cloners (out) */
+	int	ifcr_count;		/* room for this many in user buffer */
+	char	*ifcr_buffer;		/* buffer for cloner names */
+};
+
+/*
+ * Structure describing information about an interface
+ * which may be of interest to management entities.
+ */
+struct if_data {
+	/* generic interface information */
+	unsigned char	ifi_type;		/* ethernet, tokenring, etc */
+	unsigned char	ifi_physical;		/* e.g., AUI, Thinnet, 10base-T, etc */
+	unsigned char	ifi_addrlen;		/* media address length */
+	unsigned char	ifi_hdrlen;		/* media header length */
+	unsigned char	ifi_link_state;		/* current link state */
+	unsigned char	ifi_spare_char1;	/* spare byte */
+	unsigned char	ifi_spare_char2;	/* spare byte */
+	unsigned char	ifi_datalen;		/* length of this data struct */
+	unsigned long	ifi_mtu;		/* maximum transmission unit */
+	unsigned long	ifi_metric;		/* routing metric (external only) */
+	unsigned long	ifi_baudrate;		/* linespeed */
+	/* volatile statistics */
+	unsigned long	ifi_ipackets;		/* packets received on interface */
+	unsigned long	ifi_ierrors;		/* input errors on interface */
+	unsigned long	ifi_opackets;		/* packets sent on interface */
+	unsigned long	ifi_oerrors;		/* output errors on interface */
+	unsigned long	ifi_collisions;		/* collisions on csma interfaces */
+	unsigned long	ifi_ibytes;		/* total number of octets received */
+	unsigned long	ifi_obytes;		/* total number of octets sent */
+	unsigned long	ifi_imcasts;		/* packets received via multicast */
+	unsigned long	ifi_omcasts;		/* packets sent via multicast */
+	unsigned long	ifi_iqdrops;		/* dropped on input, this interface */
+	unsigned long	ifi_noproto;		/* destined for unsupported protocol */
+	unsigned long	ifi_hwassist;		/* HW offload capabilities, see IFCAP */
+	time_t	ifi_epoch;		/* uptime at attach or stat reset */
+	struct	timeval ifi_lastchange;	/* time of last administrative change */
+};
+
+/*-
+ * Interface flags are of two types: network stack owned flags, and driver
+ * owned flags.  Historically, these values were stored in the same ifnet
+ * flags field, but with the advent of fine-grained locking, they have been
+ * broken out such that the network stack is responsible for synchronizing
+ * the stack-owned fields, and the device driver the device-owned fields.
+ * Both halves can perform lockless reads of the other half's field, subject
+ * to accepting the involved races.
+ *
+ * Both sets of flags come from the same number space, and should not be
+ * permitted to conflict, as they are exposed to user space via a single
+ * field.
+ *
+ * The following symbols identify read and write requirements for fields:
+ *
+ * (i) if_flags field set by device driver before attach, read-only there
+ *     after.
+ * (n) if_flags field written only by the network stack, read by either the
+ *     stack or driver.
+ * (d) if_drv_flags field written only by the device driver, read by either
+ *     the stack or driver.
+ */
+#define	IFF_UP		0x1		/* (n) interface is up */
+#define	IFF_BROADCAST	0x2		/* (i) broadcast address valid */
+#define	IFF_DEBUG	0x4		/* (n) turn on debugging */
+#define	IFF_LOOPBACK	0x8		/* (i) is a loopback net */
+#define	IFF_POINTOPOINT	0x10		/* (i) is a point-to-point link */
+#define	IFF_SMART	0x20		/* (i) interface manages own routes */
+#define	IFF_DRV_RUNNING	0x40		/* (d) resources allocated */
+#define	IFF_NOARP	0x80		/* (n) no address resolution protocol */
+#define	IFF_PROMISC	0x100		/* (n) receive all packets */
+#define	IFF_ALLMULTI	0x200		/* (n) receive all multicast packets */
+#define	IFF_DRV_OACTIVE	0x400		/* (d) tx hardware queue is full */
+#define	IFF_SIMPLEX	0x800		/* (i) can't hear own transmissions */
+#define	IFF_LINK0	0x1000		/* per link layer defined bit */
+#define	IFF_LINK1	0x2000		/* per link layer defined bit */
+#define	IFF_LINK2	0x4000		/* per link layer defined bit */
+#define	IFF_ALTPHYS	IFF_LINK2	/* use alternate physical connection */
+#define	IFF_MULTICAST	0x8000		/* (i) supports multicast */
+/*			0x10000		*/
+#define	IFF_PPROMISC	0x20000		/* (n) user-requested promisc mode */
+#define	IFF_MONITOR	0x40000		/* (n) user-requested monitor mode */
+#define	IFF_STATICARP	0x80000		/* (n) static ARP */
+#define	IFF_NEEDSGIANT	0x100000	/* (i) hold Giant over if_start calls */
+
+/*
+ * Old names for driver flags so that user space tools can continue to use
+ * the old (portable) names.
+ */
+#ifndef _KERNEL
+#define	IFF_RUNNING	IFF_DRV_RUNNING
+#define	IFF_OACTIVE	IFF_DRV_OACTIVE
+#endif
+
+/* flags set internally only: */
+#define	IFF_CANTCHANGE \
+	(IFF_BROADCAST|IFF_POINTOPOINT|IFF_DRV_RUNNING|IFF_DRV_OACTIVE|\
+	    IFF_SIMPLEX|IFF_MULTICAST|IFF_ALLMULTI|IFF_SMART|IFF_PROMISC)
+
+/*
+ * Values for if_link_state.
+ */
+#define	LINK_STATE_UNKNOWN	0	/* link invalid/unknown */
+#define	LINK_STATE_DOWN		1	/* link is down */
+#define	LINK_STATE_UP		2	/* link is up */
+
+/*
+ * Some convenience macros used for setting ifi_baudrate.
+ * XXX 1000 vs. 1024? --thorpej@netbsd.org
+ */
+#define	IF_Kbps(x)	((x) * 1000)		/* kilobits/sec. */
+#define	IF_Mbps(x)	(IF_Kbps((x) * 1000))	/* megabits/sec. */
+#define	IF_Gbps(x)	(IF_Mbps((x) * 1000))	/* gigabits/sec. */
+
+/*
+ * Capabilities that interfaces can advertise.
+ *
+ * struct ifnet.if_capabilities
+ *   contains the optional features & capabilities a particular interface
+ *   supports (not only the driver but also the detected hw revision).
+ *   Capabilities are defined by IFCAP_* below.
+ * struct ifnet.if_capenable
+ *   contains the enabled (either by default or through ifconfig) optional
+ *   features & capabilities on this interface.
+ *   Capabilities are defined by IFCAP_* below.
+ * struct if_data.ifi_hwassist in mbuf CSUM_ flag form, controlled by above
+ *   contains the enabled optional feature & capabilites that can be used
+ *   individually per packet and are specified in the mbuf pkthdr.csum_flags
+ *   field.  IFCAP_* and CSUM_* do not match one to one and CSUM_* may be
+ *   more detailed or differenciated than IFCAP_*.
+ *   Hwassist features are defined CSUM_* in sys/mbuf.h
+ */
+#define	IFCAP_RXCSUM		0x00001  /* can offload checksum on RX */
+#define	IFCAP_TXCSUM		0x00002  /* can offload checksum on TX */
+#define	IFCAP_NETCONS		0x00004  /* can be a network console */
+#define	IFCAP_VLAN_MTU		0x00008	/* VLAN-compatible MTU */
+#define	IFCAP_VLAN_HWTAGGING	0x00010	/* hardware VLAN tag support */
+#define	IFCAP_JUMBO_MTU		0x00020	/* 9000 byte MTU supported */
+#define	IFCAP_POLLING		0x00040	/* driver supports polling */
+#define	IFCAP_VLAN_HWCSUM	0x00080	/* can do IFCAP_HWCSUM on VLANs */
+#define	IFCAP_TSO4		0x00100	/* can do TCP Segmentation Offload */
+#define	IFCAP_TSO6		0x00200	/* can do TCP6 Segmentation Offload */
+#define	IFCAP_LRO		0x00400	/* can do Large Receive Offload */
+#define	IFCAP_WOL_UCAST		0x00800	/* wake on any unicast frame */
+#define	IFCAP_WOL_MCAST		0x01000	/* wake on any multicast frame */
+#define	IFCAP_WOL_MAGIC		0x02000	/* wake on any Magic Packet */
+#define	IFCAP_TOE4		0x04000	/* interface can offload TCP */
+#define	IFCAP_TOE6		0x08000	/* interface can offload TCP6 */
+#define	IFCAP_VLAN_HWFILTER	0x10000 /* interface hw can filter vlan tag */
+
+#define	IFCAP_HWCSUM		(IFCAP_RXCSUM | IFCAP_TXCSUM)
+#define	IFCAP_TSO		(IFCAP_TSO4 | IFCAP_TSO6)
+#define	IFCAP_WOL		(IFCAP_WOL_UCAST | IFCAP_WOL_MCAST | IFCAP_WOL_MAGIC)
+#define	IFCAP_TOE		(IFCAP_TOE4 | IFCAP_TOE6)
+
+#define	IFQ_MAXLEN	50
+#define	IFNET_SLOWHZ	1		/* granularity is 1 second */
+
+/*
+ * Message format for use in obtaining information about interfaces
+ * from getkerninfo and the routing socket
+ */
+struct if_msghdr {
+	unsigned short	ifm_msglen;	/* to skip over non-understood messages */
+	unsigned char	ifm_version;	/* future binary compatibility */
+	unsigned char	ifm_type;	/* message type */
+	int	ifm_addrs;	/* like rtm_addrs */
+	int	ifm_flags;	/* value of if_flags */
+	unsigned short	ifm_index;	/* index for associated ifp */
+	struct	if_data ifm_data;/* statistics and other data about if */
+};
+
+/*
+ * Message format for use in obtaining information about interface addresses
+ * from getkerninfo and the routing socket
+ */
+struct ifa_msghdr {
+	unsigned short	ifam_msglen;	/* to skip over non-understood messages */
+	unsigned char	ifam_version;	/* future binary compatibility */
+	unsigned char	ifam_type;	/* message type */
+	int	ifam_addrs;	/* like rtm_addrs */
+	int	ifam_flags;	/* value of ifa_flags */
+	unsigned short	ifam_index;	/* index for associated ifp */
+	int	ifam_metric;	/* value of ifa_metric */
+};
+
+/*
+ * Message format for use in obtaining information about multicast addresses
+ * from the routing socket
+ */
+struct ifma_msghdr {
+	unsigned short	ifmam_msglen;	/* to skip over non-understood messages */
+	unsigned char	ifmam_version;	/* future binary compatibility */
+	unsigned char	ifmam_type;	/* message type */
+	int	ifmam_addrs;	/* like rtm_addrs */
+	int	ifmam_flags;	/* value of ifa_flags */
+	unsigned short	ifmam_index;	/* index for associated ifp */
+};
+
+/*
+ * Message format announcing the arrival or departure of a network interface.
+ */
+struct if_announcemsghdr {
+	unsigned short	ifan_msglen;	/* to skip over non-understood messages */
+	unsigned char	ifan_version;	/* future binary compatibility */
+	unsigned char	ifan_type;	/* message type */
+	unsigned short	ifan_index;	/* index for associated ifp */
+	char	ifan_name[IFNAMSIZ]; /* if name, e.g. "en0" */
+	unsigned short	ifan_what;	/* what type of announcement */
+};
+
+#define	IFAN_ARRIVAL	0	/* interface arrival */
+#define	IFAN_DEPARTURE	1	/* interface departure */
+
+/*
+ * Interface request structure used for socket
+ * ioctl's.  All interface ioctl's must have parameter
+ * definitions which begin with ifr_name.  The
+ * remainder may be interface specific.
+ */
+struct	ifreq {
+	char	ifr_name[IFNAMSIZ];		/* if name, e.g. "en0" */
+	union {
+		struct	sockaddr ifru_addr;
+		struct	sockaddr ifru_dstaddr;
+		struct	sockaddr ifru_broadaddr;
+		struct	sockaddr ifru_netmask;
+		short	ifru_flags[2];
+		short	ifru_index;
+		int	ifru_metric;
+		int	ifru_mtu;
+		int	ifru_phys;
+		int	ifru_media;
+		char *	ifru_data;
+		int	ifru_cap[2];
+	} ifr_ifru;
+#define	ifr_addr	ifr_ifru.ifru_addr	/* address */
+#define	ifr_dstaddr	ifr_ifru.ifru_dstaddr	/* other end of p-to-p link */
+#define	ifr_broadaddr	ifr_ifru.ifru_broadaddr	/* broadcast address */
+#define	ifr_netmask	ifr_ifru.ifru_netmask	/* interface net mask */
+#define	ifr_flags	ifr_ifru.ifru_flags[0]	/* flags (low 16 bits) */
+#define	ifr_flagshigh	ifr_ifru.ifru_flags[1]	/* flags (high 16 bits) */
+#define	ifr_metric	ifr_ifru.ifru_metric	/* metric */
+#define	ifr_mtu		ifr_ifru.ifru_mtu	/* mtu */
+#define ifr_phys	ifr_ifru.ifru_phys	/* physical wire */
+#define ifr_media	ifr_ifru.ifru_media	/* physical media */
+#define	ifr_data	ifr_ifru.ifru_data	/* for use by interface */
+#define	ifr_reqcap	ifr_ifru.ifru_cap[0]	/* requested capabilities */
+#define	ifr_curcap	ifr_ifru.ifru_cap[1]	/* current capabilities */
+#define	ifr_index	ifr_ifru.ifru_index	/* interface index */
+};
+
+#define	_SIZEOF_ADDR_IFREQ(ifr) \
+	((ifr).ifr_addr.sa_len > sizeof(struct sockaddr) ? \
+	 (sizeof(struct ifreq) - sizeof(struct sockaddr) + \
+	  (ifr).ifr_addr.sa_len) : sizeof(struct ifreq))
+
+struct ifaliasreq {
+	char	ifra_name[IFNAMSIZ];		/* if name, e.g. "en0" */
+	struct	sockaddr ifra_addr;
+	struct	sockaddr ifra_broadaddr;
+	struct	sockaddr ifra_mask;
+};
+
+struct ifmediareq {
+	char	ifm_name[IFNAMSIZ];	/* if name, e.g. "en0" */
+	int	ifm_current;		/* current media options */
+	int	ifm_mask;		/* don't care mask */
+	int	ifm_status;		/* media status */
+	int	ifm_active;		/* active options */
+	int	ifm_count;		/* # entries in ifm_ulist array */
+	int	*ifm_ulist;		/* media words */
+};
+
+struct  ifdrv {
+	char            ifd_name[IFNAMSIZ];     /* if name, e.g. "en0" */
+	unsigned long   ifd_cmd;
+	size_t          ifd_len;
+	void            *ifd_data;
+};
+
+/*
+ * Structure used to retrieve aux status data from interfaces.
+ * Kernel suppliers to this interface should respect the formatting
+ * needed by ifconfig(8): each line starts with a TAB and ends with
+ * a newline.  The canonical example to copy and paste is in if_tun.c.
+ */
+
+#define	IFSTATMAX	800		/* 10 lines of text */
+struct ifstat {
+	char	ifs_name[IFNAMSIZ];	/* if name, e.g. "en0" */
+	char	ascii[IFSTATMAX + 1];
+};
+
+/*
+ * Structure used in SIOCGIFCONF request.
+ * Used to retrieve interface configuration
+ * for machine (useful for programs which
+ * must know all networks accessible).
+ */
+struct	ifconf {
+	int	ifc_len;		/* size of associated buffer */
+	union {
+		char    *ifcu_buf;
+		struct	ifreq *ifcu_req;
+	} ifc_ifcu;
+#define	ifc_buf	ifc_ifcu.ifcu_buf	/* buffer address */
+#define	ifc_req	ifc_ifcu.ifcu_req	/* array of structures returned */
+};
+
+#if defined (__amd64__) || defined (COMPAT_32BIT)
+struct ifconf32 {
+	int	ifc_len;		/* size of associated buffer */
+	union {
+		unsigned int	ifcu_buf;
+		unsigned int	ifcu_req;
+	} ifc_ifcu;
+};
+#endif
+
+/*
+ * interface groups
+ */
+
+#define	IFG_ALL		"all"		/* group contains all interfaces */
+/* XXX: will we implement this? */
+#define	IFG_EGRESS	"egress"	/* if(s) default route(s) point to */
+
+struct ifg_req {
+	union {
+		char			 ifgrqu_group[IFNAMSIZ];
+		char			 ifgrqu_member[IFNAMSIZ];
+	} ifgrq_ifgrqu;
+#define	ifgrq_group	ifgrq_ifgrqu.ifgrqu_group
+#define	ifgrq_member	ifgrq_ifgrqu.ifgrqu_member
+};
+
+/*
+ * Used to lookup groups for an interface
+ */
+struct ifgroupreq {
+	char	ifgr_name[IFNAMSIZ];
+	unsigned int	ifgr_len;
+	union {
+		char	ifgru_group[IFNAMSIZ];
+		struct	ifg_req *ifgru_groups;
+	} ifgr_ifgru;
+#define ifgr_group	ifgr_ifgru.ifgru_group
+#define ifgr_groups	ifgr_ifgru.ifgru_groups
+};
+
+/*
+ * Structure for SIOC[AGD]LIFADDR
+ */
+struct if_laddrreq {
+	char	iflr_name[IFNAMSIZ];
+	unsigned int	flags;
+#define	IFLR_PREFIX	0x8000  /* in: prefix given  out: kernel fills id */
+	unsigned int	prefixlen;         /* in/out */
+	struct	sockaddr_storage addr;   /* in/out */
+	struct	sockaddr_storage dstaddr; /* out */
+};
+
+struct if_nameindex {
+	unsigned int	if_index;	/* 1, 2, ... */
+	char		*if_name;	/* null terminated name: "le0", ... */
+};
+
+__BEGIN_DECLS
+void			 if_freenameindex(struct if_nameindex *);
+char			*if_indextoname(unsigned int, char *);
+struct if_nameindex	*if_nameindex(void);
+unsigned int		 if_nametoindex(const char *);
+__END_DECLS
+
+#endif /* !_NET_IF_H_ */
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/net/if_ether.h
@@ -0,0 +1,104 @@
+/* Copyright (C) 2006 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _NET_IF_ETHER_H
+#define _NET_IF_ETHER_H	1
+
+/*
+ *	IEEE 802.3 Ethernet magic constants.  The frame sizes omit the preamble
+ *	and FCS/CRC (frame check sequence).
+ */
+
+#define ETH_ALEN	6		/* Octets in one ethernet addr	 */
+#define ETH_HLEN	14		/* Total octets in header.	 */
+#define ETH_ZLEN	60		/* Min. octets in frame sans FCS */
+#define ETH_DATA_LEN	1500		/* Max. octets in payload	 */
+#define ETH_FRAME_LEN	1514		/* Max. octets in frame sans FCS */
+
+/*
+ *	These are the defined Ethernet Protocol ID's.
+ */
+
+#define ETH_P_LOOP	0x0060		/* Ethernet Loopback packet	*/
+#define ETH_P_PUP	0x0200		/* Xerox PUP packet		*/
+#define ETH_P_PUPAT	0x0201		/* Xerox PUP Addr Trans packet	*/
+#define ETH_P_IP	0x0800		/* Internet Protocol packet	*/
+#define ETH_P_X25	0x0805		/* CCITT X.25			*/
+#define ETH_P_ARP	0x0806		/* Address Resolution packet	*/
+#define	ETH_P_BPQ	0x08FF		/* G8BPQ AX.25 Ethernet Packet	[ NOT AN OFFICIALLY REGISTERED ID ] */
+#define ETH_P_IEEEPUP	0x0a00		/* Xerox IEEE802.3 PUP packet */
+#define ETH_P_IEEEPUPAT	0x0a01		/* Xerox IEEE802.3 PUP Addr Trans packet */
+#define ETH_P_DEC       0x6000          /* DEC Assigned proto           */
+#define ETH_P_DNA_DL    0x6001          /* DEC DNA Dump/Load            */
+#define ETH_P_DNA_RC    0x6002          /* DEC DNA Remote Console       */
+#define ETH_P_DNA_RT    0x6003          /* DEC DNA Routing              */
+#define ETH_P_LAT       0x6004          /* DEC LAT                      */
+#define ETH_P_DIAG      0x6005          /* DEC Diagnostics              */
+#define ETH_P_CUST      0x6006          /* DEC Customer use             */
+#define ETH_P_SCA       0x6007          /* DEC Systems Comms Arch       */
+#define ETH_P_RARP      0x8035		/* Reverse Addr Res packet	*/
+#define ETH_P_ATALK	0x809B		/* Appletalk DDP		*/
+#define ETH_P_AARP	0x80F3		/* Appletalk AARP		*/
+#define ETH_P_8021Q	0x8100          /* 802.1Q VLAN Extended Header  */
+#define ETH_P_IPX	0x8137		/* IPX over DIX			*/
+#define ETH_P_IPV6	0x86DD		/* IPv6 over bluebook		*/
+#define ETH_P_WCCP	0x883E		/* Web-cache coordination protocol
+					 * defined in draft-wilson-wrec-wccp-v2-00.txt */
+#define ETH_P_PPP_DISC	0x8863		/* PPPoE discovery messages     */
+#define ETH_P_PPP_SES	0x8864		/* PPPoE session messages	*/
+#define ETH_P_MPLS_UC	0x8847		/* MPLS Unicast traffic		*/
+#define ETH_P_MPLS_MC	0x8848		/* MPLS Multicast traffic	*/
+#define ETH_P_ATMMPOA	0x884c		/* MultiProtocol Over ATM	*/
+#define ETH_P_ATMFATE	0x8884		/* Frame-based ATM Transport
+					 * over Ethernet
+					 */
+#define ETH_P_AOE	0x88A2		/* ATA over Ethernet		*/
+
+/*
+ *	Non DIX types. Won't clash for 1500 types.
+ */
+
+#define ETH_P_802_3	0x0001		/* Dummy type for 802.3 frames  */
+#define ETH_P_AX25	0x0002		/* Dummy protocol id for AX.25  */
+#define ETH_P_ALL	0x0003		/* Every packet (be careful!!!) */
+#define ETH_P_802_2	0x0004		/* 802.2 frames 		*/
+#define ETH_P_SNAP	0x0005		/* Internal only		*/
+#define ETH_P_DDCMP     0x0006          /* DEC DDCMP: Internal only     */
+#define ETH_P_WAN_PPP   0x0007          /* Dummy type for WAN PPP frames*/
+#define ETH_P_PPP_MP    0x0008          /* Dummy type for PPP MP frames */
+#define ETH_P_LOCALTALK 0x0009		/* Localtalk pseudo type 	*/
+#define ETH_P_PPPTALK	0x0010		/* Dummy type for Atalk over PPP*/
+#define ETH_P_TR_802_2	0x0011		/* 802.2 frames 		*/
+#define ETH_P_MOBITEX	0x0015		/* Mobitex (kaz@cafe.net)	*/
+#define ETH_P_CONTROL	0x0016		/* Card specific control frames */
+#define ETH_P_IRDA	0x0017		/* Linux-IrDA			*/
+#define ETH_P_ECONET	0x0018		/* Acorn Econet			*/
+#define ETH_P_HDLC	0x0019		/* HDLC frames			*/
+#define ETH_P_ARCNET	0x001A		/* 1A for ArcNet :-)            */
+
+/*
+ *	This is an Ethernet frame header.
+ */
+
+struct ethhdr {
+	unsigned char	h_dest[ETH_ALEN];	/* destination eth addr	*/
+	unsigned char	h_source[ETH_ALEN];	/* source ether addr	*/
+	unsigned short	h_proto;		/* packet type ID field	*/
+} __attribute__((packed));
+
+#endif	/* net/if_ether.h */
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/netinet/if_ether.h
@@ -0,0 +1,138 @@
+/* Copyright (C) 1996, 1997, 1999, 2006 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef __NETINET_IF_ETHER_H
+
+#define __NETINET_IF_ETHER_H	1
+#include <features.h>
+#include <sys/types.h>
+
+#include <net/if_ether.h>
+
+#ifdef __USE_BSD
+/*
+ * Copyright (c) 1982, 1986, 1993
+ *	The Regents of the University of California.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 4. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ *	@(#)if_ether.h	8.3 (Berkeley) 5/2/95
+ *	$FreeBSD$
+ */
+
+#include <net/ethernet.h>
+#include <net/if_arp.h>
+#include <netinet/in.h>
+
+__BEGIN_DECLS
+/*
+ * Ethernet Address Resolution Protocol.
+ *
+ * See RFC 826 for protocol description.  Structure below is adapted
+ * to resolving internet addresses.  Field names used correspond to
+ * RFC 826.
+ */
+struct	ether_arp {
+	struct	arphdr ea_hdr;		/* fixed-size header */
+	u_int8_t arp_sha[ETH_ALEN];	/* sender hardware address */
+	u_int8_t arp_spa[4];		/* sender protocol address */
+	u_int8_t arp_tha[ETH_ALEN];	/* target hardware address */
+	u_int8_t arp_tpa[4];		/* target protocol address */
+};
+#define	arp_hrd	ea_hdr.ar_hrd
+#define	arp_pro	ea_hdr.ar_pro
+#define	arp_hln	ea_hdr.ar_hln
+#define	arp_pln	ea_hdr.ar_pln
+#define	arp_op	ea_hdr.ar_op
+
+struct sockaddr_inarp {
+	__SOCKADDR_COMMON (sin_);
+	in_port_t sin_port;                 /* Port number.  */
+	struct in_addr sin_addr;            /* Internet address.  */
+	struct in_addr sin_srcaddr;
+	unsigned short sin_tos;
+	unsigned short sin_other;
+#define SIN_PROXY 1
+};
+
+/*
+ * IP and ethernet specific routing flags
+ */
+#define	RTF_USETRAILERS	RTF_PROTO1	/* use trailers */
+#define RTF_ANNOUNCE	RTF_PROTO2	/* announce new arp entry */
+
+/*
+ * Macro to map an IP multicast address to an Ethernet multicast address.
+ * The high-order 25 bits of the Ethernet address are statically assigned,
+ * and the low-order 23 bits are taken from the low end of the IP address.
+ */
+#define ETHER_MAP_IP_MULTICAST(ipaddr, enaddr) \
+	/* struct in_addr *ipaddr; */ \
+	/* u_char enaddr[ETH_ALEN];	   */ \
+{ \
+	(enaddr)[0] = 0x01; \
+	(enaddr)[1] = 0x00; \
+	(enaddr)[2] = 0x5e; \
+	(enaddr)[3] = ((u_int8_t *)ipaddr)[1] & 0x7f; \
+	(enaddr)[4] = ((u_int8_t *)ipaddr)[2]; \
+	(enaddr)[5] = ((u_int8_t *)ipaddr)[3]; \
+}
+
+/*
+ * Macro to map an IP6 multicast address to an Ethernet multicast address.
+ * The high-order 16 bits of the Ethernet address are statically assigned,
+ * and the low-order 32 bits are taken from the low end of the IP6 address.
+ */
+#define ETHER_MAP_IPV6_MULTICAST(ip6addr, enaddr)			\
+/* struct	in6_addr *ip6addr; */					\
+/* u_char	enaddr[ETH_ALEN]; */				\
+{                                                                       \
+	(enaddr)[0] = 0x33;						\
+	(enaddr)[1] = 0x33;						\
+	(enaddr)[2] = ((u_int8_t *)ip6addr)[12];				\
+	(enaddr)[3] = ((u_int8_t *)ip6addr)[13];				\
+	(enaddr)[4] = ((u_int8_t *)ip6addr)[14];				\
+	(enaddr)[5] = ((u_int8_t *)ip6addr)[15];				\
+}
+
+__END_DECLS
+#endif /* __USE_BSD */
+
+#endif /* netinet/if_ether.h */
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/netinet/ip_icmp.h
@@ -0,0 +1,296 @@
+/* Copyright (C) 1991-1993, 1995-1997, 1999, 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef __NETINET_IP_ICMP_H
+#define __NETINET_IP_ICMP_H    1
+
+#include <sys/cdefs.h>
+#include <sys/types.h>
+
+__BEGIN_DECLS
+
+struct icmphdr
+{
+  u_int8_t type;		/* message type */
+  u_int8_t code;		/* type sub-code */
+  u_int16_t checksum;
+  union
+  {
+    struct
+    {
+      u_int16_t	id;
+      u_int16_t	sequence;
+    } echo;			/* echo datagram */
+    u_int32_t	gateway;	/* gateway address */
+    struct
+    {
+      u_int16_t	__unused;
+      u_int16_t	mtu;
+    } frag;			/* path mtu discovery */
+  } un;
+};
+
+#define ICMP_ECHOREPLY		0	/* Echo Reply			*/
+#define ICMP_DEST_UNREACH	3	/* Destination Unreachable	*/
+#define ICMP_SOURCE_QUENCH	4	/* Source Quench		*/
+#define ICMP_REDIRECT		5	/* Redirect (change route)	*/
+#define ICMP_ECHO		8	/* Echo Request			*/
+#define ICMP_TIME_EXCEEDED	11	/* Time Exceeded		*/
+#define ICMP_PARAMETERPROB	12	/* Parameter Problem		*/
+#define ICMP_TIMESTAMP		13	/* Timestamp Request		*/
+#define ICMP_TIMESTAMPREPLY	14	/* Timestamp Reply		*/
+#define ICMP_INFO_REQUEST	15	/* Information Request		*/
+#define ICMP_INFO_REPLY		16	/* Information Reply		*/
+#define ICMP_ADDRESS		17	/* Address Mask Request		*/
+#define ICMP_ADDRESSREPLY	18	/* Address Mask Reply		*/
+#define NR_ICMP_TYPES		18
+
+
+/* Codes for UNREACH. */
+#define ICMP_NET_UNREACH	0	/* Network Unreachable		*/
+#define ICMP_HOST_UNREACH	1	/* Host Unreachable		*/
+#define ICMP_PROT_UNREACH	2	/* Protocol Unreachable		*/
+#define ICMP_PORT_UNREACH	3	/* Port Unreachable		*/
+#define ICMP_FRAG_NEEDED	4	/* Fragmentation Needed/DF set	*/
+#define ICMP_SR_FAILED		5	/* Source Route failed		*/
+#define ICMP_NET_UNKNOWN	6
+#define ICMP_HOST_UNKNOWN	7
+#define ICMP_HOST_ISOLATED	8
+#define ICMP_NET_ANO		9
+#define ICMP_HOST_ANO		10
+#define ICMP_NET_UNR_TOS	11
+#define ICMP_HOST_UNR_TOS	12
+#define ICMP_PKT_FILTERED	13	/* Packet filtered */
+#define ICMP_PREC_VIOLATION	14	/* Precedence violation */
+#define ICMP_PREC_CUTOFF	15	/* Precedence cut off */
+#define NR_ICMP_UNREACH		15	/* instead of hardcoding immediate value */
+
+/* Codes for REDIRECT. */
+#define ICMP_REDIR_NET		0	/* Redirect Net			*/
+#define ICMP_REDIR_HOST		1	/* Redirect Host		*/
+#define ICMP_REDIR_NETTOS	2	/* Redirect Net for TOS		*/
+#define ICMP_REDIR_HOSTTOS	3	/* Redirect Host for TOS	*/
+
+/* Codes for TIME_EXCEEDED. */
+#define ICMP_EXC_TTL		0	/* TTL count exceeded		*/
+#define ICMP_EXC_FRAGTIME	1	/* Fragment Reass time exceeded	*/
+
+
+#ifdef __USE_BSD
+/*
+ * Copyright (c) 1982, 1986, 1993
+ *	The Regents of the University of California.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 4. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ *	@(#)ip_icmp.h	8.1 (Berkeley) 6/10/93
+ */
+
+#include <netinet/in.h>
+#include <netinet/ip.h>
+
+/*
+ * Internal of an ICMP Router Advertisement
+ */
+struct icmp_ra_addr
+{
+  u_int32_t ira_addr;
+  u_int32_t ira_preference;
+};
+
+struct icmp
+{
+  u_int8_t  icmp_type;	/* type of message, see below */
+  u_int8_t  icmp_code;	/* type sub code */
+  u_int16_t icmp_cksum;	/* ones complement checksum of struct */
+  union
+  {
+    u_char ih_pptr;		/* ICMP_PARAMPROB */
+    struct in_addr ih_gwaddr;	/* gateway address */
+    struct ih_idseq		/* echo datagram */
+    {
+      u_int16_t icd_id;
+      u_int16_t icd_seq;
+    } ih_idseq;
+    u_int32_t ih_void;
+
+    /* ICMP_UNREACH_NEEDFRAG -- Path MTU Discovery (RFC1191) */
+    struct ih_pmtu
+    {
+      u_int16_t ipm_void;
+      u_int16_t ipm_nextmtu;
+    } ih_pmtu;
+
+    struct ih_rtradv
+    {
+      u_int8_t irt_num_addrs;
+      u_int8_t irt_wpa;
+      u_int16_t irt_lifetime;
+    } ih_rtradv;
+  } icmp_hun;
+#define	icmp_pptr	icmp_hun.ih_pptr
+#define	icmp_gwaddr	icmp_hun.ih_gwaddr
+#define	icmp_id		icmp_hun.ih_idseq.icd_id
+#define	icmp_seq	icmp_hun.ih_idseq.icd_seq
+#define	icmp_void	icmp_hun.ih_void
+#define	icmp_pmvoid	icmp_hun.ih_pmtu.ipm_void
+#define	icmp_nextmtu	icmp_hun.ih_pmtu.ipm_nextmtu
+#define	icmp_num_addrs	icmp_hun.ih_rtradv.irt_num_addrs
+#define	icmp_wpa	icmp_hun.ih_rtradv.irt_wpa
+#define	icmp_lifetime	icmp_hun.ih_rtradv.irt_lifetime
+  union
+  {
+    struct
+    {
+      u_int32_t its_otime;
+      u_int32_t its_rtime;
+      u_int32_t its_ttime;
+    } id_ts;
+    struct
+    {
+      struct ip idi_ip;
+      /* options and then 64 bits of data */
+    } id_ip;
+    struct icmp_ra_addr id_radv;
+    u_int32_t   id_mask;
+    u_int8_t    id_data[1];
+  } icmp_dun;
+#define	icmp_otime	icmp_dun.id_ts.its_otime
+#define	icmp_rtime	icmp_dun.id_ts.its_rtime
+#define	icmp_ttime	icmp_dun.id_ts.its_ttime
+#define	icmp_ip		icmp_dun.id_ip.idi_ip
+#define	icmp_radv	icmp_dun.id_radv
+#define	icmp_mask	icmp_dun.id_mask
+#define	icmp_data	icmp_dun.id_data
+};
+
+/*
+ * Lower bounds on packet lengths for various types.
+ * For the error advice packets must first insure that the
+ * packet is large enough to contain the returned ip header.
+ * Only then can we do the check to see if 64 bits of packet
+ * data have been returned, since we need to check the returned
+ * ip header length.
+ */
+#define	ICMP_MINLEN	8				/* abs minimum */
+#define	ICMP_TSLEN	(8 + 3 * sizeof (n_time))	/* timestamp */
+#define	ICMP_MASKLEN	12				/* address mask */
+#define	ICMP_ADVLENMIN	(8 + sizeof (struct ip) + 8)	/* min */
+#ifndef _IP_VHL
+#define	ICMP_ADVLEN(p)	(8 + ((p)->icmp_ip.ip_hl << 2) + 8)
+	/* N.B.: must separately check that ip_hl >= 5 */
+#else
+#define	ICMP_ADVLEN(p)	(8 + (IP_VHL_HL((p)->icmp_ip.ip_vhl) << 2) + 8)
+	/* N.B.: must separately check that header length >= 5 */
+#endif
+
+/*
+ * Definition of type and code field values.
+ */
+#define	ICMP_ECHOREPLY		0		/* echo reply */
+#define	ICMP_UNREACH		3		/* dest unreachable, codes: */
+#define		ICMP_UNREACH_NET	0		/* bad net */
+#define		ICMP_UNREACH_HOST	1		/* bad host */
+#define		ICMP_UNREACH_PROTOCOL	2		/* bad protocol */
+#define		ICMP_UNREACH_PORT	3		/* bad port */
+#define		ICMP_UNREACH_NEEDFRAG	4		/* IP_DF caused drop */
+#define		ICMP_UNREACH_SRCFAIL	5		/* src route failed */
+#define		ICMP_UNREACH_NET_UNKNOWN 6		/* unknown net */
+#define		ICMP_UNREACH_HOST_UNKNOWN 7		/* unknown host */
+#define		ICMP_UNREACH_ISOLATED	8		/* src host isolated */
+#define		ICMP_UNREACH_NET_PROHIB	9		/* prohibited access */
+#define		ICMP_UNREACH_HOST_PROHIB 10		/* ditto */
+#define		ICMP_UNREACH_TOSNET	11		/* bad tos for net */
+#define		ICMP_UNREACH_TOSHOST	12		/* bad tos for host */
+#define		ICMP_UNREACH_FILTER_PROHIB 13		/* admin prohib */
+#define		ICMP_UNREACH_HOST_PRECEDENCE 14		/* host prec vio. */
+#define		ICMP_UNREACH_PRECEDENCE_CUTOFF 15	/* prec cutoff */
+#define	ICMP_SOURCEQUENCH	4		/* packet lost, slow down */
+#define	ICMP_REDIRECT		5		/* shorter route, codes: */
+#define		ICMP_REDIRECT_NET	0		/* for network */
+#define		ICMP_REDIRECT_HOST	1		/* for host */
+#define		ICMP_REDIRECT_TOSNET	2		/* for tos and net */
+#define		ICMP_REDIRECT_TOSHOST	3		/* for tos and host */
+#define	ICMP_ALTHOSTADDR	6		/* alternate host address */
+#define	ICMP_ECHO		8		/* echo service */
+#define	ICMP_ROUTERADVERT	9		/* router advertisement */
+#define		ICMP_ROUTERADVERT_NORMAL		0	/* normal advertisement */
+#define		ICMP_ROUTERADVERT_NOROUTE_COMMON	16	/* selective routing */
+#define	ICMP_ROUTERSOLICIT	10		/* router solicitation */
+#define	ICMP_TIMXCEED		11		/* time exceeded, code: */
+#define		ICMP_TIMXCEED_INTRANS	0		/* ttl==0 in transit */
+#define		ICMP_TIMXCEED_REASS	1		/* ttl==0 in reass */
+#define	ICMP_PARAMPROB		12		/* ip header bad */
+#define		ICMP_PARAMPROB_ERRATPTR 0		/* error at param ptr */
+#define		ICMP_PARAMPROB_OPTABSENT 1		/* req. opt. absent */
+#define		ICMP_PARAMPROB_LENGTH 2			/* bad length */
+#define	ICMP_TSTAMP		13		/* timestamp request */
+#define	ICMP_TSTAMPREPLY	14		/* timestamp reply */
+#define	ICMP_IREQ		15		/* information request */
+#define	ICMP_IREQREPLY		16		/* information reply */
+#define	ICMP_MASKREQ		17		/* address mask request */
+#define	ICMP_MASKREPLY		18		/* address mask reply */
+#define	ICMP_TRACEROUTE		30		/* traceroute */
+#define	ICMP_DATACONVERR	31		/* data conversion error */
+#define	ICMP_MOBILE_REDIRECT	32		/* mobile host redirect */
+#define	ICMP_IPV6_WHEREAREYOU	33		/* IPv6 where-are-you */
+#define	ICMP_IPV6_IAMHERE	34		/* IPv6 i-am-here */
+#define	ICMP_MOBILE_REGREQUEST	35		/* mobile registration req */
+#define	ICMP_MOBILE_REGREPLY	36		/* mobile registration reply */
+#define	ICMP_SKIP		39		/* SKIP */
+#define	ICMP_PHOTURIS		40		/* Photuris */
+#define		ICMP_PHOTURIS_UNKNOWN_INDEX	1	/* unknown sec index */
+#define		ICMP_PHOTURIS_AUTH_FAILED	2	/* auth failed */
+#define		ICMP_PHOTURIS_DECRYPT_FAILED	3	/* decrypt failed */
+
+#define	ICMP_MAXTYPE		40
+
+#define	ICMP_INFOTYPE(type) \
+	((type) == ICMP_ECHOREPLY || (type) == ICMP_ECHO || \
+	(type) == ICMP_ROUTERADVERT || (type) == ICMP_ROUTERSOLICIT || \
+	(type) == ICMP_TSTAMP || (type) == ICMP_TSTAMPREPLY || \
+	(type) == ICMP_IREQ || (type) == ICMP_IREQREPLY || \
+	(type) == ICMP_MASKREQ || (type) == ICMP_MASKREPLY)
+
+#endif /* __USE_BSD */
+
+__END_DECLS
+
+#endif /* netinet/ip_icmp.h */
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/netinet/tcp.h
@@ -0,0 +1,258 @@
+/* netinet/tcp.h
+   Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+/*
+ * Copyright (c) 1982, 1986, 1993
+ *	The Regents of the University of California.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 4. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ *	@(#)tcp.h	8.1 (Berkeley) 6/10/93
+ */
+
+#ifndef _NETINET_TCP_H
+#define _NETINET_TCP_H	1
+
+#include <features.h>
+
+/*
+ * User-settable options (used with setsockopt).
+ */
+#define	TCP_NODELAY	 1	/* Don't delay send to coalesce packets  */
+#define	TCP_MAXSEG	 2	/* Set maximum segment size  */
+#define TCP_NOPUSH	 4	/* Don't push last block of write  */
+#define TCP_NOOPT	 8	/* Don't use TCP options  */
+
+#ifdef __USE_MISC
+# include <sys/types.h>
+
+# ifdef __FAVOR_BSD
+typedef	u_int32_t tcp_seq;
+typedef	u_int32_t tcp_cc;	/* connection count, per RFC 1644 */
+/*
+ * TCP header.
+ * Per RFC 793, September, 1981.
+ */
+struct tcphdr
+  {
+    u_int16_t th_sport;		/* source port */
+    u_int16_t th_dport;		/* destination port */
+    tcp_seq th_seq;		/* sequence number */
+    tcp_seq th_ack;		/* acknowledgement number */
+#  if __BYTE_ORDER == __LITTLE_ENDIAN
+    u_int8_t th_x2:4;		/* (unused) */
+    u_int8_t th_off:4;		/* data offset */
+#  endif
+#  if __BYTE_ORDER == __BIG_ENDIAN
+    u_int8_t th_off:4;		/* data offset */
+    u_int8_t th_x2:4;		/* (unused) */
+#  endif
+    u_int8_t th_flags;
+#  define TH_FIN	0x01
+#  define TH_SYN	0x02
+#  define TH_RST	0x04
+#  define TH_PUSH	0x08
+#  define TH_ACK	0x10
+#  define TH_URG	0x20
+    u_int16_t th_win;		/* window */
+    u_int16_t th_sum;		/* checksum */
+    u_int16_t th_urp;		/* urgent pointer */
+};
+
+# else /* !__FAVOR_BSD */
+struct tcphdr
+  {
+    u_int16_t source;
+    u_int16_t dest;
+    u_int32_t seq;
+    u_int32_t ack_seq;
+#  if __BYTE_ORDER == __LITTLE_ENDIAN
+    u_int16_t res1:4;
+    u_int16_t doff:4;
+    u_int16_t fin:1;
+    u_int16_t syn:1;
+    u_int16_t rst:1;
+    u_int16_t psh:1;
+    u_int16_t ack:1;
+    u_int16_t urg:1;
+    u_int16_t res2:2;
+#  elif __BYTE_ORDER == __BIG_ENDIAN
+    u_int16_t doff:4;
+    u_int16_t res1:4;
+    u_int16_t res2:2;
+    u_int16_t urg:1;
+    u_int16_t ack:1;
+    u_int16_t psh:1;
+    u_int16_t rst:1;
+    u_int16_t syn:1;
+    u_int16_t fin:1;
+#  else
+#   error "Adjust your <bits/endian.h> defines"
+#  endif
+    u_int16_t window;
+    u_int16_t check;
+    u_int16_t urg_ptr;
+};
+# endif /* __FAVOR_BSD */
+
+enum
+{
+  TCP_ESTABLISHED = 1,
+  TCP_SYN_SENT,
+  TCP_SYN_RECV,
+  TCP_FIN_WAIT1,
+  TCP_FIN_WAIT2,
+  TCP_TIME_WAIT,
+  TCP_CLOSE,
+  TCP_CLOSE_WAIT,
+  TCP_LAST_ACK,
+  TCP_LISTEN,
+  TCP_CLOSING   /* now a valid state */
+};
+
+# define TCPOPT_EOL		0
+# define TCPOPT_NOP		1
+# define TCPOPT_MAXSEG		2
+# define    TCPOLEN_MAXSEG		4
+# define TCPOPT_WINDOW		3
+# define    TCPOLEN_WINDOW		3
+# define TCPOPT_SACK_PERMITTED	4		/* Experimental */
+# define    TCPOLEN_SACK_PERMITTED	2
+# define TCPOPT_SACK		5		/* Experimental */
+# define TCPOPT_TIMESTAMP	8
+# define    TCPOLEN_TIMESTAMP	10
+# define    TCPOLEN_TSTAMP_APPA	(TCPOLEN_TIMESTAMP+2) /* appendix A */
+# define    TCPOPT_TSTAMP_HDR	\
+    (TCPOPT_NOP<<24|TCPOPT_NOP<<16|TCPOPT_TIMESTAMP<<8|TCPOLEN_TIMESTAMP)
+#define	TCPOPT_CC		11		/* CC options: RFC-1644 */
+#define TCPOPT_CCNEW		12
+#define TCPOPT_CCECHO		13
+#define	   TCPOLEN_CC			6
+#define	   TCPOLEN_CC_APPA		(TCPOLEN_CC+2)
+#define	   TCPOPT_CC_HDR(ccopt)		\
+    (TCPOPT_NOP<<24|TCPOPT_NOP<<16|(ccopt)<<8|TCPOLEN_CC)
+
+/*
+ * Default maximum segment size for TCP.
+ * With an IP MSS of 576, this is 536,
+ * but 512 is probably more convenient.
+ * This should be defined as MIN(512, IP_MSS - sizeof (struct tcpiphdr)).
+ */
+# define TCP_MSS	512
+
+/*
+ * Default maximum segment size for TCP6.
+ * With an IP MSS of 1280, this is 1220,
+ * but 1024 is probably more convenient.
+ * This should be defined as MIN(1024, IP6_MSS - sizeof (struct tcpip6hdr)).
+ */
+# define TCP6_MSS	1024
+
+# define TCP_MAXWIN	65535	/* largest value for (unscaled) window */
+# define TTCP_CLIENT_SND_WND 4096 /* default send window for T/TCP client */
+
+# define TCP_MAX_WINSHIFT	14	/* maximum window shift */
+
+#define TCP_MAXBURST		4	/* maximum segments in a burst */
+
+#define TCP_MAXHLEN	(0xf<<2)	/* max length of header in bytes */
+#define TCP_MAXOLEN	(TCP_MAXHLEN - sizeof (struct tcphdr))
+					/* max space left for options */
+
+# define SOL_TCP		6	/* TCP level */
+
+
+# define TCPI_OPT_TIMESTAMPS	1
+# define TCPI_OPT_SACK		2
+# define TCPI_OPT_WSCALE	4
+# define TCPI_OPT_ECN		8
+
+/* Values for tcpi_state.  */
+enum tcp_ca_state
+{
+  TCP_CA_Open = 0,
+  TCP_CA_Disorder = 1,
+  TCP_CA_CWR = 2,
+  TCP_CA_Recovery = 3,
+  TCP_CA_Loss = 4
+};
+
+struct tcp_info
+{
+  u_int8_t	tcpi_state;
+  u_int8_t	tcpi_ca_state;
+  u_int8_t	tcpi_retransmits;
+  u_int8_t	tcpi_probes;
+  u_int8_t	tcpi_backoff;
+  u_int8_t	tcpi_options;
+  u_int8_t	tcpi_snd_wscale : 4, tcpi_rcv_wscale : 4;
+
+  u_int32_t	tcpi_rto;
+  u_int32_t	tcpi_ato;
+  u_int32_t	tcpi_snd_mss;
+  u_int32_t	tcpi_rcv_mss;
+
+  u_int32_t	tcpi_unacked;
+  u_int32_t	tcpi_sacked;
+  u_int32_t	tcpi_lost;
+  u_int32_t	tcpi_retrans;
+  u_int32_t	tcpi_fackets;
+
+  /* Times. */
+  u_int32_t	tcpi_last_data_sent;
+  u_int32_t	tcpi_last_ack_sent;	/* Not remembered, sorry.  */
+  u_int32_t	tcpi_last_data_recv;
+  u_int32_t	tcpi_last_ack_recv;
+
+  /* Metrics. */
+  u_int32_t	tcpi_pmtu;
+  u_int32_t	tcpi_rcv_ssthresh;
+  u_int32_t	tcpi_rtt;
+  u_int32_t	tcpi_rttvar;
+  u_int32_t	tcpi_snd_ssthresh;
+  u_int32_t	tcpi_snd_cwnd;
+  u_int32_t	tcpi_advmss;
+  u_int32_t	tcpi_reordering;
+};
+
+#endif /* Misc.  */
+
+#endif /* netinet/tcp.h */
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/nfs/nfs.h
@@ -0,0 +1,3 @@
+#include <stdint.h>
+#include <sys/mount.h>
+#include <nfs/nfsproto.h>
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/not-cancel.h
@@ -0,0 +1,88 @@
+/* Uncancelable versions of cancelable interfaces.  kFreeBSD version.
+   Copyright (C) 2003, 2006 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Ulrich Drepper <drepper@redhat.com>, 2003.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sys/types.h>
+#include <sysdep.h>
+
+/* Uncancelable open.  */
+#define open_not_cancel(name, flags, mode) \
+   INLINE_SYSCALL (open, 3, (const char *) (name), (flags), (mode))
+#define open_not_cancel_2(name, flags) \
+   INLINE_SYSCALL (open, 2, (const char *) (name), (flags))
+
+/* Uncancelable openat.  */
+#if !defined NOT_IN_libc || defined IS_IN_libpthread || defined IS_IN_librt
+extern int __openat_nocancel (int fd, const char *fname, int oflag,
+			      mode_t mode) attribute_hidden;
+extern int __openat64_nocancel (int fd, const char *fname, int oflag,
+				mode_t mode) attribute_hidden;
+#else
+# define __openat_nocancel(fd, fname, oflag, mode) \
+  openat (fd, fname, oflag, mode)
+# define __openat64_nocancel(fd, fname, oflag, mode) \
+  openat64 (fd, fname, oflag, mode)
+#endif
+
+#define openat_not_cancel(fd, fname, oflag, mode) \
+  __openat_nocancel (fd, fname, oflag, mode)
+#define openat_not_cancel_3(fd, fname, oflag) \
+  __openat_nocancel (fd, fname, oflag, 0)
+#define openat64_not_cancel(fd, fname, oflag, mode) \
+  __openat64_nocancel (fd, fname, oflag, mode)
+#define openat64_not_cancel_3(fd, fname, oflag) \
+  __openat64_nocancel (fd, fname, oflag, 0)
+
+/* Uncancelable close.  */
+#define close_not_cancel(fd) \
+  INLINE_SYSCALL (close, 1, fd)
+#define close_not_cancel_no_status(fd) \
+  INLINE_SYSCALL (close, 1, fd)
+
+/* Uncancelable read.  */
+#define read_not_cancel(fd, buf, n) \
+  INLINE_SYSCALL (read, 3, (fd), (buf), (n))
+
+/* Uncancelable write.  */
+#define write_not_cancel(fd, buf, n) \
+  INLINE_SYSCALL (write, 3, (fd), (buf), (n))
+
+/* Uncancelable writev.  */
+#define writev_not_cancel_no_status(fd, iov, n) \
+  INLINE_SYSCALL (writev, 3, (fd), (iov), (n))
+
+/* Uncancelable fcntl.  */
+#define fcntl_not_cancel(fd, cmd, val) \
+  __fcntl_nocancel (fd, cmd, val)
+
+/* Uncancelable waitpid.  */
+# define waitpid_not_cancel(pid, stat_loc, options) \
+  INLINE_SYSCALL (wait4, 4, pid, stat_loc, options, NULL)
+
+/* Uncancelable pause.  */
+# define pause_not_cancel() \
+  __pause_nocancel ()
+
+/* Uncancelable nanosleep.  */
+# define nanosleep_not_cancel(requested_time, remaining) \
+  INLINE_SYSCALL (nanosleep, 2, requested_time, remaining)
+
+/* Uncancelable sigsuspend.  */
+#define sigsuspend_not_cancel(set) \
+  INLINE_SYSCALL (sigsuspend, 1, set)
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/ntp_gettime.c
@@ -0,0 +1,62 @@
+/* Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sys/timex.h>
+#include <sys/sysctl.h>
+#include <stddef.h>
+
+#ifndef ntptimeval
+#define ntptimeval ntptimeval4
+#endif
+
+int
+ntp_gettime (struct ntptimeval *ntv)
+{
+  /* Fetch sysctl value of "kern.ntp_pll.gettime".  */
+  /* The 'struct ntptimeval' has grown in size.  */
+  union
+    {
+      struct ntptimeval3 tv3;
+      struct ntptimeval4 tv4;
+    } tv;
+  size_t size = sizeof (tv);
+  int request[2] = { CTL_KERN, KERN_NTP_PLL };
+
+  if (__sysctl (request, 2, &tv, &size, NULL, 0) >= 0)
+    {
+      if (size == sizeof (struct ntptimeval3))
+	{
+	  if (ntv)
+	    {
+	      ntv->time = tv.tv3.time;
+	      ntv->maxerror = tv.tv3.maxerror;
+	      ntv->esterror = tv.tv3.esterror;
+	      ntv->tai = 0;
+	      ntv->time_state = tv.tv3.time_state;
+	    }
+	  return tv.tv3.time_state;
+	}
+      if (size == sizeof (struct ntptimeval4))
+	{
+	  if (ntv)
+	    *ntv = tv.tv4;
+	  return tv.tv4.time_state;
+	}
+    }
+  return TIME_ERROR;
+}
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/open.c
@@ -0,0 +1,89 @@
+/* Copyright (C) 1999, 2000, 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <fcntl.h>
+#include <stdarg.h>
+#include <unistd.h>
+#include <sysdep.h>
+#include <errno.h>
+#include <sys/stat.h>
+#include <sys/time.h>
+#include <sysdep-cancel.h>
+
+int
+__libc_open (const char *file, int oflag, ...)
+{
+  int mode = 0;
+  int fd;
+
+  if (oflag & O_CREAT)
+    {
+      va_list arg;
+      va_start (arg, oflag);
+      mode = va_arg (arg, int);
+      va_end (arg);
+    }
+
+  if (SINGLE_THREAD_P)
+  {
+    fd = INLINE_SYSCALL (open, 3, file, oflag, mode);
+  }
+  else
+  {
+    int oldtype = LIBC_CANCEL_ASYNC ();
+    fd = INLINE_SYSCALL (open, 3, file, oflag, mode);
+    LIBC_CANCEL_RESET (oldtype);
+  }
+
+  if (fd >= 0 && (oflag & O_TRUNC))
+    {
+      /* Set the modification time.  The kernel ought to do this.  */
+      int saved_errno = errno;
+      struct timeval tv[2];
+
+      if (__gettimeofday (&tv[1], NULL) >= 0)
+	{
+	  struct stat statbuf;
+
+	  if (__fxstat (_STAT_VER, fd, &statbuf) >= 0)
+	    {
+	      tv[0].tv_sec = statbuf.st_atime;
+	      tv[0].tv_usec = 0;
+
+#ifdef NOT_IN_libc
+	      futimes (fd, tv);
+#else
+	      __futimes (fd, tv);
+#endif
+	    }
+	}
+      __set_errno (saved_errno);
+    }
+
+  return fd;
+}
+libc_hidden_def (__libc_open)
+
+weak_alias (__libc_open, __open)
+libc_hidden_weak (__open)
+
+weak_alias (__libc_open, open)
+
+strong_alias (__libc_open, __libc_open64)
+weak_alias (__libc_open64, __open64)
+weak_alias (__libc_open64, open64)
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/open64.c
@@ -0,0 +1,2 @@
+/* 'open64' is the same as 'open', because __off64_t == __off_t and
+   O_LARGEFILE == 0.  */
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/open_2.c
@@ -0,0 +1,2 @@
+#include <sysdeps/unix/sysv/linux/open_2.c>
+strong_alias (__open_2, __open64_2)
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/openat.c
@@ -0,0 +1,110 @@
+/* Copyright (C) 2005, 2006 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <errno.h>
+#include <fcntl.h>
+#include <stdarg.h>
+#include <stddef.h>
+#include <stdio.h>
+#include <string.h>
+#include <sys/stat.h>
+#include <kernel-features.h>
+#include <sysdep-cancel.h>
+#include <not-cancel.h>
+
+int
+__openat_nocancel (fd, file, oflag, mode)
+     int fd;
+     const char *file;
+     int oflag;
+     mode_t mode;
+{
+  if (fd != AT_FDCWD && file[0] != '/')
+    {
+      /* Check FD is associated with a directory.  */
+      struct stat64 st;
+      if (__fxstat64 (_STAT_VER, fd, &st) != 0)
+	/* errno is already set correctly.  */
+        return -1;
+
+      if (!S_ISDIR (st.st_mode))
+	__set_errno (ENOTDIR);
+      else
+	__set_errno (ENOSYS);
+      return -1;
+    }
+  return INLINE_SYSCALL (open, 3, file, oflag, mode);
+}
+
+
+/* Open FILE with access OFLAG.  Interpret relative paths relative to
+   the directory associated with FD.  If OFLAG includes O_CREAT, a
+   third argument is the file protection.  */
+int
+__openat (fd, file, oflag)
+     int fd;
+     const char *file;
+     int oflag;
+{
+  mode_t mode = 0;
+  if (oflag & O_CREAT)
+    {
+      va_list arg;
+      va_start (arg, oflag);
+      mode = va_arg (arg, int);
+      va_end (arg);
+    }
+
+  if (SINGLE_THREAD_P)
+    return __openat_nocancel (fd, file, oflag, mode);
+
+  int oldtype = LIBC_CANCEL_ASYNC ();
+
+  int res = __openat_nocancel (fd, file, oflag, mode);
+
+  LIBC_CANCEL_RESET (oldtype);
+
+  return res;
+}
+libc_hidden_def (__openat)
+weak_alias (__openat, openat)
+
+/* openat64 is just the same as openat for us.  */
+strong_alias (__openat, __openat64)
+strong_alias (__openat_nocancel, __openat64_nocancel)
+libc_hidden_weak (__openat64)
+weak_alias (__openat64, openat64)
+
+stub_warning (openat)
+stub_warning (openat64)
+
+int
+__openat_2 (fd, file, oflag)
+     int fd;
+     const char *file;
+     int oflag;
+{
+  if (oflag & O_CREAT)
+    __fortify_fail ("invalid openat call: O_CREAT without mode");
+
+  return __openat (fd, file, oflag);
+}
+
+strong_alias (__openat_2, __openat64_2)
+stub_warning (__openat_2)
+stub_warning (__openat64_2)
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/openat64.c
@@ -0,0 +1,2 @@
+/* 'openat64' is the same as 'open', because __off64_t == __off_t and
+   O_LARGEFILE == 0.  */
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/paths.h
@@ -0,0 +1,74 @@
+/*
+ * Copyright (c) 1989, 1993
+ *	The Regents of the University of California.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 4. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ *	@(#)paths.h	8.1 (Berkeley) 6/2/93
+ */
+
+#ifndef _PATHS_H_
+#define _PATHS_H_
+
+/* Default search path. */
+#define _PATH_DEFPATH	"/usr/bin:/bin"
+/* All standard utilities path. */
+#define _PATH_STDPATH	"/usr/bin:/bin:/usr/sbin:/sbin"
+
+#define _PATH_BSHELL	"/bin/sh"
+#define _PATH_CONSOLE	"/dev/console"
+#define _PATH_CSHELL	"/bin/csh"
+#define _PATH_DEVDB	"/var/run/dev.db"
+#define _PATH_DEVNULL	"/dev/null"
+#define _PATH_DRUM	"/dev/drum"
+#define _PATH_KLOG	"/dev/klog"
+#define _PATH_KMEM	"/dev/kmem"
+#define _PATH_LASTLOG	"/var/log/lastlog"
+/* FIFOs are not permitted in /dev, so we use /var/run/log instead of /dev/log */
+#define _PATH_MAILDIR	"/var/mail"
+#define _PATH_MAN	"/usr/share/man"
+#define _PATH_MEM	"/dev/mem"
+#define _PATH_MNTTAB	"/etc/fstab"
+#define _PATH_MOUNTED	"/etc/mtab"
+#define _PATH_NOLOGIN	"/etc/nologin"
+#define _PATH_PRESERVE	"/var/preserve"
+#define _PATH_RWHODIR	"/var/rwho"
+#define _PATH_SENDMAIL	"/usr/sbin/sendmail"
+#define _PATH_SHADOW	"/etc/shadow"
+#define _PATH_SHELLS	"/etc/shells"
+#define _PATH_TTY	"/dev/tty"
+#define _PATH_UNIX	"/kernel"
+#define _PATH_UTMP	"/var/run/utmp"
+#define _PATH_VI	"/usr/bin/vi"
+#define _PATH_WTMP	"/var/log/wtmp"
+
+/* Provide trailing slash, since mostly used for building pathnames. */
+#define _PATH_DEV	"/dev/"
+#define _PATH_TMP	"/tmp/"
+#define _PATH_VARDB	"/var/db/"
+#define _PATH_VARRUN	"/var/run/"
+#define _PATH_VARTMP	"/var/tmp/"
+
+#endif /* !_PATHS_H_ */
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/pread.c
@@ -0,0 +1,50 @@
+/* Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Bruno Haible <bruno@clisp.org>, 2002.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <unistd.h>
+#include <sys/types.h>
+#include <sysdep.h>
+#include <sysdep-cancel.h>
+
+/* The real system call has a word of padding before the 64-bit off_t
+   argument.  */
+extern ssize_t __syscall_freebsd6_pread (int __fd, void *__buf, size_t __nbytes,
+				int __unused1, __off_t __offset) __THROW;
+libc_hidden_proto(__syscall_freebsd6_pread)
+
+ssize_t
+__libc_pread (int fd, void *buf, size_t nbytes, __off_t offset)
+{
+  /* We pass 5 arguments in 6 words.  */
+  if (SINGLE_THREAD_P)
+    return INLINE_SYSCALL (freebsd6_pread, 5, fd, buf, nbytes, 0, offset);
+
+  int oldtype = LIBC_CANCEL_ASYNC ();
+  ssize_t result = INLINE_SYSCALL (freebsd6_pread, 5, fd, buf, nbytes, 0, offset);
+  LIBC_CANCEL_RESET (oldtype);
+  return result;
+}
+
+strong_alias (__libc_pread, __pread)
+weak_alias (__pread, pread)
+
+/* 'pread64' is the same as 'pread', because __off64_t == __off_t.  */
+strong_alias (__libc_pread, __libc_pread64)
+weak_alias (__libc_pread64, __pread64)
+weak_alias (__libc_pread64, pread64)
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/pread64.c
@@ -0,0 +1 @@
+/* 'pread64' is the same as 'pread', because __off64_t == __off_t.  */
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/prof-freq.c
@@ -0,0 +1,47 @@
+/* Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <libc-internal.h>
+#include <stddef.h>
+#include <sys/sysctl.h>
+
+struct clockinfo
+{
+  int hz;		/* Clock frequency.  */
+  int tick;		/* Microseconds per hz tick, = 1000000 / hz.  */
+  int tickadj;		/* Clock skew rate for adjtime().  */
+  int stathz;		/* Statistics clock frequency.  */
+  int profhz;		/* Profiling clock frequency.  */
+};
+
+int
+__profile_frequency (void)
+{
+  /* Fetch the "kern.clockrate" sysctl value.  */
+  int request[2] = { CTL_KERN, KERN_CLOCKRATE };
+  struct clockinfo result;
+  size_t result_len = sizeof (result);
+
+  if (__sysctl (request, 2, &result, &result_len, NULL, 0) < 0)
+    /* Dummy result.  */
+    return 1;
+
+  /* Yes, hz, not profhz.  On i386, the value is 100, not 1024.  */
+  return result.hz;
+}
+libc_hidden_def (__profile_frequency)
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/ptrace.c
@@ -0,0 +1,68 @@
+/* Copyright (C) 1995-1998, 2000, 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <errno.h>
+#include <sys/types.h>
+#include <sys/ptrace.h>
+#include <stdarg.h>
+
+#include <sysdep.h>
+#include <sys/syscall.h>
+
+extern int __syscall_ptrace (enum __ptrace_request request, pid_t pid,
+			     void *addr, void *data);
+
+int
+ptrace (enum __ptrace_request request, ...)
+{
+  int res, ret;
+  va_list ap;
+  pid_t pid;
+  void *addr, *data;
+
+  /* Usually 4 arguments are given, except when request == PTRACE_TRACEME.
+     But it doesn't harm to peek at the stack in this case as well.  */
+  va_start (ap, request);
+  pid = va_arg (ap, pid_t);
+  addr = va_arg (ap, void *);
+  data = va_arg (ap, void *);
+  va_end (ap);
+
+  switch (request)
+    {
+    case PTRACE_PEEKTEXT:
+    case PTRACE_PEEKDATA:
+#ifdef PTRACE_PEEKUSER
+    case PTRACE_PEEKUSER:
+#endif
+      res = INLINE_SYSCALL (ptrace, 4, request, pid, addr, &ret);
+      if (res >= 0)
+	{
+	  /* ret can be -1 even for successful operation.  */
+	  __set_errno (0);
+	  return ret;
+	}
+      break;
+
+    default:
+      res = INLINE_SYSCALL (ptrace, 4, request, pid, addr, data);
+      break;
+    }
+
+  return res;
+}
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/ptsname.c
@@ -0,0 +1,104 @@
+/* Copyright (C) 1998, 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <errno.h>
+#include <paths.h>
+#include <stdlib.h>
+#include <string.h>
+#include <sys/stat.h>
+#include <sys/sysmacros.h>
+#include <sys/sysctl.h>
+#include <unistd.h>
+
+
+/* Static buffer for `ptsname'.  */
+static char buffer[sizeof (_PATH_TTY) + 2];
+
+
+/* Return the pathname of the pseudo terminal slave associated with
+   the master FD is open on, or NULL on errors.
+   The returned storage is good until the next call to this function.  */
+char *
+ptsname (int fd)
+{
+  return __ptsname_r (fd, buffer, sizeof (buffer)) != 0 ? NULL : buffer;
+}
+
+/* The are declared in getpt.c.  */
+extern const char __libc_ptyname1[] attribute_hidden;
+extern const char __libc_ptyname2[] attribute_hidden;
+
+
+/* Store at most BUFLEN characters of the pathname of the slave pseudo
+   terminal associated with the master FD is open on in BUF.
+   Return 0 on success, otherwise an error number.  */
+int
+__ptsname_r (int fd, char *buf, size_t buflen)
+{
+  int saved_errno = errno;
+  struct stat64 st;
+  char *p;
+
+  if (buf == NULL)
+    {
+      __set_errno (EINVAL);
+      return EINVAL;
+    }
+
+  /* Don't call isatty (fd) - it usually fails with errno = EAGAIN.  */
+
+  if (__fxstat64 (_STAT_VER, fd, &st) < 0)
+    return errno;
+
+  /* Check if FD really is a master pseudo terminal.  */
+  if (!(S_ISCHR (st.st_mode)))
+    {
+      __set_errno (ENOTTY);
+      return ENOTTY;
+    }
+
+  if (buflen < sizeof (_PATH_TTY) + 2)
+    {
+      __set_errno (ERANGE);
+      return ERANGE;
+    }
+
+  /* Construct the slave's pathname.  */
+  /* instead of strlen(_PATH_DEV) we use (sizeof (_PATH_DEV) - 1)  */
+  p = __mempcpy (buf, _PATH_DEV, sizeof (_PATH_DEV) - 1);
+  buflen -= (sizeof (_PATH_DEV) - 1);
+  if(__sysctlbyname("kern.devname", p, &buflen, &st.st_rdev, sizeof (st.st_rdev)) < 0)
+    return errno;
+  p[0] = 't';
+
+  if (__xstat64 (_STAT_VER, buf, &st) < 0)
+    return errno;
+
+  /* Check if the pathname we're about to return might be
+     slave pseudo terminal of the given master pseudo terminal.  */
+  if (!(S_ISCHR (st.st_mode)))
+    {
+      /* This really is a configuration problem.  */
+      __set_errno (ENOTTY);
+      return ENOTTY;
+    }
+
+  __set_errno (saved_errno);
+  return 0;
+}
+weak_alias (__ptsname_r, ptsname_r)
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/pwrite.c
@@ -0,0 +1,50 @@
+/* Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Bruno Haible <bruno@clisp.org>, 2002.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <unistd.h>
+#include <sys/types.h>
+#include <sysdep.h>
+#include <sysdep-cancel.h>
+
+/* The real system call has a word of padding before the 64-bit off_t
+   argument.  */
+extern ssize_t __syscall_freebsd6_pwrite (int __fd, const void *__buf, size_t __nbytes,
+				 int __unused1, __off_t __offset) __THROW;
+libc_hidden_proto(__syscall_freebsd6_pwrite)
+
+ssize_t
+__libc_pwrite (int fd, const void *buf, size_t nbytes, __off_t offset)
+{
+  /* We pass 5 arguments in 6 words.  */
+  if (SINGLE_THREAD_P)
+    return INLINE_SYSCALL (freebsd6_pwrite, 5, fd, buf, nbytes, 0, offset);
+
+  int oldtype = LIBC_CANCEL_ASYNC ();
+  ssize_t result = INLINE_SYSCALL (freebsd6_pwrite, 5, fd, buf, nbytes, 0, offset);
+  LIBC_CANCEL_RESET (oldtype);
+  return result;
+}
+
+strong_alias (__libc_pwrite, __pwrite)
+weak_alias (__pwrite, pwrite)
+
+/* 'pwrite64' is the same as 'pwrite', because __off64_t == __off_t.  */
+strong_alias (__libc_pwrite, __libc_pwrite64)
+weak_alias (__libc_pwrite64, __pwrite64)
+weak_alias (__libc_pwrite64, pwrite64)
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/pwrite64.c
@@ -0,0 +1 @@
+/* 'pwrite64' is the same as 'pwrite', because __off64_t == __off_t.  */
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/readdir.c
@@ -0,0 +1,11 @@
+/* 'readdir64' is the same as 'readdir', because
+   struct dirent64 == struct dirent.  */
+
+#define readdir64 __no_readdir64_decl
+#define __readdir64 __no___readdir64_decl
+#include <sysdeps/unix/readdir.c>
+#undef __readdir64
+#undef readdir64
+
+strong_alias (__readdir, __readdir64)
+weak_alias (__readdir64, readdir64)
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/readdir64.c
@@ -0,0 +1,2 @@
+/* 'readdir64' is the same as 'readdir', because
+   struct dirent64 == struct dirent.  */
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/readdir64_r.c
@@ -0,0 +1,2 @@
+/* 'readdir64_r' is the same as 'readdir_r', because
+   struct dirent64 == struct dirent.  */
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/readdir_r.c
@@ -0,0 +1,11 @@
+/* 'readdir64_r' is the same as 'readdir_r', because
+   struct dirent64 == struct dirent.  */
+
+#define readdir64_r __no_readdir64_r_decl
+#define __readdir64_r __no___readdir64_r_decl
+#include <sysdeps/unix/readdir_r.c>
+#undef __readdir64_r
+#undef readdir64_r
+
+strong_alias (__readdir_r, __readdir64_r)
+weak_alias (__readdir64_r, readdir64_r)
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/readv.c
@@ -0,0 +1,57 @@
+/* readv for FreeBSD.
+   Copyright (C) 1997-1998, 2000, 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <errno.h>
+#include <stddef.h>
+#include <sys/param.h>
+#include <sys/uio.h>
+
+#include <sysdep.h>
+#include <sys/syscall.h>
+#include <bp-checks.h>
+#include <sysdep-cancel.h>
+
+extern ssize_t __syscall_readv (int, __const struct iovec *__unbounded, int);
+libc_hidden_proto(__syscall_readv)
+
+static ssize_t __atomic_readv_replacement (int, __const struct iovec *,
+					   int) internal_function;
+
+ssize_t
+__libc_readv (int fd, const struct iovec *vector, int count)
+{
+  if (count <= UIO_MAXIOV)
+  {
+    if (SINGLE_THREAD_P)
+      return INLINE_SYSCALL (readv, 3, fd, CHECK_N (vector, count), count);
+
+    int oldtype = LIBC_CANCEL_ASYNC ();
+    ssize_t result = INLINE_SYSCALL (readv, 3, fd, CHECK_N (vector, count), count);
+    LIBC_CANCEL_RESET (oldtype);
+    return result;
+
+  }
+  else
+    return __atomic_readv_replacement (fd, vector, count);
+}
+strong_alias (__libc_readv, __readv)
+weak_alias (__libc_readv, readv)
+
+#define __libc_readv static internal_function __atomic_readv_replacement
+#include <sysdeps/posix/readv.c>
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/recv.c
@@ -0,0 +1,41 @@
+/* Copyright (C) 2001-2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sys/socket.h>
+#include <sysdep.h>
+#include <sysdep-cancel.h>
+
+/* The real syscall's name.  See sysdeps/unix/inet/syscalls.list.  */
+#define __syscall_recvfrom __libc_recvfrom
+ssize_t __libc_recvfrom(int s, void *buf, size_t len, int flags,
+                        struct sockaddr *from, socklen_t *fromlen);
+libc_hidden_proto (__libc_recvfrom)
+
+/* Read N bytes into BUF from socket FD.
+   Return the number of bytes read or -1 for error.  */
+
+ssize_t
+__libc_recv (int fd, void *buf, size_t n, int flags)
+{
+  return INLINE_SYSCALL (recvfrom, 6, fd, buf, n, flags, NULL, NULL);
+}
+
+weak_alias (__libc_recv, __recv)
+weak_alias (__libc_recv, recv)
+
+LIBC_CANCEL_HANDLED (); /* in __libc_recvfrom */
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/rtld-lowlevel.h
@@ -0,0 +1,131 @@
+/* Definitions for lowlevel handling in ld.so, FreeBSD variant
+   Copyright (C) 2006-2007 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _RTLD_LOWLEVEL_H
+#define  _RTLD_LOWLEVEL_H 1
+
+#include <atomic.h>
+#include <lowlevellock.h>
+
+/* Special multi-reader lock used in ld.so.  */
+#define __RTLD_MRLOCK_WRITER 1
+#define __RTLD_MRLOCK_RWAIT 2
+#define __RTLD_MRLOCK_WWAIT 4
+#define __RTLD_MRLOCK_RBITS \
+  ~(__RTLD_MRLOCK_WRITER | __RTLD_MRLOCK_RWAIT | __RTLD_MRLOCK_WWAIT)
+#define __RTLD_MRLOCK_INC 8
+#define __RTLD_MRLOCK_TRIES 5
+
+#define __rtld_mrlock_define(CLASS,NAME) \
+  CLASS __rtld_mrlock_t NAME;
+
+
+#define _RTLD_MRLOCK_INITIALIZER 0
+#define __rtld_mrlock_initialize(NAME) \
+  (void) ((NAME).lv = 0)
+
+
+#define __rtld_mrlock_lock(lock) \
+  do {									      \
+    __label__ out;							      \
+    while (1)								      \
+      {									      \
+	int oldval;							      \
+	for (int tries = 0; tries < __RTLD_MRLOCK_TRIES; ++tries)	      \
+	  {								      \
+	    oldval = (lock).iv;						      \
+	    while (__builtin_expect ((oldval				      \
+				      & (__RTLD_MRLOCK_WRITER		      \
+					 | __RTLD_MRLOCK_WWAIT))	      \
+				     == 0, 1))				      \
+	      {								      \
+		int newval = ((oldval & __RTLD_MRLOCK_RBITS)		      \
+			      + __RTLD_MRLOCK_INC);			      \
+		int ret = atomic_compare_and_exchange_val_acq (&(lock.iv),	      \
+							       newval,	      \
+							       oldval);	      \
+		if (__builtin_expect (ret == oldval, 1))		      \
+		  goto out;						      \
+		oldval = ret;						      \
+	      }								      \
+	    atomic_delay ();						      \
+	  }								      \
+	if ((oldval & __RTLD_MRLOCK_RWAIT) == 0)			      \
+	  {								      \
+	    atomic_or (&(lock.iv), __RTLD_MRLOCK_RWAIT);			      \
+	    oldval |= __RTLD_MRLOCK_RWAIT;				      \
+	  }								      \
+	lll_futex_wait (&(lock), oldval);					      \
+      }									      \
+  out:;									      \
+  } while (0)
+
+
+#define __rtld_mrlock_unlock(lock) \
+  do {									      \
+    int oldval = atomic_exchange_and_add (&(lock.iv), -__RTLD_MRLOCK_INC);	      \
+    if (__builtin_expect ((oldval					      \
+			   & (__RTLD_MRLOCK_RBITS | __RTLD_MRLOCK_WWAIT))     \
+			  == (__RTLD_MRLOCK_INC | __RTLD_MRLOCK_WWAIT), 0))   \
+      /* We have to wake all threads since there might be some queued	      \
+	 readers already.  */						      \
+      lll_futex_wake (&(lock), 0x7fffffff);				      \
+  } while (0)
+
+
+/* There can only ever be one thread trying to get the exclusive lock.  */
+#define __rtld_mrlock_change(lock) \
+  do {									      \
+    __label__ out;							      \
+    while (1)								      \
+      {									      \
+	int oldval;							      \
+	for (int tries = 0; tries < __RTLD_MRLOCK_TRIES; ++tries)	      \
+	  {								      \
+	    oldval = lock.iv;						      \
+	    while (__builtin_expect ((oldval & __RTLD_MRLOCK_RBITS) == 0, 1)) \
+	      {								      \
+		int newval = ((oldval & __RTLD_MRLOCK_RWAIT)		      \
+			      + __RTLD_MRLOCK_WRITER);			      \
+		int ret = atomic_compare_and_exchange_val_acq (&(lock.iv),	      \
+							       newval,	      \
+							       oldval);	      \
+		if (__builtin_expect (ret == oldval, 1))		      \
+		  goto out;						      \
+		oldval = ret;						      \
+	      }								      \
+	    atomic_delay ();						      \
+	  }								      \
+	atomic_or (&(lock.iv), __RTLD_MRLOCK_WWAIT);			      \
+	oldval |= __RTLD_MRLOCK_WWAIT;					      \
+	lll_futex_wait (&(lock), oldval);					      \
+      }									      \
+  out:;									      \
+  } while (0)
+
+
+#define __rtld_mrlock_done(lock) \
+  do {				 \
+    int oldval = atomic_exchange_and_add (&(lock.iv), -__RTLD_MRLOCK_WRITER);    \
+    if (__builtin_expect ((oldval & __RTLD_MRLOCK_RWAIT) != 0, 0))	      \
+      lll_futex_wake (&(lock), 0x7fffffff);				      \
+  } while (0)
+
+
+#endif
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/sa_len.c
@@ -0,0 +1,44 @@
+/* Copyright (C) 1998, 1999, 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sys/socket.h>
+
+#include <netatalk/at.h>
+#include <netinet/in.h>
+#include <netipx/ipx.h>
+#include <sys/un.h>
+
+int
+__libc_sa_len (sa_family_t af)
+{
+  switch (af)
+    {
+    case AF_APPLETALK:
+      return sizeof (struct sockaddr_at);
+    case AF_INET:
+      return sizeof (struct sockaddr_in);
+    case AF_INET6:
+      return sizeof (struct sockaddr_in6);
+    case AF_IPX:
+      return sizeof (struct sockaddr_ipx);
+    case AF_LOCAL:
+      return sizeof (struct sockaddr_un);
+    }
+  return 0;
+}
+INTDEF(__libc_sa_len)
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/sbrk.c
@@ -0,0 +1 @@
+#include <misc/sbrk.c>
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/sched_getp.c
@@ -0,0 +1,45 @@
+/* Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Bruno Haible <bruno@clisp.org>, 2002.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sched.h>
+#include <sys/types.h>
+#include <errno.h>
+#include <sys/rtprio.h>
+
+/* Retrieve scheduling parameters for a particular process.  */
+int
+__sched_getparam (pid_t pid, struct sched_param *param)
+{
+  /* kFreeBSD return bogus values for SYS_sched_param (see PR kern/76485);
+     fortunately the same information can be retrieved through the rtprio()
+     system call.  */
+  struct rtprio rtp;
+
+  if (__rtprio (RTP_LOOKUP, pid, &rtp) >= 0)
+    {
+      if (RTP_PRIO_IS_REALTIME (rtp.type))
+        param->sched_priority = RTP_PRIO_MAX - rtp.prio;
+      else
+        param->sched_priority = 0;
+    }
+
+  return 0;
+}
+
+weak_alias (__sched_getparam, sched_getparam)
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/seekdir.c
@@ -0,0 +1,2 @@
+/* Avoid <sysdeps/unix/bsd/telldir.c>, which doesn't pass the testsuite.  */
+#include <sysdeps/unix/seekdir.c>
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/semctl.c
@@ -0,0 +1,87 @@
+/* Copyright (C) 2004 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Robert Millan <robertmh@gnu.org>
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+/*-
+ * Copyright (c) 2002 Doug Rabson
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ */
+
+#include <sys/sem.h>
+#include <sys/syscall.h>
+#include <stdarg.h> /* va_list */
+#include <stdlib.h> /* NULL */
+#include <unistd.h>
+
+/* union semun from FreeBSD <sys/sem.h> */
+/*
+ * semctl's arg parameter structure
+ */
+union semun
+{
+  int val;			/* value for SETVAL */
+  struct semid_ds *buf;		/* buffer for IPC_STAT & IPC_SET */
+  unsigned short *array;	/* array for GETALL & SETALL */
+};
+
+int __syscall(int number, ...);
+
+int
+semctl (int semid, int semnum, int cmd, ...)
+{
+  va_list ap;
+  union semun semun;
+  union semun *semun_ptr;
+
+  va_start (ap, cmd);
+  if (cmd == IPC_SET || cmd == IPC_STAT || cmd == GETALL
+      || cmd == SETVAL || cmd == SETALL)
+    {
+      semun = va_arg (ap, union semun);
+      semun_ptr = &semun;
+    }
+  else
+    {
+      semun_ptr = NULL;
+    }
+  va_end (ap);
+
+  return __syscall (SYS_semctl, semid, semnum, cmd, semun_ptr);
+}
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/send.c
@@ -0,0 +1,47 @@
+/* Copyright (C) 2001-2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sys/socket.h>
+#include <sysdep.h>
+#include <sysdep-cancel.h>
+
+extern ssize_t __syscall_sendto (int fd, __const __ptr_t buf,
+		                 size_t n, int flags,
+				 __CONST_SOCKADDR_ARG addr,
+				 socklen_t addrlen);
+libc_hidden_proto (__syscall_sendto)
+
+/* Send N bytes of BUF to socket FD.
+   Return the number of bytes sent or -1.  */
+
+ssize_t
+__libc_send (int fd, const void *buf, size_t n, int flags)
+{
+  if (SINGLE_THREAD_P)
+    return INLINE_SYSCALL (sendto, 6, fd, buf, n, flags, NULL, 0);
+
+  int oldtype = LIBC_CANCEL_ASYNC ();
+  int result = INLINE_SYSCALL (sendto, 6, fd, buf, n, flags, NULL, 0);
+  LIBC_CANCEL_RESET (oldtype);
+  return result;
+}
+
+weak_alias (__libc_send, __send)
+libc_hidden_weak (__send)
+
+weak_alias (__send, send)
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/sendto.c
@@ -0,0 +1,70 @@
+/* Copyright (C) 2005 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Aurelien Jarno <aurelien@aurel32.net>, 2005.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sys/socket.h>
+#include <sysdep.h>
+#include <sysdep-cancel.h>
+
+/* According to POSIX.1-2004 the len argument specifies the length of
+   the sockaddr structure pointed to by the addrarg argument. However
+   the FreeBSD kernel waits the actual length of the address stored
+   there. The code below emulate this behaviour.  */
+
+extern int __libc_sa_len (sa_family_t __af);
+extern int __libc_sa_len_internal (sa_family_t __af);
+
+extern ssize_t __syscall_sendto (int fd, __const void * buf,
+		                 size_t n, int flags,
+				 __CONST_SOCKADDR_ARG addr,
+				 socklen_t addrlen);
+libc_hidden_proto (__syscall_sendto)
+
+/* Send N bytes of BUF on socket FD to peer at address ADDR (which is
+ *    ADDR_LEN bytes long).  Returns the number sent, or -1 for errors.  */
+
+
+ssize_t
+__libc_sendto (int fd, __const void * buf, size_t n, int flags,
+	       __CONST_SOCKADDR_ARG addr, socklen_t addrlen)
+{
+  socklen_t new_addrlen;
+
+#ifndef NOT_IN_libc
+  new_addrlen = INTUSE(__libc_sa_len) ((addr.__sockaddr__)->sa_family);
+#else
+  new_addrlen = __libc_sa_len ((addr.__sockaddr__)->sa_family);
+#endif
+
+  /* Only allow a smaller size, otherwise it could lead to
+    stack corruption */
+  if (new_addrlen < addrlen)
+    addrlen = new_addrlen;
+
+  /* We pass 6 arguments.  */
+  if (SINGLE_THREAD_P)
+    return INLINE_SYSCALL (sendto, 6, fd, buf, n, flags, addr, addrlen);
+
+  int oldtype = LIBC_CANCEL_ASYNC ();
+  int result = INLINE_SYSCALL (sendto, 6, fd, buf, n, flags, addr, addrlen);
+  LIBC_CANCEL_RESET (oldtype);
+  return result;
+}
+
+weak_alias (__libc_sendto, __sendto)
+weak_alias (__libc_sendto, sendto)
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/sethostid.c
@@ -0,0 +1,37 @@
+/* Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Bruno Haible <bruno@clisp.org>, 2002.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <unistd.h>
+#include <sys/sysctl.h>
+
+/* Set the current machine's Internet number to ID.
+   This call is restricted to the super-user.  */
+
+int
+sethostid (long int id)
+{
+  /* Set the "kern.hostid" sysctl value.  */
+  int value = id;
+  int request[2] = { CTL_KERN, KERN_HOSTID };
+
+  if (__sysctl (request, 2, NULL, NULL, &value, sizeof (value)) < 0)
+    return -1;
+
+  return 0;
+}
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/sethostname.c
@@ -0,0 +1,37 @@
+/* Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Bruno Haible <bruno@clisp.org>, 2002.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <unistd.h>
+#include <sys/sysctl.h>
+
+/* Set the name of the current host to NAME, which is LEN bytes long
+   (excluding a possible trailing NUL byte).  This call is restricted to
+   the super-user.  */
+
+int
+sethostname (const char *name, size_t len)
+{
+  /* Set the "kern.hostname" sysctl value.  */
+  int request[2] = { CTL_KERN, KERN_HOSTNAME };
+
+  if (__sysctl (request, 2, NULL, NULL, (void *) name, len) < 0)
+    return -1;
+
+  return 0;
+}
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/setlogin.c
@@ -0,0 +1,34 @@
+/* Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Bruno Haible <bruno@clisp.org>, 2002.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <unistd.h>
+#include <sysdep.h>
+
+/* Defined in getlogin_r.c.  */
+extern char *__getlogin_cache;
+
+extern int __syscall_setlogin (const char *__name);
+
+int
+setlogin (const char *name)
+{
+  /* FIXME: Not multithread-safe.  */
+  __getlogin_cache = NULL;
+  return INLINE_SYSCALL (setlogin, 1, name);
+}
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/setrlimit64.c
@@ -0,0 +1 @@
+/* 'setrlimit64' is the same as 'setrlimit', because __rlim64_t == __rlim_t.  */
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/sigaction.c
@@ -0,0 +1,47 @@
+/* Copyright (C) 1991,1995,1996,1997,2002,2004 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sysdep.h>
+#include <errno.h>
+#include <stddef.h>
+#include <signal.h>
+
+extern int __syscall_sigaction (int __sig,  const struct sigaction *__act, struct sigaction *__oact) __THROW;
+libc_hidden_proto (__syscall_sigaction)
+
+int
+__libc_sigaction (sig, act, oact)
+     int sig;
+     const struct sigaction *act;
+     struct sigaction *oact;
+{
+  if (sig <= 0 || sig >= NSIG)
+    {
+      __set_errno (EINVAL);
+      return -1;
+    }
+
+  return INLINE_SYSCALL (sigaction, 3, sig, act, oact);
+}
+libc_hidden_def (__libc_sigaction)
+
+#ifndef LIBC_SIGACTION
+weak_alias (__libc_sigaction, __sigaction)
+libc_hidden_weak (__sigaction)
+weak_alias (__libc_sigaction, sigaction)
+#endif
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/sigreturn.c
@@ -0,0 +1,3 @@
+/* The sigreturn syscall cannot be explicitly called on FreeBSD, only
+   implicitly by returning from a signal handler.  */
+#include <signal/sigreturn.c>
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/sigset-cvt-mask.h
@@ -0,0 +1,36 @@
+/* Convert between lowlevel sigmask and libc representation of sigset_t.
+   FreeBSD version.
+   Copyright (C) 1998, 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+static inline int __attribute__ ((unused))
+sigset_set_old_mask (sigset_t *set, int mask)
+{
+  set->__sigbits[0] = (unsigned int) mask;
+  set->__sigbits[1] = 0;
+  set->__sigbits[2] = 0;
+  set->__sigbits[3] = 0;
+
+  return 0;
+}
+
+static inline int __attribute__ ((unused))
+sigset_get_old_mask (const sigset_t *set)
+{
+  return (unsigned int) set->__sigbits[0];
+}
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/sigstack.c
@@ -0,0 +1,3 @@
+/* We can reuse the Linux implementation with some tricks.  */
+#define __NR_sigaltstack 1
+#include <sysdeps/unix/sysv/linux/sigstack.c>
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/sleep.c
@@ -0,0 +1,44 @@
+/* Implementation of the POSIX sleep function using nanosleep.
+   Copyright (C) 1996-1999, 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <time.h>
+
+/* The default implementation of sleep() in sysdeps/posix/sleep.c, based on
+   SIGALRM, does not mix well with threads.  Therefore we use the nanosleep()
+   system call.  */
+unsigned int
+__sleep (unsigned int seconds)
+{
+  struct timespec ts = { tv_sec: seconds, tv_nsec: 0 };
+  int ret;
+
+  /* This is not necessary but some buggy programs depend on this.  */
+  if (seconds == 0)
+    return 0;
+
+  ret = __nanosleep (&ts, &ts);
+
+  if (ret == 0)
+    return 0;
+
+  /* Round remaining time.  */
+  return (unsigned int) ts.tv_sec + (ts.tv_nsec >= 500000000L);
+}
+
+weak_alias (__sleep, sleep)
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/stat16conv.c
@@ -0,0 +1,80 @@
+/* Convert between different 'struct stat' formats.
+   Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Bruno Haible <bruno@clisp.org>, 2002.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <string.h>
+#include <sys/mount.h>
+#include <bits/stat16.h>
+
+extern int __syscall_fhstat (const fhandle_t *fhp, struct stat16 *buf);
+extern int __syscall_fstat (int, struct stat16 *__unbounded);
+extern int __syscall_lstat (const char *__unbounded, struct stat16 *__unbounded);
+extern int __syscall_stat (const char *__unbounded, struct stat16 *__unbounded);
+libc_hidden_proto (__syscall_fhstat)
+libc_hidden_proto (__syscall_fstat)
+libc_hidden_proto (__syscall_lstat)
+libc_hidden_proto (__syscall_stat)
+
+/* Convert a 'struct stat16' to 'struct stat'.  */
+static inline void
+stat16_to_stat (const struct stat16 *p16, struct stat *q)
+{
+  q->st_dev = p16->st_dev;
+  q->st_ino = p16->st_ino;
+  q->st_mode = p16->st_mode;
+  q->st_nlink = p16->st_nlink;
+  q->st_uid = p16->st_uid;
+  q->st_gid = p16->st_gid;
+  q->st_rdev = p16->st_rdev;
+  q->st_atim = p16->st_atimespec;
+  q->st_mtim = p16->st_mtimespec;
+  q->st_ctim = p16->st_ctimespec;
+  q->st_size = p16->st_size;
+  q->st_blocks = p16->st_blocks;
+  q->st_blksize = p16->st_blksize;
+  q->st_flags = p16->st_flags;
+  q->st_gen = p16->st_gen;
+#if 0
+  memcpy (q->__unused1, p16->__unused2, sizeof (p16->__unused2));
+#endif
+}
+
+/* Convert a 'struct stat16' to 'struct stat64'.  */
+static inline void
+stat16_to_stat64 (const struct stat16 *p16, struct stat64 *q)
+{
+  q->st_dev = p16->st_dev;
+  q->st_ino = p16->st_ino;
+  q->st_mode = p16->st_mode;
+  q->st_nlink = p16->st_nlink;
+  q->st_uid = p16->st_uid;
+  q->st_gid = p16->st_gid;
+  q->st_rdev = p16->st_rdev;
+  q->st_atim = p16->st_atimespec;
+  q->st_mtim = p16->st_mtimespec;
+  q->st_ctim = p16->st_ctimespec;
+  q->st_size = p16->st_size;
+  q->st_blocks = p16->st_blocks;
+  q->st_blksize = p16->st_blksize;
+  q->st_flags = p16->st_flags;
+  q->st_gen = p16->st_gen;
+#if 0
+  memcpy (q->__unused1, p16->__unused2, sizeof (p16->__unused2));
+#endif
+}
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/statconv.c
@@ -0,0 +1,46 @@
+/* Convert between different 'struct stat' formats.
+   Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Bruno Haible <bruno@clisp.org>, 2002.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <string.h>
+
+/* Convert a 'struct stat' to 'struct stat64'.  */
+static inline void
+stat_to_stat64 (const struct stat *p32, struct stat64 *p64)
+{
+  p64->st_dev = p32->st_dev;
+  p64->st_ino = p32->st_ino;
+  p64->st_mode = p32->st_mode;
+  p64->st_nlink = p32->st_nlink;
+  p64->st_uid = p32->st_uid;
+  p64->st_gid = p32->st_gid;
+  p64->st_rdev = p32->st_rdev;
+  p64->st_atime = p32->st_atime;
+  p64->st_atimensec = p32->st_atimensec;
+  p64->st_mtime = p32->st_mtime;
+  p64->st_mtimensec = p32->st_mtimensec;
+  p64->st_ctime = p32->st_ctime;
+  p64->st_ctimensec = p32->st_ctimensec;
+  p64->st_size = p32->st_size;
+  p64->st_blocks = p32->st_blocks;
+  p64->st_blksize = p32->st_blksize;
+  p64->st_flags = p32->st_flags;
+  p64->st_gen = p32->st_gen;
+  memcpy (p64->__unused1, p32->__unused1, sizeof (p32->__unused1));
+}
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/statfs.c
@@ -0,0 +1,40 @@
+/* Return information about the filesystem on which FILE resides.
+   Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Petr Salinger, 2006.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sys/statfs.h>
+
+#include "statfsconv.c"
+
+/* Return information about the filesystem on which FILE resides.  */
+int
+__statfs (const char *file, struct statfs *buf)
+{
+  struct statfs_fbsd5 kbuf;
+
+  if (__syscall_statfs (file, &kbuf) < 0)
+    return -1;
+
+  /* Convert a 'struct statfs' to 'struct statvfs'.  */
+  statfs5_to_statfs (&kbuf, buf);
+
+  return 0;
+}
+libc_hidden_def (__statfs)
+weak_alias (__statfs, statfs)
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/statfs64.c
@@ -0,0 +1,37 @@
+/* Return information about the filesystem on which FILE resides.
+   Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Bruno Haible <bruno@clisp.org>, 2002.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sys/statfs.h>
+
+#include "statfsconv.c"
+
+/* Return information about the filesystem on which FILE resides.  */
+int
+statfs64 (const char *file, struct statfs64 *buf)
+{
+  struct statfs_fbsd5 kbuf;
+
+  if (__syscall_statfs (file, &kbuf) < 0)
+    return -1;
+
+  statfs5_to_statfs64 (&kbuf, buf);
+
+  return 0;
+}
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/statfsconv.c
@@ -0,0 +1,203 @@
+/* Convert between different 'struct statfs' and 'struct statvfs' formats.
+   Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Bruno Haible <bruno@clisp.org>, 2002.
+   Contributed by Petr Salinger, 2006.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+
+#include <stdint.h>
+#include <string.h>
+#include <sys/mount.h>
+#include <sys/syslimits.h>
+#include <sys/statvfs.h>
+#include <sys/statfs.h>
+
+/*
+ * filesystem statistics
+ */
+
+#define MFSNAMELEN	16		/* length of type name including null */
+#define MNAMELEN	88		/* size of on/from name bufs */
+
+struct statfs_fbsd5 {
+	uint32_t f_version;		/* structure version number */
+	uint32_t f_type;		/* type of filesystem */
+	uint64_t f_flags;		/* copy of mount exported flags */
+	uint64_t f_bsize;		/* filesystem fragment size */
+	uint64_t f_iosize;		/* optimal transfer block size */
+	uint64_t f_blocks;		/* total data blocks in filesystem */
+	uint64_t f_bfree;		/* free blocks in filesystem */
+	int64_t	 f_bavail;		/* free blocks avail to non-superuser */
+	uint64_t f_files;		/* total file nodes in filesystem */
+	int64_t	 f_ffree;		/* free nodes avail to non-superuser */
+	uint64_t f_syncwrites;		/* count of sync writes since mount */
+	uint64_t f_asyncwrites;		/* count of async writes since mount */
+	uint64_t f_syncreads;		/* count of sync reads since mount */
+	uint64_t f_asyncreads;		/* count of async reads since mount */
+	uint64_t f_spare[10];		/* unused spare */
+	uint32_t f_namemax;		/* maximum filename length */
+	__uid_t	 f_owner;		/* user that mounted the filesystem */
+	__fsid_t f_fsid;		/* filesystem id */
+	char	 f_charspare[80];	   /* spare string space */
+	char	 f_fstypename[MFSNAMELEN]; /* filesystem type name */
+	char	 f_mntfromname[MNAMELEN];  /* mounted filesystem */
+	char	 f_mntonname[MNAMELEN];	   /* directory on which mounted */
+};
+
+extern int __syscall_getfsstat(struct statfs_fbsd5 *buf, long bufsize, int flags);
+extern int __syscall_statfs(const char *path, struct statfs_fbsd5 *buf);
+extern int __syscall_fstatfs(int fd, struct statfs_fbsd5 *buf);
+extern int __syscall_fhstatfs(const struct fhandle *u_fhp, struct statfs_fbsd5 *buf);
+
+
+/*
+ * Convert a FreeBSD 5.x format statfs structure to an glibc format statfs structure.
+ */
+
+static inline void
+statfs5_to_statfs(const struct statfs_fbsd5 *pk, struct statfs *p32)
+{
+  memset(p32, 0, sizeof(*p32));
+
+  p32->f_version	= pk->f_version;
+  p32->f_bsize		= MIN(pk->f_bsize,  ULONG_MAX);
+  p32->f_iosize		= MIN(pk->f_iosize, ULONG_MAX);
+
+  p32->f_blocks		= MIN(pk->f_blocks, ULONG_MAX);
+  p32->f_bfree		= MIN(pk->f_bfree,  ULONG_MAX);
+  p32->f_bavail		= MIN(pk->f_bavail, ULONG_MAX);
+  p32->f_files		= MIN(pk->f_files,  ULONG_MAX);
+  p32->f_ffree		= MIN(pk->f_ffree,  ULONG_MAX);
+
+  p32->f_fsid		= pk->f_fsid;
+  p32->f_owner		= pk->f_owner;
+  p32->f_type		= pk->f_type;
+  p32->f_flags		= pk->f_flags;
+
+  p32->f_syncwrites	= MIN(pk->f_syncwrites,	 ULONG_MAX);
+  p32->f_asyncwrites	= MIN(pk->f_asyncwrites, ULONG_MAX);
+  p32->f_syncreads	= MIN(pk->f_syncreads,	 ULONG_MAX);
+  p32->f_asyncreads	= MIN(pk->f_asyncreads,	 ULONG_MAX);
+
+  p32->f_namemax	= MIN(pk->f_namemax, USHRT_MAX);
+
+  memcpy(p32->f_fstypename, pk->f_fstypename, sizeof (p32->f_fstypename));
+  memcpy(p32->f_mntonname,  pk->f_mntonname,  sizeof (p32->f_mntonname));
+  memcpy(p32->f_mntfromname,pk->f_mntfromname,sizeof (p32->f_mntfromname));
+}
+
+
+/*
+ * Convert a FreeBSD 5.x format statfs structure to an glibc format statfs64 structure.
+ */
+
+static inline void
+statfs5_to_statfs64(const struct statfs_fbsd5 *pk, struct statfs64 *p64)
+{
+  memset(p64, 0, sizeof(*p64));
+
+  p64->f_version	= pk->f_version;
+  p64->f_bsize		= MIN(pk->f_bsize,  ULONG_MAX);
+  p64->f_iosize		= MIN(pk->f_iosize, ULONG_MAX);
+
+  p64->f_blocks		= pk->f_blocks;
+  p64->f_bfree		= pk->f_bfree;
+  p64->f_bavail		= pk->f_bavail;
+  p64->f_files		= pk->f_files;
+  p64->f_ffree		= pk->f_ffree;
+
+  p64->f_fsid		= pk->f_fsid;
+  p64->f_owner		= pk->f_owner;
+  p64->f_type		= pk->f_type;
+  p64->f_flags		= pk->f_flags;
+
+  p64->f_syncwrites	= MIN(pk->f_syncwrites,	 ULONG_MAX);
+  p64->f_asyncwrites	= MIN(pk->f_asyncwrites, ULONG_MAX);
+  p64->f_syncreads	= MIN(pk->f_syncreads,	 ULONG_MAX);
+  p64->f_asyncreads	= MIN(pk->f_asyncreads,	 ULONG_MAX);
+
+  p64->f_namemax	= MIN(pk->f_namemax, USHRT_MAX);
+
+  memcpy(p64->f_fstypename, pk->f_fstypename, sizeof (p64->f_fstypename));
+  memcpy(p64->f_mntonname,  pk->f_mntonname,  sizeof (p64->f_mntonname));
+  memcpy(p64->f_mntfromname,pk->f_mntfromname,sizeof (p64->f_mntfromname));
+}
+
+
+/*
+ * Convert a FreeBSD 5.x format statfs structure to an glibc format statvfs structure.
+ */
+
+static inline void
+statfs5_to_statvfs (const struct statfs_fbsd5 *pk, struct statvfs *p32)
+{
+  /* FIXME: What is the difference between f_bsize and f_frsize ? */
+  p32->f_bsize		= MIN(pk->f_bsize,  ULONG_MAX);
+  p32->f_frsize		= MIN(pk->f_bsize,  ULONG_MAX);
+
+  p32->f_blocks		= MIN(pk->f_blocks, ULONG_MAX);
+  p32->f_bfree		= MIN(pk->f_bfree,  ULONG_MAX);
+  p32->f_bavail		= MIN(pk->f_bavail, ULONG_MAX);
+  p32->f_files		= MIN(pk->f_files,  ULONG_MAX);
+  p32->f_ffree		= MIN(pk->f_ffree,  ULONG_MAX);
+  p32->f_favail		= MIN(pk->f_ffree,  ULONG_MAX); /* Hmm.	 May be filesystem dependent.  */
+
+  memcpy(&(p32->f_fsid), &(pk->f_fsid), sizeof(__fsid_t));
+
+  p32->f_flag		=
+      (pk->f_flags & MNT_RDONLY ? ST_RDONLY : 0)
+    | (pk->f_flags & MNT_NOSUID ? ST_NOSUID : 0)
+    | (pk->f_flags & MNT_NODEV ? ST_NODEV : 0)
+    | (pk->f_flags & MNT_NOEXEC ? ST_NOEXEC : 0)
+    | (pk->f_flags & MNT_SYNCHRONOUS ? ST_SYNCHRONOUS : 0);
+  p32->f_namemax	= pk->f_namemax;
+
+  memset (p32->f_spare, '\0', sizeof (p32->f_spare));
+}
+
+
+/*
+ * Convert a FreeBSD 5.x format statfs structure to an glibc format statvfs64 structure.
+ */
+
+static inline void
+statfs5_to_statvfs64 (const struct statfs_fbsd5 *pk, struct statvfs64 *p64)
+{
+  /* FIXME: What is the difference between f_bsize and f_frsize ? */
+  p64->f_bsize		= MIN(pk->f_bsize,  ULONG_MAX);
+  p64->f_frsize		= MIN(pk->f_bsize,  ULONG_MAX);
+
+  p64->f_blocks		= pk->f_blocks;
+  p64->f_bfree		= pk->f_bfree;
+  p64->f_bavail		= pk->f_bavail;
+  p64->f_files		= pk->f_files;
+  p64->f_ffree		= pk->f_ffree;
+  p64->f_favail		= pk->f_ffree; /* Hmm.	May be filesystem dependent.  */
+
+  memcpy(&(p64->f_fsid), &(pk->f_fsid), sizeof(__fsid_t));
+
+  p64->f_flag		=
+      (pk->f_flags & MNT_RDONLY ? ST_RDONLY : 0)
+    | (pk->f_flags & MNT_NOSUID ? ST_NOSUID : 0)
+    | (pk->f_flags & MNT_NODEV ? ST_NODEV : 0)
+    | (pk->f_flags & MNT_NOEXEC ? ST_NOEXEC : 0)
+    | (pk->f_flags & MNT_SYNCHRONOUS ? ST_SYNCHRONOUS : 0);
+  p64->f_namemax	= pk->f_namemax;
+
+  memset (p64->f_spare, '\0', sizeof (p64->f_spare));
+}
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/statvfs.c
@@ -0,0 +1,40 @@
+/* Return information about the filesystem on which FILE resides.
+   Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Bruno Haible <bruno@clisp.org>, 2002.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sys/statvfs.h>
+#include <sys/statfs.h>
+
+#include "statfsconv.c"
+
+/* Return information about the filesystem on which FILE resides.  */
+int
+statvfs (const char *file, struct statvfs *buf)
+{
+  struct statfs_fbsd5 kbuf;
+
+  if (__syscall_statfs (file, &kbuf) < 0)
+    return -1;
+
+  /* Convert a 'struct statfs' to 'struct statvfs'.  */
+  statfs5_to_statvfs (&kbuf, buf);
+
+  return 0;
+}
+libc_hidden_weak (statvfs)
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/statvfs64.c
@@ -0,0 +1,41 @@
+/* Return information about the filesystem on which FILE resides.
+   Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Bruno Haible <bruno@clisp.org>, 2002.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sys/statvfs.h>
+#include <sys/statfs.h>
+
+#include "statfsconv.c"
+
+/* Return information about the filesystem on which FILE resides.  */
+int
+__statvfs64 (const char *file, struct statvfs64 *buf)
+{
+  struct statfs_fbsd5 kbuf;
+
+  if (__syscall_statfs (file, &kbuf) < 0)
+    return -1;
+
+  /* Convert a 'struct statfs' to 'struct statvfs64'.  */
+  statfs5_to_statvfs64 (&kbuf, buf);
+
+  return 0;
+}
+
+weak_alias (__statvfs64, statvfs64)
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/stty.c
@@ -0,0 +1,2 @@
+/* use stub only variant */
+#include <misc/stty.c>
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/sys/kd.h
@@ -0,0 +1,25 @@
+/* Copyright (C) 2005 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _SYS_KD_H
+#define _SYS_KD_H	1
+
+#include <sys/consio.h>
+#include <sys/kbio.h>
+
+#endif	/* sys/kd.h */
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/sys/mount.h
@@ -0,0 +1,436 @@
+/* Header file for handling mounted filesystems.  FreeBSD version.
+   Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _SYS_MOUNT_H
+#define _SYS_MOUNT_H	1
+
+#include <features.h>
+
+/* Retrieving the list of mounted filesystems.  */
+
+#include <sys/stat.h>
+#include <sys/statfs.h>
+#include <sys/ucred.h>
+#include <sys/queue.h>
+
+/*
+ * File identifier.
+ * These are unique per filesystem on a single machine.
+ */
+#define	MAXFIDSZ	16
+
+struct fid {
+	u_short		fid_len;		/* length of data in bytes */
+	u_short		fid_reserved;		/* force longword alignment */
+	char		fid_data[MAXFIDSZ];	/* data (variable length) */
+};
+
+/*
+ * filesystem statistics
+ */
+#define	MFSNAMELEN	16		/* length of type name including null */
+#define	MNAMELEN	88		/* size of on/from name bufs */
+#define	STATFS_VERSION	0x20030518	/* current version number */
+
+
+/*
+ * User specifiable flags.
+ */
+#define	MNT_RDONLY	0x00000001	/* read only filesystem */
+#define	MNT_SYNCHRONOUS	0x00000002	/* filesystem written synchronously */
+#define	MNT_NOEXEC	0x00000004	/* can't exec from filesystem */
+#define	MNT_NOSUID	0x00000008	/* don't honor setuid bits on fs */
+#define	MNT_NODEV	0x00000010	/* don't interpret special files */
+#define	MNT_UNION	0x00000020	/* union with underlying filesystem */
+#define	MNT_ASYNC	0x00000040	/* filesystem written asynchronously */
+#define	MNT_SUIDDIR	0x00100000	/* special handling of SUID on dirs */
+#define	MNT_SOFTDEP	0x00200000	/* soft updates being done */
+#define	MNT_NOSYMFOLLOW	0x00400000	/* do not follow symlinks */
+#define	MNT_GJOURNAL	0x02000000	/* GEOM journal support enabled */
+#define	MNT_JAILDEVFS	0x02000000	/* jail-friendly DEVFS behaviour */
+#define	MNT_MULTILABEL	0x04000000	/* MAC support for individual objects */
+#define	MNT_ACLS	0x08000000	/* ACL support enabled */
+#define	MNT_NOATIME	0x10000000	/* disable update of file access time */
+#define	MNT_NOCLUSTERR	0x40000000	/* disable cluster read */
+#define	MNT_NOCLUSTERW	0x80000000	/* disable cluster write */
+
+/*
+ * NFS export related mount flags.
+ */
+#define	MNT_EXRDONLY	0x00000080	/* exported read only */
+#define	MNT_EXPORTED	0x00000100	/* filesystem is exported */
+#define	MNT_DEFEXPORTED	0x00000200	/* exported to the world */
+#define	MNT_EXPORTANON	0x00000400	/* use anon uid mapping for everyone */
+#define	MNT_EXKERB	0x00000800	/* exported with Kerberos uid mapping */
+#define	MNT_EXPUBLIC	0x20000000	/* public export (WebNFS) */
+
+/*
+ * Flags set by internal operations,
+ * but visible to the user.
+ * XXX some of these are not quite right.. (I've never seen the root flag set)
+ */
+#define	MNT_LOCAL	0x00001000	/* filesystem is stored locally */
+#define	MNT_QUOTA	0x00002000	/* quotas are enabled on filesystem */
+#define	MNT_ROOTFS	0x00004000	/* identifies the root filesystem */
+#define	MNT_USER	0x00008000	/* mounted by a user */
+#define	MNT_IGNORE	0x00800000	/* do not show entry in df */
+
+/*
+ * Mask of flags that are visible to statfs().
+ * XXX I think that this could now become (~(MNT_CMDFLAGS))
+ * but the 'mount' program may need changing to handle this.
+ */
+#define	MNT_VISFLAGMASK	(MNT_RDONLY	| MNT_SYNCHRONOUS | MNT_NOEXEC	| \
+			MNT_NOSUID	| MNT_NODEV	| MNT_UNION	| \
+			MNT_ASYNC	| MNT_EXRDONLY	| MNT_EXPORTED	| \
+			MNT_DEFEXPORTED	| MNT_EXPORTANON| MNT_EXKERB	| \
+			MNT_LOCAL	| MNT_USER	| MNT_QUOTA	| \
+			MNT_ROOTFS	| MNT_NOATIME	| MNT_NOCLUSTERR| \
+			MNT_NOCLUSTERW	| MNT_SUIDDIR	| MNT_SOFTDEP	| \
+			MNT_IGNORE	| MNT_EXPUBLIC	| MNT_NOSYMFOLLOW | \
+			MNT_JAILDEVFS	| MNT_MULTILABEL | MNT_ACLS)
+
+/* Mask of flags that can be updated. */
+#define	MNT_UPDATEMASK (MNT_NOSUID	| MNT_NOEXEC	| MNT_NODEV	| \
+			MNT_SYNCHRONOUS	| MNT_UNION	| MNT_ASYNC	| \
+			MNT_NOATIME | \
+			MNT_NOSYMFOLLOW	| MNT_IGNORE	| MNT_JAILDEVFS	| \
+			MNT_NOCLUSTERR	| MNT_NOCLUSTERW | MNT_SUIDDIR	| \
+			MNT_ACLS	| MNT_USER)
+
+/*
+ * External filesystem command modifier flags.
+ * Unmount can use the MNT_FORCE flag.
+ * XXX These are not STATES and really should be somewhere else.
+ */
+#define	MNT_UPDATE	0x00010000	/* not a real mount, just an update */
+#define	MNT_DELEXPORT	0x00020000	/* delete export host lists */
+#define	MNT_RELOAD	0x00040000	/* reload filesystem data */
+#define	MNT_FORCE	0x00080000	/* force unmount or readonly change */
+#define	MNT_SNAPSHOT	0x01000000	/* snapshot the filesystem */
+#define	MNT_BYFSID	0x08000000	/* specify filesystem by ID. */
+#define MNT_CMDFLAGS   (MNT_UPDATE	| MNT_DELEXPORT	| MNT_RELOAD	| \
+			MNT_FORCE	| MNT_SNAPSHOT	| MNT_BYFSID)
+/*
+ * Internal filesystem control flags stored in mnt_kern_flag.
+ *
+ * MNTK_UNMOUNT locks the mount entry so that name lookup cannot proceed
+ * past the mount point.  This keeps the subtree stable during mounts
+ * and unmounts.
+ *
+ * MNTK_UNMOUNTF permits filesystems to detect a forced unmount while
+ * dounmount() is still waiting to lock the mountpoint. This allows
+ * the filesystem to cancel operations that might otherwise deadlock
+ * with the unmount attempt (used by NFS).
+ */
+#define MNTK_UNMOUNTF	0x00000001	/* forced unmount in progress */
+#define MNTK_ASYNC      0x00000002      /* filtered async flag */
+#define MNTK_SOFTDEP    0x00000004      /* async disabled by softdep */
+#define MNTK_NOINSMNTQ  0x00000008      /* insmntque is not allowed */
+#define MNTK_UNMOUNT	0x01000000	/* unmount in progress */
+#define	MNTK_MWAIT	0x02000000	/* waiting for unmount to finish */
+#define MNTK_WANTRDWR	0x04000000	/* upgrade to read/write requested */
+#define MNTK_SUSPEND2   0x04000000      /* block secondary writes */
+#define	MNTK_SUSPEND	0x08000000	/* request write suspension */
+#define	MNTK_SUSPENDED	0x10000000	/* write operations are suspended */
+#define MNTK_MPSAFE     0x20000000      /* Filesystem is MPSAFE. */
+#define MNTK_NOKNOTE    0x80000000      /* Don't send KNOTEs from VOP hooks */
+#define MNTK_LOOKUP_SHARED      0x40000000 /* FS supports shared lock lookups */
+
+/*
+ * Sysctl CTL_VFS definitions.
+ *
+ * Second level identifier specifies which filesystem. Second level
+ * identifier VFS_VFSCONF returns information about all filesystems.
+ * Second level identifier VFS_GENERIC is non-terminal.
+ */
+#define	VFS_VFSCONF		0	/* get configured filesystems */
+#define	VFS_GENERIC		0	/* generic filesystem information */
+/*
+ * Third level identifiers for VFS_GENERIC are given below; third
+ * level identifiers for specific filesystems are given in their
+ * mount specific header files.
+ */
+#define VFS_MAXTYPENUM	1	/* int: highest defined filesystem type */
+#define VFS_CONF	2	/* struct: vfsconf for filesystem given
+				   as next argument */
+
+/*
+ * Flags for various system call interfaces.
+ *
+ * waitfor flags to vfs_sync() and getfsstat()
+ */
+#define MNT_WAIT	1	/* synchronously wait for I/O to complete */
+#define MNT_NOWAIT	2	/* start all I/O, but do not wait for it */
+#define MNT_LAZY	3	/* push data not written by filesystem syncer */
+#define	MNT_SUSPEND	4	/* Suspend file system after sync */
+
+/*
+ * Generic file handle
+ */
+struct fhandle {
+	fsid_t	fh_fsid;	/* Filesystem id of mount point */
+	struct	fid fh_fid;	/* Filesys specific id */
+};
+typedef struct fhandle	fhandle_t;
+
+/*
+ * Export arguments for local filesystem mount calls.
+ */
+struct export_args {
+	int	ex_flags;		/* export related flags */
+	uid_t	ex_root;		/* mapping for root uid */
+	struct	xucred ex_anon;		/* mapping for anonymous user */
+	struct	sockaddr *ex_addr;	/* net address to which exported */
+	u_char	ex_addrlen;		/* and the net address length */
+	struct	sockaddr *ex_mask;	/* mask of valid bits in saddr */
+	u_char	ex_masklen;		/* and the smask length */
+	char	*ex_indexfile;		/* index file for WebNFS URLs */
+};
+
+/*
+ * Structure holding information for a publicly exported filesystem
+ * (WebNFS). Currently the specs allow just for one such filesystem.
+ */
+struct nfs_public {
+	int		np_valid;	/* Do we hold valid information */
+	fhandle_t	np_handle;	/* Filehandle for pub fs (internal) */
+	struct mount	*np_mount;	/* Mountpoint of exported fs */
+	char		*np_index;	/* Index file */
+};
+
+/*
+ * Filesystem configuration information. One of these exists for each
+ * type of filesystem supported by the kernel. These are searched at
+ * mount time to identify the requested filesystem.
+ *
+ * XXX: Never change the first two arguments!
+ */
+struct vfsconf {
+	u_int	vfc_version;		/* ABI version number */
+	char	vfc_name[MFSNAMELEN];	/* filesystem type name */
+	struct	vfsops *vfc_vfsops;	/* filesystem operations vector */
+	int	vfc_typenum;		/* historic filesystem type number */
+	int	vfc_refcount;		/* number mounted of this type */
+	int	vfc_flags;		/* permanent flags */
+	struct	vfsoptdecl *vfc_opts;	/* mount options */
+	TAILQ_ENTRY(vfsconf) vfc_list;	/* list of vfscons */
+};
+
+/* Userland version of the struct vfsconf. */
+struct xvfsconf {
+	struct	vfsops *vfc_vfsops;	/* filesystem operations vector */
+	char	vfc_name[MFSNAMELEN];	/* filesystem type name */
+	int	vfc_typenum;		/* historic filesystem type number */
+	int	vfc_refcount;		/* number mounted of this type */
+	int	vfc_flags;		/* permanent flags */
+	struct	vfsconf *vfc_next;	/* next in list */
+};
+
+#ifndef BURN_BRIDGES
+struct ovfsconf {
+	void	*vfc_vfsops;
+	char	vfc_name[32];
+	int	vfc_index;
+	int	vfc_refcount;
+	int	vfc_flags;
+};
+#endif
+
+/*
+ * NB: these flags refer to IMPLEMENTATION properties, not properties of
+ * any actual mounts; i.e., it does not make sense to change the flags.
+ */
+#define	VFCF_STATIC	0x00010000	/* statically compiled into kernel */
+#define	VFCF_NETWORK	0x00020000	/* may get data over the network */
+#define	VFCF_READONLY	0x00040000	/* writes are not implemented */
+#define VFCF_SYNTHETIC	0x00080000	/* data does not represent real files */
+#define	VFCF_LOOPBACK	0x00100000	/* aliases some other mounted FS */
+#define	VFCF_UNICODE	0x00200000	/* stores file names as Unicode*/
+#define VFCF_JAIL       0x00400000      /* can be mounted from within a jail */
+
+typedef u_int32_t fsctlop_t;
+
+struct vfsidctl {
+	int		vc_vers;	/* should be VFSIDCTL_VERS1 (below) */
+	fsid_t		vc_fsid;	/* fsid to operate on. */
+	char		vc_fstypename[MFSNAMELEN];
+					/* type of fs 'nfs' or '*' */
+	fsctlop_t	vc_op;		/* operation VFS_CTL_* (below) */
+	void		*vc_ptr;	/* pointer to data structure. */
+	size_t		vc_len;		/* sizeof said structure. */
+	u_int32_t	vc_spare[12];	/* spare (must be zero). */
+};
+
+/* vfsidctl API version. */
+#define VFS_CTL_VERS1	0x01
+
+/*
+ * New style VFS sysctls, do not reuse/conflict with the namespace for
+ * private sysctls.
+ * All "global" sysctl ops have the 33rd bit set:
+ * 0x...1....
+ * Private sysctl ops should have the 33rd bit unset.
+ */
+#define VFS_CTL_QUERY	0x00010001	/* anything wrong? (vfsquery) */
+#define VFS_CTL_TIMEO	0x00010002	/* set timeout for vfs notification */
+#define VFS_CTL_NOLOCKS	0x00010003	/* disable file locking */
+
+struct vfsquery {
+	u_int32_t	vq_flags;
+	u_int32_t	vq_spare[31];
+};
+
+/* vfsquery flags */
+#define VQ_NOTRESP	0x0001	/* server down */
+#define VQ_NEEDAUTH	0x0002	/* server bad auth */
+#define VQ_LOWDISK	0x0004	/* we're low on space */
+#define VQ_MOUNT	0x0008	/* new filesystem arrived */
+#define VQ_UNMOUNT	0x0010	/* filesystem has left */
+#define VQ_DEAD		0x0020	/* filesystem is dead, needs force unmount */
+#define VQ_ASSIST	0x0040	/* filesystem needs assistance from external
+				   program */
+#define VQ_NOTRESPLOCK	0x0080	/* server lockd down */
+#define VQ_FLAG0100	0x0100	/* placeholder */
+#define VQ_FLAG0200	0x0200	/* placeholder */
+#define VQ_FLAG0400	0x0400	/* placeholder */
+#define VQ_FLAG0800	0x0800	/* placeholder */
+#define VQ_FLAG1000	0x1000	/* placeholder */
+#define VQ_FLAG2000	0x2000	/* placeholder */
+#define VQ_FLAG4000	0x4000	/* placeholder */
+#define VQ_FLAG8000	0x8000	/* placeholder */
+
+
+struct iovec;
+struct uio;
+
+__BEGIN_DECLS
+
+/* Mounting and unmounting filesystems.  */
+int	mount(const char *, const char *, int, void *);
+int	nmount(struct iovec *, unsigned int, int);
+int	unmount(const char *, int);
+
+/* C library stuff */
+int	getvfsbyname(const char *, struct xvfsconf *);
+
+/* getfsstat() appears in BSD 4.4.  A variant of this API is found on OSF/1,
+   but on that system the user also needs to include <sys/fs_types.h>.  */
+
+#ifndef __USE_FILE_OFFSET64
+extern int getfsstat (struct statfs *__buf, long __bufsize,
+		      int __flags) __THROW;
+#else
+# ifdef __REDIRECT
+extern int __REDIRECT (getfsstat,
+		       (struct statfs *__buf, long __bufsize, int __flags),
+		       getfsstat64);
+# else
+#  define getfsstat getfsstat64
+# endif
+#endif
+#ifdef __USE_LARGEFILE64
+extern int getfsstat64 (struct statfs64 *__buf, long __bufsize,
+			int __flags) __THROW;
+#endif
+
+#ifdef _LIBC
+extern int __getfsstat (struct statfs *__buf, long __bufsize, int __flags);
+extern int __getfsstat64 (struct statfs64 *__buf, long __bufsize, int __flags);
+#endif
+
+/* getmntinfo() appears in BSD 4.4.  */
+
+#ifndef __USE_FILE_OFFSET64
+extern int getmntinfo (struct statfs **__mntbufp, int __flags) __THROW;
+#else
+# ifdef __REDIRECT
+extern int __REDIRECT (getmntinfo,
+		       (struct statfs **__mntbufp, int __flags),
+		       getmntinfo64);
+# else
+#  define getmntinfo getmntinfo64
+# endif
+#endif
+#ifdef __USE_LARGEFILE64
+extern int getmntinfo64 (struct statfs64 **__mntbufp, int __flags) __THROW;
+#endif
+
+#ifdef _LIBC
+extern int __getmntinfo (struct statfs **__mntbufp, int __flags);
+#endif
+
+__END_DECLS
+
+
+/* Opening files on specified mounted filesystems.
+   These system calls are reserved to the superuser, for security reasons.  */
+
+__BEGIN_DECLS
+
+/* Return in *FHP the file handle corresponding to the file or directory
+   PATH.  */
+extern int getfh (__const char *__path, fhandle_t *__fhp) __THROW;
+
+/* Return in *FHP the file handle corresponding to the file or directory
+   PATH.  */
+extern int lgetfh (__const char *__path, fhandle_t *__fhp) __THROW;
+
+/* Open a file handle *FHP, using the open() like FLAGS.  Return the
+   new file descriptor.  */
+extern int fhopen (__const fhandle_t *__fhp, int __flags) __THROW;
+
+/* Get file attributes for the file whose handle is *FHP, and return them
+   in *BUF.  Like fhopen + fstat + close.  */
+#ifndef __USE_FILE_OFFSET64
+extern int fhstat (__const fhandle_t *__fhp, struct stat *__buf) __THROW;
+#else
+# ifdef __REDIRECT
+extern int __REDIRECT (fhstat,
+		       (__const fhandle_t *__fhp, struct stat *__buf),
+		       fhstat64);
+# else
+#  define fhstat fhstat64
+# endif
+#endif
+#ifdef __USE_LARGEFILE64
+extern int fhstat64 (__const fhandle_t *__fhp, struct stat64 *__buf) __THROW;
+#endif
+
+/* Return information about the filesystem on which the file resides whose
+   handle is *FHP.  Like fhopen + fstatfs + close.  */
+#ifndef __USE_FILE_OFFSET64
+extern int fhstatfs (__const fhandle_t *__fhp, struct statfs *__buf) __THROW;
+#else
+# ifdef __REDIRECT
+extern int __REDIRECT (fhstatfs,
+		       (__const fhandle_t *__fhp, struct statfs *__buf),
+		       fhstatfs64);
+# else
+#  define fhstatfs fhstatfs64
+# endif
+#endif
+#ifdef __USE_LARGEFILE64
+extern int fhstatfs64 (__const fhandle_t *__fhp,
+		       struct statfs64 *__buf) __THROW;
+#endif
+
+__END_DECLS
+
+#endif /* _SYS_MOUNT_H */
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/sys/param.h
@@ -0,0 +1,237 @@
+/* Copyright (C) 1995,1996,1997,2000,2001,2003 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _SYS_PARAM_H
+#define _SYS_PARAM_H	1
+
+#include <limits.h>
+#include <sys/syslimits.h>
+
+#ifndef NULL
+#define NULL 0
+#endif
+
+/*
+ * __FreeBSD_version numbers are documented in the Porter's Handbook.
+ * If you bump the version for any reason, you should update the documentation
+ * there.
+ * Currently this lives here:
+ *
+ *      doc/en_US.ISO8859-1/books/porters-handbook/book.sgml
+ *
+ * scheme is:  <major><two digit minor><0 if release branch, otherwise 1>xx
+ */
+#include <osreldate.h>
+
+/* Some inet code expects that this file defines the 'u_int32_t' type.  */
+#include <sys/types.h>
+
+/*
+ * Machine-independent constants (some used in following include files).
+ * Redefined constants are from POSIX 1003.1 limits file.
+ *
+ * MAXCOMLEN should be >= sizeof(ac_comm) (see <acct.h>)
+ * MAXLOGNAME should be == UT_NAMESIZE+1 (see <utmp.h>)
+ */
+
+#define MAXCOMLEN       19              /* max command name remembered */
+#define MAXINTERP       32              /* max interpreter file name length */
+#define MAXLOGNAME      17              /* max login name length (incl. NUL) */
+#define MAXUPRC         CHILD_MAX       /* max simultaneous processes */
+#define NCARGS          ARG_MAX         /* max bytes for an exec function */
+#define NGROUPS         NGROUPS_MAX     /* max number groups */
+#define NOGROUP         65535           /* marker for empty group set member */
+#define MAXHOSTNAMELEN  256             /* max hostname size */
+#define SPECNAMELEN     63              /* max length of devicename */
+#define TTY_NAME_MAX	SPECNAMELEN
+
+/* BSD names for some <limits.h> values.  */
+
+#define	NBBY		CHAR_BIT
+#ifndef	NGROUPS
+# define NGROUPS	NGROUPS_MAX
+#endif
+#define	MAXSYMLINKS	32
+#define	CANBSIZ		MAX_CANON
+#define	NCARGS		ARG_MAX
+#define MAXPATHLEN	PATH_MAX
+
+/* The following is not really correct but it is a value we used for a
+   long time and which seems to be usable.  People should not use NOFILE
+   anyway.  */
+#define NOFILE		OPEN_MAX
+
+/* Bit map related macros.  */
+#define	setbit(a,i)	((a)[(i)/NBBY] |= 1<<((i)%NBBY))
+#define	clrbit(a,i)	((a)[(i)/NBBY] &= ~(1<<((i)%NBBY)))
+#define	isset(a,i)	((a)[(i)/NBBY] & (1<<((i)%NBBY)))
+#define	isclr(a,i)	(((a)[(i)/NBBY] & (1<<((i)%NBBY))) == 0)
+
+/* Macros for counting and rounding.  */
+#ifndef howmany
+# define howmany(x, y)	(((x) + ((y) - 1)) / (y))
+#endif
+#ifdef __GNUC__
+# define roundup(x, y)	(__builtin_constant_p (y) && powerof2 (y)	      \
+			 ? (((x) + (y) - 1) & ~((y) - 1))		      \
+			 : ((((x) + ((y) - 1)) / (y)) * (y)))
+#else
+# define roundup(x, y)	((((x) + ((y) - 1)) / (y)) * (y))
+#endif
+#define powerof2(x)	((((x) - 1) & (x)) == 0)
+
+/* Macros for min/max.  */
+#define	MIN(a,b) (((a)<(b))?(a):(b))
+#define	MAX(a,b) (((a)>(b))?(a):(b))
+
+/* Machine type dependent parameters. */
+#include <machine/param.h>
+
+#ifndef DEV_BSHIFT
+#define DEV_BSHIFT	9               /* log2(DEV_BSIZE) */
+#endif
+#define DEV_BSIZE	(1<<DEV_BSHIFT)
+
+#ifndef BLKDEV_IOSIZE
+#define BLKDEV_IOSIZE	PAGE_SIZE        /* default block device I/O size */
+#endif
+#ifndef DFLTPHYS
+#define DFLTPHYS	(64 * 1024)     /* default max raw I/O transfer size */
+#endif
+#ifndef MAXPHYS
+#define MAXPHYS		(128 * 1024)    /* max raw I/O transfer size */
+#endif
+#ifndef MAXDUMPPGS
+#define MAXDUMPPGS	(DFLTPHYS/PAGE_SIZE)
+#ifndef MAXHOSTNAMELEN
+#define MAXHOSTNAMELEN 64 /* XXX */
+#endif /* No MAXHOSTNAMELEN.  */
+
+/*
+ * Constants related to network buffer management.
+ * MCLBYTES must be no larger than PAGE_SIZE.
+ */
+#ifndef	MSIZE
+#define MSIZE		256		/* size of an mbuf */
+#endif	/* MSIZE */
+
+#ifndef	MCLSHIFT
+#define MCLSHIFT	11		/* convert bytes to mbuf clusters */
+#endif	/* MCLSHIFT */
+
+#define MCLBYTES	(1 << MCLSHIFT)	/* size of an mbuf cluster */
+
+/*
+ * Some macros for units conversion
+ */
+
+/* clicks to bytes */
+#ifndef ctob
+#define ctob(x)	((x)<<PAGE_SHIFT)
+#endif
+
+/* bytes to clicks */
+#ifndef btoc
+#define btoc(x)	(((vm_offset_t)(x)+PAGE_MASK)>>PAGE_SHIFT)
+#endif
+
+/*
+ * btodb() is messy and perhaps slow because `bytes' may be an off_t.  We
+ * want to shift an unsigned type to avoid sign extension and we don't
+ * want to widen `bytes' unnecessarily.  Assume that the result fits in
+ * a daddr_t.
+ */
+#ifndef btodb
+#define btodb(bytes)	 		/* calculates (bytes / DEV_BSIZE) */ \
+	(sizeof (bytes) > sizeof(long) \
+	 ? (daddr_t)((unsigned long long)(bytes) >> DEV_BSHIFT) \
+	 : (daddr_t)((unsigned long)(bytes) >> DEV_BSHIFT))
+#endif
+
+#ifndef dbtob
+#define dbtob(db)			/* calculates (db * DEV_BSIZE) */ \
+	((off_t)(db) << DEV_BSHIFT)
+#endif
+
+#endif /* _NO_NAMESPACE_POLLUTION */
+
+#define	PRIMASK	0x0ff
+#define	PCATCH	0x100		/* OR'd with pri for tsleep to check signals */
+#define	PDROP	0x200	/* OR'd with pri to stop re-entry of interlock mutex */
+
+#define	NBPW	sizeof(int)	/* number of bytes per word (integer) */
+
+#define	CMASK	022		/* default file mask: S_IWGRP|S_IWOTH */
+
+#define	NODEV	(dev_t)(-1)	/* non-existent device */
+
+#define	CBLOCK	128		/* Clist block size, must be a power of 2. */
+#define CBQSIZE	(CBLOCK/NBBY)	/* Quote bytes/cblock - can do better. */
+				/* Data chars/clist. */
+#define	CBSIZE	(CBLOCK - sizeof(struct cblock *) - CBQSIZE)
+#define	CROUND	(CBLOCK - 1)	/* Clist rounding. */
+
+/*
+ * File system parameters and macros.
+ *
+ * MAXBSIZE -	Filesystems are made out of blocks of at most MAXBSIZE bytes
+ *		per block.  MAXBSIZE may be made larger without effecting
+ *		any existing filesystems as long as it does not exceed MAXPHYS,
+ *		and may be made smaller at the risk of not being able to use
+ *		filesystems which require a block size exceeding MAXBSIZE.
+ *
+ * BKVASIZE -	Nominal buffer space per buffer, in bytes.  BKVASIZE is the
+ *		minimum KVM memory reservation the kernel is willing to make.
+ *		Filesystems can of course request smaller chunks.  Actual
+ *		backing memory uses a chunk size of a page (PAGE_SIZE).
+ *
+ *		If you make BKVASIZE too small you risk seriously fragmenting
+ *		the buffer KVM map which may slow things down a bit.  If you
+ *		make it too big the kernel will not be able to optimally use
+ *		the KVM memory reserved for the buffer cache and will wind
+ *		up with too-few buffers.
+ *
+ *		The default is 16384, roughly 2x the block size used by a
+ *		normal UFS filesystem.
+ */
+#define MAXBSIZE	65536	/* must be power of 2 */
+#define BKVASIZE	16384	/* must be power of 2 */
+#define BKVAMASK	(BKVASIZE-1)
+
+/*
+ * Scale factor for scaled integers used to count %cpu time and load avgs.
+ *
+ * The number of CPU `tick's that map to a unique `%age' can be expressed
+ * by the formula (1 / (2 ^ (FSHIFT - 11))).  The maximum load average that
+ * can be calculated (assuming 32 bits) can be closely approximated using
+ * the formula (2 ^ (2 * (16 - FSHIFT))) for (FSHIFT < 15).
+ *
+ * For the scheduler to maintain a 1:1 mapping of CPU `tick' to `%age',
+ * FSHIFT must be at least 11; this gives us a maximum load avg of ~1024.
+ */
+#define	FSHIFT	11		/* bits to right of fixed binary point */
+#define FSCALE	(1<<FSHIFT)
+
+#define dbtoc(db)			/* calculates devblks to pages */ \
+	((db + (ctodb(1) - 1)) >> (PAGE_SHIFT - DEV_BSHIFT))
+
+#define ctodb(db)			/* calculates pages to devblks */ \
+	((db) << (PAGE_SHIFT - DEV_BSHIFT))
+
+#endif	/* _SYS_PARAM_H_ */
+
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/sys/ptrace.h
@@ -0,0 +1,132 @@
+/* `ptrace' debugger support interface.  FreeBSD version.
+   Copyright (C) 1996-1999, 2000, 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _SYS_PTRACE_H
+#define _SYS_PTRACE_H	1
+
+#include <features.h>
+
+__BEGIN_DECLS
+
+/* Type of the REQUEST argument to `ptrace.'  */
+enum __ptrace_request
+{
+  /* Indicate that the process making this request should be traced.
+     All signals received by this process can be intercepted by its
+     parent, and its parent can use the other `ptrace' requests.  */
+  PTRACE_TRACEME = 0,
+#define PT_TRACE_ME PTRACE_TRACEME
+
+  /* Return the word in the process's text space at address ADDR.  */
+  PTRACE_PEEKTEXT = 1,
+#define PT_READ_I PTRACE_PEEKTEXT
+
+  /* Return the word in the process's data space at address ADDR.  */
+  PTRACE_PEEKDATA = 2,
+#define PT_READ_D PTRACE_PEEKDATA
+
+#if 1 /* NB: removed in FreeBSD 4.6 */
+  /* Return the word in the process's user area at offset ADDR.  */
+  PTRACE_PEEKUSER = 3,
+#define PT_READ_U PTRACE_PEEKUSER
+#endif
+
+  /* Write the word DATA into the process's text space at address ADDR.  */
+  PTRACE_POKETEXT = 4,
+#define PT_WRITE_I PTRACE_POKETEXT
+
+  /* Write the word DATA into the process's data space at address ADDR.  */
+  PTRACE_POKEDATA = 5,
+#define PT_WRITE_D PTRACE_POKEDATA
+
+#if 1 /* NB: removed in FreeBSD 4.6 */
+  /* Write the word DATA into the process's user area at offset ADDR.  */
+  PTRACE_POKEUSER = 6,
+#define PT_WRITE_U PTRACE_POKEUSER
+#endif
+
+  /* Continue the process.  */
+  PTRACE_CONT = 7,
+#define PT_CONTINUE PTRACE_CONT
+
+  /* Kill the process.  */
+  PTRACE_KILL = 8,
+#define PT_KILL PTRACE_KILL
+
+  /* Single step the process.
+     This is not supported on all machines.  */
+  PTRACE_SINGLESTEP = 9,
+#define PT_STEP PTRACE_SINGLESTEP
+
+  /* Attach to a process that is already running. */
+  PTRACE_ATTACH = 10,
+#define PT_ATTACH PTRACE_ATTACH
+
+  /* Detach from a process attached to with PTRACE_ATTACH.  */
+  PTRACE_DETACH = 11,
+#define PT_DETACH PTRACE_DETACH
+
+  /* CPU specific requests start here.  */
+  __PTRACE_FIRSTMACH = 32,
+
+  /* Get all general purpose registers used by a processes.
+     This is not supported on all machines.  */
+   PTRACE_GETREGS,
+#define PT_GETREGS PTRACE_GETREGS
+
+  /* Set all general purpose registers used by a processes.
+     This is not supported on all machines.  */
+   PTRACE_SETREGS,
+#define PT_SETREGS PTRACE_SETREGS
+
+  /* Get all floating point registers used by a processes.
+     This is not supported on all machines.  */
+   PTRACE_GETFPREGS,
+#define PT_GETFPREGS PTRACE_GETFPREGS
+
+  /* Set all floating point registers used by a processes.
+     This is not supported on all machines.  */
+   PTRACE_SETFPREGS,
+#define PT_SETFPREGS PTRACE_SETFPREGS
+
+  /* Get all debug registers used by a processes.
+     This is not supported on all machines.  */
+   PTRACE_GETDBREGS,
+#define PT_GETDBREGS PTRACE_GETDBREGS
+
+  /* Set all debug registers used by a processes.
+     This is not supported on all machines.  */
+   PTRACE_SETDBREGS
+#define PT_SETDBREGS PTRACE_SETDBREGS
+};
+
+/* Perform process tracing functions.  REQUEST is one of the values
+   above, and determines the action to be taken.
+   For all requests except PTRACE_TRACEME, PID specifies the process to be
+   traced.
+
+   PID and the other arguments described above for the various requests should
+   appear (those that are used for the particular request) as:
+     pid_t PID, void *ADDR, int DATA, void *ADDR2
+   after REQUEST.  */
+extern int ptrace (enum __ptrace_request __request, ...) __THROW;
+
+__END_DECLS
+
+#endif /* _SYS_PTRACE_H */
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/sys/reboot.h
@@ -0,0 +1,75 @@
+/*-
+ * Copyright (c) 1982, 1986, 1988, 1993, 1994
+ *	The Regents of the University of California.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 4. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ *	@(#)reboot.h	8.3 (Berkeley) 12/13/94
+ * $FreeBSD: src/sys/sys/reboot.h,v 1.26.18.1 2008/11/25 02:59:29 kensmith Exp $
+ */
+
+#ifndef _SYS_REBOOT_H_
+#define	_SYS_REBOOT_H_	1
+
+#include <features.h>
+
+/*
+ * Arguments to reboot system call.  These are passed to
+ * the boot program and on to init.
+ */
+#define	RB_AUTOBOOT	0	/* flags for system auto-booting itself */
+
+#define	RB_ASKNAME	0x001	/* ask for file name to reboot from */
+#define	RB_SINGLE	0x002	/* reboot to single user only */
+#define	RB_NOSYNC	0x004	/* dont sync before reboot */
+#define	RB_HALT		0x008	/* don't reboot, just halt */
+#define	RB_INITNAME	0x010	/* name given for /etc/init (unused) */
+#define	RB_DFLTROOT	0x020	/* use compiled-in rootdev */
+#define	RB_KDB		0x040	/* give control to kernel debugger */
+#define	RB_RDONLY	0x080	/* mount root fs read-only */
+#define	RB_DUMP		0x100	/* dump kernel memory before reboot */
+#define	RB_MINIROOT	0x200	/* mini-root present in memory at boot time */
+#define	RB_VERBOSE	0x800	/* print all potentially useful info */
+#define	RB_SERIAL	0x1000	/* use serial port as console */
+#define	RB_CDROM	0x2000	/* use cdrom as root */
+#define	RB_POWEROFF	0x4000	/* turn the power off if possible */
+#define	RB_GDB		0x8000	/* use GDB remote debugger instead of DDB */
+#define	RB_MUTE		0x10000	/* start up with the console muted */
+#define	RB_SELFTEST	0x20000	/* don't complete the boot; do selftest */
+#define	RB_RESERVED1	0x40000	/* reserved for internal use of boot blocks */
+#define	RB_RESERVED2	0x80000	/* reserved for internal use of boot blocks */
+#define	RB_PAUSE	0x100000 /* pause after each output line during probe */
+#define	RB_MULTIPLE	0x20000000	/* use multiple consoles */
+
+#define	RB_BOOTINFO	0x80000000	/* have `struct bootinfo *' arg */
+
+__BEGIN_DECLS
+
+/* Reboot or halt the system.  */
+extern int reboot (int __howto) __THROW;
+
+__END_DECLS
+
+#endif
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/sys/rfork.h
@@ -0,0 +1,91 @@
+/* Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+/*
+ * Copyright (c) 1989, 1993
+ *	The Regents of the University of California.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 4. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ *	@(#)unistd.h	8.2 (Berkeley) 1/7/94
+ * $FreeBSD: src/sys/sys/unistd.h,v 1.22.2.1 2000/03/18 23:20:12 jasone Exp $
+ */
+
+#ifndef _SYS_RFORK_H
+#define _SYS_RFORK_H
+
+#include <features.h>
+
+/*
+ * rfork() options.
+ *
+ * XXX currently, operations without RFPROC set are not supported.
+ */
+#define RFNAMEG		(1<<0)  /* UNIMPL new plan9 `name space' */
+#define RFENVG		(1<<1)  /* UNIMPL copy plan9 `env space' */
+#define RFFDG		(1<<2)  /* copy fd table */
+#define RFNOTEG		(1<<3)  /* UNIMPL create new plan9 `note group' */
+#define RFPROC		(1<<4)  /* change child (else changes curproc) */
+#define RFMEM		(1<<5)  /* share `address space' */
+#define RFNOWAIT	(1<<6)  /* parent need not wait() on child */
+#define RFCNAMEG	(1<<10) /* UNIMPL zero plan9 `name space' */
+#define RFCENVG		(1<<11) /* UNIMPL zero plan9 `env space' */
+#define RFCFDG		(1<<12) /* zero fd table */
+#define RFTHREAD	(1<<13)	/* enable kernel thread support */
+#define RFSIGSHARE	(1<<14)	/* share signal handlers */
+#define RFLINUXTHPN     (1<<16) /* do linux clone exit parent notification */
+#define RFPPWAIT	(1<<31) /* parent sleeps until child exits (vfork) */
+
+#define RFTHPNSHIFT	24	/* reserve bits 24-30 */
+#define RFTHPNMASK	0x7F    /* for compatibility with linuxthreads/clone()   */
+				/* allow to specify  "clone exit parent notification" signal */
+#define RFTHPNSIGNUM(flags)	(((flags) >> RFTHPNSHIFT) & RFTHPNMASK)
+
+__BEGIN_DECLS
+
+extern int rfork (int __flags) __THROW;
+
+#ifdef _LIBC
+extern int __rfork (int __flags);
+#endif
+
+__END_DECLS
+
+#endif /* _SYS_RFORK_H */
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/sys/swap.h
@@ -0,0 +1,34 @@
+/* Calls to enable swapping on specified locations.  FreeBSD version.
+   Copyright (C) 1996-1997, 2000, 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef __SYS_SWAP_H
+
+#define __SYS_SWAP_H	1
+#include <features.h>
+
+
+__BEGIN_DECLS
+
+/* Make the block special device PATH available to the system for swapping.
+   This call is restricted to the super-user.  */
+extern int swapon (__const char *__path) __THROW;
+
+__END_DECLS
+
+#endif /* sys/swap.h */
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/sys/syscall.h
@@ -0,0 +1,419 @@
+/* Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _SYSCALL_H
+#define _SYSCALL_H	1
+
+#define	SYS_syscall	0
+#define	SYS_exit	1
+#define	SYS_fork	2
+#define	SYS_read	3
+#define	SYS_write	4
+#define	SYS_open	5
+#define	SYS_close	6
+#define	SYS_wait4	7
+				/* 8 is old creat */
+#define	SYS_link	9
+#define	SYS_unlink	10
+				/* 11 is obsolete execv */
+#define	SYS_chdir	12
+#define	SYS_fchdir	13
+#define	SYS_mknod	14
+#define	SYS_chmod	15
+#define	SYS_chown	16
+#define	SYS_obreak	17
+#define	SYS_freebsd4_getfsstat	18
+				/* 19 is old lseek */
+#define	SYS_getpid	20
+#define	SYS_mount	21
+#define	SYS_unmount	22
+#define	SYS_setuid	23
+#define	SYS_getuid	24
+#define	SYS_geteuid	25
+#define	SYS_ptrace	26
+#define	SYS_recvmsg	27
+#define	SYS_sendmsg	28
+#define	SYS_recvfrom	29
+#define	SYS_accept	30
+#define	SYS_getpeername	31
+#define	SYS_getsockname	32
+#define	SYS_access	33
+#define	SYS_chflags	34
+#define	SYS_fchflags	35
+#define	SYS_sync	36
+#define	SYS_kill	37
+				/* 38 is old stat */
+#define	SYS_getppid	39
+				/* 40 is old lstat */
+#define	SYS_dup	41
+#define	SYS_pipe	42
+#define	SYS_getegid	43
+#define	SYS_profil	44
+#define	SYS_ktrace	45
+				/* 46 is old sigaction */
+#define	SYS_getgid	47
+				/* 48 is old sigprocmask */
+#define	SYS_getlogin	49
+#define	SYS_setlogin	50
+#define	SYS_acct	51
+				/* 52 is old sigpending */
+#define	SYS_sigaltstack	53
+#define	SYS_ioctl	54
+#define	SYS_reboot	55
+#define	SYS_revoke	56
+#define	SYS_symlink	57
+#define	SYS_readlink	58
+#define	SYS_execve	59
+#define	SYS_umask	60
+#define	SYS_chroot	61
+				/* 62 is old fstat */
+				/* 63 is old getkerninfo */
+				/* 64 is old getpagesize */
+#define	SYS_msync	65
+#define	SYS_vfork	66
+				/* 67 is obsolete vread */
+				/* 68 is obsolete vwrite */
+#define	SYS_sbrk	69
+#define	SYS_sstk	70
+				/* 71 is old mmap */
+#define	SYS_vadvise	72
+#define	SYS_munmap	73
+#define	SYS_mprotect	74
+#define	SYS_madvise	75
+				/* 76 is obsolete vhangup */
+				/* 77 is obsolete vlimit */
+#define	SYS_mincore	78
+#define	SYS_getgroups	79
+#define	SYS_setgroups	80
+#define	SYS_getpgrp	81
+#define	SYS_setpgid	82
+#define	SYS_setitimer	83
+				/* 84 is old wait */
+#define	SYS_swapon	85
+#define	SYS_getitimer	86
+				/* 87 is old gethostname */
+				/* 88 is old sethostname */
+#define	SYS_getdtablesize	89
+#define	SYS_dup2	90
+#define	SYS_fcntl	92
+#define	SYS_select	93
+#define	SYS_fsync	95
+#define	SYS_setpriority	96
+#define	SYS_socket	97
+#define	SYS_connect	98
+				/* 99 is old accept */
+#define	SYS_getpriority	100
+				/* 101 is old send */
+				/* 102 is old recv */
+				/* 103 is old sigreturn */
+#define	SYS_bind	104
+#define	SYS_setsockopt	105
+#define	SYS_listen	106
+				/* 107 is obsolete vtimes */
+				/* 108 is old sigvec */
+				/* 109 is old sigblock */
+				/* 110 is old sigsetmask */
+				/* 111 is old sigsuspend */
+				/* 112 is old sigstack */
+				/* 113 is old recvmsg */
+				/* 114 is old sendmsg */
+				/* 115 is obsolete vtrace */
+#define	SYS_gettimeofday	116
+#define	SYS_getrusage	117
+#define	SYS_getsockopt	118
+#define	SYS_readv	120
+#define	SYS_writev	121
+#define	SYS_settimeofday	122
+#define	SYS_fchown	123
+#define	SYS_fchmod	124
+				/* 125 is old recvfrom */
+#define	SYS_setreuid	126
+#define	SYS_setregid	127
+#define	SYS_rename	128
+				/* 129 is old truncate */
+				/* 130 is old ftruncate */
+#define	SYS_flock	131
+#define	SYS_mkfifo	132
+#define	SYS_sendto	133
+#define	SYS_shutdown	134
+#define	SYS_socketpair	135
+#define	SYS_mkdir	136
+#define	SYS_rmdir	137
+#define	SYS_utimes	138
+				/* 139 is obsolete 4.2 sigreturn */
+#define	SYS_adjtime	140
+				/* 141 is old getpeername */
+				/* 142 is old gethostid */
+				/* 143 is old sethostid */
+				/* 144 is old getrlimit */
+				/* 145 is old setrlimit */
+				/* 146 is old killpg */
+#define	SYS_setsid	147
+#define	SYS_quotactl	148
+				/* 149 is old quota */
+				/* 150 is old getsockname */
+#define	SYS_nfssvc	155
+				/* 156 is old getdirentries */
+#define	SYS_freebsd4_statfs	157
+#define	SYS_freebsd4_fstatfs	158
+#define	SYS_lgetfh	160
+#define	SYS_getfh	161
+#define	SYS_getdomainname	162
+#define	SYS_setdomainname	163
+#define	SYS_uname	164
+#define	SYS_sysarch	165
+#define	SYS_rtprio	166
+#define	SYS_semsys	169
+#define	SYS_msgsys	170
+#define	SYS_shmsys	171
+#define	SYS_freebsd6_pread	173
+#define	SYS_freebsd6_pwrite	174
+#define	SYS_ntp_adjtime	176
+#define	SYS_setgid	181
+#define	SYS_setegid	182
+#define	SYS_seteuid	183
+#define	SYS_stat	188
+#define	SYS_fstat	189
+#define	SYS_lstat	190
+#define	SYS_pathconf	191
+#define	SYS_fpathconf	192
+#define	SYS_getrlimit	194
+#define	SYS_setrlimit	195
+#define	SYS_getdirentries	196
+#define	SYS_freebsd6_mmap	197
+#define	SYS___syscall	198
+#define	SYS_freebsd6_lseek	199
+#define	SYS_freebsd6_truncate	200
+#define	SYS_freebsd6_ftruncate	201
+#define	SYS_sysctl	202
+#define	SYS_mlock	203
+#define	SYS_munlock	204
+#define	SYS_undelete	205
+#define	SYS_futimes	206
+#define	SYS_getpgid	207
+#define	SYS_poll	209
+#define	SYS_semctl	220
+#define	SYS_semget	221
+#define	SYS_semop	222
+#define	SYS_msgctl	224
+#define	SYS_msgget	225
+#define	SYS_msgsnd	226
+#define	SYS_msgrcv	227
+#define	SYS_shmat	228
+#define	SYS_shmctl	229
+#define	SYS_shmdt	230
+#define	SYS_shmget	231
+#define	SYS_clock_gettime	232
+#define	SYS_clock_settime	233
+#define	SYS_clock_getres	234
+#define	SYS_ktimer_create	235
+#define	SYS_ktimer_delete	236
+#define	SYS_ktimer_settime	237
+#define	SYS_ktimer_gettime	238
+#define	SYS_ktimer_getoverrun	239
+#define	SYS_nanosleep	240
+#define	SYS_ntp_gettime	248
+#define	SYS_minherit	250
+#define	SYS_rfork	251
+#define	SYS_openbsd_poll	252
+#define	SYS_issetugid	253
+#define	SYS_lchown	254
+#define	SYS_aio_read	255
+#define	SYS_aio_write	256
+#define	SYS_lio_listio	257
+#define	SYS_getdents	272
+#define	SYS_lchmod	274
+#define	SYS_netbsd_lchown	275
+#define	SYS_lutimes	276
+#define	SYS_netbsd_msync	277
+#define	SYS_nstat	278
+#define	SYS_nfstat	279
+#define	SYS_nlstat	280
+#define	SYS_preadv	289
+#define	SYS_pwritev	290
+#define	SYS_freebsd4_fhstatfs	297
+#define	SYS_fhopen	298
+#define	SYS_fhstat	299
+#define	SYS_modnext	300
+#define	SYS_modstat	301
+#define	SYS_modfnext	302
+#define	SYS_modfind	303
+#define	SYS_kldload	304
+#define	SYS_kldunload	305
+#define	SYS_kldfind	306
+#define	SYS_kldnext	307
+#define	SYS_kldstat	308
+#define	SYS_kldfirstmod	309
+#define	SYS_getsid	310
+#define	SYS_setresuid	311
+#define	SYS_setresgid	312
+				/* 313 is obsolete signanosleep */
+#define	SYS_aio_return	314
+#define	SYS_aio_suspend	315
+#define	SYS_aio_cancel	316
+#define	SYS_aio_error	317
+#define	SYS_oaio_read	318
+#define	SYS_oaio_write	319
+#define	SYS_olio_listio	320
+#define	SYS_yield	321
+				/* 322 is obsolete thr_sleep */
+				/* 323 is obsolete thr_wakeup */
+#define	SYS_mlockall	324
+#define	SYS_munlockall	325
+#define	SYS_getcwd	326
+#define	SYS_sched_setparam	327
+#define	SYS_sched_getparam	328
+#define	SYS_sched_setscheduler	329
+#define	SYS_sched_getscheduler	330
+#define	SYS_sched_yield	331
+#define	SYS_sched_get_priority_max	332
+#define	SYS_sched_get_priority_min	333
+#define	SYS_sched_rr_get_interval	334
+#define	SYS_utrace	335
+#define	SYS_freebsd4_sendfile	336
+#define	SYS_kldsym	337
+#define	SYS_jail	338
+#define	SYS_sigprocmask	340
+#define	SYS_sigsuspend	341
+#define	SYS_freebsd4_sigaction	342
+#define	SYS_sigpending	343
+#define	SYS_freebsd4_sigreturn	344
+#define	SYS_sigtimedwait	345
+#define	SYS_sigwaitinfo	346
+#define	SYS_acl_get_file	347
+#define	SYS_acl_set_file	348
+#define	SYS_acl_get_fd	349
+#define	SYS_acl_set_fd	350
+#define	SYS_acl_delete_file	351
+#define	SYS_acl_delete_fd	352
+#define	SYS_acl_aclcheck_file	353
+#define	SYS_acl_aclcheck_fd	354
+#define	SYS_extattrctl	355
+#define	SYS_extattr_set_file	356
+#define	SYS_extattr_get_file	357
+#define	SYS_extattr_delete_file	358
+#define	SYS_aio_waitcomplete	359
+#define	SYS_getresuid	360
+#define	SYS_getresgid	361
+#define	SYS_kqueue	362
+#define	SYS_kevent	363
+#define	SYS_extattr_set_fd	371
+#define	SYS_extattr_get_fd	372
+#define	SYS_extattr_delete_fd	373
+#define	SYS_setugid	374
+#define	SYS_nfsclnt	375
+#define	SYS_eaccess	376
+#define	SYS_nmount	378
+#define	SYS_kse_exit	379
+#define	SYS_kse_wakeup	380
+#define	SYS_kse_create	381
+#define	SYS_kse_thr_interrupt	382
+#define	SYS_kse_release	383
+#define	SYS_mac_get_proc	384
+#define	SYS_mac_set_proc	385
+#define	SYS_mac_get_fd	386
+#define	SYS_mac_get_file	387
+#define	SYS_mac_set_fd	388
+#define	SYS_mac_set_file	389
+#define	SYS_kenv	390
+#define	SYS_lchflags	391
+#define	SYS_uuidgen	392
+#define	SYS_sendfile	393
+#define	SYS_mac_syscall	394
+#define	SYS_getfsstat	395
+#define	SYS_statfs	396
+#define	SYS_fstatfs	397
+#define	SYS_fhstatfs	398
+#define	SYS_ksem_close	400
+#define	SYS_ksem_post	401
+#define	SYS_ksem_wait	402
+#define	SYS_ksem_trywait	403
+#define	SYS_ksem_init	404
+#define	SYS_ksem_open	405
+#define	SYS_ksem_unlink	406
+#define	SYS_ksem_getvalue	407
+#define	SYS_ksem_destroy	408
+#define	SYS_mac_get_pid	409
+#define	SYS_mac_get_link	410
+#define	SYS_mac_set_link	411
+#define	SYS_extattr_set_link	412
+#define	SYS_extattr_get_link	413
+#define	SYS_extattr_delete_link	414
+#define	SYS_mac_execve	415
+#define	SYS_sigaction	416
+#define	SYS_sigreturn	417
+#define	SYS_getcontext	421
+#define	SYS_setcontext	422
+#define	SYS_swapcontext	423
+#define	SYS_swapoff	424
+#define	SYS_acl_get_link	425
+#define	SYS_acl_set_link	426
+#define	SYS_acl_delete_link	427
+#define	SYS_acl_aclcheck_link	428
+#define	SYS_sigwait	429
+#define	SYS_thr_create	430
+#define	SYS_thr_exit	431
+#define	SYS_thr_self	432
+#define	SYS_thr_kill	433
+#define	SYS__umtx_lock	434
+#define	SYS__umtx_unlock	435
+#define	SYS_jail_attach	436
+#define	SYS_extattr_list_fd	437
+#define	SYS_extattr_list_file	438
+#define	SYS_extattr_list_link	439
+#define	SYS_kse_switchin	440
+#define	SYS_ksem_timedwait	441
+#define	SYS_thr_suspend	442
+#define	SYS_thr_wake	443
+#define	SYS_kldunloadf	444
+#define	SYS_audit	445
+#define	SYS_auditon	446
+#define	SYS_getauid	447
+#define	SYS_setauid	448
+#define	SYS_getaudit	449
+#define	SYS_setaudit	450
+#define	SYS_getaudit_addr	451
+#define	SYS_setaudit_addr	452
+#define	SYS_auditctl	453
+#define	SYS__umtx_op	454
+#define	SYS_thr_new	455
+#define	SYS_sigqueue	456
+#define	SYS_kmq_open	457
+#define	SYS_kmq_setattr	458
+#define	SYS_kmq_timedreceive	459
+#define	SYS_kmq_timedsend	460
+#define	SYS_kmq_notify	461
+#define	SYS_kmq_unlink	462
+#define	SYS_abort2	463
+#define	SYS_thr_set_name	464
+#define	SYS_aio_fsync	465
+#define	SYS_rtprio_thread	466
+#define	SYS_sctp_peeloff	471
+#define	SYS_sctp_generic_sendmsg	472
+#define	SYS_sctp_generic_sendmsg_iov	473
+#define	SYS_sctp_generic_recvmsg	474
+#define	SYS_pread	475
+#define	SYS_pwrite	476
+#define	SYS_mmap	477
+#define	SYS_lseek	478
+#define	SYS_truncate	479
+#define	SYS_ftruncate	480
+#define	SYS_thr_kill2	481
+#define	SYS_MAXSYSCALL	482
+
+#endif
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/sys/sysmacros.h
@@ -0,0 +1,36 @@
+/* Definitions of macros to access `dev_t' values.  FreeBSD version.
+   Copyright (C) 1996-1997, 1999, 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _SYS_SYSMACROS_H
+#define _SYS_SYSMACROS_H	1
+
+/* For compatibility we provide alternative names.
+
+   The problem here is that compilers other than GCC probably don't
+   have the `long long' type and so `dev_t' is actually an array.  */
+#define major(dev) ((int)(((unsigned int) (dev) >> 8) & 0xff))
+#define minor(dev) ((int)((dev) & 0xffff00ff))
+#define makedev(major, minor) (((major) << 8) | (minor))
+
+/* Access the functions with their new names.  */
+#define gnu_dev_major(dev) major (dev)
+#define gnu_dev_minor(dev) minor (dev)
+#define gnu_dev_makedev(maj, min) makedev (maj, min)
+
+#endif /* sys/sysmacros.h */
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/sys/ttydefaults.h
@@ -0,0 +1,97 @@
+/*-
+ * Copyright (c) 1982, 1986, 1993
+ *	The Regents of the University of California.  All rights reserved.
+ * (c) UNIX System Laboratories, Inc.
+ * All or some portions of this file are derived from material licensed
+ * to the University of California by American Telephone and Telegraph
+ * Co. or Unix System Laboratories, Inc. and are reproduced herein with
+ * the permission of UNIX System Laboratories, Inc.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 4. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ *	@(#)ttydefaults.h	8.4 (Berkeley) 1/21/94
+ */
+
+/*
+ * System wide defaults for terminal state.  FreeBSD version.
+ */
+#ifndef _SYS_TTYDEFAULTS_H_
+#define _SYS_TTYDEFAULTS_H_
+
+/*
+ * Defaults on "first" open.
+ */
+#define TTYDEF_IFLAG	(BRKINT | ICRNL | IMAXBEL | IXON | IXANY)
+#define TTYDEF_OFLAG	(OPOST | ONLCR)
+#define TTYDEF_LFLAG	(ECHO | ICANON | ISIG | IEXTEN | ECHOE|ECHOKE|ECHOCTL)
+#define TTYDEF_CFLAG	(CREAD | CS8 | HUPCL)
+#define TTYDEF_SPEED	(B9600)
+
+/*
+ * Control Character Defaults
+ */
+#define CTRL(x)	(x&037)
+#define CEOF		CTRL('d')
+#ifdef _POSIX_VDISABLE
+# define CEOL		_POSIX_VDISABLE
+#else
+# define CEOL		((unsigned char)'\377')	/* XXX avoid _POSIX_VDISABLE */
+#endif
+#define CERASE		0177
+#define CERASE2		CTRL('h')
+#define CINTR		CTRL('c')
+#define CSTATUS		CTRL('t')
+#define CKILL		CTRL('u')
+#define CMIN		1
+#define CQUIT		034		/* FS, ^\ */
+#define CSUSP		CTRL('z')
+#define CTIME		0
+#define CDSUSP		CTRL('y')
+#define CSTART		CTRL('q')
+#define CSTOP		CTRL('s')
+#define CLNEXT		CTRL('v')
+#define CDISCARD 	CTRL('o')
+#define CWERASE 	CTRL('w')
+#define CREPRINT 	CTRL('r')
+#define CEOT		CEOF
+/* compat */
+#define CBRK		CEOL
+#define CRPRNT		CREPRINT
+#define CFLUSH		CDISCARD
+
+/* PROTECTED INCLUSION ENDS HERE */
+#endif /* !_SYS_TTYDEFAULTS_H_ */
+
+/*
+ * #define TTYDEFCHARS to include an array of default control characters.
+ */
+#ifdef TTYDEFCHARS
+cc_t	ttydefchars[NCCS] = {
+	CEOF,	CEOL,	CEOL,	CERASE, CWERASE, CKILL, CREPRINT,
+	CERASE2, CINTR,	CQUIT,	CSUSP,	CDSUSP,	CSTART,	CSTOP,	CLNEXT,
+	CDISCARD, CMIN,	CTIME,  CSTATUS, _POSIX_VDISABLE
+};
+#undef TTYDEFCHARS
+#endif
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/sys/ucontext.h
@@ -0,0 +1,48 @@
+/* Data structures for user-level context switching.  Generic version.
+   Copyright (C) 1997-1999, 2001-2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+/* This file's definitions suffice for any platform where all
+   the machine-specific state is described in `struct sigcontext'.  */
+
+#ifndef _SYS_UCONTEXT_H
+#define _SYS_UCONTEXT_H	1
+
+#include <features.h>
+#include <signal.h>
+
+/* We need the signal context definitions even if they are not used
+   included in <signal.h>.  */
+#include <bits/sigcontext.h>
+
+/* This include file defines the type 'mcontext_t'.  */
+#include <bits/mcontext.h>
+
+/* Userlevel context.  */
+typedef struct ucontext
+  {
+    __sigset_t uc_sigmask;
+    mcontext_t uc_mcontext;
+    struct ucontext *uc_link;
+    stack_t uc_stack;
+    int     uc_flags;
+#define UCF_SWAPPED     0x00000001      /* Used by swapcontext(3). */
+    int __unused1[4];
+  } ucontext_t;
+
+#endif /* sys/ucontext.h */
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/syscalls-inline.h
@@ -0,0 +1,54 @@
+/* prototypes of generally used "inline syscalls"
+   Copyright (C) 2006 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef KFREEBSD_INLINE_SYSCALLS_H
+#define KFREEBSD_INLINE_SYSCALLS_H
+
+#include <sys/types.h>
+#define __need_sigset_t
+#include <signal.h>
+
+struct iovec;
+struct rusage;
+struct timespec;
+
+int __syscall_open(const char *path, int flags, ...);
+int __syscall_close(int fd);
+libc_hidden_proto (__syscall_open)
+libc_hidden_proto (__syscall_close)
+
+ssize_t __syscall_read(int fd, void *buf, size_t nbyte);
+ssize_t __syscall_write(int fd, const void *buf, size_t nbyte);
+ssize_t __syscall_writev(int fd, const struct iovec *iovp, int iovcnt);
+libc_hidden_proto (__syscall_read)
+libc_hidden_proto (__syscall_write)
+libc_hidden_proto (__syscall_writev)
+
+int __syscall_fcntl(int fd, int cmd, ...);
+int __syscall_fork(void);
+int __syscall_wait4(int pid, int *status, int options, struct rusage *rusage);
+int __syscall_sigsuspend (const sigset_t *set);
+int __syscall_nanosleep (const struct timespec *requested_time, struct timespec *remaining);
+libc_hidden_proto (__syscall_fcntl)
+libc_hidden_proto (__syscall_fork)
+libc_hidden_proto (__syscall_wait4)
+libc_hidden_proto (__syscall_sigsuspend)
+libc_hidden_proto (__syscall_nanosleep)
+
+#endif
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/syscalls.list
@@ -0,0 +1,157 @@
+# File name	Caller	Syscall name		# args	Strong name	Weak names
+
+acl_aclcheck_fd	-	acl_aclcheck_fd		i:iip	__acl_aclcheck_fd
+acl_aclcheck_file -	acl_aclcheck_file	i:sip	__acl_aclcheck_file
+acl_delete_fd	-	acl_delete_fd		i:ii	__acl_delete_fd
+acl_delete_file	-	acl_delete_file		i:si	__acl_delete_file
+acl_get_fd	-	acl_get_fd		i:iip	__acl_get_fd
+acl_get_file	-	acl_get_file		i:sip	__acl_get_file
+acl_set_fd	-	acl_set_fd		i:iip	__acl_set_fd
+acl_set_file	-	acl_set_file		i:sip	__acl_set_file
+sys_aio_cancel	-	aio_cancel		i:ip	__syscall_aio_cancel
+sys_aio_error	-	aio_error		i:p	__syscall_aio_error
+sys_aio_read	-	aio_read		i:p	__syscall_aio_read
+sys_aio_return	-	aio_return		i:p	__syscall_aio_return
+sys_aio_suspend	-	aio_suspend		i:bnP	__syscall_aio_suspend
+sys_aio_waitcomplete -	aio_waitcomplete	i:pp	__syscall_aio_waitcomplete
+sys_aio_write	-	aio_write		i:p	__syscall_aio_write
+sys_clock_getres -	clock_getres		i:ip	__syscall_clock_getres
+sys_clock_gettime -	clock_gettime		i:ip	__syscall_clock_gettime
+sys_clock_settime -	clock_settime		i:ip	__syscall_clock_settime
+sys_execve	-	execve			i:ppp	__syscall_execve
+extattrctl	-	extattrctl		i:sisI	extattrctl
+extattr_delete_file -	extattr_delete_file	i:ss	extattr_delete_file
+extattr_get_file -	extattr_get_file	i:ssbn	extattr_get_file
+extattr_set_file -	extattr_set_file	i:ssbn	extattr_set_file
+fhopen		-	fhopen			i:pi	fhopen
+sys_fork	-	fork			i:	__syscall_fork fork
+sys_fhstat	-	fhstat			i:pp	__syscall_fhstat
+sys_getfsstat	-	getfsstat		i:pii	__syscall_getfsstat
+sys_statfs	-	statfs			i:sp	__syscall_statfs
+sys_fstatfs	-	fstatfs			i:ip	__syscall_fstatfs
+sys_fhstatfs	-	fhstatfs		i:pp	__syscall_fhstatfs
+sys_fstat	-	fstat			i:ip	__syscall_fstat
+sys_ftruncate	-	freebsd6_ftruncate	i:iii	__syscall_freebsd6_ftruncate
+futimes		-	futimes			i:ip	__futimes	futimes
+sys_getcwd	-	getcwd			i:bn	__syscall_getcwd
+sys_getdents	-	getdents		i:ibn	__syscall_getdents
+sys_getdirentries -	getdirentries		i:ibnP	__syscall_getdirentries
+getfh		-	getfh			i:sp	getfh
+sys_getlogin	-	getlogin		i:bn	__syscall_getlogin
+getpgid		-	getpgid			i:i	__getpgid	__getpgid_internal getpgid
+getpgrp		-	getpgrp			i:	getpgrp
+getresgid	-	getresgid		i:ppp	getresgid
+getresuid	-	getresuid		i:ppp	getresuid
+getrlimit	-	getrlimit		i:ip	__getrlimit	getrlimit getrlimit64
+getsid		-	getsid			i:i	getsid
+issetugid	-	issetugid		i:	issetugid
+jail		-	jail			i:p	jail
+kldfind		-	kldfind			i:s	kldfind
+kldfirstmod	-	kldfirstmod		i:i	kldfirstmod
+kldload		-	kldload			i:s	kldload
+kldnext		-	kldnext			i:i	kldnext
+kldstat		-	kldstat			i:ip	kldstat
+kldsym		-	kldsym			i:iip	kldsym
+kldunload	-	kldunload		i:i	kldunload
+kldunloadf	-	kldunloadf		i:ii	kldunloadf
+ktrace		-	ktrace			i:siii	ktrace
+lchmod		-	lchmod			i:si	lchmod
+lchown		-	lchown			i:sii	__lchown	lchown
+sys_lio_listio	-	lio_listio		i:ibnP	__syscall_lio_listio
+sys_lseek	-	freebsd6_lseek		i:iiii	__syscall_freebsd6_lseek
+sys_lstat	-	lstat			i:sp	__syscall_lstat
+lutimes		-	lutimes			i:sp	__lutimes	lutimes
+posix_madvise	-	madvise			i:pii	posix_madvise
+minherit	-	minherit		i:aii	minherit
+mincore		-	mincore			i:anV	mincore
+mlock		-	mlock			i:bn	mlock
+mlockall	-	mlockall		i:i	mlockall
+mkfifo		-	mkfifo			i:si	__mkfifo	mkfifo
+sys_mknod	-	mknod			i:sii	__syscall_mknod
+sys_mmap	-	freebsd6_mmap		b:aniiiii __syscall_freebsd6_mmap
+sys_munmap	munmap	munmap			i:pi	__syscall_munmap
+modfind		-	modfind			i:s	modfind
+modfnext	-	modfnext		i:i	modfnext
+modnext		-	modnext			i:i	modnext
+modstat		-	modstat			i:ip	modstat
+mount		-	mount			i:ssiP	mount
+msgctl		-	msgctl			i:iip	msgctl
+msgget		-	msgget			i:ii	msgget
+msgrcv		-	msgrcv			Ci:ibnii	__libc_msgrcv	msgrcv
+msgsnd		-	msgsnd			Ci:ibni	__libc_msgsnd	msgsnd
+munlock		-	munlock			i:ai	munlock
+munlockall	-	munlockall		i:	munlockall
+nanosleep	-	nanosleep		Ci:pp	__libc_nanosleep __nanosleep nanosleep
+nmount		-	nmount			i:pii	nmount
+sys_nfstat	-	nfstat			i:ip	__syscall_nfstat
+sys_nlstat	-	nlstat			i:sp	__syscall_nlstat
+sys_nstat	-	nstat			i:sp	__syscall_nstat
+ntp_adjtime	-	ntp_adjtime		i:p	ntp_adjtime
+obreak		-	obreak			i:a	__syscall_obreak
+sys_open	-	open			i:siv	__syscall_open
+poll		-	poll			Ci:pii	__poll		poll
+sys_pread	-	freebsd6_pread		i:ibnii	__syscall_freebsd6_pread
+sys_ptrace	-	ptrace			i:iipi	__syscall_ptrace
+sys_pwrite	-	freebsd6_pwrite		i:ibnii	__syscall_freebsd6_pwrite
+quotactl	-	quotactl		i:siip	quotactl
+sys_readv	-	readv			i:ipi	__syscall_readv
+rfork		-	rfork			i:i	__rfork		rfork
+rtprio		-	rtprio			i:iip	__rtprio	rtprio
+sched_gets	-	sched_getscheduler	i:i	__sched_getscheduler sched_getscheduler
+sched_primax	-	sched_get_priority_max	i:i	__sched_get_priority_max sched_get_priority_max
+sched_primin	-	sched_get_priority_min	i:i	__sched_get_priority_min sched_get_priority_min
+sched_rr_gi	-	sched_rr_get_interval	i:ip	__sched_rr_get_interval sched_rr_get_interval
+sched_setp	-	sched_setparam		i:ip	__sched_setparam sched_setparam
+sched_sets	-	sched_setscheduler	i:iip	__sched_setscheduler sched_setscheduler
+sched_yield	-	sched_yield		i:	__sched_yield sched_yield
+semget		-	semget			i:iii	semget
+semop		-	semop			i:ipi	semop
+bsd_sendfile	-	sendfile		i:iiiippi bsd_sendfile
+setegid		-	setegid			i:i	setegid
+seteuid		-	seteuid			i:i	seteuid
+setgid		-	setgid			i:i	__setgid	setgid
+sys_setlogin	-	setlogin		i:s	__syscall_setlogin
+setpgid		-	setpgid			i:ii	__setpgid	setpgid
+setresgid	-	setresgid		i:iii	setresgid
+setresuid	-	setresuid		i:iii	setresuid
+setrlimit	-	setrlimit		i:ip	__setrlimit	setrlimit setrlimit64
+setsid		-	setsid			i:	__setsid	setsid
+setuid		-	setuid			i:i	__setuid	setuid
+shmat		-	shmat			i:iai	shmat
+shmctl		-	shmctl			i:iip	shmctl
+shmdt		-	shmdt			i:a	shmdt
+shmget		-	shmget			i:iii	shmget
+sys_sigaction	-	sigaction		i:ipp   __syscall_sigaction
+sigpending	-	sigpending		i:p	sigpending
+sigprocmask	-	sigprocmask		i:iPP	__sigprocmask	sigprocmask
+sigsuspend	-	sigsuspend		Ci:p	__sigsuspend	sigsuspend
+sigwaitinfo	-	sigwaitinfo		Ci:pp	__sigwaitinfo	sigwaitinfo
+sigtimedwait	-	sigtimedwait		Ci:ppP	__sigtimedwait	sigtimedwait
+sys_stat	-	stat			i:sp	__syscall_stat
+sysarch		-	sysarch			i:ip	__sysarch	sysarch
+sysctl		-	sysctl			i:pibNbn __sysctl	sysctl
+sys_truncate	-	freebsd6_truncate	i:sii	__syscall_freebsd6_truncate
+undelete	-	undelete		i:s	undelete
+unmount		-	unmount			i:si	unmount
+utrace		-	utrace			i:bn	utrace
+sys_writev	-	writev			i:ipi	__syscall_writev
+yield		-	yield			i:	__syscall_yield
+wait4		-       wait4                   i:iWiP  __syscall_wait4	__wait4	wait4
+sys_close      	-       close                   i:i     __syscall_close
+sys_fcntl       -       fcntl                   i:iiF   __syscall_fcntl
+sys_write       -       write                   i:ibn   __syscall_write
+sys_read        -       read                    i:ibn   __syscall_read
+sys_connect	-       connect	                i:ipi	__syscall_connect
+sys_bind        -       bind                    i:ipi   __syscall_bind
+sys_sendto      -       sendto          	i:ibnibn __syscall_sendto
+sys_nanosleep	EXTRA	nanosleep		i:pp	__syscall_nanosleep
+sys_sigsuspend	EXTRA	sigsuspend		i:p	__syscall_sigsuspend
+swapcontext	-	swapcontext		i:pp	__swapcontext	swapcontext
+swapon		-	swapon			i:s	swapon
+swapoff		-	swapoff			i:s	swapoff
+getcontext	-	getcontext		i:p	__getcontext	getcontext
+setcontext	-	setcontext		i:p	__setcontext	setcontext
+kqueue		EXTRA	kqueue			i:	__kqueue	kqueue
+kevent		EXTRA	kevent			i:ipipip	__kevent	kevent
+sys_umtx	-	_umtx_op		i:piipp	__syscall__umtx_op
+
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/sysconf.c
@@ -0,0 +1,50 @@
+/* Get file-specific information about a file.
+   Copyright (C) 2006 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <errno.h>
+#include <fcntl.h>
+#include <stdlib.h>
+#include <sysdep.h>
+#include <time.h>
+#include <unistd.h>
+#include <hp-timing.h>
+
+static long int posix_sysconf (int name);
+
+/* Get the value of the system variable NAME.  */
+long int
+__sysconf (int name)
+{
+  if (name == _SC_CPUTIME || name == _SC_THREAD_CPUTIME)
+    {
+#if HP_TIMING_AVAIL
+      // XXX We can add  here test for machines which cannot support a
+      // XXX usable TSC.
+      return 200112L;
+#else
+      return -1;
+#endif
+    }
+  return posix_sysconf (name);
+}
+
+/* Now the POSIX version.  */
+#undef __sysconf
+#define __sysconf static posix_sysconf
+#include <sysdeps/posix/sysconf.c>
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/sysctlbyname.c
@@ -0,0 +1,44 @@
+/* Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Bruno Haible <bruno@clisp.org>, 2002.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sys/sysctl.h>
+#include <string.h>
+
+/* Read or write system parameters.  */
+int
+__sysctlbyname (const char *name, void *oldval, size_t *oldlenp, void *newval, size_t newlen)
+{
+  int request[CTL_MAXNAME];
+  size_t requestlen = sizeof (request);
+
+  /* Convert the string NAME to a binary encoded request.  The kernel
+     contains a routine for doing this, called "name2oid".  But the way
+     to call it is a little bit strange.  */
+  int name2oid_request[2] = { 0, 3 };
+  if (__sysctl (name2oid_request, 2, request, &requestlen,
+		(void *) name, strlen (name))
+      < 0)
+    return -1;
+
+  /* Now call sysctl using the binary encoded request.  */
+  return __sysctl (request, requestlen / sizeof (int),
+		   oldval, oldlenp, newval, newlen);
+}
+
+weak_alias (__sysctlbyname, sysctlbyname)
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/tcdrain.c
@@ -0,0 +1,41 @@
+/* Copyright (C) 1995, 1996, 1997, 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <errno.h>
+#include <termios.h>
+#include <sys/ioctl.h>
+#include <sysdep-cancel.h>
+#include <stddef.h>
+
+/* Wait for pending output to be written on FD.  */
+int
+__libc_tcdrain (int fd)
+{
+  if (SINGLE_THREAD_P)
+    return __ioctl (fd, TIOCDRAIN);
+
+  int oldtype = LIBC_CANCEL_ASYNC ();
+
+  int result = __ioctl (fd, TIOCDRAIN);
+
+  LIBC_CANCEL_RESET (oldtype);
+
+  return result;
+}
+weak_alias (__libc_tcdrain, tcdrain)
+
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/tcflow.c
@@ -0,0 +1,4 @@
+/* just use internal functions */
+#define tcgetattr __tcgetattr
+#define write __write
+#include <sysdeps/unix/bsd/tcflow.c>
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/telldir.c
@@ -0,0 +1,2 @@
+/* Avoid <sysdeps/unix/bsd/telldir.c>, which doesn't pass the testsuite.  */
+#include <sysdeps/unix/telldir.c>
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/testrtsig.h
@@ -0,0 +1,44 @@
+/* Test whether RT signals are really available.
+   Copyright (C) 2008 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sys/sysctl.h>
+#include <errno.h>
+#include <string.h>
+
+#include <kernel-features.h>
+
+static int
+kernel_has_rtsig (void)
+{
+#if __ASSUME_REALTIME_SIGNALS
+  return 1;
+#else
+
+  int request[2] = { CTL_KERN, KERN_OSRELDATE};
+  size_t len;
+  int val;
+
+  len = sizeof (val);
+  if (__sysctl (request, 2, &val, &len, NULL, 0) < 0)
+      return 0;
+  if ( val < 700050) /* FreeBSD 7.0 is 700055 */
+      return 0;
+  return 1;
+#endif
+}
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/truncate.c
@@ -0,0 +1,41 @@
+/* Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Bruno Haible <bruno@clisp.org>, 2002.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <unistd.h>
+#include <sys/types.h>
+#include <sysdep.h>
+
+/* The real system call has a word of padding before the 64-bit off_t
+   argument.  */
+extern int __syscall_freebsd6_truncate (const char *__file, int __unused1,
+			       __off_t __length) __THROW;
+libc_hidden_proto (__syscall_freebsd6_truncate)
+
+int
+__truncate (const char *file, __off_t length)
+{
+  /* We pass 2 arguments in 4 words.  */
+  return INLINE_SYSCALL (freebsd6_truncate, 2, file, 0, length);
+}
+
+weak_alias (__truncate, truncate)
+
+/* 'truncate64' is the same as 'truncate', because __off64_t == __off_t.  */
+strong_alias (__truncate, __truncate64)
+weak_alias (__truncate64, truncate64)
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/truncate64.c
@@ -0,0 +1 @@
+/* 'truncate64' is the same as 'truncate', because __off64_t == __off_t.  */
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/ulimit.c
@@ -0,0 +1,2 @@
+/* just use linux variant */
+#include <sysdeps/unix/sysv/linux/ulimit.c>
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/uname.c
@@ -0,0 +1,110 @@
+/* Copyright (C) 2002, 2006 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Bruno Haible <bruno@clisp.org>.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sys/utsname.h>
+#include <sys/sysctl.h>
+#include <errno.h>
+#include <string.h>
+
+#define SYSNAME                "GNU/kFreeBSD"
+#define SYSNAME_LEN    13
+
+/* Check for bounds in pre-processor */
+#if SYSNAME_LEN > _UTSNAME_SYSNAME_LENGTH
+#error
+#endif
+
+/* Put information about the system in NAME.  */
+int
+__uname (struct utsname *name)
+{
+  int request[2] = { CTL_KERN };
+  size_t len;
+
+  /* Fill sysname: "uname -s". */
+  strcpy (name->sysname, SYSNAME);
+
+  /* Fill nodename: "uname -n".  Fetch sysctl "kern.hostname".  */
+  request[1] = KERN_HOSTNAME;
+  len = sizeof (name->nodename);
+  if (__sysctl (request, 2, name->nodename, &len, NULL, 0) >= 0)
+    {
+      if (len < sizeof (name->nodename))
+	name->nodename[len] = '\0';
+    }
+
+  /* Fill release: "uname -r".  Fetch sysctl "kern.osrelease".  */
+  request[1] = KERN_OSRELEASE;
+  len = sizeof (name->release);
+  if (__sysctl (request, 2, name->release, &len, NULL, 0) >= 0)
+    {
+      if (len < sizeof (name->release))
+        name->release[len] = '\0';
+    }
+
+  /* Fill version: "uname -v".  Fetch sysctl "kern.version".  */
+  request[1] = KERN_VERSION;
+  len = sizeof (name->version);
+  if (__sysctl (request, 2, name->version, &len, NULL, 0) >= 0)
+    {
+      if (len < sizeof (name->version))
+        name->version[len] = '\0';
+    }
+
+  /* Remove trailing whitespace.  Turn non-trailing whitespace to
+     spaces.  */
+  {
+    char *p0 = name->version;
+    char *p = p0 + __strnlen (p0, sizeof (name->version));
+
+    while (p > p0 && (p[-1] == '\t' || p[-1] == '\n' || p[-1] == ' '))
+      *--p = '\0';
+
+    while (p > p0)
+      {
+        --p;
+        if (*p == '\t' || *p == '\n')
+          *p = ' ';
+      }
+  }
+
+#ifdef __x86_64__
+  /* Check for bounds in pre-processor */
+# if 7 > _UTSNAME_MACHINE_LENGTH
+#  error
+# endif
+  /* Pristine FreeBSD kernel would return "amd64".  Avoid that.  */
+  strcpy (name->machine, "x86_64");
+#else
+  /* Fill machine: "uname -m".  Fetch sysctl "hw.machine".  */
+  request[0] = CTL_HW;
+  request[1] = HW_MACHINE;
+  len = sizeof (name->machine);
+  if (__sysctl (request, 2, name->machine, &len, NULL, 0) >= 0)
+    {
+      if (len < sizeof (name->machine))
+        name->machine[len] = '\0';
+    }
+#endif
+
+  return 0;
+}
+libc_hidden_def (__uname)
+weak_alias (__uname, uname)
+libc_hidden_def (uname)
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/unlockpt.c
@@ -0,0 +1,45 @@
+/* Copyright (C) 2007 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <errno.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <unistd.h>
+
+
+int
+__unlockpt (int fd)
+{
+  struct stat64 st;
+
+  /* there is no need/way to do unlocking of slave pseudo-terminal device,
+     just check whether fd might be valid master pseudo-terminal device */
+
+  if (__fxstat64 (_STAT_VER, fd, &st) < 0)
+    return -1;
+
+  if (!(S_ISCHR (st.st_mode)))
+  {
+    __set_errno (ENOTTY);
+    return -1;
+  }
+
+  return 0;
+}
+
+weak_alias (__unlockpt, unlockpt)
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/usleep.c
@@ -0,0 +1,50 @@
+/* Implementation of the BSD usleep function using nanosleep.
+   Copyright (C) 1996-1997, 1999, 2001-2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <time.h>
+#include <unistd.h>
+
+int
+usleep (useconds_t useconds)
+{
+  unsigned int sec;
+  unsigned int usec;
+  struct timespec ts;
+
+  /* POSIX:2001 says that useconds >= 1000000 is invalid; nevertheless let's
+     be forgiving.  */
+  if (__builtin_expect (useconds < 1000000, 1))
+    {
+      sec = 0;
+      usec = useconds;
+    }
+  else
+    {
+      sec = useconds / 1000000;
+      usec = useconds % 1000000;
+    }
+
+  ts.tv_sec = sec;
+  ts.tv_nsec = usec * 1000;	/* Multiply as 32-bit integers.  */
+
+  /* Note the usleep() is a cancellation point.  But since we call
+     nanosleep() which itself is a cancellation point we do not have
+     to do anything here.  */
+  return __nanosleep (&ts, NULL);
+}
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/ustat.c
@@ -0,0 +1,66 @@
+/* Return info on filesystem.
+   Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Bruno Haible <bruno@clisp.org>, 2002.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sys/ustat.h>
+#include <sys/mount.h>
+#include <sys/stat.h>
+#include <stdlib.h>
+#include <string.h>
+#include <errno.h>
+
+int
+ustat (dev_t dev, struct ustat *ubuf)
+{
+  int mntcount;
+  struct statfs *mntlist;
+
+  /* Search for the device among the f_mntfromname fields of all mounted
+     filesystems.  */
+  mntcount = __getmntinfo (&mntlist, 0);
+  if (mntcount == 0 && errno != 0)
+    return -1;
+  if (mntcount > 0)
+    {
+      int i;
+
+      for (i = 0; i < mntcount; i++)
+	{
+	  struct statfs *mnt = &mntlist[i];
+	  struct stat statbuf;
+
+	  if ((__strnlen (mnt->f_mntfromname, sizeof (mnt->f_mntfromname))
+	       < sizeof (mnt->f_mntfromname))
+	      && __xstat (_STAT_VER, mnt->f_mntfromname, &statbuf) >= 0
+	      && S_ISBLK (statbuf.st_mode)
+	      && statbuf.st_rdev == dev)
+	    {
+	      /* Found the device.  Now produce the result.  */
+	      memset (ubuf, '\0', sizeof (struct ustat));
+	      ubuf->f_tfree = mnt->f_bfree;
+	      ubuf->f_tinode = mnt->f_ffree;
+	      return 0;
+	    }
+	}
+    }
+
+  /* DEV is not among the mounted devices.  */
+  __set_errno (EINVAL);
+  return -1;
+}
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/utmp-compat/Makefile
@@ -0,0 +1,6 @@
+# Additional functions:
+
+ifeq ($(subdir),login)
+# For <utmpx.h>.
+sysdep_routines += utmpconv
+endif
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/utmp-compat/bits/utmp.h
@@ -0,0 +1,50 @@
+/* The `struct utmp' type, describing entries in the utmp file.  For FreeBSD.
+   Copyright (C) 1993, 1996-1997, 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _UTMP_H
+# error "Never include <bits/utmp.h> directly; use <utmp.h> instead."
+#endif
+
+#include <paths.h>
+#include <time.h>
+
+
+#define	UT_NAMESIZE	16
+#define	UT_LINESIZE	8
+#define	UT_HOSTSIZE	16
+
+
+struct lastlog
+  {
+    time_t ll_time;
+    char ll_line[UT_LINESIZE];
+    char ll_host[UT_HOSTSIZE];
+  };
+
+struct utmp
+  {
+    char ut_line[UT_LINESIZE];
+    char ut_user[UT_NAMESIZE];
+#define ut_name ut_user
+    char ut_host[UT_HOSTSIZE];
+    __time_t ut_time;
+  };
+
+
+#define _HAVE_UT_HOST 1		/* We have the ut_host field.  */
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/utmp-compat/getutmp.c
@@ -0,0 +1,31 @@
+/* Copyright (C) 1999, 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <utmpx.h>
+#include <utmp.h>
+#include <string.h>
+
+extern int __utmpx_to_utmp (const struct utmpx *, struct utmp *);
+
+/* Copy the information in UTMPX to UTMP. */
+void
+getutmp (const struct utmpx *utmpx, struct utmp *utmp)
+{
+  if (__utmpx_to_utmp (utmpx, utmp) < 0)
+    memset (utmp, '\0', sizeof (struct utmp));
+}
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/utmp-compat/getutmpx.c
@@ -0,0 +1,31 @@
+/* Copyright (C) 1999, 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <utmpx.h>
+#include <utmp.h>
+#include <string.h>
+
+extern int __utmp_to_utmpx (const struct utmp *, struct utmpx *);
+
+/* Copy the information in UTMP to UTMPX. */
+void
+getutmpx (const struct utmp *utmp, struct utmpx *utmpx)
+{
+  if (__utmp_to_utmpx (utmp, utmpx) < 0)
+    memset (utmpx, '\0', sizeof (struct utmpx));
+}
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/utmp-compat/getutxent.c
@@ -0,0 +1,46 @@
+/* Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Bruno Haible <bruno@clisp.org>, 2002.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <utmpx.h>
+#include <utmp.h>
+#include <stddef.h>
+
+extern int __utmp_to_utmpx (const struct utmp *, struct utmpx *);
+
+/* Static buffer to store the result.  */
+static struct utmpx buffer;
+
+struct utmpx *
+__getutxent (void)
+{
+  for (;;)
+    {
+      struct utmp *tmp = __getutent ();
+
+      if (tmp == NULL)
+	return NULL;
+
+      if (__utmp_to_utmpx (tmp, &buffer) >= 0)
+	return &buffer;
+
+      /* Skip entries that cannot be converted to utmpx.  */
+    }
+}
+
+weak_alias (__getutxent, getutxent)
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/utmp-compat/getutxid.c
@@ -0,0 +1,68 @@
+/* Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Bruno Haible <bruno@clisp.org>, 2002.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <utmpx.h>
+#include <stddef.h>
+#include <string.h>
+
+extern struct utmpx *__getutxent (void);
+
+struct utmpx *
+getutxid (const struct utmpx *id)
+{
+  switch (id->ut_type)
+    {
+    case INIT_PROCESS:
+    case LOGIN_PROCESS:
+    case USER_PROCESS:
+    case DEAD_PROCESS:
+      for (;;)
+	{
+	  struct utmpx *next = __getutxent ();
+
+	  if (next == NULL)
+	    return NULL;
+
+	  switch (next->ut_type)
+	    {
+	    case INIT_PROCESS:
+	    case LOGIN_PROCESS:
+	    case USER_PROCESS:
+	    case DEAD_PROCESS:
+	      if (strncmp (next->ut_id, id->ut_id, sizeof (id->ut_id)) == 0)
+		return next;
+	      break;
+	    default:
+	      break;
+	    }
+	}
+
+    default:
+      for (;;)
+	{
+	  struct utmpx *next = __getutxent ();
+
+	  if (next == NULL)
+	    return NULL;
+
+	  if (next->ut_type == id->ut_type)
+	    return next;
+	}
+    }
+}
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/utmp-compat/getutxline.c
@@ -0,0 +1,40 @@
+/* Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Bruno Haible <bruno@clisp.org>, 2002.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <utmpx.h>
+#include <stddef.h>
+#include <string.h>
+
+extern struct utmpx *__getutxent (void);
+
+struct utmpx *
+getutxline (const struct utmpx *line)
+{
+  for (;;)
+    {
+      struct utmpx *next = __getutxent ();
+
+      if (next == NULL)
+	return NULL;
+
+      if ((next->ut_type == LOGIN_PROCESS || next->ut_type == USER_PROCESS)
+	  && strncmp (next->ut_line, line->ut_line, __UT_LINESIZE) == 0)
+	return next;
+    }
+}
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/utmp-compat/pututxline.c
@@ -0,0 +1,50 @@
+/* Copyright (C) 1998, 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <utmpx.h>
+#include <utmp.h>
+#include <stddef.h>
+#include <string.h>
+
+extern int __utmp_to_utmpx (const struct utmp *, struct utmpx *);
+extern int __utmpx_to_utmp (const struct utmpx *, struct utmp *);
+
+/* Static buffer to store the result.  */
+static struct utmpx buffer;
+
+struct utmpx *
+pututxline (const struct utmpx *utmpx)
+{
+  struct utmp tmp;
+
+  if (__utmpx_to_utmp (utmpx, &tmp) >= 0)
+    {
+      struct utmp *tmpres = __pututline (&tmp);
+
+      if (tmpres != NULL)
+	{
+	  if (__utmp_to_utmpx (tmpres, &buffer) >= 0)
+	    return &buffer;
+
+	  /* Hmm.  We wrote a 'struct utmp' that we cannot convert back
+	     to 'struct utmpx'.  Shouldn't happen that often.  */
+	  return NULL;
+	}
+    }
+  return NULL;
+}
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/utmp-compat/updwtmpx.c
@@ -0,0 +1,31 @@
+/* Copyright (C) 1998, 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <utmpx.h>
+#include <utmp.h>
+
+extern int __utmpx_to_utmp (const struct utmpx *, struct utmp *);
+
+void
+updwtmpx (const char *wtmpx_file, const struct utmpx *utmpx)
+{
+  struct utmp tmp;
+
+  if (__utmpx_to_utmp (utmpx, &tmp) >= 0)
+    __updwtmp (wtmpx_file, &tmp);
+}
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/utmp-compat/utmp-equal.h
@@ -0,0 +1,50 @@
+/* Copyright (C) 1996-1999,2000-2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <string.h>
+#include <utmp.h>
+
+#include <utmp-private.h>
+
+/* Test whether two entries match.  */
+static int
+__utmp_equal (const struct utmp *entry, const struct utmp *match)
+{
+  /* This implementation is consistent with the __utmp_to_utmpx function.  */
+  return
+    (!((entry->ut_line[0] == '\0' && entry->ut_name[0] == '\0'
+	&& entry->ut_host[0] == '\0')
+       || ((entry->ut_line[0] == '~' || entry->ut_line[0] == '{'
+	    || entry->ut_line[0] == '|')
+	   && entry->ut_line[1] == '\0'))
+     &&
+     !((match->ut_line[0] == '\0' && match->ut_name[0] == '\0'
+	&& match->ut_host[0] == '\0')
+       || ((match->ut_line[0] == '~' || match->ut_line[0] == '{'
+	    || match->ut_line[0] == '|')
+	   && match->ut_line[1] == '\0'))
+     &&
+#if _HAVE_UT_ID - 0
+     (entry->ut_id[0] && match->ut_id[0]
+      ? strncmp (entry->ut_id, match->ut_id, sizeof match->ut_id) == 0
+      : strncmp (entry->ut_line, match->ut_line, sizeof match->ut_line) == 0)
+#else
+     strncmp (entry->ut_line, match->ut_line, sizeof match->ut_line) == 0
+#endif
+     );
+}
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/utmp-compat/utmp_file.c
@@ -0,0 +1 @@
+#include <login/utmp_file.c>
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/utmp-compat/utmpconv.c
@@ -0,0 +1,227 @@
+/* Convert between 'struct utmp' and 'struct utmx'.
+   Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Bruno Haible <bruno@clisp.org>, 2002.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+/* We reuse the 'struct utmp' file format also for 'struct utmpx' records.
+   The mapping from 'struct utmp' to 'struct utmpx' is injective; the
+   reverse mapping succeeds only when common conventions are respected.  */
+
+#include <utmp.h>
+#include <utmpx.h>
+#include <string.h>
+#include <stdlib.h>
+#include <stdio.h>
+
+/* Compare two 'struct utmpx' records.  */
+int
+__utmpx_equal (const struct utmpx *u1, const struct utmpx *u2)
+{
+  return (u1->ut_type == u2->ut_type)
+	 && (u1->ut_pid == u2->ut_pid)
+	 && (strncmp (u1->ut_line, u2->ut_line, __UT_LINESIZE) == 0)
+	 && (strncmp (u1->ut_id, u2->ut_id, sizeof (u1->ut_id)) == 0)
+	 && (strncmp (u1->ut_user, u2->ut_user, __UT_NAMESIZE) == 0)
+	 && (strncmp (u1->ut_host, u2->ut_host, __UT_HOSTSIZE) == 0)
+	 && (u1->ut_exit.e_termination == u2->ut_exit.e_termination)
+	 && (u1->ut_exit.e_exit == u2->ut_exit.e_exit)
+	 && (u1->ut_session == u2->ut_session)
+	 && (u1->ut_tv.tv_sec == u2->ut_tv.tv_sec)
+	 && (u1->ut_tv.tv_usec == u2->ut_tv.tv_usec)
+	 && (memcmp (u1->ut_addr_v6, u2->ut_addr_v6, sizeof (u1->ut_addr_v6))
+	     == 0);
+}
+
+int
+__utmp_to_utmpx (const struct utmp *u, struct utmpx *ux)
+{
+  memset (ux, '\0', sizeof (struct utmpx));
+
+  if (u->ut_line[0] == '\0' && u->ut_name[0] == '\0' && u->ut_host[0] == '\0')
+    {
+      ux->ut_type = EMPTY;
+    }
+  else
+    {
+      if (u->ut_line[0] == '~' && u->ut_line[1] == '\0')
+	{
+	  if (strncmp (u->ut_name, "runlevel", UT_NAMESIZE) == 0)
+	    ux->ut_type = RUN_LVL;
+	  else if (strncmp (u->ut_name, "reboot", UT_NAMESIZE) == 0)
+	    ux->ut_type = BOOT_TIME;
+	  else if (strncmp (u->ut_name, "acct", UT_NAMESIZE) == 0)
+	    ux->ut_type = ACCOUNTING;
+	  else
+	    return -1;
+	}
+      else if (u->ut_line[0] == '{' && u->ut_line[1] == '\0')
+	{
+	  if (strncmp (u->ut_name, "date", UT_NAMESIZE) == 0)
+	    ux->ut_type = NEW_TIME;
+	  else
+	    return -1;
+	}
+      else if (u->ut_line[0] == '|' && u->ut_line[1] == '\0')
+	{
+	  if (strncmp (u->ut_name, "date", UT_NAMESIZE) == 0)
+	    ux->ut_type = OLD_TIME;
+	  else
+	    return -1;
+	}
+      else
+	{
+	  if (strncmp (u->ut_name, "INIT", UT_NAMESIZE) == 0)
+	    ux->ut_type = INIT_PROCESS;
+	  else if (strncmp (u->ut_name, "LOGIN", UT_NAMESIZE) == 0)
+	    ux->ut_type = LOGIN_PROCESS;
+	  else if (strncmp (u->ut_name, "", UT_NAMESIZE) == 0)
+	    ux->ut_type = DEAD_PROCESS;
+	  else
+	    ux->ut_type = USER_PROCESS;
+
+	  if (ux->ut_type == LOGIN_PROCESS || ux->ut_type == USER_PROCESS)
+	    strncpy (ux->ut_user, u->ut_name, UT_NAMESIZE);
+
+	  if (strncmp (u->ut_line, "tty", 3) == 0)
+	    {
+	      strncpy (ux->ut_line, u->ut_line, UT_LINESIZE);
+	      strncpy (ux->ut_id, u->ut_line + 3, sizeof (ux->ut_id));
+	    }
+	  else
+	    {
+	      strncpy (ux->ut_id, u->ut_line, sizeof (ux->ut_id));
+	    }
+	}
+
+      strncpy (ux->ut_host, u->ut_host, UT_HOSTSIZE);
+
+      /* Hack: Recover the ut_pid from the hidden place after the host.  */
+      if (__strnlen (u->ut_host, UT_HOSTSIZE) < UT_HOSTSIZE - 2)
+	{
+	  const char *hidden = u->ut_host + strlen (u->ut_host) + 1;
+
+	  if (hidden[0] != '\0')
+	    {
+	      size_t n = UT_HOSTSIZE - strlen (u->ut_host) - 1;
+	      char buf[UT_HOSTSIZE];
+	      unsigned long pid;
+	      char *endp;
+
+	      strncpy (buf, hidden, n);
+	      buf[n] = '\0';
+
+	      pid = strtoul (buf, &endp, 10);
+	      if (endp != buf && *endp == '\0')
+		ux->ut_pid = pid;
+	    }
+	}
+
+      ux->ut_tv.tv_sec = u->ut_time;
+      ux->ut_tv.tv_usec = 0;
+    }
+
+  return 0;
+}
+
+int
+__utmpx_to_utmp (const struct utmpx *ux, struct utmp *u)
+{
+  char buf[10+1];
+
+  switch (ux->ut_type)
+    {
+    case EMPTY:
+      strncpy (u->ut_line, "", UT_LINESIZE);
+      strncpy (u->ut_name, "", UT_NAMESIZE);
+      strncpy (u->ut_host, "", UT_HOSTSIZE);
+      break;
+
+    case RUN_LVL:
+      strncpy (u->ut_line, "~", UT_LINESIZE);
+      strncpy (u->ut_name, "runlevel", UT_NAMESIZE);
+      strncpy (u->ut_host, ux->ut_host, UT_HOSTSIZE);
+      break;
+
+    case BOOT_TIME:
+      strncpy (u->ut_line, "~", UT_LINESIZE);
+      strncpy (u->ut_name, "reboot", UT_NAMESIZE);
+      strncpy (u->ut_host, ux->ut_host, UT_HOSTSIZE);
+      break;
+
+    case NEW_TIME:
+      strncpy (u->ut_line, "{", UT_LINESIZE);
+      strncpy (u->ut_name, "date", UT_NAMESIZE);
+      strncpy (u->ut_host, ux->ut_host, UT_HOSTSIZE);
+      break;
+
+    case OLD_TIME:
+      strncpy (u->ut_line, "|", UT_LINESIZE);
+      strncpy (u->ut_name, "date", UT_NAMESIZE);
+      strncpy (u->ut_host, ux->ut_host, UT_HOSTSIZE);
+      break;
+
+    case INIT_PROCESS:
+    case LOGIN_PROCESS:
+    case USER_PROCESS:
+    case DEAD_PROCESS:
+      if (ux->ut_line[0] != '\0')
+	strncpy (u->ut_line, ux->ut_line, UT_LINESIZE);
+      else
+	strncpy (u->ut_line, ux->ut_id, sizeof (ux->ut_id));
+      switch (ux->ut_type)
+	{
+	case INIT_PROCESS:
+	  strncpy (u->ut_name, "INIT", UT_NAMESIZE);
+	  break;
+	case LOGIN_PROCESS:
+	  strncpy (u->ut_name, "LOGIN", UT_NAMESIZE);
+	  break;
+	case USER_PROCESS:
+	  strncpy (u->ut_name, ux->ut_user, UT_NAMESIZE);
+	  break;
+	case DEAD_PROCESS:
+	  strncpy (u->ut_name, "", UT_NAMESIZE);
+	  break;
+	}
+      strncpy (u->ut_host, ux->ut_host, UT_HOSTSIZE);
+      break;
+
+    case ACCOUNTING:
+      strncpy (u->ut_line, "~", UT_LINESIZE);
+      strncpy (u->ut_name, "acct", UT_NAMESIZE);
+      strncpy (u->ut_host, ux->ut_host, UT_HOSTSIZE);
+      break;
+
+    default:
+      return -1;
+    }
+
+  u->ut_time = ux->ut_tv.tv_sec;
+
+  /* Hack: Put the ut_pid at a hidden place where there is likely room.  */
+  if (ux->ut_pid != 0)
+    {
+      size_t room = UT_HOSTSIZE - strlen (u->ut_host) - 1;
+
+      sprintf (buf, "%lu", (unsigned long) ux->ut_pid);
+      if (strlen (buf) <= room)
+	strncpy (u->ut_host + strlen (u->ut_host) + 1, buf, room);
+    }
+
+  return 0;
+}
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/utmp-utmpx/utmp_file.c
@@ -0,0 +1 @@
+#include <sysdeps/unix/sysv/linux/utmp_file.c>
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/wait.c
@@ -0,0 +1 @@
+#include <sysdeps/unix/sysv/linux/wait.c>
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/wait3.c
@@ -0,0 +1 @@
+#include <sysdeps/unix/sysv/linux/wait3.c>
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/waitpid.c
@@ -0,0 +1,56 @@
+/* Copyright (C) 1991,95,96,97,2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <errno.h>
+#include <sys/wait.h>
+#include <sys/types.h>
+#include <stddef.h>
+#include <sysdep-cancel.h>
+
+/* Wait for a child matching PID to die.
+   If PID is greater than 0, match any process whose process ID is PID.
+   If PID is (pid_t) -1, match any process.
+   If PID is (pid_t) 0, match any process with the
+   same process group as the current process.
+   If PID is less than -1, match any process whose
+   process group is the absolute value of PID.
+   If the WNOHANG bit is set in OPTIONS, and that child
+   is not already dead, return (pid_t) 0.  If successful,
+   return PID and store the dead child's status in STAT_LOC.
+   Return (pid_t) -1 for errors.  If the WUNTRACED bit is set in OPTIONS,
+   return status for stopped children; otherwise don't.  */
+pid_t
+__libc_waitpid (pid_t pid, int *stat_loc, int options)
+{
+  if (SINGLE_THREAD_P)
+  {
+      return INLINE_SYSCALL (wait4, 4, pid, stat_loc, options, NULL);
+  }
+
+  int oldtype = LIBC_CANCEL_ASYNC ();
+
+  int result = INLINE_SYSCALL (wait4, 4, pid, stat_loc, options, NULL);
+
+  LIBC_CANCEL_RESET (oldtype);
+
+  return result;
+}
+
+weak_alias (__libc_waitpid, __waitpid)
+libc_hidden_weak (__waitpid)
+weak_alias (__libc_waitpid, waitpid)
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/writev.c
@@ -0,0 +1,57 @@
+/* writev for FreeBSD.
+   Copyright (C) 1997-1998, 2000, 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <errno.h>
+#include <stddef.h>
+#include <sys/param.h>
+#include <sys/uio.h>
+
+#include <sysdep.h>
+#include <sys/syscall.h>
+#include <bp-checks.h>
+#include <sysdep-cancel.h>
+
+extern ssize_t __syscall_writev (int, const struct iovec *__unbounded, int);
+
+static ssize_t __atomic_writev_replacement (int, const struct iovec *,
+					    int) internal_function;
+
+ssize_t
+__libc_writev (int fd, const struct iovec *vector, int count)
+{
+  if (count <= UIO_MAXIOV)
+  {
+    if (SINGLE_THREAD_P)
+      return INLINE_SYSCALL (writev, 3, fd, CHECK_N (vector, count), count);
+
+    int oldtype = LIBC_CANCEL_ASYNC ();
+    ssize_t result =  INLINE_SYSCALL (writev, 3, fd, CHECK_N (vector, count), count);
+    LIBC_CANCEL_RESET (oldtype);
+    return result;
+
+  }
+  else
+    return __atomic_writev_replacement (fd, vector, count);
+}
+strong_alias (__libc_writev, __writev)
+weak_alias (__libc_writev, writev)
+
+#define __libc_writev static internal_function __atomic_writev_replacement
+#include <sysdeps/posix/writev.c>
+
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/x86_64/Makefile
@@ -0,0 +1,17 @@
+32bit-predefine = __i386__
+64bit-predefine = __x86_64__
+
+# Additional header files to be installed in $prefix/include:
+
+ifeq ($(subdir),misc)
+sysdep_headers += \
+ sys/io.h \
+ sys/perm.h
+endif
+
+# Additional functions, and particular system calls:
+
+ifeq ($(subdir),misc)
+# For <sys/io.h> and <sys/perm.h>.
+sysdep_routines += iopl
+endif
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/x86_64/Versions
@@ -0,0 +1,5 @@
+libc {
+  GLIBC_2.3.4 {
+    iopl;
+  }
+}
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/x86_64/bits/mcontext.h
@@ -0,0 +1,167 @@
+/* Machine-dependent processor state structure for FreeBSD.
+   Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.  x86_64 version.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#if !defined _SYS_UCONTEXT_H
+# error "Never use <bits/mcontext.h> directly; include <sys/ucontext.h> instead."
+#endif
+
+/*-
+ * Copyright (c) 2003 Peter Wemm
+ * Copyright (c) 1999 Marcel Moolenaar
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer
+ *    in this position and unchanged.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * based on $FreeBSD: src/sys/amd64/include/ucontext.h,v 1.18 2003/11/08 04:39:22 peter Exp $
+ */
+
+#ifdef __i386__
+
+/* Whole processor state.  */
+typedef struct
+  {
+    /*
+     * The first 20 fields must match the definition of
+     * sigcontext. So that we can support sigcontext
+     * and ucontext_t at the same time.
+     */
+
+    int mc_onstack;		/* Nonzero if running on sigstack.  */
+
+    /* Segment registers.  */
+    int mc_gs;
+    int mc_fs;
+    int mc_es;
+    int mc_ds;
+
+    /* "General" registers.  These members are in the order that the i386
+       `pusha' and `popa' instructions use (`popa' ignores %esp).  */
+    int mc_edi;
+    int mc_esi;
+    int mc_ebp;
+    int mc_isp;			/* Not used; sc_esp is used instead.  */
+    int mc_ebx;
+    int mc_edx;
+    int mc_ecx;
+    int mc_eax;
+
+    int mc_trapno;
+    int mc_err;
+
+    int mc_eip;			/* Instruction pointer.  */
+    int mc_cs;			/* Code segment register.  */
+
+    int mc_efl;			/* Processor flags.  */
+
+    int mc_esp;			/* This stack pointer is used.  */
+    int mc_ss;			/* Stack segment register.  */
+
+    int mc_len;			/* sizeof(mcontext_t) */
+#define	_MC_FPFMT_NODEV		0x10000	/* device not present or configured */
+#define	_MC_FPFMT_387		0x10001
+#define	_MC_FPFMT_XMM		0x10002
+    int mc_fpformat;
+#define	_MC_FPOWNED_NONE	0x20000	/* FP state not used */
+#define	_MC_FPOWNED_FPU		0x20001	/* FP state came from FPU */
+#define	_MC_FPOWNED_PCB		0x20002	/* FP state came from PCB */
+    int mc_ownedfp;
+    int mc_spare1[1];		/* align next field to 16 bytes */
+    /*
+     * See <machine/npx.h> for the internals of mc_fpstate[].
+     */
+    int mc_fpstate[128] __attribute__((aligned(16)));
+    int mc_spare2[8];
+  } mcontext_t;
+
+#else
+
+/* Whole processor state.  */
+typedef struct
+  {
+    /*
+     * The first 20 fields must match the definition of
+     * sigcontext. So that we can support sigcontext
+     * and ucontext_t at the same time.
+     */
+    long mc_onstack;		/* XXX - sigcontext compat. */
+    long mc_rdi;			/* machine state (struct trapframe) */
+    long mc_rsi;
+    long mc_rdx;
+    long mc_rcx;
+    long mc_r8;
+    long mc_r9;
+    long mc_rax;
+    long mc_rbx;
+    long mc_rbp;
+    long mc_r10;
+    long mc_r11;
+    long mc_r12;
+    long mc_r13;
+    long mc_r14;
+    long mc_r15;
+    long mc_trapno;
+    long mc_addr;
+    long mc_flags;
+    long mc_err;
+    long mc_rip;
+    long mc_cs;
+    long mc_rflags;
+    long mc_rsp;
+    long mc_ss;
+
+    long mc_len;			/* sizeof(mcontext_t) */
+#define	_MC_FPFMT_NODEV		0x10000	/* device not present or configured */
+#define	_MC_FPFMT_XMM		0x10002
+    long mc_fpformat;
+#define	_MC_FPOWNED_NONE	0x20000	/* FP state not used */
+#define	_MC_FPOWNED_FPU		0x20001	/* FP state came from FPU */
+#define	_MC_FPOWNED_PCB		0x20002	/* FP state came from PCB */
+    long mc_ownedfp;
+     /*
+      * See <machine/fpu.h> for the internals of mc_fpstate[].
+      */
+    long mc_fpstate[64] __attribute__((aligned(16)));
+    long mc_spare[8];
+} mcontext_t;
+
+#endif
+
+/* Traditional BSD names for some members.  */
+#define mc_eflags	mc_efl
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/x86_64/bits/sigcontext.h
@@ -0,0 +1,147 @@
+/* Machine-dependent signal context structure for FreeBSD.  i386 version.
+   Copyright (C) 1991-1992,1994,1997,2001-2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#if !defined _SIGNAL_H && !defined _SYS_UCONTEXT_H
+# error "Never use <bits/sigcontext.h> directly; include <signal.h> instead."
+#endif
+
+#ifndef _BITS_SIGCONTEXT_H
+#define _BITS_SIGCONTEXT_H  1
+
+#ifdef __i386__
+
+/* State of this thread when the signal was taken.
+   The unions below are for compatibility with Linux (whose sigcontext
+   components don't have sc_ prefix) */
+struct sigcontext
+  {
+    __sigset_t 	sc_mask;		/* Blocked signals to restore.  */
+    int 	sc_onstack;		/* Nonzero if running on sigstack.  */
+
+    /* Segment registers.  */
+    union { int sc_gs; int gs; };
+    union { int sc_fs; int fs; };
+    union { int sc_es; int es; };
+    union { int sc_ds; int ds; };
+
+    /* "General" registers.  These members are in the order that the i386
+       `pusha' and `popa' instructions use (`popa' ignores %esp).  */
+    union { int sc_edi; int edi; };
+    union { int sc_esi; int esi; };
+    union { int sc_ebp; int ebp; };
+    union { int sc_isp; int isp; };		/* Not used; sc_esp is used instead.  */
+    union { int sc_ebx; int ebx; };
+    union { int sc_edx; int edx; };
+    union { int sc_ecx; int ecx; };
+    union { int sc_eax; int eax; };
+
+    union { int sc_trapno; int trapno; };
+    union { int sc_err; int err; };
+
+    union { int sc_eip; int eip; };		/* Instruction pointer.  */
+    union { int sc_cs; int cs; };		/* Code segment register.  */
+
+    union { int sc_efl; int eflags; }; 		/* Processor flags.  */
+
+    union { int sc_esp; int esp; };		/* This stack pointer is used.  */
+    union { int sc_ss; int ss; };		/* Stack segment register.  */
+
+    int     sc_len;                 /* sizeof(mcontext_t) */
+    /*
+     * XXX - See <machine/ucontext.h> and <machine/npx.h> for
+     *       the following fields.
+     */
+    int     sc_fpformat;
+    int     sc_ownedfp;
+    int     sc_spare1[1];
+    int     sc_fpstate[128] __attribute__((aligned(16)));
+    int     sc_spare2[8];
+  };
+
+/* Traditional BSD names for some members.  */
+#define sc_sp		sc_esp		/* Stack pointer.  */
+#define sc_fp		sc_ebp		/* Frame pointer.  */
+#define sc_pc		sc_eip		/* Process counter.  */
+#define sc_ps		sc_efl
+#define sc_eflags	sc_efl
+
+#if 1 /* FIXME: These need verification.  */
+
+/* Codes for SIGILL.  */
+#define ILL_PRIVIN_FAULT	1
+#define ILL_ALIGN_FAULT		14
+#define ILL_FPOP_FAULT		24
+
+/* Codes for SIGBUS.  */
+#define BUS_PAGE_FAULT		12
+#define BUS_SEGNP_FAULT		26
+#define BUS_STK_FAULT		27
+#define BUS_SEGM_FAULT		29
+
+#endif
+
+#else
+
+struct sigcontext
+  {
+    __sigset_t 	sc_mask;		/* Blocked signals to restore.  */
+    long 	sc_onstack;		/* Nonzero if running on sigstack.  */
+    union { long sc_rdi; long rdi;};
+    union { long sc_rsi; long rsi;};
+    union { long sc_rdx; long rdx;};
+    union { long sc_rcx; long rcx;};
+    union { long sc_r8; long r8;};
+    union { long sc_r9; long r9;};
+    union { long sc_rax; long rax;};
+    union { long sc_rbx; long rbx;};
+    union { long sc_rbp; long rbp;};
+    union { long sc_r10; long r10;};
+    union { long sc_r11; long r11;};
+    union { long sc_r12; long r12;};
+    union { long sc_r13; long r13;};
+    union { long sc_r14; long r14;};
+    union { long sc_r15; long r15;};
+    union { long sc_trapno; long trapno;};
+    union { long sc_addr; long addr;};
+    union { long sc_flags; long flags;};
+    union { long sc_err; long err;};
+    union { long sc_rip; long rip;};
+    union { long sc_cs; long cs;};
+    union { long sc_rflags; long rflags;};
+    union { long sc_rsp; long rsp;};
+    union { long sc_ss; long ss;};
+    long	sc_len;        /* sizeof(mcontext_t) */
+    /*
+     * XXX - See <machine/ucontext.h> and <machine/fpu.h> for
+     *       the following fields.
+     */
+    long	sc_fpformat;
+    long	sc_ownedfp;
+    long	sc_fpstate[64] __attribute__((aligned(16)));
+    long	sc_spare[8];
+  };
+
+/* Traditional BSD names for some members.  */
+#define sc_sp           sc_rsp          /* Stack pointer.  */
+#define sc_fp           sc_rbp          /* Frame pointer.  */
+#define sc_pc           sc_rip          /* Process counter.  */
+
+#endif
+
+#endif /* _BITS_SIGCONTEXT_H */
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/x86_64/bits/time.h
@@ -0,0 +1,89 @@
+/* System-dependent timing definitions.  FreeBSD version.
+   Copyright (C) 1996-1997, 1999, 2000, 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+/*
+ * Never include this file directly; use <time.h> instead.
+ */
+
+#ifndef __need_timeval
+# ifndef _BITS_TIME_H
+#  define _BITS_TIME_H	1
+
+/* ISO/IEC 9899:1990 7.12.1: <time.h>
+   The macro `CLOCKS_PER_SEC' is the number per second of the value
+   returned by the `clock' function. */
+/* CAE XSH, Issue 4, Version 2: <time.h>
+   The value of CLOCKS_PER_SEC is required to be 1 million on all
+   XSI-conformant systems. */
+#  define CLOCKS_PER_SEC  1000000l
+
+#  if !defined __STRICT_ANSI__ && !defined __USE_XOPEN2K
+/* Even though CLOCKS_PER_SEC has such a strange value CLK_TCK
+   presents the real value for clock ticks per second for the system.  */
+#   define CLK_TCK 128
+#  endif
+
+#  ifdef __USE_POSIX199309
+/* Identifier for system-wide realtime clock.  */
+#   define CLOCK_REALTIME		0
+/* High-resolution timer from the CPU.  */
+#   define CLOCK_PROCESS_CPUTIME_ID	2
+/* Thread-specific CPU-time clock.  */
+#   define CLOCK_THREAD_CPUTIME_ID	3
+/* Monotonic system-wide clock.  */
+#   define CLOCK_MONOTONIC		4
+/* These are BSD specific clocks.  */
+#   ifdef __USE_BSD
+#    define CLOCK_VIRTUAL		1
+#    define CLOCK_PROF			2
+#   endif
+
+/* Flag to indicate time is absolute.  */
+#   define TIMER_ABSTIME		1
+#  endif
+
+
+/* Getkerninfo clock information structure */
+struct clockinfo
+  {
+    int hz;		/* clock frequency */
+    int tick;		/* micro-seconds per hz tick */
+    int spare;
+    int stathz;		/* statistics clock frequency */
+    int profhz;		/* profiling clock frequency */
+  };
+
+# endif	/* bits/time.h */
+#endif
+
+#ifdef __need_timeval
+# undef __need_timeval
+# ifndef _STRUCT_TIMEVAL
+#  define _STRUCT_TIMEVAL	1
+#  include <bits/types.h>
+
+/* A time value that is accurate to the nearest
+   microsecond but also has a range of years.  */
+struct timeval
+  {
+    __time_t tv_sec;		/* Seconds.  */
+    __suseconds_t tv_usec;	/* Microseconds.  */
+  };
+# endif	/* struct timeval */
+#endif	/* need timeval */
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/x86_64/dl-cache.h
@@ -0,0 +1 @@
+#include <sysdeps/unix/sysv/linux/x86_64/dl-cache.h>
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/x86_64/dl-machine.h
@@ -0,0 +1,80 @@
+/* Machine-dependent ELF dynamic relocation inline functions.  FreeBSD/amd64 version.
+   Copyright (C) 2006 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Petr Salinger, 2006.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifdef dl_machine_h
+#include_next <dl-machine.h>
+#else
+#include_next <dl-machine.h>
+
+#undef RTLD_START
+
+/* Initial entry point code for the dynamic linker.
+   The C function `_dl_start' is the real entry point;
+   its return value is the user program's entry point.  */
+#define RTLD_START asm ("\n\
+.text\n\
+	.align 16\n\
+.globl _start\n\
+# we dont use it: .globl _dl_start_user\n\
+_start:\n\
+	# align stack.\n\
+	andq $-16, %rsp\n\
+	# save argument pointer.\n\
+	movq %rdi, %r13\n\
+	call _dl_start\n\
+# we dont use it: _dl_start_user:\n\
+	# Save the user entry point address in %r12.\n\
+	movq %rax, %r12\n\
+	# See if we were run as a command with the executable file\n\
+	# name as an extra leading argument.\n\
+	movl _dl_skip_args(%rip), %eax\n\
+	# get the original argument count.\n\
+	movq 0(%r13), %rdx\n\
+	# Adjust the pointer to skip _dl_skip_args words.\n\
+	leaq (%r13,%rax,8), %r13\n\
+	# Subtract _dl_skip_args from argc.\n\
+	subl %eax, %edx\n\
+	# Put argc on adjusted place\n\
+	movq %rdx, 0(%r13)\n\
+	# Call _dl_init (struct link_map *main_map, int argc, char **argv, char **env)\n\
+	# argc -> rsi\n\
+	movq %rdx, %rsi\n\
+	# _dl_loaded -> rdi\n\
+	movq _rtld_local(%rip), %rdi\n\
+	# env -> rcx\n\
+	leaq 16(%r13,%rdx,8), %rcx\n\
+	# argv -> rdx\n\
+	leaq 8(%r13), %rdx\n\
+	# Clear %rbp to mark outermost frame obviously even for constructors.\n\
+	xorl %ebp, %ebp\n\
+	# Call the function to run the initializers.\n\
+	call _dl_init_internal@PLT\n\
+	# Pass our finalizer function to the user in %rdx, as per ELF ABI draft.\n\
+	leaq _dl_fini(%rip), %rdx\n\
+	# And make sure %rdi points to argc stored on the stack.\n\
+	movq %r13, %rdi\n\
+	# Pass finalizer function also in %rsi, as per C calling convention.\n\
+	movq %rdx, %rsi\n\
+	# Jump to the user's entry point.\n\
+	jmp *%r12\n\
+.previous\n\
+");
+
+#endif
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/x86_64/dl-procinfo.c
@@ -0,0 +1 @@
+#include <sysdeps/unix/sysv/linux/x86_64/dl-procinfo.c>
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/x86_64/dl-procinfo.h
@@ -0,0 +1 @@
+#include <sysdeps/unix/sysv/linux/x86_64/dl-procinfo.h>
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/x86_64/elf/start.S
@@ -0,0 +1,143 @@
+/* Startup code for FreeBSD/amd64 ABI.
+   Copyright (C) 2001, 2002, 2003 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Andreas Jaeger <aj@suse.de>, 2001.
+   FreeBSD modification by Petr Salinger, 2006.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   In addition to the permissions in the GNU Lesser General Public
+   License, the Free Software Foundation gives you unlimited
+   permission to link the compiled version of this file with other
+   programs, and to distribute those programs without any restriction
+   coming from the use of this file. (The GNU Lesser General Public
+   License restrictions do apply in other respects; for example, they
+   cover modification of the file, and distribution when not linked
+   into another program.)
+
+   Note that people who make modified versions of this file are not
+   obligated to grant this special exception for their modified
+   versions; it is their choice whether to do so. The GNU Lesser
+   General Public License gives permission to release a modified
+   version without this exception; this exception also makes it
+   possible to release a modified version which carries forward this
+   exception.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+/* This is the canonical entry point, usually the first thing in the text
+   segment.  The SVR4/i386 ABI (pages 3-31, 3-32) says that when the entry
+   point runs, most registers' values are unspecified, except for a few.
+   Blindly applied on amd64:
+
+   %rdx		Contains a function pointer to be registered with `atexit'.
+		This is how the dynamic linker arranges to have DT_FINI
+		functions called for shared libraries that have been loaded
+		before this code runs.
+
+   %rsp		The stack contains the arguments and environment:
+		0(%rsp)			argc
+		8(%rsp)			argv[0]
+		...
+		(8*argc)(%rsp)		NULL
+		(8*(argc+1))(%rsp)	envp[0]
+		...
+					NULL
+
+   But on amd64 %rsp also have to be 16-byte aligned,
+   standard C calling convention already passes arguments in registers.
+
+   FreeBSD uses %edi as pointer to arguments and environment, %rsp is passed aligned.
+   On entry from kernel, %rsp=%rdi or %rsp=%rdi-8,
+   on entry from ld.so, glibc might set up it slightly differently.
+
+   On FreeBSD, we use %rsi for passing function pointer to rtld_fini().
+   On entry from FreeBSD kernel, %rsi is cleared, %rdx is not cleared,
+   on entry from ld.so, glibc sets both %rsi and %rdx to point to rtld_fini().
+
+   Used interface (via %rdi, %rsi) is equal to standard C calling interface for
+
+   void _start(void *arg, void *rtld_fini());
+
+*/
+
+#include "bp-sym.h"
+
+	.text
+	.globl _start
+	.type _start,@function
+_start:
+	/* Clear the frame pointer.  The ABI suggests this be done, to mark
+	   the outermost frame obviously.  */
+	xorl %ebp, %ebp		/* zero extending clears whole rbp */
+
+	/* Extract the arguments as encoded on the stack and set up
+	   the arguments for __libc_start_main (int (*main) (int, char **, char **),
+		   int argc, char *argv,
+		   void (*init) (void), void (*fini) (void),
+		   void (*rtld_fini) (void), void *stack_end).
+	   The arguments are passed via registers and on the stack:
+	main:		%rdi
+	argc:		%rsi
+	argv:		%rdx
+	init:		%rcx
+	fini:		%r8
+	rtld_fini:	%r9
+	stack_end:	stack.	*/
+
+	movq %rsi, %r9		/* Address of the shared library termination
+				   function.  */
+	movq 0(%rdi), %rsi	/* argument count.  */
+	leaq 8(%rdi), %rdx      /* argv starts just at above argc.  */
+
+	/* Align the stack to a 16 byte boundary to follow the ABI.  */
+	andq  $~15, %rsp
+
+	pushq %rax		/* Push garbage because we push 8 more bytes.  */
+
+	/* Provide the highest stack address to the user code (for stacks
+	   which grow downwards).  */
+	pushq %rsp
+
+#ifdef SHARED
+	/* Pass address of our own entry points to .fini and .init.  */
+	movq __libc_csu_fini@GOTPCREL(%rip), %r8
+	movq __libc_csu_init@GOTPCREL(%rip), %rcx
+
+	movq BP_SYM (main)@GOTPCREL(%rip), %rdi
+
+	/* Call the user's main function, and exit with its value.
+	   But let the libc call main.	  */
+	call BP_SYM (__libc_start_main)@PLT
+#else
+	/* Pass address of our own entry points to .fini and .init.  */
+	movq $__libc_csu_fini, %r8
+	movq $__libc_csu_init, %rcx
+
+	movq $BP_SYM (main), %rdi
+
+	/* Call the user's main function, and exit with its value.
+	   But let the libc call main.	  */
+	call BP_SYM (__libc_start_main)
+#endif
+
+	hlt			/* Crash if somehow `exit' does return.	 */
+
+/* Define a symbol for the first piece of initialized data.  */
+	.data
+	.globl __data_start
+__data_start:
+	.long 0
+	.weak data_start
+	data_start = __data_start
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/x86_64/get_clockfreq.c
@@ -0,0 +1 @@
+#include "../i386/get_clockfreq.c"
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/x86_64/getcontext.S
@@ -0,0 +1,38 @@
+/* Save current context.
+   Copyright (C) 2006 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sysdep.h>
+
+.text
+ENTRY(__getcontext)
+        clc
+        movq 0(%rsp), %rsi	/* save the return PC value */
+
+        DO_CALL (getcontext, 1)
+        jb SYSCALL_ERROR_LABEL
+
+        addq $8, %rsp		/* remove stale return address */
+        jmp  *%rsi
+
+L(pseudo_end):
+	ret
+
+PSEUDO_END(__getcontext)
+
+weak_alias(__getcontext, getcontext)
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/x86_64/iopl.c
@@ -0,0 +1 @@
+#include "../i386/iopl.c"
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/x86_64/ldconfig.h
@@ -0,0 +1,39 @@
+/* Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sysdeps/generic/ldconfig.h>
+
+#define SYSDEP_KNOWN_INTERPRETER_NAMES \
+  { "/lib/ld.so.1", FLAG_ELF_LIBC6 },				\
+  { "/lib/ld-kfreebsd-x86-64.so.1", FLAG_ELF_LIBC6 },		\
+  { "/lib64/ld-kfreebsd-x86-64.so.1", FLAG_ELF_LIBC6 },		\
+  { "/libexec/ld-elf.so.1", FLAG_ELF_LIBC5 },
+
+#define SYSDEP_KNOWN_LIBRARY_NAMES \
+  { "libc.so.0.1", FLAG_ELF_LIBC6 },				\
+  { "libm.so.1", FLAG_ELF_LIBC6 },				\
+  { "libc.so.4", FLAG_ELF_LIBC5 },				\
+  { "libm.so.4", FLAG_ELF_LIBC5 },				\
+  { "libc.so.5", FLAG_ELF_LIBC5 },				\
+  { "libm.so.5", FLAG_ELF_LIBC5 },				\
+  { "libc.so.6", FLAG_ELF_LIBC5 },				\
+  { "libm.so.6", FLAG_ELF_LIBC5 },				\
+  { "libc.so.7", FLAG_ELF_LIBC5 },				\
+  { "libm.so.7", FLAG_ELF_LIBC5 },				\
+  { "libc.so.8", FLAG_ELF_LIBC5 },				\
+  { "libm.so.8", FLAG_ELF_LIBC5 },
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/x86_64/ldd-rewrite.sed
@@ -0,0 +1,3 @@
+/LD_TRACE_LOADED_OBJECTS=1/a\
+add_env="$add_env LD_LIBRARY_VERSION=\\$verify_out"
+s_^\(RTLDLIST=\)\(.*lib\)\(\|64\)\(/[^/]*\)\(-kfreebsd-x86-64\)\(\.so\.[0-9.]*\)[ 	]*$_\1"\2\4\6 \264\4\5\6"_
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/x86_64/linuxthreads/Makefile
@@ -0,0 +1,4 @@
+ifeq ($(subdir),linuxthreads)
+CFLAGS-pt-initfini.s = -g0 -fPIC -fno-inline-functions \
+		       -fno-asynchronous-unwind-tables $(fno-unit-at-a-time)
+endif
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/x86_64/linuxthreads/asm/prctl.h
@@ -0,0 +1 @@
+/* placeholder to make linuxthreads/sysdeps/x86_64/pt-machine.h happy */
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/x86_64/linuxthreads/pt-machine.h
@@ -0,0 +1,51 @@
+/* Machine-dependent pthreads configuration and inline functions.
+   x86-64 FreeBSD version.
+   Copyright (C) 2001, 2002, 2003, 2004 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _FREEBSD_PT_MACHINE_H
+#define _FREEBSD_PT_MACHINE_H   1
+
+/*
+  almost all parts are common with linux version
+ */
+
+#include <linuxthreads/sysdeps/x86_64/pt-machine.h>
+
+#ifndef __ASSEMBLER__
+
+/* and only one FreeBSD specifics */
+
+#include <sysarch.h>
+
+/* Initialize the thread-unique value. */
+
+#undef INIT_THREAD_SELF
+#define INIT_THREAD_SELF(descr, nr)             \
+{                                               \
+  long tmp;                                     \
+  tmp = (long) descr;                           \
+  if (sysarch(AMD64_SET_FSBASE, &tmp)  != 0)    \
+  {                                             \
+    abort();                                    \
+  }                                             \
+}
+
+#endif /* !__ASSEMBLER__ */
+
+#endif /* pt-machine.h */
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/x86_64/linuxthreads/sysdep-cancel.h
@@ -0,0 +1,145 @@
+/* Copyright (C) 2002, 2003 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Jakub Jelinek <jakub@redhat.com>, 2002.
+   Modification for FreeBSD contributed by Petr Salinger, 2006.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sysdep.h>
+#include <tls.h>
+#include <pt-machine.h>
+#ifndef __ASSEMBLER__
+# include <linuxthreads/internals.h>
+#endif
+
+/* Syscalls with more than 6 arguments are not supported here.  */
+
+#if !defined NOT_IN_libc || defined IS_IN_libpthread || defined IS_IN_librt
+
+# undef PSEUDO
+# define PSEUDO(name, syscall_name, args)				      \
+  .text;								      \
+  ENTRY (name)								      \
+    SINGLE_THREAD_P;							      \
+    jne L(pseudo_cancel);						      \
+    DO_CALL (syscall_name, args);					      \
+    jb SYSCALL_ERROR_LABEL;						      \
+    ret;								      \
+  L(pseudo_cancel):							      \
+    /* Save registers that might get destroyed.  */			      \
+    SAVESTK_##args							      \
+    PUSHARGS_##args							      \
+    CENABLE								      \
+    /* Restore registers.  */						      \
+    POPARGS_##args							      \
+    RESTSTK_##args							      \
+    /* The return value from CENABLE is argument for CDISABLE.  */	      \
+    movq %rax, (%rsp);							      \
+    movl $SYS_ify (syscall_name), %eax;					      \
+    syscall;								      \
+    popq %rdi; cfi_adjust_cfa_offset(-8);				      \
+    pushfq; cfi_adjust_cfa_offset(8);					      \
+    /* Save %rax since it's the return/error code from the syscall.  */	      \
+    movq %rax, 8(%rsp);							      \
+    CDISABLE								      \
+    popfq; cfi_adjust_cfa_offset(-8);                                         \
+    /* fetch the error code from the syscall.  */              		      \
+    popq %rax; cfi_adjust_cfa_offset(-8);                                     \
+    /* adjust rsp, do not change flags	*/				      \
+    popq %rdx; cfi_adjust_cfa_offset(-8);                                     \
+    jb SYSCALL_ERROR_LABEL;						      \
+  L(pseudo_end):
+
+# define PUSHARGS_0	/* Nothing.  */
+# define PUSHARGS_1	PUSHARGS_0 movq %rdi, 8(%rsp);
+# define PUSHARGS_2	PUSHARGS_1 movq %rsi, 16(%rsp);
+# define PUSHARGS_3	PUSHARGS_2 movq %rdx, 24(%rsp);
+# define PUSHARGS_4	PUSHARGS_3 movq %rcx, 32(%rsp);
+# define PUSHARGS_5	PUSHARGS_4 movq %r8, 40(%rsp);
+# define PUSHARGS_6	PUSHARGS_5 movq %r9, 48(%rsp);
+
+# define POPARGS_0	/* Nothing.  */
+# define POPARGS_1	POPARGS_0 movq 8(%rsp), %rdi;
+# define POPARGS_2	POPARGS_1 movq 16(%rsp), %rsi;
+# define POPARGS_3	POPARGS_2 movq 24(%rsp), %rdx;
+# define POPARGS_4	POPARGS_3 movq 32(%rsp), %r10;
+# define POPARGS_5	POPARGS_4 movq 40(%rsp), %r8;
+# define POPARGS_6	POPARGS_5 movq 48(%rsp), %r9;
+
+/* We always have to align the stack before calling a function.  */
+# define SAVESTK_0	subq $24, %rsp;cfi_adjust_cfa_offset(24);
+# define SAVESTK_1	SAVESTK_0
+# define SAVESTK_2	SAVESTK_1
+# define SAVESTK_3	subq $40, %rsp;cfi_adjust_cfa_offset(40);
+# define SAVESTK_4	SAVESTK_3
+# define SAVESTK_5	subq $56, %rsp;cfi_adjust_cfa_offset(56);
+# define SAVESTK_6	SAVESTK_5
+
+# define RESTSTK_0	/* Nothing.  */
+# define RESTSTK_1	RESTSTK_0
+# define RESTSTK_2	RESTSTK_1
+# define RESTSTK_3	addq $16, %rsp;cfi_adjust_cfa_offset(-16);
+# define RESTSTK_4	RESTSTK_3
+# define RESTSTK_5	addq $32, %rsp;cfi_adjust_cfa_offset(-32);
+# define RESTSTK_6	RESTSTK_5
+
+# ifdef IS_IN_libpthread
+#  define CENABLE	call __pthread_enable_asynccancel;
+#  define CDISABLE	call __pthread_disable_asynccancel;
+#  define __local_multiple_threads __pthread_multiple_threads
+# elif !defined NOT_IN_libc
+#  define CENABLE	call __libc_enable_asynccancel;
+#  define CDISABLE	call __libc_disable_asynccancel;
+#  define __local_multiple_threads __libc_multiple_threads
+# else
+#  define CENABLE	call __librt_enable_asynccancel@plt;
+#  define CDISABLE	call __librt_disable_asynccancel@plt;
+# endif
+
+# if defined IS_IN_libpthread || !defined NOT_IN_libc
+#  ifndef __ASSEMBLER__
+extern int __local_multiple_threads attribute_hidden;
+#   define SINGLE_THREAD_P \
+  __builtin_expect (__local_multiple_threads == 0, 1)
+#  else
+#   define SINGLE_THREAD_P cmpl $0, __local_multiple_threads(%rip)
+#  endif
+
+# else
+
+#  ifndef __ASSEMBLER__
+#   define SINGLE_THREAD_P \
+  __builtin_expect (THREAD_GETMEM (THREAD_SELF, \
+				   p_header.data.multiple_threads) == 0, 1)
+#  else
+#   define SINGLE_THREAD_P cmpl $0, %fs:MULTIPLE_THREADS_OFFSET
+#  endif
+
+# endif
+
+#elif !defined __ASSEMBLER__
+
+/* This code should never be used but we define it anyhow.  */
+# define SINGLE_THREAD_P (1)
+# define NO_CANCELLATION 1
+
+#endif
+
+#ifndef __ASSEMBLER__
+# define RTLD_SINGLE_THREAD_P \
+  __builtin_expect (THREAD_GETMEM (THREAD_SELF, \
+                                     p_header.data.multiple_threads) == 0, 1)
+#endif
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/x86_64/linuxthreads/tls.h
@@ -0,0 +1,62 @@
+/* Definitions for thread-local data handling.  linuxthreads/x86-64 version.
+   Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Modification for FreeBSD by Petr Salinger, 2006.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _FREEBSD_TLS_H
+#define _FREEBSD_TLS_H
+
+#include <linuxthreads/sysdeps/x86_64/tls.h>
+
+#ifdef HAVE_TLS_SUPPORT
+
+# ifndef __ASSEMBLER__
+
+#include <sysarch.h>
+#include <sys/syscall.h>
+
+/* Code to initially initialize the thread pointer.  This might need
+   special attention since 'errno' is not yet available and if the
+   operation can cause a failure 'errno' must not be touched.  */
+
+# undef TLS_INIT_TP
+# define TLS_INIT_TP(descr, secondcall)					      \
+  ({									      \
+    void *_descr = (descr);						      \
+    tcbhead_t *head = _descr;						      \
+    long int _result;							      \
+									      \
+    head->tcb = _descr;							      \
+    /* For now the thread descriptor is at the same address.  */	      \
+    head->self = _descr;						      \
+									      \
+    asm volatile ("syscall"						      \
+		  : "=a" (_result)					      \
+		  : "0" ((unsigned long int) SYS_sysarch),		      \
+		    "D" ((unsigned long int) AMD64_SET_FSBASE),		      \
+		    "S" (&_descr)					      \
+		  : "memory", "cc", "cx", "dx", "r8", "r9", "r10", "r11");    \
+									      \
+    _result ? "cannot set %fs base address for thread-local storage" : 0;     \
+  })
+
+
+# endif	/* HAVE_TLS_SUPPORT */
+#endif /* __ASSEMBLER__ */
+
+#endif	/* tls.h */
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/x86_64/makecontext.S
@@ -0,0 +1,146 @@
+/* makecontext() for FreeBSD/amd64.
+   Copyright (C) 2006 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Petr Salinger, 2006.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sysdep.h>
+#include <ucontext_i.h>
+
+/*
+   void makecontext(ucontext_t *ucp, void *func(), int argc, ...);
+
+
+   input parameters:
+
+   rdi		ucp
+   rsi		func
+   edx		argc
+   rcx		arg1	-> ucp.rdi
+   r8		arg2	-> ucp.rsi
+   r9		arg3	-> ucp.rdx
+    8(%rsp)	arg4	-> ucp.rcx
+   16(%rsp)	arg5	-> ucp.r8
+   24(%rsp)	arg6	-> ucp.r9
+   i*8+24(%rsp) arg(6+i)-> future stack
+
+*/
+
+ENTRY(__makecontext)
+
+	/* Compute the address of the stack.
+	   The information comes from us_stack element. */
+	movq	oSS_SP(%rdi), %rax
+	addq	oSS_SIZE(%rdi), %rax
+
+	/* Put start addr into ucp */
+	movq	%rsi, oRIP(%rdi)
+
+	/* properly align future stack */
+	andq $-16, %rax
+	subq   $8, %rax
+
+	/* Put the next context into preserved ucp.rbx
+	   (from the uc_link element).  */
+	movq	oLINK(%rdi), %rsi
+	movq	%rsi, oRBX(%rdi)
+
+	/* save future registers arguments */
+
+	orl %edx, %edx
+	jz L(param_done)
+
+	decl %edx
+	movq %rcx, oRDI(%rdi)
+	jz L(param_done)
+
+	decl %edx
+	movq %r8,  oRSI(%rdi)
+	jz L(param_done)
+
+	decl %edx
+	movq %r9,  oRDX(%rdi)
+	jz L(param_done)
+
+	movq 8(%rsp), %rsi
+	decl %edx
+	movq %rsi, oRCX(%rdi)
+	jz L(param_done)
+
+	movq 16(%rsp), %rcx
+	decl %edx
+	movq %rcx, oR8(%rdi)
+	jz L(param_done)
+
+	movq 24(%rsp), %rsi
+	decl %edx
+	movq %rsi, oR9(%rdi)
+	jz L(param_done)
+
+	/* we have to copy some arguments also on the future stack */
+	movl %edx, %ecx
+	negq %rdx
+	leaq -16(%rax,%rdx,8), %rax /* we a litle bit waste stack space */
+	orq  $8, %rax
+
+1:	movq 24(%rsp,%rcx,8), %rsi
+	movq %rsi,(%rax,%rcx,8)
+	loop 1b
+
+L(param_done):
+
+	/* Store the future stack pointer and chain helper code. */
+	leaq	L(exitcode)(%rip), %rdx
+	movq	%rax, oRSP(%rdi)
+	movq	%rdx, (%rax)
+
+	/* 'makecontext' returns no value.  */
+	ret
+
+/***************************************************************************/
+
+	/* This is the helper code which gets called if a function which
+	   is registered with 'makecontext' returns.  In this case we
+	   have to install the context listed in the uc_link element of
+	   the context 'makecontext' manipulated at the time of the
+	   'makecontext' call.  If the pointer is NULL the process must
+	   terminate.  */
+
+L(exitcode):
+	/* we don't bother with extra arguments left on the stack
+		- more than 6 arguments is rare
+		- setcontext changes stacks immediately
+		- exit will call _exit in near future
+	*/
+
+	testq %rbx, %rbx	/* If it is zero exit.  */
+	jz 2f
+
+	movq %rbx, %rdi
+	call	JUMPTARGET(__setcontext)
+	/* If this returns (which can happen if the syscall fails) we'll
+	   exit the program with the return error value (-1).  */
+
+2:	movq %rax, %rdi
+	call	HIDDEN_JUMPTARGET(exit)
+	/* The 'exit' call should never return.  In case it does cause
+	   the process to terminate.  */
+	hlt
+END(__makecontext)
+
+weak_alias(__makecontext, makecontext)
+
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/x86_64/pipe.S
@@ -0,0 +1,32 @@
+/* Copyright (C) 2006 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sysdep.h>
+
+.text
+ENTRY (__pipe)
+	DO_CALL (pipe, 1)
+	jb SYSCALL_ERROR_LABEL
+        movl %eax, 0(%rdi)
+        movl %edx, 4(%rdi)
+        xorl %eax, %eax
+L(pseudo_end):
+	ret
+PSEUDO_END (__pipe)
+libc_hidden_def (__pipe)
+weak_alias (__pipe, pipe)
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/x86_64/readelflib.c
@@ -0,0 +1,62 @@
+/* Copyright (C) 1999, 2001, 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Andreas Jaeger <aj@suse.de>, 1999 and
+		  Jakub Jelinek <jakub@redhat.com>, 1999.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+
+int process_elf32_file (const char *file_name, const char *lib, int *flag,
+			unsigned int *osversion, char **soname,
+			void *file_contents, size_t file_length);
+int process_elf64_file (const char *file_name, const char *lib, int *flag,
+			unsigned int *osversion, char **soname,
+			void *file_contents, size_t file_length);
+
+/* Returns 0 if everything is ok, != 0 in case of error.  */
+int
+process_elf_file (const char *file_name, const char *lib, int *flag,
+		  unsigned int *osversion, char **soname, void *file_contents,
+		  size_t file_length)
+{
+  ElfW(Ehdr) *elf_header = (ElfW(Ehdr) *) file_contents;
+  int ret;
+
+  if (elf_header->e_ident [EI_CLASS] == ELFCLASS32)
+    return process_elf32_file (file_name, lib, flag, osversion, soname,
+			       file_contents, file_length);
+  else
+    {
+      ret = process_elf64_file (file_name, lib, flag, osversion, soname,
+				file_contents, file_length);
+      /* x86-64 64bit libraries are always LIBC6.  */
+      if (!ret)
+	*flag = FLAG_X8664_LIB64|FLAG_ELF_LIBC6;
+      return ret;
+    }
+}
+
+#undef __ELF_NATIVE_CLASS
+#undef process_elf_file
+#define process_elf_file process_elf32_file
+#define __ELF_NATIVE_CLASS 32
+#include "elf/readelflib.c"
+
+#undef __ELF_NATIVE_CLASS
+#undef process_elf_file
+#define process_elf_file process_elf64_file
+#define __ELF_NATIVE_CLASS 64
+#include "elf/readelflib.c"
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/x86_64/rfork.S
@@ -0,0 +1,44 @@
+/* Copyright (C) 1991-1992, 1994-1995, 1997, 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sysdep.h>
+
+.text;
+ENTRY (__rfork)
+	/* save the return PC value into RSI */
+	movq 0(%rsp), %rsi;
+	DO_CALL (rfork, 1)
+	jb SYSCALL_ERROR_LABEL;
+	/* R1 is now 0 for the parent and 1 for the child.  Decrement it to
+	   make it -1 (all bits set) for the parent, and 0 (no bits set)
+	   for the child.  Then AND it with R0, so the parent gets
+	   R0&-1==R0, and the child gets R0&0==0.  */
+	decq %rdx
+	andq %rdx, %rax
+
+	popq %rdx
+	cfi_adjust_cfa_offset(-8)
+
+	jmp  *%rsi
+
+L(pseudo_end):
+	ret
+PSEUDO_END (__rfork)
+
+weak_alias (__rfork, rfork)
+
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/x86_64/sigcontextinfo.h
@@ -0,0 +1,35 @@
+/* Copyright (C) 1998, 1999, 2001, 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+/*
+native FreeBSD:
+        sighandler(int signum, int code,       struct sigcontext * sg, void * fault_ip)
+posix like:
+        sighandler(int signum, siginfo_t * si, struct sigcontext * sg, void * fault_ip)
+*/
+
+#define SIGCONTEXT long _code, struct sigcontext * _sg, void *
+#define SIGCONTEXT_EXTRA_ARGS _code, _sg,
+
+/* really, really, rest of glibc expects that struct sigcontext is the last argument */
+#define GET_PC(ctx)	((void *) (_sg)->sc_rip)
+#define GET_FRAME(ctx)	((void *) (_sg)->sc_rbp)
+#define GET_STACK(ctx)	((void *) (_sg)->sc_rsp)
+
+#define CALL_SIGHANDLER(handler, signo, ctx) \
+  (handler)((signo), SIGCONTEXT_EXTRA_ARGS (ctx))
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/x86_64/start_thread.S
@@ -0,0 +1,196 @@
+/* Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Bruno Haible <bruno@clisp.org>, 2002.
+   Modification for amd64 contributed by Petr Salinger, 2006.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+/* __start_thread (flags, stack, func, arg)
+   calls __rfork (flags), and in the child sets the stack pointer and then
+   calls _exit (func (arg)).
+   It cannot be done in portable C.  */
+
+/*
+   The parameters are passed in registers:
+   rdi: flags for rfork
+   rsi: child_stack
+   rdx: func
+   rcx: arg
+*/
+
+#include <sysdep.h>
+#include <asm-syntax.h>
+
+#define SIG_SETMASK	3
+
+/* There is a window of a few instructions, right after the rfork
+   system call, where the handling of a signal would write garbage
+   into the stack shared by the parent and the child (assuming
+   RFMEM is set in flags).  To solve this: 1. We block all signals
+   around the rfork system call and unblock them afterwards in
+   the parent and in the child (but only after changing the stack
+   pointer).  2. The child accesses only values passed in registers
+   and on its own stack.  This way, if the parent is scheduled to
+   run first, and handles a signal, it will not affect the child;
+   and if the child runs first, and handles a signal, it will use
+   the child's stack and not affect the parent.
+*/
+
+	.text
+ENTRY (__start_thread)
+
+        /* Insert the argument onto the new aligned stack.  */
+        andq	$-16,%rsi
+        subq    $16,%rsi
+        movq    %rcx,8(%rsi)
+
+        /* Save the function pointer.  It will be popped off in the child */
+        movq    %rdx,0(%rsi)
+
+	testq	$32, %rdi	/* flags & RFMEM */
+	jnz	L(complex)
+
+        /* Do the system call.  */
+	movl    $SYS_ify(rfork),%eax
+        /* End FDE now, because in the child the unwind info will be
+           wrong.  */
+        cfi_endproc;
+        syscall			/* rdi and rsi are extra preserved */
+
+        jb SYSCALL_ERROR_LABEL
+
+	testq   %rdx,%rdx	/*  0 for the parent and 1 for the child */
+	jz     L(pseudo_end)	/* just return in parent */
+
+L(thread_start):
+
+	/* set up stack */
+	movq	%rsi, %rsp
+
+        /* Clear the frame pointer.  The ABI suggests this be done, to mark
+           the outermost frame obviously.  */
+        xorl    %ebp, %ebp
+
+L(thread_start2):
+
+        /* Set up arguments for the function call.  */
+        popq    %rax            /* Function to call.  */
+        popq    %rdi            /* Argument.  */
+        call    *%rax
+
+        /* Call exit with return value from function call. */
+        movq    %rax, %rdi
+        call    HIDDEN_JUMPTARGET (_exit)
+
+
+/******************************************************************************************************
+ *
+ * and now the complex one ...
+ *
+ ******************************************************************************************************/
+
+L(complex):
+
+        subq    $32, %rsp
+
+        /* save arguments - flags and stack */
+        movq    %rdi,0(%rsp)
+        movq    %rsi,8(%rsp)
+
+        /* Block all signals.  */
+        orq     $-1, %rax
+        movq    %rax, 16(%rsp)
+        movq    %rax, 24(%rsp)
+
+        leaq    16(%rsp), %rsi
+        movl    $SIG_SETMASK, %edi
+        movq    %rsi,%rdx
+        DO_CALL (sigprocmask, 3)
+        jb      L(error)
+
+        /* restore arguments - flags and stack */
+        movq    0(%rsp),%rdi
+        movq    8(%rsp),%rsi
+
+        /* Copy mask info into the child's stack.  */
+
+        subq    $16,%rsi
+        movq    16(%rsp),%rcx
+        movq    24(%rsp),%rdx
+        movq    %rcx, 0(%rsi)
+        movq    %rdx, 8(%rsi)
+
+        /* Perform the rfork system call.  */
+        DO_CALL (rfork, 1)
+        jb      L(error_unmask)
+
+        /* %rdx is now 0 for the parent and 1 for the child.  */
+        testq   %rdx, %rdx
+        jnz     L(child)
+
+        /* Save the child pid, currently in %rax.  */
+        movq    %rax, 0(%rsp)
+
+        /* Restore the previous signal mask.  */
+        movl    $SIG_SETMASK, %edi
+        leaq    16(%rsp), %rsi
+        xorl    %edx,%edx
+        DO_CALL (sigprocmask, 3)
+
+        /* Return the child pid, saved on stack.  */
+        movq    0(%rsp), %rax
+        addq    $32, %rsp
+L(pseudo_end):
+        ret
+
+L(error_unmask):
+
+        /* Save the error code, currently in %rax.  */
+        movq    %rax, 0(%rsp)
+
+        /* Restore the previous signal mask.  */
+        movq    $SIG_SETMASK, %rdi
+        leaq    16(%rsp), %rsi
+        xorl    %edx,%edx
+        DO_CALL (sigprocmask, 3)
+
+	/* load saved error code */
+        movq    0(%rsp), %rax
+
+L(error):
+        addq    $32, %rsp
+        jmp     SYSCALL_ERROR_LABEL
+
+L(child):/* Here we are in the child thread.  */
+
+        /* set up stack */
+        movq    %rsi, %rsp
+
+        /* Clear the frame pointer.  The ABI suggests this be done, to mark
+           the outermost frame obviously.  */
+        xorl    %ebp, %ebp
+
+        /* Restore the previous signal mask.  */
+        movq    $SIG_SETMASK, %rdi
+        xorl    %edx,%edx
+        DO_CALL (sigprocmask, 3)
+
+        addq    $16, %rsp
+        jmp     L(thread_start2)
+
+        cfi_startproc;
+
+PSEUDO_END (__start_thread)
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/x86_64/swapcontext.S
@@ -0,0 +1,32 @@
+/* swap current context.
+   Copyright (C) 2006 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sysdep.h>
+
+.text
+ENTRY(__swapcontext)
+        clc
+        DO_CALL (swapcontext, 2)
+        jb SYSCALL_ERROR_LABEL
+L(pseudo_end):
+	ret
+
+PSEUDO_END(__swapcontext)
+
+weak_alias(__swapcontext, swapcontext)
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/x86_64/sys/io.h
@@ -0,0 +1,171 @@
+/* Copyright (C) 1996, 2000, 2002, 2004 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef	_SYS_IO_H
+#define	_SYS_IO_H	1
+
+#include <features.h>
+
+__BEGIN_DECLS
+
+/* Set the I/O privilege level to LEVEL.  If LEVEL>3, permission to
+   access any I/O port is granted.  This call requires root
+   privileges. */
+extern int iopl (int __level) __THROW;
+
+#if defined __GNUC__ && __GNUC__ >= 2
+
+static __inline unsigned char
+inb (unsigned short int port)
+{
+  unsigned char _v;
+
+  __asm__ __volatile__ ("inb %w1,%0":"=a" (_v):"Nd" (port));
+  return _v;
+}
+
+static __inline unsigned char
+inb_p (unsigned short int port)
+{
+  unsigned char _v;
+
+  __asm__ __volatile__ ("inb %w1,%0\noutb %%al,$0x80":"=a" (_v):"Nd" (port));
+  return _v;
+}
+
+static __inline unsigned short int
+inw (unsigned short int port)
+{
+  unsigned short _v;
+
+  __asm__ __volatile__ ("inw %w1,%0":"=a" (_v):"Nd" (port));
+  return _v;
+}
+
+static __inline unsigned short int
+inw_p (unsigned short int port)
+{
+  unsigned short int _v;
+
+  __asm__ __volatile__ ("inw %w1,%0\noutb %%al,$0x80":"=a" (_v):"Nd" (port));
+  return _v;
+}
+
+static __inline unsigned int
+inl (unsigned short int port)
+{
+  unsigned int _v;
+
+  __asm__ __volatile__ ("inl %w1,%0":"=a" (_v):"Nd" (port));
+  return _v;
+}
+
+static __inline unsigned int
+inl_p (unsigned short int port)
+{
+  unsigned int _v;
+  __asm__ __volatile__ ("inl %w1,%0\noutb %%al,$0x80":"=a" (_v):"Nd" (port));
+  return _v;
+}
+
+static __inline void
+outb (unsigned char value, unsigned short int port)
+{
+  __asm__ __volatile__ ("outb %b0,%w1": :"a" (value), "Nd" (port));
+}
+
+static __inline void
+outb_p (unsigned char value, unsigned short int port)
+{
+  __asm__ __volatile__ ("outb %b0,%w1\noutb %%al,$0x80": :"a" (value),
+			"Nd" (port));
+}
+
+static __inline void
+outw (unsigned short int value, unsigned short int port)
+{
+  __asm__ __volatile__ ("outw %w0,%w1": :"a" (value), "Nd" (port));
+
+}
+
+static __inline void
+outw_p (unsigned short int value, unsigned short int port)
+{
+  __asm__ __volatile__ ("outw %w0,%w1\noutb %%al,$0x80": :"a" (value),
+			"Nd" (port));
+}
+
+static __inline void
+outl (unsigned int value, unsigned short int port)
+{
+  __asm__ __volatile__ ("outl %0,%w1": :"a" (value), "Nd" (port));
+}
+
+static __inline void
+outl_p (unsigned int value, unsigned short int port)
+{
+  __asm__ __volatile__ ("outl %0,%w1\noutb %%al,$0x80": :"a" (value),
+			"Nd" (port));
+}
+
+static __inline void
+insb (unsigned short int port, void *addr, unsigned long int count)
+{
+  __asm__ __volatile__ ("cld ; rep ; insb":"=D" (addr),
+			"=c" (count):"d" (port), "0" (addr), "1" (count));
+}
+
+static __inline void
+insw (unsigned short int port, void *addr, unsigned long int count)
+{
+  __asm__ __volatile__ ("cld ; rep ; insw":"=D" (addr),
+			"=c" (count):"d" (port), "0" (addr), "1" (count));
+}
+
+static __inline void
+insl (unsigned short int port, void *addr, unsigned long int count)
+{
+  __asm__ __volatile__ ("cld ; rep ; insl":"=D" (addr),
+			"=c" (count):"d" (port), "0" (addr), "1" (count));
+}
+
+static __inline void
+outsb (unsigned short int port, const void *addr, unsigned long int count)
+{
+  __asm__ __volatile__ ("cld ; rep ; outsb":"=S" (addr),
+			"=c" (count):"d" (port), "0" (addr), "1" (count));
+}
+
+static __inline void
+outsw (unsigned short int port, const void *addr, unsigned long int count)
+{
+  __asm__ __volatile__ ("cld ; rep ; outsw":"=S" (addr),
+			"=c" (count):"d" (port), "0" (addr), "1" (count));
+}
+
+static __inline void
+outsl (unsigned short int port, const void *addr, unsigned long int count)
+{
+  __asm__ __volatile__ ("cld ; rep ; outsl":"=S" (addr),
+			"=c" (count):"d" (port), "0" (addr), "1" (count));
+}
+
+#endif	/* GNU C */
+
+__END_DECLS
+#endif /* _SYS_IO_H */
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/x86_64/sys/perm.h
@@ -0,0 +1,31 @@
+/* Copyright (C) 1996, 1999, 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _SYS_PERM_H
+#define _SYS_PERM_H	1
+
+#include <features.h>
+
+__BEGIN_DECLS
+
+/* Change I/O privilege level.  */
+extern int iopl (int __level) __THROW;
+
+__END_DECLS
+
+#endif	/* _SYS_PERM_H */
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/x86_64/sys_fork.S
@@ -0,0 +1,36 @@
+/* Copyright (C) 1991-1992, 1994-1995, 1997, 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sysdep.h>
+
+.text;
+ENTRY (__syscall_fork)
+	DO_CALL (fork, 0)
+	jb SYSCALL_ERROR_LABEL;
+	/* R1 is now 0 for the parent and 1 for the child.  Decrement it to
+	   make it -1 (all bits set) for the parent, and 0 (no bits set)
+	   for the child.  Then AND it with R0, so the parent gets
+	   R0&-1==R0, and the child gets R0&0==0.  */
+
+	decq	%rdx
+	andq	%rdx, %rax
+
+L(pseudo_end):
+	ret
+PSEUDO_END (__syscall_fork)
+libc_hidden_def (__syscall_fork)
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/x86_64/sysarch.h
@@ -0,0 +1,48 @@
+/* Parameters for the architecture specific system call.  amd64 version.
+   Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _SYSARCH_H
+#define _SYSARCH_H	1
+
+#include <features.h>
+
+/* Function that can be used as first argument to 'sysarch'.  */
+
+#define	I386_GET_FSBASE		7
+#define	I386_SET_FSBASE		8
+#define	I386_GET_GSBASE		9
+#define	I386_SET_GSBASE		10
+
+/* Leave space for 0-127 for to avoid translating syscalls */
+#define	AMD64_GET_FSBASE	128
+#define	AMD64_SET_FSBASE	129
+#define	AMD64_GET_GSBASE	130
+#define	AMD64_SET_GSBASE	131
+
+__BEGIN_DECLS
+
+extern int sysarch (int __cmd, void *__arg);
+
+#ifdef _LIBC
+extern int __sysarch (int __cmd, void *__arg);
+#endif
+
+__END_DECLS
+
+#endif /* _SYSARCH_H */
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/x86_64/syscall.S
@@ -0,0 +1,31 @@
+/* Copyright (C) 2006 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Modification for FreeBSD contributed by Petr Salinger, 2006.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sysdep.h>
+
+	.text
+ENTRY (__syscall)
+	movq %rcx, %r10
+	movl $SYS_ify (syscall), %eax
+	syscall
+	jb SYSCALL_ERROR_LABEL
+L(pseudo_end):
+	ret
+PSEUDO_END (__syscall)
+weak_alias (__syscall, syscall)
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/x86_64/sysdep.S
@@ -0,0 +1,40 @@
+/* Copyright (C) 2001, 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sysdep.h>
+
+/* The following code is only used in the shared library when we
+   compile the reentrant version.  Otherwise each system call defines
+   each own version.  */
+
+#ifndef PIC
+
+/* The syscall stubs jump here when they detect an error.
+   The code for Linux is almost identical to the canonical Unix
+   code, except that the error number in %rax is negated.  */
+
+#undef CALL_MCOUNT
+#define CALL_MCOUNT /* Don't insert the profiling call, it clobbers %rax.  */
+
+	.text
+ENTRY (__syscall_error)
+
+#define __syscall_error __syscall_error_1
+#include <sysdeps/unix/x86_64/sysdep.S>
+
+#endif	/* !PIC */
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/x86_64/sysdep.h
@@ -0,0 +1,233 @@
+/* Copyright (C) 2001,02,03,04 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Modification for FreeBSD contributed by Petr Salinger, 2006.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _KFREEBSD_X86_64_SYSDEP_H
+#define _KFREEBSD_X86_64_SYSDEP_H 1
+
+/* There is some commonality.  */
+#include <sysdeps/unix/x86_64/sysdep.h>
+#include <bp-sym.h>
+#include <bp-asm.h>
+#include <tls.h>
+
+#ifdef IS_IN_rtld
+# include <dl-sysdep.h>		/* Defines RTLD_PRIVATE_ERRNO.  */
+#endif
+
+
+#ifdef __ASSEMBLER__
+
+/* We don't want the label for the error handle to be global when we define
+   it here.  */
+#ifdef PIC
+# define SYSCALL_ERROR_LABEL 0f
+#else
+# define SYSCALL_ERROR_LABEL syscall_error
+#endif
+
+#undef	PSEUDO
+#define	PSEUDO(name, syscall_name, args)				      \
+  .text;								      \
+  ENTRY (name)								      \
+    DO_CALL (syscall_name, args);					      \
+    jb SYSCALL_ERROR_LABEL;						      \
+  L(pseudo_end):
+
+#undef	PSEUDO_END
+#define	PSEUDO_END(name)						      \
+  SYSCALL_ERROR_HANDLER							      \
+  END (name)
+
+#undef	PSEUDO_NOERRNO
+#define	PSEUDO_NOERRNO(name, syscall_name, args) \
+  .text;								      \
+  ENTRY (name)								      \
+    DO_CALL (syscall_name, args)
+
+#undef	PSEUDO_END_NOERRNO
+#define	PSEUDO_END_NOERRNO(name) \
+  END (name)
+
+#define ret_NOERRNO ret
+
+#undef	PSEUDO_ERRVAL
+#define	PSEUDO_ERRVAL(name, syscall_name, args) \
+  .text;								      \
+  ENTRY (name)								      \
+    DO_CALL (syscall_name, args);					      \
+
+#undef	PSEUDO_END_ERRVAL
+#define	PSEUDO_END_ERRVAL(name) \
+  END (name)
+
+#define ret_ERRVAL ret
+
+#ifndef PIC
+#define SYSCALL_ERROR_HANDLER	/* Nothing here; code in sysdep.S is used.  */
+#elif RTLD_PRIVATE_ERRNO
+# define SYSCALL_ERROR_HANDLER			\
+0:						\
+  leaq rtld_errno(%rip), %rcx;			\
+  movl %eax, (%rcx);				\
+  orq $-1, %rax;				\
+  jmp L(pseudo_end);
+#elif USE___THREAD
+# ifndef NOT_IN_libc
+#  define SYSCALL_ERROR_ERRNO __libc_errno
+# else
+#  define SYSCALL_ERROR_ERRNO errno
+# endif
+# define SYSCALL_ERROR_HANDLER			\
+0:						\
+  movq SYSCALL_ERROR_ERRNO@GOTTPOFF(%rip), %rcx;\
+  movl %eax, %fs:(%rcx);			\
+  orq $-1, %rax;				\
+  jmp L(pseudo_end);
+#elif defined _LIBC_REENTRANT
+/* Store (%eax) into errno through the GOT.
+   Note that errno occupies only 4 bytes.  */
+# define SYSCALL_ERROR_HANDLER			\
+0:						\
+  pushq %rax;					\
+  cfi_adjust_cfa_offset(8);			\
+  PUSH_ERRNO_LOCATION_RETURN;			\
+  call BP_SYM (__errno_location)@PLT;		\
+  POP_ERRNO_LOCATION_RETURN;			\
+  popq %rdx;					\
+  cfi_adjust_cfa_offset(-8);			\
+  movl %edx, (%rax);				\
+  orq $-1, %rax;				\
+  jmp L(pseudo_end);
+
+/* A quick note: it is assumed that the call to `__errno_location' does
+   not modify the stack!  */
+#else /* Not _LIBC_REENTRANT.  */
+# define SYSCALL_ERROR_HANDLER			\
+0:movq errno@GOTPCREL(%RIP), %rcx;		\
+  movl %eax, (%rcx);				\
+  orq $-1, %rax;				\
+  jmp L(pseudo_end);
+#endif	/* PIC */
+
+/* The FreeBSD/amd64 kernel expects the system call parameters in
+   registers according to the following table:
+
+    syscall number	rax
+    arg 1		rdi
+    arg 2		rsi
+    arg 3		rdx
+    arg 4		r10
+    arg 5		r8
+    arg 6		r9
+
+    The FreeBSD kernel internal syscall usage of registers:
+
+    preserved:
+	stack pointer			rsp
+	C preserved			rbx, rbp, r12-r15
+	some input params		rdi, rsi
+
+    destroyed:
+	return value(s)			rax, rdx, eflags
+	return address from syscall	rcx
+	eflags from syscall		r11
+	used internally			r8-r10
+
+    Normal function call, including calls to the system call stub
+    functions in the libc, get the first six parameters passed in
+    registers and the seventh parameter and later on the stack.  The
+    register use is as follows:
+
+     system call number	in the DO_CALL macro
+     arg 1		rdi
+     arg 2		rsi
+     arg 3		rdx
+     arg 4		rcx
+     arg 5		r8
+     arg 6		r9
+
+    We have to take care that the stack is aligned to 16 bytes.  When
+    called the stack is not aligned since the return address has just
+    been pushed.
+
+*/
+
+#undef	DO_CALL
+#define DO_CALL(syscall_name, args)		\
+    DOARGS_##args				\
+    movl $SYS_ify (syscall_name), %eax;		\
+    syscall;
+
+#define DOARGS_0 /* nothing */
+#define DOARGS_1 /* nothing */
+#define DOARGS_2 /* nothing */
+#define DOARGS_3 /* nothing */
+#define DOARGS_4 movq %rcx, %r10;
+#define DOARGS_5 DOARGS_4
+#define DOARGS_6 DOARGS_5
+#define DOARGS_7 DOARGS_6
+#define DOARGS_8 DOARGS_7
+
+#else   /* !__ASSEMBLER__ */
+
+#include <syscalls-inline.h>
+
+#endif	/* __ASSEMBLER__ */
+
+
+/* Pointer mangling support.  */
+#if defined NOT_IN_libc && defined IS_IN_rtld
+/* We cannot use the thread descriptor because in ld.so we use setjmp
+   earlier than the descriptor is initialized.  */
+# ifdef __ASSEMBLER__
+#  define PTR_MANGLE(reg)	xorq __pointer_chk_guard_local(%rip), reg;    \
+				rolq $17, reg
+#  define PTR_DEMANGLE(reg)	rorq $17, reg;				      \
+				xorq __pointer_chk_guard_local(%rip), reg
+# else
+#  define PTR_MANGLE(reg)	asm ("xorq __pointer_chk_guard_local(%%rip), %0\n" \
+				     "rolq $17, %0"			      \
+				     : "=r" (reg) : "0" (reg))
+#  define PTR_DEMANGLE(reg)	asm ("rorq $17, %0\n"			      \
+				     "xorq __pointer_chk_guard_local(%%rip), %0" \
+				     : "=r" (reg) : "0" (reg))
+# endif
+#else
+# ifdef __ASSEMBLER__
+#  define PTR_MANGLE(reg)	xorq %fs:POINTER_GUARD, reg;		      \
+				rolq $17, reg
+#  define PTR_DEMANGLE(reg)	rorq $17, reg;				      \
+				xorq %fs:POINTER_GUARD, reg
+# else
+#  define PTR_MANGLE(var)	asm ("xorq %%fs:%c2, %0\n"		      \
+				     "rolq $17, %0"			      \
+				     : "=r" (var)			      \
+				     : "0" (var),			      \
+				       "i" (offsetof (tcbhead_t,	      \
+						      pointer_guard)))
+#  define PTR_DEMANGLE(var)	asm ("rorq $17, %0\n"			      \
+				     "xorq %%fs:%c2, %0"		      \
+				     : "=r" (var)			      \
+				     : "0" (var),			      \
+				       "i" (offsetof (tcbhead_t,	      \
+						      pointer_guard)))
+# endif
+#endif
+
+#endif /* _KFREEBSD_X86_64_SYSDEP_H  */
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/x86_64/ucontext_i.h
@@ -0,0 +1,38 @@
+/* Offsets  needed in the makecontext() function implementation.
+   Copyright (C) 2006 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+/* Offsets of the fields in the ucontext_t structure. */
+
+#define oRDI		24
+#define oRSI		32
+#define oRDX		40
+#define oRCX		48
+#define oR8		56
+#define oR9		64
+
+#define oRAX		72
+#define oRBX		80
+#define oRBP		88
+
+#define oRIP		176
+#define oRSP		200
+
+#define oLINK		816
+#define oSS_SP		824
+#define oSS_SIZE	832
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/x86_64/vfork.S
@@ -0,0 +1,58 @@
+/* Copyright (C) 1999, 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sysdep.h>
+
+/* Clone the calling process, but without copying the whole address space.
+   The calling process is suspended until the new process exits or is
+   replaced by a call to `execve'.  Return -1 for errors, 0 to the new process,
+   and the process ID of the new process to the old process.  */
+
+ENTRY (__vfork)
+
+	/* Pop the return PC value into ESI.  */
+	popq	%rsi
+	cfi_adjust_cfa_offset(-8)
+
+	/* Perform the system call.  */
+	DO_CALL (vfork, 0)
+	jb	L(error)	/* Branch forward if it failed.  */
+
+	/* In the parent process, %rdx == 0, %rax == child pid.  */
+	/* In the child process, %rdx == 1, %rax == parent pid.  */
+
+	/* Change %rax to be 0 in the child process.  */
+	decq	%rdx
+	andq	%rdx, %rax
+
+	/* Jump to the return PC.  */
+	jmp	*%rsi
+
+L(error):
+	/* Push back the return PC.  */
+	pushq	%rsi
+	cfi_adjust_cfa_offset(8)
+
+	/* Branch to the error handler, hidden in PSEUDO_END.  */
+	jmp	SYSCALL_ERROR_LABEL
+L(pseudo_end):
+	ret
+PSEUDO_END (__vfork)
+libc_hidden_def (__vfork)
+
+weak_alias (__vfork, vfork)
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/xmknod.c
@@ -0,0 +1,48 @@
+/* xmknod call using old-style Unix mknod and mkfifo system calls.
+   Copyright (C) 1991, 1993, 1995-1997, 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <errno.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+
+extern int __syscall_mknod (const char *, mode_t, dev_t);
+extern int __mkfifo (const char *, mode_t);
+
+/* Create a device file named PATH, with permission and special bits MODE
+   and device number DEV (which can be constructed from major and minor
+   device numbers with the `makedev' macro above).  */
+int
+__xmknod (int vers, const char *path, mode_t mode, dev_t *dev)
+{
+  if (vers != _MKNOD_VER)
+    {
+      __set_errno (EINVAL);
+      return -1;
+    }
+
+  /* The FreeBSD mknod() system call cannot be used to create FIFOs; we
+     must use the mkfifo() system call for this purpose.  */
+  if (S_ISFIFO (mode))
+    return __mkfifo (path, mode & ~S_IFMT);
+
+  return __syscall_mknod (path, mode, *dev);
+}
+libc_hidden_def (__xmknod)
+
+weak_alias (__xmknod, _xmknod)
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/xstat.c
@@ -0,0 +1,49 @@
+/* xstat using FreeBSD stat, nstat system calls.
+   Copyright (C) 1991,1995-1997,2000,2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <errno.h>
+#include <stddef.h>
+#include <sys/stat.h>
+#include <bp-checks.h>
+
+#include "stat16conv.c"
+
+int
+__xstat (int vers, const char *file, struct stat *buf)
+{
+  if (__builtin_expect (vers == _STAT_VER, 1))
+    {
+      struct stat16 buf16;
+      int result = __syscall_stat (CHECK_STRING (file), __ptrvalue (&buf16));
+      if (result == 0)
+	stat16_to_stat (&buf16, buf);
+      return result;
+    }
+  else if (__builtin_expect (vers == _STAT_VER_stat, 1))
+    return __syscall_stat (CHECK_STRING (file),
+			   CHECK_1 ((struct stat16 *) buf));
+  else
+    {
+      __set_errno (EINVAL);
+      return -1;
+    }
+}
+hidden_def (__xstat)
+
+weak_alias (__xstat, _xstat)
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/xstat64.c
@@ -0,0 +1,44 @@
+/* xstat using FreeBSD stat, nstat system calls.
+   Copyright (C) 1991,1995-1997,2000,2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <errno.h>
+#include <stddef.h>
+#include <sys/stat.h>
+#include <bp-checks.h>
+
+#include "stat16conv.c"
+
+int
+__xstat64 (int vers, const char *file, struct stat64 *buf)
+{
+  if (__builtin_expect (vers == _STAT_VER, 1))
+    {
+      struct stat16 buf16;
+      int result = __syscall_stat (CHECK_STRING (file), __ptrvalue (&buf16));
+      if (result == 0)
+	stat16_to_stat64 (&buf16, buf);
+      return result;
+    }
+  else
+    {
+      __set_errno (EINVAL);
+      return -1;
+    }
+}
+hidden_def (__xstat64)
