#! /bin/sh -e

# All lines beginning with `# DP:' are a description of the patch.
# DP: Description: 
# DP: Related bugs: Ubuntu#7897
# DP: Dpatch author: Jeff Bailey
# DP: Patch author:  Jakub
# DP: Upstream status: In CVS
# DP: Status Details: 
# DP: Date: 2005-03-22

PATCHLEVEL=1

if [ $# -ne 2 ]; then
    echo >&2 "`basename $0`: script expects -patch|-unpatch as argument"
    exit 1
fi
case "$1" in
    -patch) patch -d "$2" -f --no-backup-if-mismatch -p$PATCHLEVEL < $0;;
    -unpatch) patch -d "$2" -f --no-backup-if-mismatch -R -p$PATCHLEVEL < $0;;
    *)
	echo >&2 "`basename $0`: script expects -patch|-unpatch as argument"
	exit 1
esac
exit 0

# append the patch here and adjust the -p? flag in the patch calls.

2003-12-19  Jakub Jelinek  <jakub@redhat.com>

	* libc-cancellation.c (__libc_enable_asynccancel): Don't cancel
	if CANCELSTATE_BITMASK is set.
	* sysdeps/pthread/librt-cancellation.c (__librt_enable_asynccancel):
	Likewise.

	* Makefile (tests): Add tst-cancel22 and tst-cancel23.
	(tests-reverse): Add tst-cancel23.
	* tst-cancel22.c: New test.
	* tst-cancel23.c: New test.

2003-11-05  Jakub Jelinek  <jakub@redhat.com>

	* unwind.c (FRAME_LEFT): Define.
	(unwind_stop): Handle old style cleanups here.
	(__pthread_unwind): Handle old style cleanups only if
	!HAVE_FORCED_UNWIND.


--- libc/nptl/Makefile	19 Dec 2003 01:34:09 -0000	1.132
+++ libc/nptl/Makefile	21 Dec 2003 20:05:16 -0000	1.133
@@ -215,7 +215,7 @@
 	tst-cancel1 tst-cancel2 tst-cancel3 tst-cancel4 tst-cancel5 \
 	tst-cancel6 tst-cancel7 tst-cancel8 tst-cancel9 tst-cancel10 \
 	tst-cancel11 tst-cancel12 tst-cancel13 tst-cancel14 tst-cancel15 \
-	tst-cancel16 tst-cancel17 tst-cancel18 \
+	tst-cancel16 tst-cancel17 tst-cancel18 tst-cancel22 tst-cancel23 \
 	tst-cleanup0 tst-cleanup1 tst-cleanup2 tst-cleanup3 \
 	tst-flock1 tst-flock2 \
 	tst-signal1 tst-signal2 tst-signal3 tst-signal4 tst-signal5 \
@@ -326,7 +326,7 @@ ifeq ($(build-static),yes)
 tests-static += tst-locale1 tst-locale2
 endif
 # These tests are linked with libc before libpthread
-tests-reverse += tst-cancel5
+tests-reverse += tst-cancel5 tst-cancel23
 
 include ../Rules
 
--- libc/nptl/libc-cancellation.c	2 Jul 2003 05:12:20 -0000	1.9
+++ libc/nptl/libc-cancellation.c	20 Dec 2003 06:31:25 -0000	1.10
@@ -42,8 +42,9 @@ __libc_enable_asynccancel (void)
 
       if (__builtin_expect ((oldval & CANCELED_BITMASK) != 0, 0))
 	{
-	  /* If we are already exiting stop right here.  */
-	  if ((oldval & EXITING_BITMASK) != 0)
+	  /* If we are already exiting or if PTHREAD_CANCEL_DISABLED,
+	     stop right here.  */
+	  if ((oldval & (EXITING_BITMASK | CANCELSTATE_BITMASK)) != 0)
 	    break;
 
 	  int curval = THREAD_ATOMIC_CMPXCHG_VAL (self, cancelhandling,
--- libc/nptl/tst-cancel22.c	1 Jan 1970 00:00:00 -0000
+++ libc/nptl/tst-cancel22.c	20 Dec 2003 06:32:20 -0000	1.1
@@ -0,0 +1,121 @@
+/* Copyright (C) 2003 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Jakub Jelinek <jakub@redhat.com>, 2003.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <errno.h>
+#include <pthread.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <unistd.h>
+
+pthread_barrier_t b;
+int seen;
+
+static void *
+tf (void *arg)
+{
+  int old;
+  int r = pthread_setcancelstate (PTHREAD_CANCEL_DISABLE, &old);
+  if (r != 0)
+    {
+      puts ("setcancelstate failed");
+      exit (1);
+    }
+
+  r = pthread_barrier_wait (&b);
+  if (r != 0 && r != PTHREAD_BARRIER_SERIAL_THREAD)
+    {
+      puts ("barrier_wait failed");
+      exit (1);
+    }
+
+  for (int i = 0; i < 10; ++i)
+    {
+      struct timespec ts = { .tv_sec = 0, .tv_nsec = 100000000 };
+      TEMP_FAILURE_RETRY (nanosleep (&ts, &ts));
+    }
+
+  seen = 1;
+  pthread_setcancelstate (old, NULL);
+
+  struct timespec ts = { .tv_sec = 0, .tv_nsec = 100000000 };
+  TEMP_FAILURE_RETRY (nanosleep (&ts, &ts));
+
+  exit (1);
+}
+
+
+static int
+do_test (void)
+{
+  if (pthread_barrier_init (&b, NULL, 2) != 0)
+   {
+     puts ("barrier init failed");
+     return 1;
+   }
+
+  pthread_t th;
+  if (pthread_create (&th, NULL, tf, NULL) != 0)
+    {
+      puts ("thread creation failed");
+      return 1;
+    }
+
+  int r = pthread_barrier_wait (&b);
+  if (r != 0 && r != PTHREAD_BARRIER_SERIAL_THREAD)
+    {
+      puts ("barrier_wait failed");
+      return 1;
+    }
+
+  if (pthread_cancel (th) != 0)
+    {
+      puts ("cancel failed");
+      return 1;
+    }
+
+  void *status;
+  if (pthread_join (th, &status) != 0)
+    {
+      puts ("join failed");
+      return 1;
+    }
+  if (status != PTHREAD_CANCELED)
+    {
+      puts ("thread not canceled");
+      return 1;
+    }
+
+  if (pthread_barrier_destroy (&b) != 0)
+    {
+      puts ("barrier_destroy failed");
+      return 1;
+    }
+
+  if (seen != 1)
+    {
+      puts ("thread cancelled when PTHREAD_CANCEL_DISABLED");
+      return 1;
+    }
+
+  return 0;
+}
+
+#define TIMEOUT 5
+#define TEST_FUNCTION do_test ()
+#include "../test-skeleton.c"
--- libc/nptl/tst-cancel23.c	1 Jan 1970 00:00:00 -0000
+++ libc/nptl/tst-cancel23.c	20 Dec 2003 06:32:20 -0000	1.1
@@ -0,0 +1 @@
+#include "tst-cancel22.c"
--- libc/nptl/sysdeps/pthread/librt-cancellation.c	3 Jul 2003 07:35:59 -0000	1.3
+++ libc/nptl/sysdeps/pthread/librt-cancellation.c	20 Dec 2003 06:31:48 -0000	1.4
@@ -41,8 +41,9 @@ __librt_enable_asynccancel (void)
 
       if (__builtin_expect ((oldval & CANCELED_BITMASK) != 0, 0))
 	{
-	  /* If we are already exiting stop right here.  */
-	  if ((oldval & EXITING_BITMASK) != 0)
+	  /* If we are already exiting or if PTHREAD_CANCEL_DISABLED,
+	     stop right here.  */
+	  if ((oldval & (EXITING_BITMASK | CANCELSTATE_BITMASK)) != 0)
 	    break;
 
 	  int curval = THREAD_ATOMIC_CMPXCHG_VAL (self, cancelhandling,
--- libc/nptl/unwind.c	4 Sep 2003 05:43:37 -0000	1.9
+++ libc/nptl/unwind.c	6 Nov 2003 04:29:04 -0000	1.10
@@ -27,6 +27,14 @@
 
 #ifdef HAVE_FORCED_UNWIND
 
+#ifdef _STACK_GROWS_DOWN
+# define FRAME_LEFT(frame, other) ((char *) frame >= (char *) other)
+#elif _STACK_GROWS_UP
+# define FRAME_LEFT(frame, other) ((char *) frame <= (char *) other)
+#else
+# error "Define either _STACK_GROWS_DOWN or _STACK_GROWS_UP"
+#endif
+
 static _Unwind_Reason_Code
 unwind_stop (int version, _Unwind_Action actions,
 	     _Unwind_Exception_Class exc_class,
@@ -34,6 +42,9 @@ unwind_stop (int version, _Unwind_Action
 	     struct _Unwind_Context *context, void *stop_parameter)
 {
   struct pthread_unwind_buf *buf = stop_parameter;
+  struct pthread *self = THREAD_SELF;
+  struct _pthread_cleanup_buffer *curp = THREAD_GETMEM (self, cleanup);
+  int do_longjump = 0;
 
   /* Do longjmp if we're at "end of stack", aka "end of unwind data".
      We assume there are only C frame without unwind data in between
@@ -42,6 +53,37 @@ unwind_stop (int version, _Unwind_Action
      previous frame.  */
   if ((actions & _UA_END_OF_STACK)
       || ! _JMPBUF_CFA_UNWINDS  (buf->cancel_jmp_buf[0].jmp_buf, context))
+    do_longjump = 1;
+
+  if (__builtin_expect (curp != NULL, 0))
+    {
+      /* Handle the compatibility stuff.  Execute all handlers
+	 registered with the old method which would be unwound by this
+	 step.  */
+      struct _pthread_cleanup_buffer *oldp = buf->priv.data.cleanup;
+      void *cfa = (void *) _Unwind_GetCFA (context);
+
+      if (curp != oldp && (do_longjump || FRAME_LEFT (cfa, curp)))
+	{
+	  do
+	    {
+	      /* Pointer to the next element.  */
+	      struct _pthread_cleanup_buffer *nextp = curp->__prev;
+
+	      /* Call the handler.  */
+	      curp->__routine (curp->__arg);
+
+	      /* To the next.  */
+	      curp = nextp;
+	    }
+	  while (curp != oldp && (do_longjump || FRAME_LEFT (cfa, curp)));
+
+	  /* Mark the current element as handled.  */
+	  THREAD_SETMEM (self, cleanup, curp);
+	}
+    }
+
+  if (do_longjump)
     __libc_longjmp ((struct __jmp_buf_tag *) buf->cancel_jmp_buf, 1);
 
   return _URC_NO_REASON;
@@ -70,6 +112,14 @@ __pthread_unwind (__pthread_unwind_buf_t
   struct pthread_unwind_buf *ibuf = (struct pthread_unwind_buf *) buf;
   struct pthread *self = THREAD_SELF;
 
+#ifdef HAVE_FORCED_UNWIND
+  /* This is not a catchable exception, so don't provide any details about
+     the exception type.  We do need to initialize the field though.  */
+  THREAD_SETMEM (self, exc.exception_class, 0);
+  THREAD_SETMEM (self, exc.exception_cleanup, unwind_cleanup);
+
+  _Unwind_ForcedUnwind (&self->exc, unwind_stop, ibuf);
+#else
   /* Handle the compatibility stuff first.  Execute all handlers
      registered with the old method.  We don't execute them in order,
      instead, they will run first.  */
@@ -95,14 +145,6 @@ __pthread_unwind (__pthread_unwind_buf_t
       THREAD_SETMEM (self, cleanup, curp);
     }
 
-#ifdef HAVE_FORCED_UNWIND
-  /* This is not a catchable exception, so don't provide any details about
-     the exception type.  We do need to initialize the field though.  */
-  THREAD_SETMEM (self, exc.exception_class, 0);
-  THREAD_SETMEM (self, exc.exception_cleanup, unwind_cleanup);
-
-  _Unwind_ForcedUnwind (&self->exc, unwind_stop, ibuf);
-#else
   /* We simply jump to the registered setjmp buffer.  */
   __libc_longjmp ((struct __jmp_buf_tag *) ibuf->cancel_jmp_buf, 1);
 #endif

