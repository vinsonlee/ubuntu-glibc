#! /bin/sh -e

# All lines beginning with `# DP:' are a description of the patch.
# DP: Description: fix ioperm build error on arm

if [ $# -ne 2 ]; then
    echo >&2 "`basename $0`: script expects -patch|-unpatch as argument"
    exit 1
fi
case "$1" in
    -patch) patch -d "$2" -f --no-backup-if-mismatch -p0 < $0;;
    -unpatch) patch -d "$2" -f --no-backup-if-mismatch -R -p0 < $0;;
    *)
	echo >&2 "`basename $0`: script expects -patch|-unpatch as argument"
	exit 1
esac
exit 0

--- Makeconfig.orig	2006-03-23 17:32:26.000000000 +0100
+++ Makeconfig	2006-03-23 14:13:10.000000000 +0100
@@ -904,7 +904,7 @@
 # is more or less arbitrary.  The sorting step will take care of the
 # dependencies.  Only the $(binfmt-subdir) should always be kept at the
 # end of the list.
-all-subdirs = csu assert ctype locale intl catgets math setjmp signal	    \
+all-subdirs = soft-fp csu assert ctype locale intl catgets math setjmp signal	    \
 	      stdlib stdio-common libio malloc string wcsmbs time dirent \
 	      grp pwd posix io termios resource misc socket sysvipc gmon    \
 	      gnulib iconv iconvdata wctype manual shadow po argp	    \
--- sysdeps/arm/sfp-machine.h	1970-01-01 01:00:00.000000000 +0100
+++ sysdeps/arm/sfp-machine.h	2000-09-05 10:41:37.000000000 +0200
@@ -0,0 +1,47 @@
+#define _FP_W_TYPE_SIZE		32
+#define _FP_W_TYPE		unsigned long
+#define _FP_WS_TYPE		signed long
+#define _FP_I_TYPE		long
+
+#define _FP_MUL_MEAT_S(R,X,Y)				\
+  _FP_MUL_MEAT_1_wide(_FP_WFRACBITS_S,R,X,Y,umul_ppmm)
+#define _FP_MUL_MEAT_D(R,X,Y)				\
+  _FP_MUL_MEAT_2_wide(_FP_WFRACBITS_D,R,X,Y,umul_ppmm)
+#define _FP_MUL_MEAT_Q(R,X,Y)				\
+  _FP_MUL_MEAT_4_wide(_FP_WFRACBITS_Q,R,X,Y,umul_ppmm)
+
+#define _FP_DIV_MEAT_S(R,X,Y)	_FP_DIV_MEAT_1_udiv_norm(S,R,X,Y)
+#define _FP_DIV_MEAT_D(R,X,Y)	_FP_DIV_MEAT_2_udiv(D,R,X,Y)
+#define _FP_DIV_MEAT_Q(R,X,Y)	_FP_DIV_MEAT_4_udiv(Q,R,X,Y)
+
+#define _FP_NANFRAC_S		((_FP_QNANBIT_S << 1) - 1)
+#define _FP_NANFRAC_D		((_FP_QNANBIT_D << 1) - 1), -1
+#define _FP_NANFRAC_Q		((_FP_QNANBIT_Q << 1) - 1), -1, -1, -1
+#define _FP_NANSIGN_S		0
+#define _FP_NANSIGN_D		0
+#define _FP_NANSIGN_Q		0
+
+#define _FP_KEEPNANFRACP 1
+/* From my experiments it seems X is chosen unless one of the
+   NaNs is sNaN,  in which case the result is NANSIGN/NANFRAC.  */
+#define _FP_CHOOSENAN(fs, wc, R, X, Y, OP)			\
+  do {								\
+    if ((_FP_FRAC_HIGH_RAW_##fs(X) |				\
+	 _FP_FRAC_HIGH_RAW_##fs(Y)) & _FP_QNANBIT_##fs)		\
+      {								\
+	R##_s = _FP_NANSIGN_##fs;				\
+        _FP_FRAC_SET_##wc(R,_FP_NANFRAC_##fs);			\
+      }								\
+    else							\
+      {								\
+	R##_s = X##_s;						\
+        _FP_FRAC_COPY_##wc(R,X);				\
+      }								\
+    R##_c = FP_CLS_NAN;						\
+  } while (0)
+
+#define FP_EX_INVALID           (1 << 4)
+#define FP_EX_DIVZERO           (1 << 3)
+#define FP_EX_OVERFLOW          (1 << 2)
+#define FP_EX_UNDERFLOW         (1 << 1)
+#define FP_EX_INEXACT           (1 << 0)
--- soft-fp/Makefile.orig	2006-03-23 23:58:48.000000000 +0100
+++ soft-fp/Makefile	2006-03-23 23:59:22.000000000 +0100
@@ -35,10 +35,14 @@
 	fixunstfdi floatditf extendsftf2 trunctfsf2 extenddftf2 \
 	trunctfdf2 sqrttf2
 
+routines = $(gcc-single-routines) \
+	$(gcc-double-routines) \
+	$(gcc-quad-routines)
+
+static-only-routines = $(routines)
+
 distribute := double.h op-1.h op-2.h op-4.h op-common.h quad.h \
 	single.h soft-fp.h extended.h Banner op-8.h testit.c \
-	$(addsuffix .c,$(gcc-single-routines)) \
-	$(addsuffix .c,$(gcc-double-routines)) \
-	$(addsuffix .c,$(gcc-quad-routines))
+	$(addsuffix .c,$(routines))
 
 include ../Rules
