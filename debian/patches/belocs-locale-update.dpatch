#! /bin/sh -e

# All lines beginning with `# DP:' are a description of the patch.
# DP: Description: Update locale and localedef binaries from Belocs
# DP: Related bugs: 
# DP: Dpatch author: Jeff Bailey
# DP: Patch author: Denis Barbier
# DP: Upstream status: Not submitted
# DP: Status Details: 
# DP: Date: 2005-11-30

PATCHLEVEL=1

if [ $# -ne 2 ]; then
    echo >&2 "`basename $0`: script expects -patch|-unpatch as argument"
    exit 1
fi
case "$1" in
    -patch) patch -d "$2" -f --no-backup-if-mismatch -p$PATCHLEVEL < $0;;
    -unpatch) patch -d "$2" -f --no-backup-if-mismatch -R -p$PATCHLEVEL < $0;;
    *)
	echo >&2 "`basename $0`: script expects -patch|-unpatch as argument"
	exit 1
esac
exit 0

# append the patch here and adjust the -p? flag in the patch calls.
--- glibc-2.3.5/locale/programs/charmap-dir.c	2003-01-13 03:58:54.000000000 -0500
+++ glibc-2.3.5/locale/programs/charmap-dir.c	2005-11-30 11:09:02.000000000 -0500
@@ -16,6 +16,10 @@
    Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
    02111-1307 USA.  */
 
+#ifdef HAVE_CONFIG_H
+# include <config.h>
+#endif
+
 #include <dirent.h>
 #include <errno.h>
 #include <error.h>
--- glibc-2.3.5/locale/programs/ld-address.c	2002-06-30 17:41:11.000000000 -0400
+++ glibc-2.3.5/locale/programs/ld-address.c	2005-11-30 11:09:02.000000000 -0500
@@ -1,4 +1,4 @@
-/* Copyright (C) 1998, 1999, 2000, 2001, 2002 Free Software Foundation, Inc.
+/* Copyright (C) 1998-2002, 2005 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
    Contributed by Ulrich Drepper <drepper@cygnus.com>, 1998.
 
@@ -26,6 +26,7 @@
 #include <langinfo.h>
 #include <string.h>
 #include <sys/uio.h>
+#include <stdlib.h>
 
 #include <assert.h>
 
@@ -34,12 +35,13 @@
 #include "locfile.h"
 
 
-static struct
+struct iso3166_t
 {
-  const char ab2[3];
-  const char ab3[4];
+  char ab2[3];
+  char ab3[4];
   uint32_t num;
-} iso3166[] =
+};
+static struct iso3166_t dft_iso3166[] =
 {
 #define DEFINE_COUNTRY_CODE(Name, Ab2, Ab3, Num) \
   { #Ab2, #Ab3, Num },
@@ -47,12 +49,13 @@
 };
 
 
-static struct
+struct iso639_t
 {
-  const char ab[3];
-  const char term[4];
-  const char lib[4];
-} iso639[] =
+  char ab[3];
+  char term[4];
+  char lib[4];
+};
+static struct iso639_t dft_iso639[] =
 {
 #define DEFINE_LANGUAGE_CODE(Name, Ab, Term, Lib) \
   { #Ab, #Term, #Lib },
@@ -96,6 +99,163 @@
     }
 }
 
+static void
+get_iso639_def(struct iso639_t **iso639, size_t *nr_iso639)
+{
+  FILE *fp;
+  char *line = NULL;
+  size_t linelength = 0, nelem = 0;
+  int n, cnt, in_string;
+  char *cp;
+  struct iso639_t *tab;
+
+  *iso639 = dft_iso639;
+  *nr_iso639 = sizeof (dft_iso639) / sizeof (dft_iso639[0]);
+  fp = fopen (LOCSRCDIR "/iso-639.def", "rm");
+  if (fp == NULL)
+    return;
+  /*  First get the number of elements.  */
+  while (1)
+    {
+      n = getline(&line, &linelength, fp);
+      if (n < 0)
+        break;
+      if (strncmp(line, "DEFINE_LANGUAGE_CODE", 20) == 0)
+        nelem++;
+    }
+  tab = (struct iso639_t *) xmalloc(nelem * sizeof (struct iso639_t));
+  nelem = 0;
+  rewind (fp);
+  while (1)
+    {
+      n = getline(&line, &linelength, fp);
+      if (n < 0)
+        break;
+      if (strncmp(line, "DEFINE_LANGUAGE_CODE", 20) == 0)
+        {
+          in_string = 0;
+          cnt = 0;
+          if (line[20] == '3')
+                  cnt++;
+          tab[nelem].ab[0] = tab[nelem].term[0] = tab[nelem].lib[0] = '\0';
+          for (cp = line+20; *cp != '\0'; cp++)
+            {
+              if (*cp == '"')
+                in_string = !in_string;
+              else if (*cp == ',' && !in_string)
+                {
+                  cnt++;
+                  cp++;
+                  while (*cp == ' ' || *cp == '\t')
+                    cp++;
+                  if (cnt == 1)
+                    {
+                      tab[nelem].ab[0] = *cp;
+                      tab[nelem].ab[1] = *(cp+1);
+                      tab[nelem].ab[2] = '\0';
+                    }
+                  else if (cnt == 2)
+                    {
+                      tab[nelem].term[0] = *cp;
+                      tab[nelem].term[1] = *(cp+1);
+                      tab[nelem].term[2] = *(cp+2);
+                      tab[nelem].term[3] = '\0';
+                    }
+                  else if (cnt == 3)
+                    {
+                      tab[nelem].lib[0] = *cp;
+                      tab[nelem].lib[1] = *(cp+1);
+                      tab[nelem].lib[2] = *(cp+2);
+                      tab[nelem].lib[3] = '\0';
+                    }
+                }
+            }
+          nelem++;
+        }
+    }
+  fclose (fp);
+  free(line);
+  *nr_iso639 = nelem;
+  *iso639 = tab;
+}
+
+
+static void
+get_iso3166_def(struct iso3166_t **iso3166, size_t *nr_iso3166)
+{
+  FILE *fp;
+  char *line = NULL;
+  size_t linelength = 0, nelem = 0;
+  int n, cnt, in_string;
+  char *cp;
+  struct iso3166_t *tab;
+
+  *iso3166 = dft_iso3166;
+  *nr_iso3166 = sizeof (dft_iso3166) / sizeof (dft_iso3166[0]);
+  fp = fopen (LOCSRCDIR "/iso-3166.def", "rm");
+  if (fp == NULL)
+    return;
+  /*  First get the number of elements.  */
+  while (!feof(fp))
+    {
+      n = getline(&line, &linelength, fp);
+      if (n < 0)
+        break;
+      if (strncmp(line, "DEFINE_COUNTRY_CODE", 19) == 0)
+        nelem++;
+    }
+  tab = (struct iso3166_t *) xmalloc(nelem * sizeof (struct iso3166_t));
+  nelem = 0;
+  rewind (fp);
+  while (1)
+    {
+      n = getline(&line, &linelength, fp);
+      if (n < 0)
+        break;
+      if (strncmp(line, "DEFINE_COUNTRY_CODE", 19) == 0)
+        {
+          in_string = 0;
+          cnt = 0;
+          tab[nelem].ab2[0] = tab[nelem].ab3[0] = '\0';
+          tab[nelem].num = 0;
+          for (cp = line+19; *cp != '\0'; cp++)
+            {
+              if (*cp == '"')
+                in_string = !in_string;
+              else if (*cp == ',' && !in_string)
+                {
+                  cnt++;
+                  cp++;
+                  while (*cp == ' ' || *cp == '\t')
+                    cp++;
+                  if (cnt == 1)
+                    {
+                      tab[nelem].ab2[0] = *cp;
+                      tab[nelem].ab2[1] = *(cp+1);
+                      tab[nelem].ab2[2] = '\0';
+                    }
+                  else if (cnt == 2)
+                    {
+                      tab[nelem].ab3[0] = *cp;
+                      tab[nelem].ab3[1] = *(cp+1);
+                      tab[nelem].ab3[2] = *(cp+2);
+                      tab[nelem].ab3[3] = '\0';
+                    }
+                  else if (cnt == 3)
+                    {
+                      tab[nelem].num = (uint32_t) strtol(cp, NULL, 10);
+                    }
+                }
+            }
+          nelem++;
+        }
+    }
+  fclose (fp);
+  free(line);
+  *nr_iso3166 = nelem;
+  *iso3166 = tab;
+}
+
 
 void
 address_finish (struct localedef_t *locale, const struct charmap_t *charmap)
@@ -104,6 +264,11 @@
   size_t cnt;
   int helper;
   int nothing = 0;
+  struct iso3166_t *iso3166;
+  struct iso639_t *iso639;
+  size_t nr_iso3166, nr_iso639;
+  get_iso3166_def(&iso3166, &nr_iso3166);
+  get_iso639_def(&iso639, &nr_iso639);
 
   /* Now resolve copying and also handle completely missing definitions.  */
   if (address == NULL)
@@ -201,22 +366,22 @@
 	WITH_CUR_LOCALE (error (0, 0, _("%s: field `%s' not defined"),
 				"LC_ADDRESS", "lang_term"));
       address->lang_term = "";
-      cnt = sizeof (iso639) / sizeof (iso639[0]);
+      cnt = nr_iso639;
     }
   else if (address->lang_term[0] == '\0')
     {
       if (verbose)
 	WITH_CUR_LOCALE (error (0, 0, _("%s: field `%s' must not be empty"),
 				"LC_ADDRESS", "lang_term"));
-      cnt = sizeof (iso639) / sizeof (iso639[0]);
+      cnt = nr_iso639;
     }
   else
     {
       /* Look for this language in the table.  */
-      for (cnt = 0; cnt < sizeof (iso639) / sizeof (iso639[0]); ++cnt)
+      for (cnt = 0; cnt < nr_iso639; ++cnt)
 	if (strcmp (address->lang_term, iso639[cnt].term) == 0)
 	  break;
-      if (cnt == sizeof (iso639) / sizeof (iso639[0]))
+      if (cnt == nr_iso639)
 	WITH_CUR_LOCALE (error (0, 0, _("\
 %s: terminology language code `%s' not defined"),
 				"LC_ADDRESS", address->lang_term));
@@ -224,26 +389,33 @@
 
   if (address->lang_ab == NULL)
     {
-      if (verbose && ! nothing)
+      if (iso639[cnt].ab[0] != '\0' && verbose && ! nothing)
 	WITH_CUR_LOCALE (error (0, 0, _("%s: field `%s' not defined"),
 				"LC_ADDRESS", "lang_ab"));
       address->lang_ab = "";
     }
   else if (address->lang_ab[0] == '\0')
     {
-      if (verbose)
+      if (iso639[cnt].ab[0] != '\0' && verbose)
 	WITH_CUR_LOCALE (error (0, 0, _("%s: field `%s' must not be empty"),
 				"LC_ADDRESS", "lang_ab"));
     }
+  else if (iso639[cnt].ab[0] == '\0')
+    {
+      WITH_CUR_LOCALE (error (0, 0, _("%s: field `%s' must not be defined"),
+			      "LC_ADDRESS", "lang_ab"));
+
+      address->lang_ab = "";
+    }
   else
     {
-      if (cnt == sizeof (iso639) / sizeof (iso639[0]))
+      if (cnt == nr_iso639)
 	{
 	  helper = 2;
-	  for (cnt = 0; cnt < sizeof (iso639) / sizeof (iso639[0]); ++cnt)
+	  for (cnt = 0; cnt < nr_iso639; ++cnt)
 	    if (strcmp (address->lang_ab, iso639[cnt].ab) == 0)
 	      break;
-	  if (cnt == sizeof (iso639) / sizeof (iso639[0]))
+	  if (cnt == nr_iso639)
 	    WITH_CUR_LOCALE (error (0, 0, _("\
 %s: language abbreviation `%s' not defined"),
 				    "LC_ADDRESS", address->lang_ab));
@@ -267,12 +439,12 @@
     }
   else
     {
-      if (cnt == sizeof (iso639) / sizeof (iso639[0]))
+      if (cnt == nr_iso639)
 	{
-	  for (cnt = 0; cnt < sizeof (iso639) / sizeof (iso639[0]); ++cnt)
+	  for (cnt = 0; cnt < nr_iso639; ++cnt)
 	    if (strcmp (address->lang_lib, iso639[cnt].lib) == 0)
 	      break;
-	  if (cnt == sizeof (iso639) / sizeof (iso639[0]))
+	  if (cnt == nr_iso639)
 	    WITH_CUR_LOCALE (error (0, 0, _("\
 %s: language abbreviation `%s' not defined"),
 				    "LC_ADDRESS", address->lang_lib));
@@ -289,15 +461,26 @@
       if (verbose && ! nothing)
 	WITH_CUR_LOCALE (error (0, 0, _("%s: field `%s' not defined"),
 				"LC_ADDRESS", "country_num"));
-      cnt = sizeof (iso3166) / sizeof (iso3166[0]);
+      cnt = nr_iso3166;
     }
   else
     {
-      for (cnt = 0; cnt < sizeof (iso3166) / sizeof (iso3166[0]); ++cnt)
+      for (cnt = 0; cnt < nr_iso3166; ++cnt)
 	if (address->country_num == iso3166[cnt].num)
-	  break;
+	  {
+	    /* Countries are sometimes renamed without code change,
+	       see YU -> CS for instance.  We may want to keep both
+	       entries to help transitioning.  */
+	    if (address->country_ab2 != NULL &&
+		strcmp (address->country_ab2, iso3166[cnt].ab2) != 0)
+	      continue;
+	    if (address->country_ab3 != NULL &&
+		strcmp (address->country_ab3, iso3166[cnt].ab3) != 0)
+	      continue;
+	    break;
+	  }
 
-      if (cnt == sizeof (iso3166) / sizeof (iso3166[0]))
+      if (cnt == nr_iso3166)
 	WITH_CUR_LOCALE (error (0, 0, _("\
 %s: numeric country code `%d' not valid"),
 				"LC_ADDRESS", address->country_num));
@@ -310,7 +493,7 @@
 				"LC_ADDRESS", "country_ab2"));
       address->country_ab2 = "  ";
     }
-  else if (cnt != sizeof (iso3166) / sizeof (iso3166[0])
+  else if (cnt != nr_iso3166
 	   && strcmp (address->country_ab2, iso3166[cnt].ab2) != 0)
     WITH_CUR_LOCALE (error (0, 0,
 			    _("%s: `%s' value does not match `%s' value"),
@@ -323,7 +506,7 @@
 				"LC_ADDRESS", "country_ab3"));
       address->country_ab3 = "   ";
     }
-  else if (cnt != sizeof (iso3166) / sizeof (iso3166[0])
+  else if (cnt != nr_iso3166
 	   && strcmp (address->country_ab3, iso3166[cnt].ab3) != 0)
     WITH_CUR_LOCALE (error (0, 0, _("\
 %s: `%s' value does not match `%s' value"),
--- glibc-2.3.5/locale/programs/ld-collate.c	2003-06-13 16:50:24.000000000 -0400
+++ glibc-2.3.5/locale/programs/ld-collate.c	2005-11-30 11:09:02.000000000 -0500
@@ -1,4 +1,4 @@
-/* Copyright (C) 1995-2002, 2003 Free Software Foundation, Inc.
+/* Copyright (C) 1995-2002, 2003, 2005 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
    Contributed by Ulrich Drepper <drepper@gnu.org>, 1995.
 
@@ -161,6 +161,24 @@
   size_t line;
 };
 
+/* Data type for toggles.  */
+struct toggle_list_t;
+
+struct toggle_list_t
+{
+  const char *name;
+
+  /* Predecessor in the list.  */
+  struct toggle_list_t *last;
+
+  /* This flag is set when a keyword is undefined.  */
+  int is_undefined;
+
+  /* Where does the branch come from.  */
+  const char *file;
+  size_t line;
+};
+
 /* Sparse table of struct element_t *.  */
 #define TABLE wchead_table
 #define ELEMENT struct element_t *
@@ -214,6 +232,12 @@
   /* This value is used when handling ellipsis.  */
   struct element_t ellipsis_weight;
 
+  /* Known keywords.  */
+  struct toggle_list_t *defined_keywords;
+
+  /* This is a stack of .  */
+  struct toggle_list_t *flow_control;
+
   /* Known collating elements.  */
   hash_table elem_table;
 
@@ -1456,6 +1480,56 @@
 }
 
 
+static struct token *
+flow_skip (struct linereader *ldfile, const struct charmap_t *charmap,
+	   struct locale_collate_t *collate)
+{
+  int level = 0;
+  struct token *now;
+  enum token_t nowtok;
+  while (1)
+    {
+      lr_ignore_rest (ldfile, 0);
+      now = lr_token (ldfile, charmap, NULL, NULL, 0);
+      nowtok = now->tok;
+      if (nowtok == tok_eof)
+	break;
+      else if (nowtok == tok_ifdef || nowtok == tok_ifndef)
+	++level ;
+      else if (nowtok == tok_else)
+	{
+	  if (strcmp (collate->flow_control->name, "else") == 0)
+	    lr_error (ldfile,
+		      _("%s: `else' statement at `%s:%Zu' cannot be followed by another `else' statement"),
+		      "LC_COLLATE", collate->flow_control->name, collate->flow_control->line);
+	  if (level == 0)
+	    {
+	      collate->flow_control->name = "else";
+	      collate->flow_control->file = ldfile->fname;
+	      collate->flow_control->line = ldfile->lineno;
+	      break;
+	    }
+	}
+      else if (nowtok == tok_endif)
+	{
+	  if (level == 0)
+	    {
+	      collate->flow_control = collate->flow_control->last;
+	      break;
+	    }
+	  --level ;
+	}
+    }
+  if (nowtok == tok_eof)
+    WITH_CUR_LOCALE (error (0, 0, _("\
+%s: unterminated `%s' flow control beginning at %s:%Zu"),
+				 "LC_COLLATE", collate->flow_control->name,
+				 collate->flow_control->file,
+				 collate->flow_control->line));
+  return now;
+}
+
+
 static void
 collate_startup (struct linereader *ldfile, struct localedef_t *locale,
 		 struct localedef_t *copy_locale, int ignore_content)
@@ -1524,6 +1598,7 @@
   int i;
   int need_undefined = 0;
   struct section_list *sect;
+  enum coll_sort_rule *orules;
   int ruleidx;
   int nr_wide_elems = 0;
 
@@ -1535,17 +1610,28 @@
 				"LC_COLLATE"));
       return;
     }
+  if (nrules == 0)
+    {
+      /* An error message has already been printed:
+          empty category description not allowed.  */
+      return;
+    }
+
 
   /* If this assertion is hit change the type in `element_t'.  */
   assert (nrules <= sizeof (runp->used_in_level) * 8);
 
   /* Make sure that the `position' rule is used either in all sections
      or in none.  */
+  sect = collate->sections;
+  while (sect != NULL && sect->rules == NULL)
+    sect = sect->next;
+  orules = sect->rules;
   for (i = 0; i < nrules; ++i)
     for (sect = collate->sections; sect != NULL; sect = sect->next)
       if (sect->rules != NULL
 	  && ((sect->rules[i] & sort_position)
-	      != (collate->sections->rules[i] & sort_position)))
+	      != (orules[i] & sort_position)))
 	{
 	  WITH_CUR_LOCALE (error (0, 0, _("\
 %s: `position' must be used for a specific level in all sections or none"),
@@ -1840,7 +1926,7 @@
 
       while (osect != sect)
 	if (osect->rules != NULL
-	    && memcmp (osect->rules, sect->rules, nrules) == 0)
+	    && memcmp (osect->rules, sect->rules, nrules * sizeof (*osect->rules)) == 0)
 	  break;
 	else
 	  osect = osect->next;
@@ -2469,14 +2555,15 @@
   runp = collate->start;
   while (runp != NULL)
     {
-      if (runp->mbs != NULL && runp->weights != NULL)
+      if (runp->mbs != NULL && runp->weights != NULL && !runp->is_character)
 	/* Yep, the element really counts.  */
 	++elem_size;
 
       runp = runp->next;
     }
+rehash:
   /* Add 40% and find the next prime number.  */
-  elem_size = MIN (next_prime (elem_size * 1.4), 257);
+  elem_size = next_prime (elem_size * 1.4);
 
   /* Allocate the table.  Each entry consists of two words: the hash
      value and an index in a secondary table which provides the index
@@ -2496,18 +2583,29 @@
 	  uint32_t namelen = strlen (runp->name);
 	  uint32_t hash = elem_hash (runp->name, namelen);
 	  size_t idx = hash % elem_size;
+	  size_t start_idx = idx;
 
 	  if (elem_table[idx * 2] != 0)
 	    {
-	      /* The spot is already take.  Try iterating using the value
+	      /* The spot is already taken.  Try iterating using the value
 		 from the secondary hashing function.  */
-	      size_t iter = hash % (elem_size - 2);
+	      size_t iter = hash % (elem_size - 2) + 1;
+	      if ((LIMAGIC (0)) < 0x20051014)
+	        {
+		  iter--;
+		  if (iter == 0)
+		    {
+		      obstack_free (&extrapool, elem_table);
+		      goto rehash;
+		    }
+		}
 
 	      do
 		{
 		  idx += iter;
 		  if (idx >= elem_size)
 		    idx -= elem_size;
+		  assert (idx != start_idx);
 		}
 	      while (elem_table[idx * 2] != 0);
 	    }
@@ -2631,9 +2729,11 @@
     }
   while (nowtok == tok_eol);
 
+/* Copying locales do not work well with cached md5sums, and is
+   quite inefficient with large archive files anyway.  */
+#if 0
   if (nowtok == tok_copy)
     {
-      state = 2;
       now = lr_token (ldfile, charmap, result, NULL, verbose);
       if (now->tok != tok_string)
 	{
@@ -2678,6 +2778,7 @@
       now = lr_token (ldfile, charmap, result, NULL, verbose);
       nowtok = now->tok;
     }
+#endif
 
   /* Prepare the data structures.  */
   collate_startup (ldfile, result, copy_locale, ignore_content);
@@ -2704,14 +2805,23 @@
       switch (nowtok)
 	{
 	case tok_copy:
-	  /* Allow copying other locales.  */
+	  /* Ignore the rest of the line if we don't need the input of
+	     this line.  */
+	  if (ignore_content)
+	    {
+	      lr_ignore_rest (ldfile, 0);
+	      break;
+	    }
+
 	  now = lr_token (ldfile, charmap, result, NULL, verbose);
 	  if (now->tok != tok_string)
 	    goto err_label;
 
-	  if (! ignore_content)
-	    load_locale (LC_COLLATE, now->val.str.startmb, repertoire_name,
-			 charmap, result);
+	  if (state == 1 || state == 3 || state == 5)
+	    goto err_label;
+
+	  load_locale (LC_COLLATE, now->val.str.startmb, repertoire_name,
+		       charmap, result);
 
 	  lr_ignore_rest (ldfile, 1);
 	  break;
@@ -2725,9 +2835,6 @@
 	      break;
 	    }
 
-	  if (state != 0)
-	    goto err_label;
-
 	  arg = lr_token (ldfile, charmap, result, NULL, verbose);
 	  if (arg->tok != tok_number)
 	    goto err_label;
@@ -2748,7 +2855,7 @@
 	      break;
 	    }
 
-	  if (state != 0)
+	  if (state == 1 || state == 3 || state == 5)
 	    goto err_label;
 
 	  arg = lr_token (ldfile, charmap, result, repertoire, verbose);
@@ -2795,7 +2902,7 @@
 	      break;
 	    }
 
-	  if (state != 0 && state != 2)
+	  if (state == 1 || state == 3 || state == 5)
 	    goto err_label;
 
 	  arg = lr_token (ldfile, charmap, result, repertoire, verbose);
@@ -2864,7 +2971,7 @@
 	      break;
 	    }
 
-	  if (state != 0 && state != 2)
+	  if (state == 1 || state == 3 || state == 5)
 	    goto err_label;
 
 	  arg = lr_token (ldfile, charmap, result, repertoire, verbose);
@@ -3012,7 +3119,7 @@
 	      break;
 	    }
 
-	  if (state != 0)
+	  if (state == 1 || state == 3 || state == 5)
 	    goto err_label;
 
 	  arg = lr_token (ldfile, charmap, result, repertoire, verbose);
@@ -3128,7 +3235,7 @@
 	      break;
 	    }
 
-	  if (state != 0 && state != 1)
+	  if (state == 3 || state == 5)
 	    goto err_label;
 	  state = 1;
 
@@ -3184,12 +3291,15 @@
 		    {
 		      /* Insert sp in the collate->sections list,
 			 right after collate->current_section.  */
-		      if (collate->current_section == NULL)
+		      if (collate->sections == NULL)
+			collate->sections = collate->current_section = sp;
+		      else if (collate->current_section == NULL)
 			collate->current_section = sp;
 		      else
 			{
 			  sp->next = collate->current_section->next;
 			  collate->current_section->next = sp;
+			  collate->current_section = sp;
 			}
 		    }
 
@@ -3296,8 +3406,12 @@
 		  was_ellipsis = tok_none;
 		}
 	    }
-	  else if (state != 2 && state != 3)
-	    goto err_label;
+	  else if (state == 5)
+	    {
+	      WITH_CUR_LOCALE (error (0, 0, _("\
+%s: missing `reorder-sections-end' keyword"), "LC_COLLATE"));
+	      state = 6;
+	    }
 	  state = 3;
 
 	  arg = lr_token (ldfile, charmap, result, repertoire, verbose);
@@ -3380,6 +3494,9 @@
 		      no_error = 0;
 		    }
 		}
+	      /* Update current section.  */
+	      if (collate->cursor != NULL)
+		collate->current_section = collate->cursor->section;
 
 	      lr_ignore_rest (ldfile, no_error);
 	    }
@@ -3429,8 +3546,6 @@
 %s: missing `reorder-end' keyword"), "LC_COLLATE"));
 	      state = 4;
 	    }
-	  else if (state != 2 && state != 4)
-	    goto err_label;
 	  state = 5;
 
 	  /* Get the name of the sections we are adding after.  */
@@ -3519,8 +3634,17 @@
 	    }
 	  else if (arg != NULL)
 	    {
+	      void *ptr = NULL;
 	      symstr = arg->val.str.startmb;
 	      symlen = arg->val.str.lenmb;
+	      if (state != 5
+		  && find_entry (&collate->elem_table, symstr, symlen, &ptr) != 0
+	          && find_entry (&collate->sym_table, symstr, symlen, &ptr) != 0)
+		{
+		  lr_error (ldfile, _("%s: symbol `%.*s' not known"),
+			    "LC_COLLATE", (int) symlen, symstr);
+		  lr_ignore_rest (ldfile, 0);
+		}
 	    }
 	  else
 	    {
@@ -3763,11 +3887,210 @@
 			  repertoire, result, nowtok);
 	  break;
 
+	case tok_define:
+	  /* Ignore the rest of the line if we don't need the input of
+	     this line.  */
+	  if (ignore_content)
+	    {
+	      lr_ignore_rest (ldfile, 0);
+	      break;
+	    }
+
+	  arg = lr_token (ldfile, charmap, result, NULL, verbose);
+	  if (arg->tok != tok_ident)
+	    goto err_label;
+	  else
+	    {
+	      struct toggle_list_t *runp = collate->defined_keywords;
+	      char *name;
+
+	      while (runp != NULL)
+		if (strncmp (runp->name, arg->val.str.startmb,
+			     arg->val.str.lenmb) == 0
+		    && runp->name[arg->val.str.lenmb] == '\0')
+		  break;
+		else
+		  runp = runp->last;
+
+	      if (runp != NULL && runp->is_undefined == 0)
+		{
+		  lr_ignore_rest (ldfile, 0);
+		  break;
+		}
+
+	      if (runp == NULL)
+		{
+		  runp = (struct toggle_list_t *) xcalloc (1, sizeof (*runp));
+		  runp->last = collate->defined_keywords;
+		  collate->defined_keywords = runp;
+		}
+	      else
+		{
+		  free ((char *) runp->name);
+		  runp->is_undefined = 0;
+		}
+
+	      name = (char *) xmalloc (arg->val.str.lenmb + 1);
+	      memcpy (name, arg->val.str.startmb, arg->val.str.lenmb);
+	      name[arg->val.str.lenmb] = '\0';
+	      runp->name = name;
+	    }
+	  lr_ignore_rest (ldfile, 1);
+	  break;
+
+	case tok_undef:
+	  /* Ignore the rest of the line if we don't need the input of
+	     this line.  */
+	  if (ignore_content)
+	    {
+	      lr_ignore_rest (ldfile, 0);
+	      break;
+	    }
+
+	  arg = lr_token (ldfile, charmap, result, NULL, verbose);
+	  if (arg->tok != tok_ident)
+	    goto err_label;
+	  else
+	    {
+	      struct toggle_list_t *runp = collate->defined_keywords;
+	      while (runp != NULL)
+		if (strncmp (runp->name, arg->val.str.startmb,
+			     arg->val.str.lenmb) == 0
+		    && runp->name[arg->val.str.lenmb] == '\0')
+		{
+		  runp->is_undefined = 1;
+		  break;
+		}
+		else
+		  runp = runp->last;
+	    }
+	  lr_ignore_rest (ldfile, 1);
+	  break;
+
+	case tok_ifdef:
+	  /* Ignore the rest of the line if we don't need the input of
+	     this line.  */
+	  if (ignore_content)
+	    {
+	      lr_ignore_rest (ldfile, 0);
+	      break;
+	    }
+
+	  arg = lr_token (ldfile, charmap, result, NULL, verbose);
+	  if (arg->tok != tok_ident)
+	    goto err_label;
+	  else
+	    {
+	      struct toggle_list_t *runp = collate->defined_keywords;
+	      struct toggle_list_t *flow = (struct toggle_list_t *) xcalloc (1, sizeof (*runp));
+	      flow->name = "ifdef";
+	      flow->file = ldfile->fname;
+	      flow->line = ldfile->lineno;
+	      flow->last = collate->flow_control;
+	      collate->flow_control = flow;
+
+	      while (runp != NULL)
+		if (strncmp (runp->name, arg->val.str.startmb,
+			     arg->val.str.lenmb) == 0
+		    && runp->name[arg->val.str.lenmb] == '\0')
+		  break;
+		else
+		  runp = runp->last;
+
+	      if (runp == NULL)
+		{
+		  now = flow_skip(ldfile, charmap, collate);
+		  if (now->tok == tok_eof)
+		    WITH_CUR_LOCALE (error (0, 0, _("\
+%s: unterminated `%s' flow control"), "LC_COLLATE", collate->flow_control->name));
+		}
+	    }
+	  lr_ignore_rest (ldfile, 1);
+	  break;
+
+	case tok_ifndef:
+	  /* Ignore the rest of the line if we don't need the input of
+	     this line.  */
+	  if (ignore_content)
+	    {
+	      lr_ignore_rest (ldfile, 0);
+	      break;
+	    }
+
+	  arg = lr_token (ldfile, charmap, result, NULL, verbose);
+	  if (arg->tok != tok_ident)
+	    goto err_label;
+	  else
+	    {
+	      struct toggle_list_t *runp = collate->defined_keywords;
+	      struct toggle_list_t *flow = (struct toggle_list_t *) xcalloc (1, sizeof (*runp));
+	      flow->name = "ifndef";
+	      flow->file = ldfile->fname;
+	      flow->line = ldfile->lineno;
+	      flow->last = collate->flow_control;
+	      collate->flow_control = flow;
+
+	      while (runp != NULL)
+		if (strncmp (runp->name, arg->val.str.startmb,
+			     arg->val.str.lenmb) == 0
+		    && runp->name[arg->val.str.lenmb] == '\0')
+		  break;
+		else
+		  runp = runp->last;
+
+	      if (runp != NULL)
+		{
+		  now = flow_skip(ldfile, charmap, collate);
+		  if (now->tok == tok_eof)
+		    WITH_CUR_LOCALE (error (0, 0, _("\
+%s: unterminated `%s' flow control"), "LC_COLLATE", collate->flow_control->name));
+		}
+	    }
+	  lr_ignore_rest (ldfile, 1);
+	  break;
+
+	case tok_else:
+	  /* Ignore the rest of the line if we don't need the input of
+	     this line.  */
+	  if (ignore_content)
+	    {
+	      lr_ignore_rest (ldfile, 0);
+	      break;
+	    }
+
+	  if (strcmp (collate->flow_control->name, "else") == 0)
+	    lr_error (ldfile,
+		      _("%s: `else' statement at `%s:%Zu' cannot be followed by another `else' statement"),
+		      "LC_COLLATE", collate->flow_control->name, collate->flow_control->line);
+	  collate->flow_control->name = "else";
+	  collate->flow_control->file = ldfile->fname;
+	  collate->flow_control->line = ldfile->lineno;
+	  now = flow_skip(ldfile, charmap, collate);
+	  if (now->tok == tok_eof)
+	    WITH_CUR_LOCALE (error (0, 0, _("\
+%s: unterminated `%s' flow control"), "LC_COLLATE", collate->flow_control->name));
+	  break;
+
+	case tok_endif:
+	  /* Ignore the rest of the line if we don't need the input of
+	     this line.  */
+	  if (ignore_content)
+	    {
+	      lr_ignore_rest (ldfile, 0);
+	      break;
+	    }
+
+	  if (collate->flow_control == NULL)
+	    goto err_label;
+	  else
+	    collate->flow_control = collate->flow_control->last;
+	  break;
+
 	case tok_end:
 	  /* Next we assume `LC_COLLATE'.  */
 	  if (!ignore_content)
 	    {
-	      if (state == 0)
+	      if (state == 0 && nrules == 0)
 		/* We must either see a copy statement or have
 		   ordering values.  */
 		lr_error (ldfile,
@@ -3792,6 +4115,13 @@
 	      else if (state == 5)
 		WITH_CUR_LOCALE (error (0, 0, _("\
 %s: missing `reorder-sections-end' keyword"), "LC_COLLATE"));
+	      if (collate->flow_control != NULL
+		  && strcmp(collate->flow_control->file, ldfile->fname) == 0)
+		WITH_CUR_LOCALE (error (0, 0, _("\
+%s: unterminated `%s' flow control beginning at %s:%Zu"),
+				 "LC_COLLATE", collate->flow_control->name,
+				 collate->flow_control->file,
+				 collate->flow_control->line));
 	    }
 	  arg = lr_token (ldfile, charmap, result, NULL, verbose);
 	  if (arg->tok == tok_eof)
--- glibc-2.3.5/locale/programs/ld-ctype.c	2004-03-24 22:51:53.000000000 -0500
+++ glibc-2.3.5/locale/programs/ld-ctype.c	2005-11-30 11:09:02.000000000 -0500
@@ -879,10 +879,30 @@
 }
 
 
+static void
+ctype_output_20000828 (struct localedef_t *locale, const struct charmap_t *charmap, const char *output_path);
+
+static void
+ctype_output_20031115 (struct localedef_t *locale, const struct charmap_t *charmap, const char *output_path);
+
+
 void
 ctype_output (struct localedef_t *locale, const struct charmap_t *charmap,
 	      const char *output_path)
 {
+  if (LIMAGIC (0) == 0x20000828)
+    return ctype_output_20000828 (locale, charmap, output_path);
+  else if (LIMAGIC (0) != 0x20031115)
+    WITH_CUR_LOCALE (error (1, 0, _("\
+%s: unknown magic number: `%x'"),
+      "LC_CTYPE", LIMAGIC (0)));
+  return ctype_output_20031115 (locale, charmap, output_path);
+}
+
+static void
+ctype_output_20031115 (struct localedef_t *locale, const struct charmap_t *charmap,
+	      const char *output_path)
+{
   static const char nulbytes[4] = { 0, 0, 0, 0 };
   struct locale_ctype_t *ctype = locale->categories[LC_CTYPE].ctype;
   const size_t nelems = (_NL_ITEM_INDEX (_NL_CTYPE_EXTRA_MAP_1)
@@ -1229,6 +1249,356 @@
 }
 
 
+void
+ctype_output_20000828 (struct localedef_t *locale, const struct charmap_t *charmap,
+	      const char *output_path)
+{
+  static const char nulbytes[4] = { 0, 0, 0, 0 };
+  struct locale_ctype_t *ctype = locale->categories[LC_CTYPE].ctype;
+  const size_t nelems = (_NL_ITEM_INDEX (_NL_CTYPE_EXTRA_MAP_1) - 1
+			 + ctype->nr_charclass + ctype->map_collection_nr);
+  struct iovec *iov = alloca (sizeof *iov
+			      * (2 + nelems + 2 * ctype->nr_charclass
+				 + ctype->map_collection_nr + 4));
+  struct locale_file data;
+  uint32_t *idx = alloca (sizeof *idx * (nelems + 1));
+  uint32_t default_missing_len;
+  size_t elem, cnt, offset, total;
+  char *cp;
+
+  /* Now prepare the output: Find the sizes of the table we can use.  */
+  allocate_arrays (ctype, charmap, ctype->repertoire);
+
+  data.magic = LIMAGIC (LC_CTYPE);
+  data.n = nelems;
+  iov[0].iov_base = (void *) &data;
+  iov[0].iov_len = sizeof (data);
+
+  iov[1].iov_base = (void *) idx;
+  iov[1].iov_len = nelems * sizeof (uint32_t);
+
+  idx[0] = iov[0].iov_len + iov[1].iov_len;
+  offset = 0;
+
+  for (elem = 0; elem < nelems + 1; ++elem)
+    {
+      if (elem < _NL_ITEM_INDEX (_NL_CTYPE_EXTRA_MAP_1))
+	switch (elem)
+	  {
+#undef CTYPE_EMPTY
+#define CTYPE_EMPTY(name) \
+	  case name:							      \
+	    iov[2 + elem + offset].iov_base = NULL;			      \
+	    iov[2 + elem + offset].iov_len = 0;				      \
+	    idx[elem + 1] = idx[elem];					      \
+	    break
+
+	  CTYPE_EMPTY(_NL_CTYPE_GAP1);
+	  CTYPE_EMPTY(_NL_CTYPE_GAP2);
+	  CTYPE_EMPTY(_NL_CTYPE_GAP3);
+	  CTYPE_EMPTY(_NL_CTYPE_GAP4);
+	  CTYPE_EMPTY(_NL_CTYPE_GAP5);
+	  CTYPE_EMPTY(_NL_CTYPE_GAP6);
+
+#undef CTYPE_DATA
+#define CTYPE_DATA(name, base, len)					      \
+	  case _NL_ITEM_INDEX (name):					      \
+	    iov[2 + elem + offset].iov_base = (base);			      \
+	    iov[2 + elem + offset].iov_len = (len);			      \
+	    idx[elem + 1] = idx[elem] + iov[2 + elem + offset].iov_len;	      \
+	    break
+
+	  CTYPE_DATA (_NL_CTYPE_CLASS,
+		      ctype->ctype_b,
+		      (256 + 128) * sizeof (char_class_t));
+
+	  CTYPE_DATA (_NL_CTYPE_TOUPPER,
+		      ctype->map_b[0],
+		      (256 + 128) * sizeof (uint32_t));
+	  CTYPE_DATA (_NL_CTYPE_TOLOWER,
+		      ctype->map_b[1],
+		      (256 + 128) * sizeof (uint32_t));
+
+	  CTYPE_DATA (_NL_CTYPE_TOUPPER32,
+		      ctype->map32_b[0],
+		      256 * sizeof (uint32_t));
+	  CTYPE_DATA (_NL_CTYPE_TOLOWER32,
+		      ctype->map32_b[1],
+		      256 * sizeof (uint32_t));
+
+	  CTYPE_DATA (_NL_CTYPE_CLASS32,
+		      ctype->ctype32_b,
+		      256 * sizeof (char_class32_t));
+
+	  CTYPE_DATA (_NL_CTYPE_CLASS_OFFSET,
+		      &ctype->class_offset, sizeof (uint32_t));
+
+	  CTYPE_DATA (_NL_CTYPE_MAP_OFFSET,
+		      &ctype->map_offset, sizeof (uint32_t));
+
+	  CTYPE_DATA (_NL_CTYPE_TRANSLIT_TAB_SIZE,
+		      &ctype->translit_idx_size, sizeof (uint32_t));
+
+	  CTYPE_DATA (_NL_CTYPE_TRANSLIT_FROM_IDX,
+		      ctype->translit_from_idx,
+		      ctype->translit_idx_size * sizeof (uint32_t));
+
+	  CTYPE_DATA (_NL_CTYPE_TRANSLIT_FROM_TBL,
+		      ctype->translit_from_tbl,
+		      ctype->translit_from_tbl_size);
+
+	  CTYPE_DATA (_NL_CTYPE_TRANSLIT_TO_IDX,
+		      ctype->translit_to_idx,
+		      ctype->translit_idx_size * sizeof (uint32_t));
+
+	  CTYPE_DATA (_NL_CTYPE_TRANSLIT_TO_TBL,
+		      ctype->translit_to_tbl, ctype->translit_to_tbl_size);
+
+	  case _NL_ITEM_INDEX (_NL_CTYPE_CLASS_NAMES):
+	    /* The class name array.  */
+	    total = 0;
+	    for (cnt = 0; cnt < ctype->nr_charclass; ++cnt, ++offset)
+	      {
+		iov[2 + elem + offset].iov_base
+		  = (void *) ctype->classnames[cnt];
+		iov[2 + elem + offset].iov_len
+		  = strlen (ctype->classnames[cnt]) + 1;
+		total += iov[2 + elem + offset].iov_len;
+	      }
+	    iov[2 + elem + offset].iov_base = (void *) nulbytes;
+	    iov[2 + elem + offset].iov_len = 1 + (4 - ((total + 1) % 4));
+	    total += 1 + (4 - ((total + 1) % 4));
+
+	    idx[elem + 1] = idx[elem] + total;
+	    break;
+
+	  case _NL_ITEM_INDEX (_NL_CTYPE_MAP_NAMES):
+	    /* The class name array.  */
+	    total = 0;
+	    for (cnt = 0; cnt < ctype->map_collection_nr; ++cnt, ++offset)
+	      {
+		iov[2 + elem + offset].iov_base
+		  = (void *) ctype->mapnames[cnt];
+		iov[2 + elem + offset].iov_len
+		  = strlen (ctype->mapnames[cnt]) + 1;
+		total += iov[2 + elem + offset].iov_len;
+	      }
+	    iov[2 + elem + offset].iov_base = (void *) nulbytes;
+	    iov[2 + elem + offset].iov_len = 1 + (4 - ((total + 1) % 4));
+	    total += 1 + (4 - ((total + 1) % 4));
+
+	    idx[elem + 1] = idx[elem] + total;
+	    break;
+
+	  CTYPE_DATA (_NL_CTYPE_WIDTH,
+		      ctype->width.iov_base,
+		      ctype->width.iov_len);
+
+	  CTYPE_DATA (_NL_CTYPE_MB_CUR_MAX,
+		      &ctype->mb_cur_max, sizeof (uint32_t));
+
+	  case _NL_ITEM_INDEX (_NL_CTYPE_CODESET_NAME):
+	    total = strlen (ctype->codeset_name) + 1;
+	    if (total % 4 == 0)
+	      iov[2 + elem + offset].iov_base = (char *) ctype->codeset_name;
+	    else
+	      {
+		iov[2 + elem + offset].iov_base = alloca ((total + 3) & ~3);
+		memset (mempcpy (iov[2 + elem + offset].iov_base,
+				 ctype->codeset_name, total),
+			'\0', 4 - (total & 3));
+		total = (total + 3) & ~3;
+	      }
+	    iov[2 + elem + offset].iov_len = total;
+	    idx[elem + 1] = idx[elem] + iov[2 + elem + offset].iov_len;
+	    break;
+
+
+	  case _NL_ITEM_INDEX (_NL_CTYPE_MAP_TO_NONASCII):
+	    --offset;
+	    break;
+
+	  case _NL_ITEM_INDEX (_NL_CTYPE_INDIGITS_MB_LEN):
+	    iov[2 + elem + offset].iov_base = alloca (sizeof (uint32_t));
+	    iov[2 + elem + offset].iov_len = sizeof (uint32_t);
+	    *(uint32_t *) iov[2 + elem + offset].iov_base =
+	      ctype->mbdigits_act / 10;
+	    idx[elem + 1] = idx[elem] + sizeof (uint32_t);
+	    break;
+
+	  case _NL_ITEM_INDEX (_NL_CTYPE_INDIGITS_WC_LEN):
+	    /* Align entries.  */
+	    iov[2 + elem + offset].iov_base = (void *) nulbytes;
+	    iov[2 + elem + offset].iov_len = (4 - idx[elem] % 4) % 4;
+	    idx[elem] += iov[2 + elem + offset].iov_len;
+	    ++offset;
+
+	    iov[2 + elem + offset].iov_base = alloca (sizeof (uint32_t));
+	    iov[2 + elem + offset].iov_len = sizeof (uint32_t);
+	    *(uint32_t *) iov[2 + elem + offset].iov_base =
+	      ctype->wcdigits_act / 10;
+	    idx[elem + 1] = idx[elem] + sizeof (uint32_t);
+	    break;
+
+	  case _NL_ITEM_INDEX (_NL_CTYPE_INDIGITS0_MB) ... _NL_ITEM_INDEX (_NL_CTYPE_INDIGITS9_MB):
+	    /* Compute the length of all possible characters.  For INDIGITS
+	       there might be more than one.  We simply concatenate all of
+	       them with a NUL byte following.  The NUL byte wouldn't be
+	       necessary but it makes it easier for the user.  */
+	    total = 0;
+
+	    for (cnt = elem - _NL_ITEM_INDEX (_NL_CTYPE_INDIGITS0_MB);
+		 cnt < ctype->mbdigits_act; cnt += 10)
+	      total += ctype->mbdigits[cnt]->nbytes + 1;
+	    iov[2 + elem + offset].iov_base = (char *) alloca (total);
+	    iov[2 + elem + offset].iov_len = total;
+
+	    cp = iov[2 + elem + offset].iov_base;
+	    for (cnt = elem - _NL_ITEM_INDEX (_NL_CTYPE_INDIGITS0_MB);
+		 cnt < ctype->mbdigits_act; cnt += 10)
+	      {
+		cp = mempcpy (cp, ctype->mbdigits[cnt]->bytes,
+			      ctype->mbdigits[cnt]->nbytes);
+		*cp++ = '\0';
+	      }
+	    idx[elem + 1] = idx[elem] + iov[2 + elem + offset].iov_len;
+	    break;
+
+	  case _NL_ITEM_INDEX (_NL_CTYPE_OUTDIGIT0_MB) ... _NL_ITEM_INDEX (_NL_CTYPE_OUTDIGIT9_MB):
+	    /* Compute the length of all possible characters.  For INDIGITS
+	       there might be more than one.  We simply concatenate all of
+	       them with a NUL byte following.  The NUL byte wouldn't be
+	       necessary but it makes it easier for the user.  */
+	    cnt = elem - _NL_ITEM_INDEX (_NL_CTYPE_OUTDIGIT0_MB);
+	    total = ctype->mboutdigits[cnt]->nbytes + 1;
+	    iov[2 + elem + offset].iov_base = (char *) alloca (total);
+	    iov[2 + elem + offset].iov_len = total;
+
+	    *(char *) mempcpy (iov[2 + elem + offset].iov_base,
+			       ctype->mboutdigits[cnt]->bytes,
+			       ctype->mboutdigits[cnt]->nbytes) = '\0';
+	    idx[elem + 1] = idx[elem] + iov[2 + elem + offset].iov_len;
+	    break;
+
+	  case _NL_ITEM_INDEX (_NL_CTYPE_INDIGITS0_WC) ... _NL_ITEM_INDEX (_NL_CTYPE_INDIGITS9_WC):
+	    total = ctype->wcdigits_act / 10;
+
+	    iov[2 + elem + offset].iov_base =
+	      (uint32_t *) alloca (total * sizeof (uint32_t));
+	    iov[2 + elem + offset].iov_len = total * sizeof (uint32_t);
+
+	    for (cnt = elem - _NL_ITEM_INDEX (_NL_CTYPE_INDIGITS0_WC);
+		 cnt < ctype->wcdigits_act; cnt += 10)
+	      ((uint32_t *) iov[2 + elem + offset].iov_base)[cnt / 10]
+		= ctype->wcdigits[cnt];
+	    idx[elem + 1] = idx[elem] + iov[2 + elem + offset].iov_len;
+	    break;
+
+	  case _NL_ITEM_INDEX (_NL_CTYPE_OUTDIGIT0_WC):
+	    /* Align entries.  */
+	    iov[2 + elem + offset].iov_base = (void *) nulbytes;
+	    iov[2 + elem + offset].iov_len = (4 - idx[elem] % 4) % 4;
+	    idx[elem] += iov[2 + elem + offset].iov_len;
+	    ++offset;
+	    /* FALLTRHOUGH */
+
+	  case _NL_ITEM_INDEX (_NL_CTYPE_OUTDIGIT1_WC) ... _NL_ITEM_INDEX (_NL_CTYPE_OUTDIGIT9_WC):
+	    cnt = elem - _NL_ITEM_INDEX (_NL_CTYPE_OUTDIGIT0_WC);
+	    iov[2 + elem + offset].iov_base = &ctype->wcoutdigits[cnt];
+	    iov[2 + elem + offset].iov_len = sizeof (uint32_t);
+	    idx[elem + 1] = idx[elem] + iov[2 + elem + offset].iov_len;
+	    break;
+
+	  case _NL_ITEM_INDEX(_NL_CTYPE_TRANSLIT_DEFAULT_MISSING_LEN):
+	    /* Align entries.  */
+	    iov[2 + elem + offset].iov_base = (void *) nulbytes;
+	    iov[2 + elem + offset].iov_len = (4 - idx[elem] % 4) % 4;
+	    idx[elem] += iov[2 + elem + offset].iov_len;
+	    ++offset;
+
+	    default_missing_len = (ctype->default_missing
+				   ? wcslen ((wchar_t *)ctype->default_missing)
+				   : 0);
+	    iov[2 + elem + offset].iov_base = &default_missing_len;
+	    iov[2 + elem + offset].iov_len = sizeof (uint32_t);
+	    idx[elem + 1] = idx[elem] + iov[2 + elem + offset].iov_len;
+	    break;
+
+	  case _NL_ITEM_INDEX(_NL_CTYPE_TRANSLIT_DEFAULT_MISSING):
+	    iov[2 + elem + offset].iov_base =
+	      ctype->default_missing ?: (uint32_t *) L"";
+	    iov[2 + elem + offset].iov_len =
+	      wcslen (iov[2 + elem + offset].iov_base);
+	    idx[elem + 1] = idx[elem] + iov[2 + elem + offset].iov_len;
+	    break;
+
+	  case _NL_ITEM_INDEX(_NL_CTYPE_TRANSLIT_IGNORE_LEN):
+	    /* Align entries.  */
+	    iov[2 + elem + offset].iov_base = (void *) nulbytes;
+	    iov[2 + elem + offset].iov_len = (4 - idx[elem] % 4) % 4;
+	    idx[elem] += iov[2 + elem + offset].iov_len;
+	    ++offset;
+
+	    iov[2 + elem + offset].iov_base = &ctype->ntranslit_ignore;
+	    iov[2 + elem + offset].iov_len = sizeof (uint32_t);
+	    idx[elem + 1] = idx[elem] + iov[2 + elem + offset].iov_len;
+	    break;
+
+	  case _NL_ITEM_INDEX(_NL_CTYPE_TRANSLIT_IGNORE):
+	    {
+	      uint32_t *ranges = (uint32_t *) alloca (ctype->ntranslit_ignore
+						      * 3 * sizeof (uint32_t));
+	      struct translit_ignore_t *runp;
+
+	      iov[2 + elem + offset].iov_base = ranges;
+	      iov[2 + elem + offset].iov_len = (ctype->ntranslit_ignore
+						* 3 * sizeof (uint32_t));
+
+	      for (runp = ctype->translit_ignore; runp != NULL;
+		   runp = runp->next)
+		{
+		  *ranges++ = runp->from;
+		  *ranges++ = runp->to;
+		  *ranges++ = runp->step;
+		}
+	    }
+	    idx[elem + 1] = idx[elem] + iov[2 + elem + offset].iov_len;
+	    break;
+
+	  default:
+	    assert (! "unknown CTYPE element");
+	  }
+      else
+	{
+	  /* Handle extra maps.  */
+	  size_t nr = elem - _NL_ITEM_INDEX (_NL_CTYPE_EXTRA_MAP_1);
+	  if (nr < ctype->nr_charclass)
+	    {
+	      iov[2 + elem + offset].iov_base = ctype->class_b[nr];
+	      iov[2 + elem + offset].iov_len = 256 / 32 * sizeof (uint32_t);
+	      idx[elem - 1] += iov[2 + elem + offset].iov_len;
+	      ++offset;
+
+	      iov[2 + elem + offset] = ctype->class_3level[nr];
+	    }
+	  else
+	    {
+	      nr -= ctype->nr_charclass;
+	      assert (nr < ctype->map_collection_nr);
+	      iov[2 + elem + offset] = ctype->map_3level[nr];
+	    }
+	  idx[elem] = idx[elem - 1] + iov[2 + elem + offset].iov_len;
+	}
+    }
+
+  assert (2 + elem + offset == (nelems + 2 * ctype->nr_charclass
+				+ ctype->map_collection_nr + 4 + 2));
+
+  write_locale_data (output_path, LC_CTYPE, "LC_CTYPE", 2 + elem + offset,
+		     iov);
+}
+
+
 /* Local functions.  */
 static void
 ctype_class_new (struct linereader *lr, struct locale_ctype_t *ctype,
@@ -3951,6 +4321,8 @@
 					      * sizeof (uint32_t));
 
   ctype->class_offset = _NL_ITEM_INDEX (_NL_CTYPE_EXTRA_MAP_1);
+  if (LIMAGIC (0) == 0x20000828)
+    --(ctype->class_offset);
   ctype->map_offset = ctype->class_offset + ctype->nr_charclass;
 
   /* Array for width information.  Because the expected widths are very
--- glibc-2.3.5/locale/programs/ld-identification.c	2002-04-18 03:53:59.000000000 -0400
+++ glibc-2.3.5/locale/programs/ld-identification.c	2005-11-30 11:09:02.000000000 -0500
@@ -148,6 +148,9 @@
 			       	"LC_IDENTIFICATION", #cat));		      \
       identification->cat = "";						      \
     }
+#define TEST_ELEM_OPT(cat) \
+  if (identification->cat == NULL)					      \
+    identification->cat = "";						      \
 
   TEST_ELEM (title);
   TEST_ELEM (source);
@@ -158,9 +161,9 @@
   TEST_ELEM (fax);
   TEST_ELEM (language);
   TEST_ELEM (territory);
-  TEST_ELEM (audience);
-  TEST_ELEM (application);
-  TEST_ELEM (abbreviation);
+  TEST_ELEM_OPT (audience);
+  TEST_ELEM_OPT (application);
+  TEST_ELEM_OPT (abbreviation);
   TEST_ELEM (revision);
   TEST_ELEM (date);
 
--- glibc-2.3.5/locale/programs/ld-monetary.c	2003-11-26 02:22:27.000000000 -0500
+++ glibc-2.3.5/locale/programs/ld-monetary.c	2005-11-30 11:09:02.000000000 -0500
@@ -88,10 +88,16 @@
 };
 
 
+struct iso4217_t
+{
+  char name[4];
+};
+
+
 /* The content iof the field int_curr_symbol has to be taken from
    ISO-4217.  We test for correct values.  */
-#define DEFINE_INT_CURR(str) str,
-static const char *const valid_int_curr[] =
+#define DEFINE_INT_CURR(str) { str },
+static struct iso4217_t dft_iso4217[] =
   {
 #   include "../iso-4217.def"
   };
@@ -101,8 +107,8 @@
 
 
 /* Prototypes for local functions.  */
-static int curr_strcmp (const char *s1, const char **s2);
-
+static int curr_strcmp (const char *s1, const struct iso4217_t *s2);
+static void get_iso4217_def(struct iso4217_t **iso4217, size_t *nr_iso4217);
 
 static void
 monetary_startup (struct linereader *lr, struct localedef_t *locale,
@@ -158,12 +164,69 @@
 }
 
 
+static void
+get_iso4217_def(struct iso4217_t **iso4217, size_t *nr_iso4217)
+{
+  FILE *fp;
+  char *line = NULL;
+  size_t linelength = 0, nelem = 0;
+  int n, in_string;
+  char *cp;
+  struct iso4217_t *tab;
+
+  *iso4217 = dft_iso4217;
+  *nr_iso4217 = sizeof (dft_iso4217) / sizeof (dft_iso4217[0]);
+  fp = fopen (LOCSRCDIR "/iso-4217.def", "rm");
+  if (fp == NULL)
+    return;
+  /*  First get the number of elements.  */
+  while (1)
+    {
+      n = getline(&line, &linelength, fp);
+      if (n < 0)
+        break;
+      if (strncmp(line, "DEFINE_INT_CURR", 15) == 0)
+        nelem++;
+    }
+  tab = (struct iso4217_t *) xmalloc(nelem * sizeof (struct iso4217_t));
+  nelem = 0;
+  rewind (fp);
+  while (1)
+    {
+      n = getline(&line, &linelength, fp);
+      if (n < 0)
+        break;
+      if (strncmp(line, "DEFINE_INT_CURR", 15) == 0)
+        {
+          in_string = 0;
+          tab[nelem].name[0] = '\0';
+          cp = strchr(line+15, '"');
+          if (cp != NULL)
+            {
+              tab[nelem].name[0] = *(cp+1);
+              tab[nelem].name[1] = *(cp+2);
+              tab[nelem].name[2] = *(cp+3);
+              tab[nelem].name[3] = '\0';
+              nelem++;
+            }
+        }
+    }
+  fclose (fp);
+  free(line);
+  *nr_iso4217 = nelem;
+  *iso4217 = tab;
+}
+
+
 void
 monetary_finish (struct localedef_t *locale, const struct charmap_t *charmap)
 {
   struct locale_monetary_t *monetary
     = locale->categories[LC_MONETARY].monetary;
   int nothing = 0;
+  struct iso4217_t *iso4217;
+  size_t nr_iso4217;
+  get_iso4217_def(&iso4217, &nr_iso4217);
 
   /* Now resolve copying and also handle completely missing definitions.  */
   if (monetary == NULL)
@@ -230,8 +293,8 @@
 	  char symbol[4];
 	  strncpy (symbol, monetary->int_curr_symbol, 3);
 	  symbol[3] = '\0';
-	  if (bsearch (symbol, valid_int_curr, NR_VALID_INT_CURR,
-		       sizeof (const char *),
+	  if (bsearch (symbol, iso4217, nr_iso4217,
+		       sizeof (struct iso4217_t),
 		       (comparison_fn_t) curr_strcmp) == NULL
 	       && !be_quiet)
 	    WITH_CUR_LOCALE (error (0, 0, _("\
@@ -624,9 +687,9 @@
 
 
 static int
-curr_strcmp (const char *s1, const char **s2)
+curr_strcmp (const char *s1, const struct iso4217_t *s2)
 {
-  return strcmp (s1, *s2);
+  return strcmp (s1, s2->name);
 }
 
 
--- glibc-2.3.5/locale/programs/linereader.c	2004-08-04 17:45:00.000000000 -0400
+++ glibc-2.3.5/locale/programs/linereader.c	2005-11-30 11:09:02.000000000 -0500
@@ -531,8 +531,8 @@
     {
       lr->token.tok = tok_bsymbol;
 
-      buf[bufact] = '\0';
       buf = xrealloc (buf, bufact + 1);
+      buf[bufact] = '\0';
 
       lr->token.val.str.startmb = buf;
       lr->token.val.str.lenmb = bufact - 1;
@@ -584,8 +584,8 @@
     {
       lr->token.tok = tok_ident;
 
-      buf[bufact] = '\0';
       buf = xrealloc (buf, bufact + 1);
+      buf[bufact] = '\0';
 
       lr->token.val.str.startmb = buf;
       lr->token.val.str.lenmb = bufact;
--- glibc-2.3.5/locale/programs/locale.c	2005-02-16 05:29:33.000000000 -0500
+++ glibc-2.3.5/locale/programs/locale.c	2005-11-30 11:09:02.000000000 -0500
@@ -196,7 +200,7 @@
     error (0, errno, gettext ("Cannot set LC_MESSAGES to default locale"));
 
   /* Initialize the message catalog.  */
-  textdomain (PACKAGE);
+  textdomain (_libc_intl_domainname);
 
   /* Parse and process arguments.  */
   argp_parse (&argp, argc, argv, 0, &remaining, NULL);
@@ -272,7 +276,7 @@
 static void
 print_version (FILE *stream, struct argp_state *state)
 {
-  fprintf (stream, "locale (GNU %s) %s\n", PACKAGE, VERSION);
+  fprintf (stream, "locale (%s) %s\n", PACKAGE, VERSION);
   fprintf (stream, gettext ("\
 Copyright (C) %s Free Software Foundation, Inc.\n\
 This is free software; see the source for copying conditions.  There is NO\n\
@@ -753,6 +757,7 @@
 {
   size_t cat_no;
   const char *lcall = getenv ("LC_ALL");
+  const char *language = getenv ("LANGUAGE");
   const char *lang = getenv ("LANG") ? : "";
 
   auto void get_source (const char *name);
@@ -771,6 +776,9 @@
   /* LANG has to be the first value.  */
   printf ("LANG=%s\n", lang);
 
+  if (language != NULL)
+    printf ("LANGUAGE=%s\n", language);
+
   /* Now all categories in an unspecified order.  */
   for (cat_no = 0; cat_no < NCATEGORIES; ++cat_no)
     if (cat_no != LC_ALL)
--- glibc-2.3.5/locale/programs/localedef.c	2005-02-16 05:29:33.000000000 -0500
+++ glibc-2.3.5/locale/programs/localedef.c	2005-11-30 11:09:02.000000000 -0500
@@ -67,6 +67,9 @@
 /* Prefix for output files.  */
 const char *output_prefix;
 
+/* Magic number currently used by GNU libc.  */
+static int locale_magic = 0x20031115;
+
 /* Name of the character map file.  */
 static const char *charmap_file;
 
@@ -114,6 +117,7 @@
 #define OPT_REPLACE 307
 #define OPT_DELETE_FROM_ARCHIVE 308
 #define OPT_LIST_ARCHIVE 309
+#define OPT_MAGIC 310
 
 /* Definitions of arguments for argp functions.  */
 static const struct argp_option options[] =
@@ -128,6 +132,7 @@
   { NULL, 0, NULL, 0, N_("Output control:") },
   { "force", 'c', NULL, 0,
     N_("Create output even if warning messages were issued") },
+  { "magic", OPT_MAGIC, "NUMBER", 0, N_("Set GNU libc magic NUMBER") },
   { "old-style", OPT_OLDSTYLE, NULL, 0, N_("Create old-style tables") },
   { "prefix", OPT_PREFIX, "PATH", 0, N_("Optional output file prefix") },
   { "posix", OPT_POSIX, NULL, 0, N_("Be strictly POSIX conform") },
@@ -205,6 +210,22 @@
   argp_err_exit_status = 4;
   argp_parse (&argp, argc, argv, 0, &remaining, NULL);
 
+  switch (locale_magic)
+    {
+    case 0x20000828:
+    case 0x20031115:
+    case 0x20051014:
+      break;
+    default:
+      fprintf (stderr, _("\
+magic number %x is requested, but this version only handles:\n"), locale_magic);
+      fprintf (stderr, "  %x\n", 0x20000828);
+      fprintf (stderr, "  %x\n", 0x20031115);
+      fprintf (stderr, "  %x\n", 0x20051014);
+      error (10, 0, _("\
+You must either change the desired magic number or update this program."));
+    }
+
   /* Handle a few special cases.  */
   if (list_archive)
     show_archive_content (verbose);
@@ -315,6 +336,9 @@
     case OPT_PREFIX:
       output_prefix = arg;
       break;
+    case OPT_MAGIC:
+      locale_magic = strtol(arg, NULL, 16);
+      break;
     case OPT_NO_ARCHIVE:
       no_archive = true;
       break;
@@ -384,7 +408,7 @@
 static void
 print_version (FILE *stream, struct argp_state *state)
 {
-  fprintf (stream, "localedef (GNU %s) %s\n", PACKAGE, VERSION);
+  fprintf (stream, "localedef (%s) %s\n", PACKAGE, VERSION);
   fprintf (stream, gettext ("\
 Copyright (C) %s Free Software Foundation, Inc.\n\
 This is free software; see the source for copying conditions.  There is NO\n\
@@ -623,6 +647,17 @@
   return result;
 }
 
+unsigned int
+get_magic(int category)
+{
+  if (locale_magic < 0x20051014)
+    return (locale_magic ^ category);
+  if (category == LC_COLLATE)
+    return (0x20051014 ^ category);
+  else
+    return (0x20031115 ^ category);
+}
+
 static void
 turn_on_mcheck (void)
 {
--- glibc-2.3.5/locale/programs/localedef.h	2002-08-10 02:21:39.000000000 -0400
+++ glibc-2.3.5/locale/programs/localedef.h	2005-11-30 11:09:02.000000000 -0500
@@ -178,4 +183,7 @@
 /* List content of locale archive.  */
 extern void show_archive_content (int verbose);
 
+/* Returns the desired magic number.  */
+extern unsigned int get_magic(int category);
+
 #endif /* localedef.h */
