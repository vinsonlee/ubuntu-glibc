#! /bin/sh -e

# All lines beginning with `# DP:' are a description of the patch.
# DP: Description: Fix getcwd to not blow up on ERANGE when it gets that
# DP:		from the kernel (PAGE_SIZE >> PATH_MAX)
# DP:		Fixes Debian Bug#355109
# DP: Author: LaMont Jones <lamont.jones@hp.com>
# DP: Upstream status: Not submitted
# DP: Status Details: Not submitted
# DP: Date: 2006-03-23

if [ $# -ne 2 ]; then
    echo >&2 "`basename $0`: script expects -patch|-unpatch as argument"
    exit 1
fi
case "$1" in
    -patch) patch -d "$2" -f --no-backup-if-mismatch -p0 < $0;;
    -unpatch) patch -d "$2" -f --no-backup-if-mismatch -R -p0 < $0;;
    *)
	echo >&2 "`basename $0`: script expects -patch|-unpatch as argument"
	exit 1
esac
exit 0

# append the patch here and adjust the -p? flag in the patch calls.
2005-01-02  GOTO Masanori  <gotom@debian.org>

	* sysdeps/i386/dl-procinfo.h: Update to add CMOV for VIA C3 chip.

--- sysdeps/unix/sysv/linux/getcwd.c.orig	2006-03-24 08:01:29.000000000 -0700
+++ sysdeps/unix/sysv/linux/getcwd.c	2006-03-24 08:06:32.000000000 -0700
@@ -124,10 +124,11 @@
 	}
 
 # if __ASSUME_GETCWD_SYSCALL
-      /* It should never happen that the `getcwd' syscall failed because
-	 the buffer is too small if we allocated the buffer ourselves
-	 large enough.  */
-      assert (errno != ERANGE || buf != NULL || size != 0);
+      /* It is possible that the `getcwd' syscall failed because
+	 the buffer is too small even though we allocaed MAX_PATH
+	 bytes.  if PAGE_SIZE != PATH_MAX, then we can get back ERANGE
+	 instead of ENAMETOOLONG in this case. */
+      /* assert (errno != ERANGE || buf != NULL || size != 0); */
 
 #  ifndef NO_ALLOCATION
       if (buf == NULL)
