#! /bin/sh -e

# All lines beginning with `# DP:' are a description of the patch.
# DP: Description: allow dynamic long-running processes to
# DP: re-read a dynamically updated resolv.conf on the fly
# DP: Dpatch author: Adam Conrad <adconrad@ubuntu.com>
# DP: Patch author: Thorsten Kukuk <kukuk@suse.de>
# DP: Upstream status: Ubuntu-Specific
# DP: Date: 2006-01-13 08:14:21 UTC

PATCHLEVEL=1

if [ $# -ne 2 ]; then
    echo >&2 "`basename $0`: script expects -patch|-unpatch as argument"
    exit 1
fi
case "$1" in
    -patch) patch -d "$2" -f --no-backup-if-mismatch -p$PATCHLEVEL < $0;;
    -unpatch) patch -d "$2" -f --no-backup-if-mismatch -R -p$PATCHLEVEL < $0;;
    *)
	echo >&2 "`basename $0`: script expects -patch|-unpatch as argument"
	exit 1
esac
exit 0

# append the patch here and adjust the -p? flag in the patch calls.
--- glibc-2.3.6/resolv/res_libc.c	2004-08-13 15:44:46.000000000 +1000
+++ glibc-2.3.6/resolv/res_libc.c	2006-01-13 19:10:28.000000000 +1100
@@ -22,7 +22,7 @@
 #include <arpa/nameser.h>
 #include <resolv.h>
 #include <bits/libc-lock.h>
-
+#include <sys/stat.h>
 
 /* The following bit is copied from res_data.c (where it is #ifdef'ed
    out) since res_init() should go into libc.so but the rest of that
@@ -100,8 +100,17 @@
 int
 __res_maybe_init (res_state resp, int preinit)
 {
-	if (resp->options & RES_INIT) {
-		if (__res_initstamp != resp->_u._ext.initstamp) {
+  static time_t last_mtime;
+  struct stat statbuf;
+  int ret;
+
+		
+  if (resp->options & RES_INIT) {
+	ret = stat (_PATH_RESCONF, &statbuf);
+		if (__res_initstamp != resp->_u._ext.initstamp
+		  || (ret == 0) && (last_mtime != statbuf.st_mtime))
+		  {
+		        last_mtime = statbuf.st_mtime;
 			if (resp->nscount > 0) {
 				__res_nclose (resp);
 				for (int ns = 0; ns < MAXNS; ns++) {
