No topgit branch, TODO.

diff --git a/sysdeps/mach/hurd/profil.c b/sysdeps/mach/hurd/profil.c
index fa5c016..abdfdee 100644
--- a/sysdeps/mach/hurd/profil.c
+++ b/sysdeps/mach/hurd/profil.c
@@ -35,6 +35,7 @@ static u_short *samples;
 static size_t maxsamples;
 static size_t pc_offset;
 static size_t sample_scale;
+static sampled_pc_flavor_t sample_type;
 static sampled_pc_seqno_t seqno;
 static spin_lock_t lock = SPIN_LOCK_INITIALIZER;
 static mach_msg_timeout_t collector_timeout; /* ms between collections.  */
@@ -58,7 +59,7 @@ static void profile_waiter (void);
    disable profiling.  Returns zero on success, -1 on error.  */
 
 static error_t
-update_waiter (u_short *sample_buffer, size_t size, size_t offset, u_int scale)
+update_waiter (u_short *sample_buffer, size_t size, size_t offset, u_int scale, sampled_pc_flavor_t sample_type)
 {
   error_t err;
 
@@ -78,7 +79,7 @@ update_waiter (u_short *sample_buffer, size_t size, size_t offset, u_int scale)
   if (! err)
     {
       err = __task_enable_pc_sampling (__mach_task_self (), &profile_tick,
-				       SAMPLED_PC_PERIODIC);
+				       sample_type);
       if (!err && sample_scale == 0)
 	/* Profiling was not turned on, so the collector thread was
 	   suspended.  Resume it.  */
@@ -89,6 +90,7 @@ update_waiter (u_short *sample_buffer, size_t size, size_t offset, u_int scale)
 	  maxsamples = size / sizeof *sample_buffer;
 	  pc_offset = offset;
 	  sample_scale = scale;
+	  sample_type = sample_type;
 	  /* Calculate a good period for the collector thread.  From TICK
 	     and the kernel buffer size we get the length of time it takes
 	     to fill the buffer; translate that to milliseconds for
@@ -108,7 +110,7 @@ __profile_frequency (void)
 libc_hidden_def (__profile_frequency)
 
 int
-__profil (u_short *sample_buffer, size_t size, size_t offset, u_int scale)
+__mach_profil (u_short *sample_buffer, size_t size, size_t offset, u_int scale, sampled_pc_flavor_t sample_type)
 {
   error_t err;
 
@@ -128,15 +130,23 @@ __profil (u_short *sample_buffer, size_t size, size_t offset, u_int scale)
 
       err = __task_disable_pc_sampling (__mach_task_self (), &count);
       sample_scale = 0;
+      sample_type = 0;
       seqno = 0;
     }
   else
-    err = update_waiter (sample_buffer, size, offset, scale);
+    err = update_waiter (sample_buffer, size, offset, scale, sample_type);
 
   __spin_unlock (&lock);
 
   return err ? __hurd_fail (err) : 0;
 }
+weak_alias (__mach_profil, mach_profil)
+
+int
+__profil (u_short *sample_buffer, size_t size, size_t offset, u_int scale)
+{
+  return __mach_profil (sample_buffer, size, offset, scale, SAMPLED_PC_PERIODIC);
+}
 weak_alias (__profil, profil)
 
 /* Fetch PC samples.  This function must be very careful not to depend
@@ -226,6 +236,7 @@ fork_profil_child (void)
 {
   u_short *sb;
   size_t n, o, ss;
+  sampled_pc_flavor_t st;
   error_t err;
 
   __spin_unlock (&lock);
@@ -244,10 +255,12 @@ fork_profil_child (void)
   pc_offset = 0;
   ss = sample_scale;
   sample_scale = 0;
+  st = sample_type;
+  sample_type = 0;
 
   if (ss != 0)
     {
-      err = update_waiter (sb, n * sizeof *sb, o, ss);
+      err = update_waiter (sb, n * sizeof *sb, o, ss, st);
       assert_perror (err);
     }
 }
