mrlocks have gone from CVS head, so implementing them would be a loss of time,
when backporting the GSCOPE_SET/RESET/WAIT can be actually done easily.

diff -ur glibc-2.6-orig/elf/dl-close.c glibc-2.6/build-tree/glibc-2.6/elf/dl-close.c
--- glibc-2.6-orig/elf/dl-close.c	2007-05-11 20:46:34.000000000 +0200
+++ glibc-2.6/elf/dl-close.c	2007-07-20 03:58:27.000000000 +0200
@@ -32,6 +32,8 @@
 #include <sys/mman.h>
 #include <sysdep-cancel.h>
 
+#include "gscope.h"
+
 
 /* Type of the constructor functions.  */
 typedef void (*fini_t) (void);
@@ -228,6 +230,7 @@
   bool do_audit = GLRO(dl_naudit) > 0 && !ns->_ns_loaded->l_auditing;
 #endif
   bool unload_any = false;
+  bool scope_mem_left = false;
   unsigned int first_loaded = ~0;
   for (unsigned int i = 0; i < nloaded; ++i)
     {
@@ -400,18 +403,18 @@
 
 	      struct r_scope_elem **old = imap->l_scope;
 
-	      if (RTLD_SINGLE_THREAD_P)
-		imap->l_scope = newp;
-	      else
-		{
-		  __rtld_mrlock_change (imap->l_scope_lock);
-		  imap->l_scope = newp;
-		  __rtld_mrlock_done (imap->l_scope_lock);
-		}
+	      imap->l_scope = newp;
 
 	      /* No user anymore, we can free it now.  */
 	      if (old != imap->l_scope_mem)
-		free (old);
+	        {
+		  if (_dl_scope_free (old))
+		    /* If _dl_scope_free used THREAD_GSCOPE_WAIT (),
+		       no need to repeat it. */
+		    scope_mem_left = false;
+		}
+	      else
+		scope_mem_left = true;
 
 	      imap->l_scope_max = new_size;
 	    }
@@ -457,6 +460,20 @@
   r->r_state = RT_DELETE;
   _dl_debug_state ();
 
+  if (!RTLD_SINGLE_THREAD_P
+      && (scope_mem_left
+	 || (GL(dl_scope_free_list) != NULL
+	     && GL(dl_scope_free_list)->count)))
+    {
+      THREAD_GSCOPE_WAIT ();
+
+      /* Now we can free any queued old scopes.  */
+      struct dl_scope_free_list *fsl = GL(dl_scope_free_list);
+      if (fsl != NULL)
+        while (fsl->count > 0)
+	  free (fsl->list[--fsl->count]);
+    }
+
   size_t tls_free_start;
   size_t tls_free_end;
   tls_free_start = tls_free_end = NO_TLS_OFFSET;
@@ -769,4 +786,8 @@
 	   malloc), and in the static library it's in .bss space.  */
 	free_slotinfo (&GL(dl_tls_dtv_slotinfo_list)->next);
     }
+
+  void *scope_free_list = GL(dl_scope_free_list);
+  GL(dl_scope_free_list) = NULL;
+  free(scope_free_list);
 }
diff -ur glibc-2.6-orig/elf/dl-lookup.c glibc-2.6/build-tree/glibc-2.6/elf/dl-lookup.c
--- glibc-2.6-orig/elf/dl-lookup.c	2007-01-15 21:45:53.000000000 +0100
+++ glibc-2.6/elf/dl-lookup.c	2007-07-20 03:07:43.000000000 +0200
@@ -86,7 +86,7 @@
 /* Add extra dependency on MAP to UNDEF_MAP.  */
 static int
 internal_function
-add_dependency (struct link_map *undef_map, struct link_map *map, int flags)
+add_dependency (struct link_map *undef_map, struct link_map *map)
 {
   struct link_map **list;
   struct link_map *runp;
@@ -99,18 +99,8 @@
   if (undef_map == map)
     return 0;
 
-  /* Make sure nobody can unload the object while we are at it.
-     If we hold a scope lock drop it now to avoid ABBA locking problems.  */
-  if ((flags & DL_LOOKUP_SCOPE_LOCK) != 0 && !RTLD_SINGLE_THREAD_P)
-    {
-      __rtld_mrlock_unlock (undef_map->l_scope_lock);
-
-      __rtld_lock_lock_recursive (GL(dl_load_lock));
-
-      __rtld_mrlock_lock (undef_map->l_scope_lock);
-    }
-  else
-    __rtld_lock_lock_recursive (GL(dl_load_lock));
+  /* Make sure nobody can unload the object while we are at it. */
+  __rtld_lock_lock_recursive (GL(dl_load_lock));
 
   /* Avoid references to objects which cannot be unloaded anyway.  */
   if (map->l_type != lt_loaded
@@ -237,10 +227,9 @@
 
   bump_num_relocations ();
 
-  /* No other flag than DL_LOOKUP_ADD_DEPENDENCY and DL_LOOKUP_SCOPE_LOCK
-     is allowed if we look up a versioned symbol.  */
-  assert (version == NULL || (flags & ~(DL_LOOKUP_ADD_DEPENDENCY
-					| DL_LOOKUP_SCOPE_LOCK)) == 0);
+  /* No other flag than DL_LOOKUP_ADD_DEPENDENCY is allowed if we look
+     up a versioned symbol.  */
+  assert (version == NULL || (flags & ~(DL_LOOKUP_ADD_DEPENDENCY)) == 0);
 
   size_t i = 0;
   if (__builtin_expect (skip_map != NULL, 0))
@@ -350,13 +339,11 @@
 	 runtime lookups.  */
       && (flags & DL_LOOKUP_ADD_DEPENDENCY) != 0
       /* Add UNDEF_MAP to the dependencies.  */
-      && add_dependency (undef_map, current_value.m, flags) < 0)
+      && add_dependency (undef_map, current_value.m) < 0)
       /* Something went wrong.  Perhaps the object we tried to reference
 	 was just removed.  Try finding another definition.  */
-      return _dl_lookup_symbol_x (undef_name, undef_map, ref,
-				  (flags & DL_LOOKUP_SCOPE_LOCK) == 0
-				  ? symbol_scope : undef_map->l_scope, version,
-				  type_class, flags, skip_map);
+      return _dl_lookup_symbol_x (undef_name, undef_map, ref, symbol_scope,
+				  version, type_class, flags, skip_map);
 
   /* The object is used.  */
   current_value.m->l_used = 1;
diff -ur glibc-2.6-orig/elf/dl-object.c glibc-2.6/build-tree/glibc-2.6/elf/dl-object.c
--- glibc-2.6-orig/elf/dl-object.c	2006-10-28 01:11:41.000000000 +0200
+++ glibc-2.6/elf/dl-object.c	2007-07-20 03:07:17.000000000 +0200
@@ -25,6 +25,8 @@
 
 #include <assert.h>
 
+#include "gscope.h"
+
 
 /* Allocate a `struct link_map' for a new object being loaded,
    and enter it into the _dl_loaded list.  */
@@ -85,11 +87,6 @@
   new->l_scope = new->l_scope_mem;
   new->l_scope_max = sizeof (new->l_scope_mem) / sizeof (new->l_scope_mem[0]);
 
-  /* No need to initialize the scope lock if the initializer is zero.  */
-#if _RTLD_MRLOCK_INITIALIZER != 0
-  __rtld_mrlock_initialize (new->l_scope_lock);
-#endif
-
   /* Counter for the scopes we have to handle.  */
   idx = 0;
 
diff -ur glibc-2.6-orig/elf/dl-open.c glibc-2.6/build-tree/glibc-2.6/elf/dl-open.c
--- glibc-2.6-orig/elf/dl-open.c	2007-05-11 23:34:32.000000000 +0200
+++ glibc-2.6/elf/dl-open.c	2007-07-20 04:22:28.000000000 +0200
@@ -32,9 +32,11 @@
 #include <bp-sym.h>
 #include <caller.h>
 #include <sysdep-cancel.h>
+#include <atomic.h>
 
 #include <dl-dst.h>
 
+#include "gscope.h"
 
 extern ElfW(Addr) _dl_sysdep_start (void **start_argptr,
 				    void (*dl_main) (const ElfW(Phdr) *phdr,
@@ -154,6 +156,40 @@
   return 0;
 }
 
+int
+_dl_scope_free (struct r_scope_elem **old)
+{
+  struct dl_scope_free_list *fsl;
+#define DL_SCOPE_FREE_LIST_SIZE (sizeof (fsl->list) / sizeof (fsl->list[0]))
+
+  if (RTLD_SINGLE_THREAD_P)
+    free (old);
+  else if ((fsl = GL(dl_scope_free_list)) == NULL)
+    {
+      GL(dl_scope_free_list) = fsl = malloc (sizeof (*fsl));
+      if (fsl == NULL)
+	{
+	  THREAD_GSCOPE_WAIT ();
+	  free (old);
+	  return 1;
+	}
+      else
+	{
+	  fsl->list[0] = old;
+	  fsl->count = 1;
+	}
+    }
+  else if (fsl->count < DL_SCOPE_FREE_LIST_SIZE)
+    fsl->list[fsl->count++] = old;
+  else
+    {
+      THREAD_GSCOPE_WAIT ();
+      while (fsl->count > 0)
+	free (fsl->list[--fsl->count]);
+      return 1;
+    }
+  return 0;
+}
 
 static void
 dl_open_worker (void *a)
@@ -418,17 +454,10 @@
 	      memcpy (newp, imap->l_scope, cnt * sizeof (imap->l_scope[0]));
 	      struct r_scope_elem **old = imap->l_scope;
 
-	      if (RTLD_SINGLE_THREAD_P)
-		imap->l_scope = newp;
-	      else
-		{
-		  __rtld_mrlock_change (imap->l_scope_lock);
-		  imap->l_scope = newp;
-		  __rtld_mrlock_done (imap->l_scope_lock);
-		}
+	      imap->l_scope = newp;
 
 	      if (old != imap->l_scope_mem)
-		free (old);
+		_dl_scope_free (old);
 
 	      imap->l_scope_max = new_size;
 	    }
diff -ur glibc-2.6-orig/elf/dl-runtime.c glibc-2.6/build-tree/glibc-2.6/elf/dl-runtime.c
--- glibc-2.6-orig/elf/dl-runtime.c	2007-01-15 21:46:54.000000000 +0100
+++ glibc-2.6/elf/dl-runtime.c	2007-07-20 03:07:14.000000000 +0200
@@ -27,6 +27,8 @@
 #include <sysdep-cancel.h>
 #include "dynamic-link.h"
 
+#include "gscope.h"
+
 #if (!defined ELF_MACHINE_NO_RELA && !defined ELF_MACHINE_PLT_REL) \
     || ELF_MACHINE_NO_REL
 # define PLTREL  ElfW(Rela)
@@ -97,17 +99,15 @@
 	 not necessary for objects which cannot be unloaded or when
 	 we are not using any threads (yet).  */
       int flags = DL_LOOKUP_ADD_DEPENDENCY;
-      if (l->l_type == lt_loaded && !RTLD_SINGLE_THREAD_P)
-	{
-	  __rtld_mrlock_lock (l->l_scope_lock);
-	  flags |= DL_LOOKUP_SCOPE_LOCK;
-	}
+      if (!RTLD_SINGLE_THREAD_P)
+	THREAD_GSCOPE_SET_FLAG ();
 
       result = _dl_lookup_symbol_x (strtab + sym->st_name, l, &sym, l->l_scope,
 				    version, ELF_RTYPE_CLASS_PLT, flags, NULL);
 
-      if ((flags & DL_LOOKUP_SCOPE_LOCK) != 0)
-	__rtld_mrlock_unlock (l->l_scope_lock);
+      /* We are done with the global scope.  */
+      if (!RTLD_SINGLE_THREAD_P)
+	THREAD_GSCOPE_RESET_FLAG ();
 
       /* Currently result contains the base load address (or link map)
 	 of the object that defines sym.  Now add in the symbol
@@ -191,18 +191,16 @@
 	     not necessary for objects which cannot be unloaded or when
 	     we are not using any threads (yet).  */
 	  int flags = DL_LOOKUP_ADD_DEPENDENCY;
-	  if (l->l_type == lt_loaded && !RTLD_SINGLE_THREAD_P)
-	    {
-	      __rtld_mrlock_lock (l->l_scope_lock);
-	      flags |= DL_LOOKUP_SCOPE_LOCK;
-	    }
+	  if (!RTLD_SINGLE_THREAD_P)
+	    THREAD_GSCOPE_SET_FLAG ();
 
 	  result = _dl_lookup_symbol_x (strtab + refsym->st_name, l,
 					&defsym, l->l_scope, version,
 					ELF_RTYPE_CLASS_PLT, flags, NULL);
 
-	  if ((flags & DL_LOOKUP_SCOPE_LOCK) != 0)
-	    __rtld_mrlock_unlock (l->l_scope_lock);
+	  /* We are done with the global scope.  */
+	  if (!RTLD_SINGLE_THREAD_P)
+	    THREAD_GSCOPE_RESET_FLAG ();
 
 	  /* Currently result contains the base load address (or link map)
 	     of the object that defines sym.  Now add in the symbol
diff -ur glibc-2.6-orig/elf/dl-support.c glibc-2.6/build-tree/glibc-2.6/elf/dl-support.c
--- glibc-2.6-orig/elf/dl-support.c	2007-07-19 23:45:07.000000000 +0200
+++ glibc-2.6/elf/dl-support.c	2007-07-20 04:33:59.000000000 +0200
@@ -33,6 +33,8 @@
 #include <unsecvars.h>
 #include <hp-timing.h>
 
+#include "gscope.h"
+
 extern char *__progname;
 char **_dl_argv = &__progname;	/* This is checked for some error messages.  */
 
@@ -137,6 +139,8 @@
 int (*_dl_make_stack_executable_hook) (void **) internal_function
   = _dl_make_stack_executable;
 
+int volatile _dl_thread_gscope_count;
+struct dl_scope_free_list *_dl_scope_free_list;
 
 #ifdef NEED_DL_SYSINFO
 /* Needed for improved syscall handling on at least x86/Linux.  */
diff -ur glibc-2.6-orig/elf/dl-sym.c glibc-2.6/build-tree/glibc-2.6/elf/dl-sym.c
--- glibc-2.6-orig/elf/dl-sym.c	2007-01-15 21:47:44.000000000 +0100
+++ glibc-2.6/elf/dl-sym.c	2007-07-20 03:07:15.000000000 +0200
@@ -28,6 +28,8 @@
 #include <sysdep-cancel.h>
 #include <dl-tls.h>
 
+#include "gscope.h"
+
 
 #ifdef SHARED
 /* Systems which do not have tls_index also probably have to define
@@ -113,29 +115,29 @@
 	 the initial binary.  And then the more complex part
 	 where the object is dynamically loaded and the scope
 	 array can change.  */
-      if (match->l_type != lt_loaded || RTLD_SINGLE_THREAD_P)
+      if (RTLD_SINGLE_THREAD_P)
 	result = GLRO(dl_lookup_symbol_x) (name, match, &ref,
 					   match->l_scope, vers, 0,
 					   flags | DL_LOOKUP_ADD_DEPENDENCY,
 					   NULL);
       else
 	{
-	  __rtld_mrlock_lock (match->l_scope_lock);
-
 	  struct call_dl_lookup_args args;
 	  args.name = name;
 	  args.map = match;
 	  args.vers = vers;
-	  args.flags = flags | DL_LOOKUP_ADD_DEPENDENCY | DL_LOOKUP_SCOPE_LOCK;
+	  args.flags = flags | DL_LOOKUP_ADD_DEPENDENCY;
 	  args.refp = &ref;
 
+	  THREAD_GSCOPE_SET_FLAG ();
+
 	  const char *objname;
 	  const char *errstring = NULL;
 	  bool malloced;
 	  int err = GLRO(dl_catch_error) (&objname, &errstring, &malloced,
 					  call_dl_lookup, &args);
 
-	  __rtld_mrlock_unlock (match->l_scope_lock);
+	  THREAD_GSCOPE_RESET_FLAG ();
 
 	  if (__builtin_expect (errstring != NULL, 0))
 	    {
diff -ur glibc-2.6-orig/sysdeps/generic/ldsodefs.h glibc-2.6/build-tree/glibc-2.6/sysdeps/generic/ldsodefs.h
--- glibc-2.6-orig/sysdeps/generic/ldsodefs.h	2007-07-19 23:45:14.000000000 +0200
+++ glibc-2.6/sysdeps/generic/ldsodefs.h	2007-07-20 04:41:36.000000000 +0200
@@ -38,7 +38,6 @@
 #include <bits/libc-lock.h>
 #include <hp-timing.h>
 #include <tls.h>
-#include <rtld-lowlevel.h>
 
 __BEGIN_DECLS
 
@@ -486,6 +485,12 @@
 
   EXTERN void (*_dl_init_static_tls) (struct link_map *);
 
+  EXTERN struct dl_scope_free_list
+  {
+    size_t count;
+    struct r_scope_elem **list[50];
+  } *_dl_scope_free_list;
+  EXTERN volatile int _dl_thread_gscope_count;
 #ifdef SHARED
 };
 # define __rtld_global_attribute__
@@ -838,9 +843,7 @@
     DL_LOOKUP_ADD_DEPENDENCY = 1,
     /* Return most recent version instead of default version for
        unversioned lookup.  */
-    DL_LOOKUP_RETURN_NEWEST = 2,
-    /* Set if the scopr lock in the UNDEF_MAP is taken.  */
-    DL_LOOKUP_SCOPE_LOCK = 4
+    DL_LOOKUP_RETURN_NEWEST = 2
   };
 
 /* Lookup versioned symbol.  */
@@ -1048,6 +1051,11 @@
 		       Lmid_t nsid, int argc, char *argv[], char *env[])
      attribute_hidden;
 
+/* Free or queue for freeing scope OLD.  If other threads might be 
+   in the middle of _dl_fixup, _dl_profile_fixup or dl*sym using the 
+   old scope, OLD can't be freed until no thread is using it.  */ 
+extern int _dl_scope_free (struct r_scope_elem **old) attribute_hidden; 
+
 /* Add module to slot information data.  */
 extern void _dl_add_to_slotinfo (struct link_map  *l) attribute_hidden;
 
--- glibc-2.6-orig/include/link.h	2007-05-11 06:38:05.000000000 +0000
+++ glibc-2.6/include/link.h	2007-07-20 17:14:35.000000000 +0000
@@ -44,7 +44,6 @@
 #include <dl-lookupcfg.h>
 #include <tls.h>
 #include <bits/libc-lock.h>
-#include <rtld-lowlevel.h>
 
 
 /* Some internal data structures of the dynamic linker used in the
@@ -220,8 +219,6 @@
     /* This is an array defining the lookup scope for this link map.
        There are initially at most three different scope lists.  */
     struct r_scope_elem **l_scope;
-    /* We need to protect using the SCOPEREC.  */
-    __rtld_mrlock_define (, l_scope_lock)
 
     /* A similar array, this time only with the local scope.  This is
        used occasionally.  */
--- /dev/null	2005-07-17 23:39:37.000000000 +0000
+++ glibc-2.6/elf/gscope.h	2007-07-19 23:00:57.000000000 +0000
@@ -0,0 +1,13 @@
+#ifndef _GSCOPE_H
+#define _GSCOPE_H 1
+#include <mach/mach_traps.h>
+/* Temporary poor-man's global scope switch support: just busy-waits */
+#define THREAD_GSCOPE_SET_FLAG() \
+	asm volatile ("lock incl %0":"=m"(GL(dl_thread_gscope_count)))
+#define THREAD_GSCOPE_RESET_FLAG() \
+	asm volatile ("lock decl %0":"=m"(GL(dl_thread_gscope_count)))
+#define THREAD_GSCOPE_WAIT() \
+  while (GL(dl_thread_gscope_count)) { \
+    __swtch_pri (0); \
+  }
+#endif
--- /dev/null	2007-07-20 20:36:08.980000000 +0200
+++ glibc-2.6/sysdeps/mach/hurd/sysdep-cancel.h	2007-07-20 01:24:22.000000000 +0200
@@ -0,0 +1,9 @@
+#include <sysdep.h>
+
+/* Always multi-thread (since there's at least the sig handler), but no
+   handling enabled.  */
+#define SINGLE_THREAD_P (0)
+#define RTLD_SINGLE_THREAD_P (0)
+#define LIBC_CANCEL_ASYNC()	0 /* Just a dummy value.  */
+#define LIBC_CANCEL_RESET(val)	((void)(val)) /* Nothing, but evaluate it.  */
+#define LIBC_CANCEL_HANDLED()	/* Nothing.  */
