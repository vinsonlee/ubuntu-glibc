Index: csu/libc-start.c
===================================================================
RCS file: /cvs/glibc/libc/csu/libc-start.c,v
retrieving revision 1.3
diff -u -p -r1.3 libc-start.c
--- csu/libc-start.c	17 Jan 2007 08:36:51 -0000	1.3
+++ csu/libc-start.c	19 Jul 2007 22:37:08 -0000
@@ -134,11 +134,13 @@ LIBC_START_MAIN (int (*main) (int, char 
     }
 # endif
 
+#ifndef __GNU__
   /* Initialize the thread library at least a bit since the libgcc
      functions are using thread functions if these are available and
      we need to setup errno.  */
   __pthread_initialize_minimal ();
 #endif
+#endif
 
 # ifndef SHARED
   /* Set up the stack checker's canary.  */
Index: hurd/hurdfault.c
===================================================================
RCS file: /cvs/glibc/libc/hurd/hurdfault.c,v
retrieving revision 1.21
diff -u -p -r1.21 hurdfault.c
--- hurd/hurdfault.c	21 Dec 2005 22:16:20 -0000	1.21
+++ hurd/hurdfault.c	19 Jul 2007 22:37:08 -0000
@@ -206,6 +206,8 @@ _hurdsig_fault_init (void)
   /* This state will be restored when we fault.
      It runs the function above.  */
   memset (&state, 0, sizeof state);
+
+  MACHINE_THREAD_STATE_FIX_NEW (&state);
   MACHINE_THREAD_STATE_SET_PC (&state, faulted);
   MACHINE_THREAD_STATE_SET_SP (&state, faultstack, sizeof faultstack);
 
Index: mach/setup-thread.c
===================================================================
RCS file: /cvs/glibc/libc/mach/setup-thread.c,v
retrieving revision 1.19
diff -u -p -r1.19 setup-thread.c
--- mach/setup-thread.c	22 Dec 2005 11:31:24 -0000	1.19
+++ mach/setup-thread.c	19 Jul 2007 22:37:08 -0000
@@ -20,6 +20,7 @@
 #include <thread_state.h>
 #include <string.h>
 #include <mach/machine/vm_param.h>
+#include <ldsodefs.h>
 #include "sysdep.h"		/* Defines stack direction.  */
 
 #define	STACK_SIZE	(16 * 1024 * 1024) /* 16MB, arbitrary.  */
@@ -73,8 +74,23 @@ __mach_setup_thread (task_t task, thread
   if (error = __vm_protect (task, stack, __vm_page_size, 0, VM_PROT_NONE))
     return error;
 
-  return __thread_set_state (thread, MACHINE_THREAD_STATE_FLAVOR,
+  if (error = __thread_set_state (thread, MACHINE_NEW_THREAD_STATE_FLAVOR,
+			     (natural_t *) &ts, tssize))
+    return error;
+
+  /* now we have a clean state, setup TLS */
+  if (error = __thread_get_state (thread, MACHINE_THREAD_STATE_FLAVOR,
+			     (natural_t *) &ts, &tssize))
+    return error;
+  assert (tssize == MACHINE_THREAD_STATE_COUNT);
+  tcbhead_t *tcb;
+  tcb = _dl_allocate_tls(NULL);
+  if (!tcb)
+    return KERN_RESOURCE_SHORTAGE;
+  _hurd_tls_new(thread, &ts, tcb);
+  error = __thread_set_state (thread, MACHINE_THREAD_STATE_FLAVOR,
 			     (natural_t *) &ts, tssize);
+  return error;
 }
 
 weak_alias (__mach_setup_thread, mach_setup_thread)
Index: sysdeps/generic/thread_state.h
===================================================================
RCS file: /cvs/glibc/libc/sysdeps/generic/thread_state.h,v
retrieving revision 1.2
diff -u -p -r1.2 thread_state.h
--- sysdeps/generic/thread_state.h	6 Jul 2001 04:55:50 -0000	1.2
+++ sysdeps/generic/thread_state.h	19 Jul 2007 22:37:09 -0000
@@ -23,6 +23,7 @@
 
 /* Replace <machine> with "i386" or "mips" or whatever.  */
 
+#define MACHINE_NEW_THREAD_STATE_FLAVOR	<machine>_NEW_THREAD_STATE
 #define MACHINE_THREAD_STATE_FLAVOR	<machine>_THREAD_STATE
 #define MACHINE_THREAD_STATE_COUNT	<machine>_THREAD_STATE_COUNT
 
Index: sysdeps/mach/thread_state.h
===================================================================
RCS file: /cvs/glibc/libc/sysdeps/mach/thread_state.h,v
retrieving revision 1.13
diff -u -p -r1.13 thread_state.h
--- sysdeps/mach/thread_state.h	6 Jul 2001 04:55:56 -0000	1.13
+++ sysdeps/mach/thread_state.h	19 Jul 2007 22:37:09 -0000
@@ -38,6 +38,9 @@
   ((ts)->SP = (unsigned long int) (stack) + (size))
 #endif
 #endif
+#ifndef MACHINE_THREAD_STATE_FIX_NEW
+#define MACHINE_THREAD_STATE_FIX_NEW(ts)
+#endif
 
 /* These functions are of use in machine-dependent signal trampoline
    implementations.  */
Index: sysdeps/mach/alpha/thread_state.h
===================================================================
RCS file: /cvs/glibc/libc/sysdeps/mach/alpha/thread_state.h,v
retrieving revision 1.5
diff -u -p -r1.5 thread_state.h
--- sysdeps/mach/alpha/thread_state.h	6 Jul 2001 04:55:56 -0000	1.5
+++ sysdeps/mach/alpha/thread_state.h	19 Jul 2007 22:37:09 -0000
@@ -19,6 +19,7 @@
 
 #include <mach/machine/thread_status.h>
 
+#define MACHINE_NEW_THREAD_STATE_FLAVOR	ALPHA_THREAD_STATE
 #define MACHINE_THREAD_STATE_FLAVOR	ALPHA_THREAD_STATE
 #define MACHINE_THREAD_STATE_COUNT	ALPHA_THREAD_STATE_COUNT
 
Index: sysdeps/mach/hurd/fork.c
===================================================================
RCS file: /cvs/glibc/libc/sysdeps/mach/hurd/fork.c,v
retrieving revision 1.58
diff -u -p -r1.58 fork.c
--- sysdeps/mach/hurd/fork.c	27 Oct 2006 23:11:46 -0000	1.58
+++ sysdeps/mach/hurd/fork.c	19 Jul 2007 22:37:09 -0000
@@ -523,6 +523,11 @@ __fork (void)
 #endif
       MACHINE_THREAD_STATE_SET_PC (&state,
 				   (unsigned long int) _hurd_msgport_receive);
+
+      /* Do special thread setup for TLS if needed.  */
+      if (err = _hurd_tls_fork (sigthread, _hurd_msgport_thread, &state))
+	LOSE;
+
       if (err = __thread_set_state (sigthread, MACHINE_THREAD_STATE_FLAVOR,
 				    (natural_t *) &state, statecount))
 	LOSE;
@@ -533,7 +538,7 @@ __fork (void)
       _hurd_longjmp_thread_state (&state, env, 1);
 
       /* Do special thread setup for TLS if needed.  */
-      if (err = _hurd_tls_fork (thread, &state))
+      if (err = _hurd_tls_fork (thread, __mach_thread_self (), &state))
 	LOSE;
 
       if (err = __thread_set_state (thread, MACHINE_THREAD_STATE_FLAVOR,
Index: sysdeps/mach/hurd/i386/init-first.c
===================================================================
RCS file: /cvs/glibc/libc/sysdeps/mach/hurd/i386/init-first.c,v
retrieving revision 1.44
diff -u -p -r1.44 init-first.c
--- sysdeps/mach/hurd/i386/init-first.c	16 Oct 2005 09:52:58 -0000	1.44
+++ sysdeps/mach/hurd/i386/init-first.c	19 Jul 2007 22:37:09 -0000
@@ -104,10 +104,6 @@ init1 (int argc, char *arg0, ...)
   char **argv = &arg0;
   char **envp = &argv[argc + 1];
   struct hurd_startup_data *d;
-#ifndef SHARED
-  extern ElfW(Phdr) *_dl_phdr;
-  extern size_t _dl_phnum;
-#endif
 
   while (*envp)
     ++envp;
@@ -118,27 +114,9 @@ init1 (int argc, char *arg0, ...)
      data block; the argument strings start there.  */
   if ((void *) d == argv[0])
     {
-#ifndef SHARED
-      /* We may need to see our own phdrs, e.g. for TLS setup.
-         Try the usual kludge to find the headers without help from
-	 the exec server.  */
-      extern const void _start;
-      const ElfW(Ehdr) *const ehdr = &_start;
-      _dl_phdr = (ElfW(Phdr) *) ((const void *) ehdr + ehdr->e_phoff);
-      _dl_phnum = ehdr->e_phnum;
-      assert (ehdr->e_phentsize == sizeof (ElfW(Phdr)));
-#endif
       return;
     }
 
-#ifndef SHARED
-  __libc_enable_secure = d->flags & EXEC_SECURE;
-
-  _dl_phdr = (ElfW(Phdr) *) d->phdr;
-  _dl_phnum = d->phdrsz / sizeof (ElfW(Phdr));
-  assert (d->phdrsz % sizeof (ElfW(Phdr)) == 0);
-#endif
-
   _hurd_init_dtable = d->dtable;
   _hurd_init_dtablesize = d->dtablesize;
 
@@ -172,6 +150,10 @@ init (int *data)
   char **envp = &argv[argc + 1];
   struct hurd_startup_data *d;
   unsigned long int threadvars[_HURD_THREADVAR_MAX];
+#ifndef SHARED
+  extern ElfW(Phdr) *_dl_phdr;
+  extern size_t _dl_phnum;
+#endif
 
   /* Provide temporary storage for thread-specific variables on the
      startup stack so the cthreads initialization code can use them
@@ -192,6 +174,39 @@ init (int *data)
     ++envp;
   d = (void *) ++envp;
 
+  /* If we are the bootstrap task started by the kernel,
+     then after the environment pointers there is no Hurd
+     data block; the argument strings start there.  */
+  if ((void *) d == argv[0])
+    {
+#ifndef SHARED
+      /* We may need to see our own phdrs, e.g. for TLS setup.
+         Try the usual kludge to find the headers without help from
+	 the exec server.  */
+      extern const void __executable_start;
+      const ElfW(Ehdr) *const ehdr = &__executable_start;
+      _dl_phdr = (ElfW(Phdr) *) ((const void *) ehdr + ehdr->e_phoff);
+      _dl_phnum = ehdr->e_phnum;
+      assert (ehdr->e_phentsize == sizeof (ElfW(Phdr)));
+#endif
+    }
+  else
+    {
+#ifndef SHARED
+      __libc_enable_secure = d->flags & EXEC_SECURE;
+
+      _dl_phdr = (ElfW(Phdr) *) d->phdr;
+      _dl_phnum = d->phdrsz / sizeof (ElfW(Phdr));
+      assert (d->phdrsz % sizeof (ElfW(Phdr)) == 0);
+#endif
+    }
+
+#ifndef SHARED
+  /* We need to setup TLS before starting sigthread */
+  extern void __pthread_initialize_minimal(void);
+  __pthread_initialize_minimal();
+#endif
+
   /* The user might have defined a value for this, to get more variables.
      Otherwise it will be zero on startup.  We must make sure it is set
      properly before before cthreads initialization, so cthreads can know
Index: sysdeps/mach/hurd/i386/tls.h
===================================================================
RCS file: /cvs/glibc/libc/sysdeps/mach/hurd/i386/tls.h,v
retrieving revision 1.12
diff -u -p -r1.12 tls.h
--- sysdeps/mach/hurd/i386/tls.h	27 Oct 2006 23:11:46 -0000	1.12
+++ sysdeps/mach/hurd/i386/tls.h	19 Jul 2007 22:37:09 -0000
@@ -96,7 +96,7 @@ _hurd_tls_init (tcbhead_t *tcb, int seco
       /* Fetch the selector set by the first call.  */
       int sel;
       asm ("mov %%gs, %w0" : "=q" (sel) : "0" (0));
-      if (__builtin_expect (sel, 0x50) & 4) /* LDT selector */
+      if (__builtin_expect (sel, 0x48) & 4) /* LDT selector */
 	{
 	  error_t err = __i386_set_ldt (tcb->self, sel, &desc, 1);
 	  assert_perror (err);
@@ -142,9 +142,40 @@ _hurd_tls_init (tcbhead_t *tcb, int seco
 
 #include <mach/machine/thread_status.h>
 
-/* Set up TLS in the new thread of a fork child, copying from our own.  */
+/* Set up TLS in the new thread of a fork child, copying from the original.  */
 static inline error_t __attribute__ ((unused))
-_hurd_tls_fork (thread_t child, struct i386_thread_state *state)
+_hurd_tls_fork (thread_t child, thread_t orig, struct i386_thread_state *state)
+{
+  /* Fetch the selector set by _hurd_tls_init.  */
+  int sel;
+  asm ("mov %%gs, %w0" : "=q" (sel) : "0" (0));
+  if (sel == state->ds)		/* _hurd_tls_init was never called.  */
+    return 0;
+
+  struct descriptor desc, *_desc = &desc;
+  error_t err;
+  unsigned int count;
+
+  if (__builtin_expect (sel, 0x48) & 4) /* LDT selector */
+    err = __i386_get_ldt (orig, sel, 1, &_desc, &count);
+  else
+    err = __i386_get_gdt (orig, sel, &desc);
+
+  assert_perror (err);
+  if (err)
+    return err;
+
+  if (__builtin_expect (sel, 0x48) & 4) /* LDT selector */
+    err = __i386_set_ldt (child, sel, &desc, 1);
+  else
+    err = __i386_set_gdt (child, &sel, desc);
+
+  state->gs = sel;
+  return err;
+}
+
+static inline error_t __attribute__ ((unused))
+_hurd_tls_new (thread_t child, struct i386_thread_state *state, tcbhead_t *tcb)
 {
   /* Fetch the selector set by _hurd_tls_init.  */
   int sel;
@@ -152,11 +183,13 @@ _hurd_tls_fork (thread_t child, struct i
   if (sel == state->ds)		/* _hurd_tls_init was never called.  */
     return 0;
 
-  tcbhead_t *const tcb = THREAD_SELF;
   HURD_TLS_DESC_DECL (desc, tcb);
   error_t err;
 
-  if (__builtin_expect (sel, 0x50) & 4) /* LDT selector */
+  tcb->tcb = tcb;
+  tcb->self = child;
+
+  if (__builtin_expect (sel, 0x48) & 4) /* LDT selector */
     err = __i386_set_ldt (child, sel, &desc, 1);
   else
     err = __i386_set_gdt (child, &sel, desc);
Index: sysdeps/mach/hurd/i386/trampoline.c
===================================================================
RCS file: /cvs/glibc/libc/sysdeps/mach/hurd/i386/trampoline.c,v
retrieving revision 1.30
diff -u -p -r1.30 trampoline.c
--- sysdeps/mach/hurd/i386/trampoline.c	21 Dec 2005 22:16:20 -0000	1.30
+++ sysdeps/mach/hurd/i386/trampoline.c	19 Jul 2007 22:37:09 -0000
@@ -64,7 +64,7 @@ _hurd_setup_sighandler (struct hurd_sigs
 		  sizeof (state->basic));
 	  memcpy (&state->fpu, &ss->context->sc_i386_float_state,
 		  sizeof (state->fpu));
-	  state->set |= (1 << i386_THREAD_STATE) | (1 << i386_FLOAT_STATE);
+	  state->set |= (1 << i386_REGS_SEGS_STATE) | (1 << i386_FLOAT_STATE);
 	}
     }
 
Index: sysdeps/mach/i386/thread_state.h
===================================================================
RCS file: /cvs/glibc/libc/sysdeps/mach/i386/thread_state.h,v
retrieving revision 1.14
diff -u -p -r1.14 thread_state.h
--- sysdeps/mach/i386/thread_state.h	6 Jul 2001 04:56:00 -0000	1.14
+++ sysdeps/mach/i386/thread_state.h	19 Jul 2007 22:37:09 -0000
@@ -19,7 +19,8 @@
 
 #include <mach/machine/thread_status.h>
 
-#define MACHINE_THREAD_STATE_FLAVOR	i386_THREAD_STATE
+#define MACHINE_NEW_THREAD_STATE_FLAVOR	i386_THREAD_STATE
+#define MACHINE_THREAD_STATE_FLAVOR	i386_REGS_SEGS_STATE
 #define MACHINE_THREAD_STATE_COUNT	i386_THREAD_STATE_COUNT
 
 #define machine_thread_state i386_thread_state
@@ -28,6 +29,14 @@
 #define SP uesp
 #define SYSRETURN eax
 
+#define MACHINE_THREAD_STATE_FIX_NEW(ts) do { \
+	asm ("mov %%cs, %w0" : "=q" ((ts)->cs)); \
+	asm ("mov %%ds, %w0" : "=q" ((ts)->ds)); \
+	asm ("mov %%es, %w0" : "=q" ((ts)->es)); \
+	asm ("mov %%fs, %w0" : "=q" ((ts)->fs)); \
+	asm ("mov %%gs, %w0" : "=q" ((ts)->gs)); \
+} while(0)
+
 struct machine_thread_all_state
   {
     int set;			/* Mask of bits (1 << FLAVOR).  */
Index: sysdeps/mach/powerpc/thread_state.h
===================================================================
RCS file: /cvs/glibc/libc/sysdeps/mach/powerpc/thread_state.h,v
retrieving revision 1.2
diff -u -p -r1.2 thread_state.h
--- sysdeps/mach/powerpc/thread_state.h	26 Aug 2002 22:39:44 -0000	1.2
+++ sysdeps/mach/powerpc/thread_state.h	19 Jul 2007 22:37:09 -0000
@@ -19,6 +19,7 @@
 
 #include <mach/machine/thread_status.h>
 
+#define MACHINE_NEW_THREAD_STATE_FLAVOR	PPC_THREAD_STATE
 #define MACHINE_THREAD_STATE_FLAVOR	PPC_THREAD_STATE
 #define MACHINE_THREAD_STATE_COUNT	PPC_THREAD_STATE_COUNT
 
--- sysdeps/mach/hurd/bits/libc-tsd.h	2002-09-02 07:08:51.000000000 +0000
+++ /dev/null	2005-07-17 23:39:37.000000000 +0000
@@ -1,34 +0,0 @@
-/* libc-internal interface for thread-specific data.  Hurd version.
-   Copyright (C) 1998,2002 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, write to the Free
-   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
-   02111-1307 USA.  */
-
-#ifndef _BITS_LIBC_TSD_H
-#define _BITS_LIBC_TSD_H 1
-
-#include <hurd/threadvar.h>
-
-#define __libc_tsd_define(CLASS, KEY) /* nothing, always have threadvars */
-
-#define __libc_tsd_address(KEY) \
-  ((void **) __hurd_threadvar_location (_HURD_THREADVAR_##KEY))
-
-#define __libc_tsd_get(KEY)		(*__libc_tsd_address (KEY))
-#define __libc_tsd_set(KEY, VALUE)	(*__libc_tsd_address (KEY) = (VALUE))
-
-
-#endif	/* bits/libc-tsd.h */
