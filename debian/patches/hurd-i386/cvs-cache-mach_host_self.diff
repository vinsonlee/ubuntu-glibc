From: Justus Winter <4winter@informatik.uni-hamburg.de>
Subject: [PATCH glibc 1/2] mach: cache the host port

Cache the host port like we cache the task port.  This way we do not
need to call the kernel just to get the port.  Furthermore, we no
longer increase the reference count on every invocation of
`mach_host_self'.

* mach/mach/mach_traps.h (__mach_host_self, mach_host_self):
Protect declarations against the macro expansion.
* mach/mach_init.c (__mach_host_self_): New variable.
(mach_init): Initialize `__mach_host_self_'.
* mach/mach_init.h (__mach_host_self_): New declaration.
(__mach_host_self, mach_host_self): New macros.
* sysdeps/mach/hurd/dl-sysdep.c (_dl_sysdep_start_cleanup):
Release reference.
---
 mach/mach/mach_traps.h        | 7 ++++---
 mach/mach_init.c              | 2 ++
 mach/mach_init.h              | 5 +++++
 sysdeps/mach/hurd/dl-sysdep.c | 1 +
 4 files changed, 12 insertions(+), 3 deletions(-)

--- a/mach/mach/mach_traps.h
+++ b/mach/mach/mach_traps.h
@@ -41,9 +41,10 @@ extern mach_port_t __mach_thread_self (v
 extern mach_port_t (mach_task_self) (void);
 extern mach_port_t (__mach_task_self) (void);
 
-/* Return the host information port for the host of the calling task.  */
-extern mach_port_t mach_host_self (void);
-extern mach_port_t __mach_host_self (void);
+/* Return the host information port for the host of the calling task.
+   The parens are needed to protect against the macro in <mach_init.h>.  */
+extern mach_port_t (mach_host_self) (void);
+extern mach_port_t (__mach_host_self) (void);
 
 /* Attempt to context switch the current thread off the processor.  Returns
    true if there are other threads that can be run and false if not.  */
--- a/mach/mach_init.c
+++ b/mach/mach_init.c
@@ -20,6 +20,7 @@
 #include <unistd.h>
 
 mach_port_t __mach_task_self_;
+mach_port_t __mach_host_self_;
 vm_size_t __vm_page_size = 0;	/* Must be data not bss for weak alias.  */
 weak_alias (__vm_page_size, vm_page_size)
 
@@ -34,6 +35,7 @@ __mach_init (void)
   kern_return_t err;
 
   __mach_task_self_ = (__mach_task_self) ();
+  __mach_host_self_ = (__mach_host_self) ();
   __mig_init (0);
 
 #ifdef HAVE_HOST_PAGE_SIZE
--- a/mach/mach_init.h
+++ b/mach/mach_init.h
@@ -31,6 +31,11 @@ extern mach_port_t __mach_task_self_;
 #define __mach_task_self()	(__mach_task_self_ + 0)	/* Not an lvalue.  */
 #define mach_task_self()	(__mach_task_self ())
 
+/* This cache is initialized at startup.  */
+extern mach_port_t __mach_host_self_;
+#define __mach_host_self()	(__mach_host_self_ + 0)	/* Not an lvalue.  */
+#define mach_host_self()	(__mach_host_self ())
+
 /* Kernel page size.  */
 extern vm_size_t __vm_page_size;
 extern vm_size_t vm_page_size;
--- a/sysdeps/mach/hurd/dl-sysdep.c
+++ b/sysdeps/mach/hurd/dl-sysdep.c
@@ -278,6 +278,7 @@ _dl_sysdep_start_cleanup (void)
      __mach_init.  We are done with them now, and the user will
      reacquire them for himself when he wants them.  */
   __mig_dealloc_reply_port (MACH_PORT_NULL);
+  __mach_port_deallocate (__mach_task_self (), __mach_host_self_);
   __mach_port_deallocate (__mach_task_self (), __mach_task_self_);
 }
 
--- a/mach/Versions
+++ b/mach/Versions
@@ -54,6 +54,9 @@ libc {
     # This was always there, but not exported as it should have been.
     mig_strncpy;
   }
+  GLIBC_2.21 {
+    __mach_host_self_;
+  }
 
   HURD_CTHREADS_0.3 {
     __mutex_init; __mutex_lock; __mutex_lock_solid; __mutex_trylock;
