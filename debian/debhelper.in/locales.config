#!/bin/sh
set -e

. /usr/share/debconf/confmodule
db_version 2.0
db_capb backup multiselect

#   Initializes debconf default values from the ones found in
#   configuration files
if [ -e /etc/locale.gen ]; then
    LG=/etc/locale.gen
    #  Debconf templates in locales < 2.3.2 were completely different,
    #  the locales/locales_to_be_generated question could have a "Leave alone"
    #  value in which case locale-gen was not run.
    #  With current implementation, this string has to be removed.
    grep -q "Leave alone" $LG && sed -e '/^Leave alone/d' $LG > $LG.tmp && mv $LG.tmp $LG

    SELECTED_LOCALES=$(sed -e '/^[a-zA-Z]/!d' $LG | LC_COLLATE=C sort -u | tr '\n' ',' | sed -e 's/,/, /g' -e 's/, *$//')
    db_set locales/locales_to_be_generated "${SELECTED_LOCALES}"
else
    LG=/dev/null
fi
if [ -e /etc/environment ]; then
    db_set locales/default_environment_locale $(awk 'BEGIN {lang="None"} /^LANG=/ {gsub("\"", ""); sub("LANG=", ""); lang=$0;} END {print lang}' /etc/environment)
else
    db_set locales/default_environment_locale None
fi

#   Add a newline in case /etc/locale.gen has no trailing newline at EOF
SUPPORTED_LOCALES="
__SUPPORTED_LOCALES__"

# Figure out current and supported locale lists for handling of locale
# migration.
WORK="$(mktemp -t -d locales.XXXXXX)"
trap 'rm -rf "$WORK"' EXIT HUP INT QUIT TERM
db_get locales/locales_to_be_generated
GENERATED="$RET"
echo "$GENERATED" | sed -e 's/, /,/g' | tr ',' '\n' | \
    LC_COLLATE=C sort -u > "$WORK/current"
(cat "$LG" && echo "$SUPPORTED_LOCALES") | sed -e '/^[a-zA-Z]/!d' | \
    LC_COLLATE=C sort -u > "$WORK/supported"

SUPPORTED_LOCALES=$(< "$WORK/supported" tr '\n' ',' | sed -e 's/,/, /g' -e 's/, *$//')
db_subst locales/locales_to_be_generated locales "${SUPPORTED_LOCALES}"

# Does FINDLOC exist (in the current list or the supported list, depending
# on MAP)?
find_locale () {
    findloc="$1"
    map="$2"
    echo "$findloc" | LC_COLLATE=C join - "$WORK/$map"
}

# Try to add TRYLOC as a future replacement for the legacy locale OLDLOC. If
# it's available, print a message and add it to $GENERATED.
maybe_add_locale () {
    oldloc="$1"
    tryloc="$2"

    # Don't automatically migrate to *.UTF-8@euro (see Debian bug #274491).
    [ "${tryloc%.UTF-8@euro}" = "$tryloc" ] || return 0

    if ! find_locale "$tryloc" current | grep -q .; then
        newloc="$(find_locale "$tryloc" supported | tr '\n' ',' | sed -e 's/,/, /g' -e 's/, *$//')"
        if [ "$newloc" ]; then
            echo "Automatically selecting $tryloc locale in addition to $oldloc." >&2
            GENERATED="${GENERATED:+$GENERATED, }$newloc"
            echo "$newloc" >> "$WORK/current"
            LC_COLLATE=C sort -u "$WORK/current" > "$WORK/current.new"
            mv -f "$WORK/current.new" "$WORK/current"
        fi
    fi
}

# For each currently selected locale, try to select a corresponding UTF-8
# locale as well.
# TODO: We should check whether we've done this migration already. How? A
# version comparison is problematic due to merges among distributions.
for loc in $(< "$WORK/current" grep -v ' UTF-8$' | cut -d' ' -f1); do
    maybe_add_locale "$loc" \
        "$(echo "$loc" | sed -e 's/^[a-z][a-z]*_[A-Z][A-Z]*/&.UTF-8/')"
    # also try without modifiers (de_DE@euro => de_DE.UTF-8)
    maybe_add_locale "$loc" \
        "$(echo "$loc" | sed -e 's/^\([a-z][a-z]*_[A-Z][A-Z]*\)@.*/\1.UTF-8/')"
done
db_set locales/locales_to_be_generated "$GENERATED"

STATE=1
while [ "$STATE" -ge 0 ]; do
    case "$STATE" in
    0)
        exit 1
        ;;
    1)
        db_input medium locales/locales_to_be_generated || true
        ;;
    2)
        db_get locales/locales_to_be_generated && DEFAULT_LOCALES=$(echo $RET | sed -e 's/None,*//g' -e 's/ [^ ]*,/,/g' -e 's/ [^ ]*$//')

        if test -n "$DEFAULT_LOCALES"; then
            db_subst locales/default_environment_locale locales $DEFAULT_LOCALES
            db_input medium locales/default_environment_locale || true
        fi
        ;;
    *)
        break
        ;;
    esac
    if db_go; then
        STATE=$(($STATE + 1))
    else
        STATE=$(($STATE - 1))
    fi
done
